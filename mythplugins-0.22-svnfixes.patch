Index: mythplugins/mythweather/mythweather/scripts/uk_bbc/BBCLocation.pm
===================================================================
--- mythplugins/mythweather/mythweather/scripts/uk_bbc/BBCLocation.pm	(revision 22751)
+++ mythplugins/mythweather/mythweather/scripts/uk_bbc/BBCLocation.pm	(working copy)
@@ -12,19 +12,17 @@
 
 sub Search {
 
-    my $base_url       = 'http://news.bbc.co.uk/weather/forecast/';
-    my $world_base_url = $base_url . '?lowgraphics=true&search=';
-    my $local_base_url = $base_url . '?lowgraphics=true&type=county_state&search=';
+    my $base_url       = 'http://news.bbc.co.uk/weather/util/search/Search.xhtml?';
+    my $world_base_url = $base_url . 'lowgraphics=true&region=world&search=';
+    my $local_base_url = $base_url . 'lowgraphics=true&region=uk&search=';
 
     my $search_string = shift;
 
     my $world_response = get $world_base_url . $search_string;
-    die unless defined $world_response;
     my $local_response = get $local_base_url . $search_string;
-    die unless defined $local_response;
 
-    &parseResults($world_response);
-    &parseResults($local_response);
+    &parseResults($world_response) if defined($world_response);
+    &parseResults($local_response) if defined($local_response);
 
     if ( ($resultcount > 0 ) && ($#searchresults < 0) ) {
         foreach my $url (@resulturl) {
@@ -40,8 +38,6 @@
 sub parseResults {
     my $response = shift;
     my $isresults = 0;
-    my $havename = 0;
-    my $haveid = 0;
     my $resultline = "";
 
     foreach (split("\n", $response)) {
@@ -59,14 +55,14 @@
             $resultcount = $1 if (/<strong>There \w{2,3} (\d*) forecasts? matching/);
 
             # Collect result URLs
-            if (/<a id=\"result_\d*\" href \=\"?.*search\=.*/) {
+            if (/<a id=\"result_\d*\" .* href \=\"?.*search\=.*/) {
                 $url = $_;
                 $url =~ s/.*href \=\"(.*)\".*/$1/s;
                 push (@resulturl, $url);
             }
 
             # Collect location IDs and location names
-            elsif (/<a id=\"result_\d*\" href \=\"\/weather\/forecast\//) {
+            elsif (/<a id=\"result_\d*\" .* href \=\"\/weather\/forecast\//) {
                 $locid = $_;
                 $locid =~ s/.*\/weather\/forecast\/(\d{0,5})\?.*/$1/s;
         
@@ -74,14 +70,11 @@
                 $locname =~ s/.*<a id=\"result_\d*\".*>(.*)<\/a>.*/$1/s;
 
                 $resultline = $locid . "::" . $locname;
-                push (@searchresults, $resultline);
+                if (! grep(/^$locid/, @searchresults)) {
+                    push (@searchresults, $resultline);
+                }
             }
         }
-
-        if ($havename && $haveid) {
-            push (@searchresults, $resultline);
-            last;
-        }
     }
 
     return @searchresults;
Index: mythplugins/mythweather/mythweather/main.cpp
===================================================================
--- mythplugins/mythweather/mythweather/main.cpp	(revision 23433)
+++ mythplugins/mythweather/mythweather/main.cpp	(working copy)
@@ -142,8 +142,10 @@
     menu->setKillable();
     if (menu->foundTheme())
     {
-        if (LCD *lcd = LCD::Get())
+        if (LCD *lcd = LCD::Get()) {
+            lcd->setFunctionLEDs(FUNC_NEWS, false);
             lcd->switchToTime();
+        }
 
         GetMythMainWindow()->GetMainStack()->AddScreen(menu);
         return 0;
Index: mythplugins/mythmovies/ignyte/ignytegrabber.cpp
===================================================================
--- mythplugins/mythmovies/ignyte/ignytegrabber.cpp	(revision 22751)
+++ mythplugins/mythmovies/ignyte/ignytegrabber.cpp	(working copy)
@@ -19,7 +19,7 @@
             "</tns:GetTheatersAndMovies>\n"
             "</soap:Body>\n"
             "</soap:Envelope>\n");
-    QString server("ignyte.com");
+    QString server("www.ignyte.com");
     QString path("/webservices/ignyte.whatsshowing.webservice/moviefunctions.asmx");
     QString soapAction("http://www.ignyte.com/whatsshowing/GetTheatersAndMovies");
     ms->doSoapRequest(server, path, soapAction, fields);
Index: mythplugins/mythvideo/mtd/dvdprobe.cpp
===================================================================
--- mythplugins/mythvideo/mtd/dvdprobe.cpp	(revision 22751)
+++ mythplugins/mythvideo/mtd/dvdprobe.cpp	(working copy)
@@ -47,6 +47,10 @@
     }
 }
 
+#define LOC_ERR  QString("dvdprobe.cpp, Error: ")
+#define LOC_WARN QString("dvdprobe.cpp, Warning: ")
+#define LOC      QString("dvdprobe.cpp: ")
+
 DVDSubTitle::DVDSubTitle(int subtitle_id, const QString &a_language) :
     id(subtitle_id), language(a_language.toUtf8())
 {
@@ -431,25 +435,47 @@
     //  Before touching libdvdread stuff
     //  (below), see if there's actually
     //  a drive with media in it
-    QFile dvdDevice(device);
-    if (!dvdDevice.exists())
     {
-        //  Device doesn't exist. Silly user
-        Reset();
-        return false;
+        QFile dvdDevice(device);
+        if (!dvdDevice.exists())
+        {
+            //  Device doesn't exist. Silly user
+            Reset();
+            return false;
+        }
     }
 
-    if (!dvdDevice.open(QIODevice::ReadOnly))
+    // On UNIX like file systems O_NONBLOCK should be used to
+    // indicate we don't want to do reading or writing, we
+    // just want to issue some ioctls. This will prevent the
+    // OS from helping out and shearing the fingers off any
+    // person's attempting to place a DVD in the drive when
+    // we call open.
+    int flags = O_RDONLY;
+#ifdef O_NONBLOCK
+    flags |= O_NONBLOCK;
+#endif
+
+    // Ideally we can open with exclusive flag.
+#ifdef O_EXCL
+    flags |= O_EXCL;
+#endif
+    
+    int drive_handle = open(device.toLocal8Bit().constData(), flags);
+
+#ifdef O_EXCL
+    // If this failed with exclusive, try without.
+    if (drive_handle < 0)
     {
-        // Can't open device.
-        Reset();
-        return false;
+        flags &= ~O_EXCL;
+        drive_handle = open(device.toLocal8Bit().constData(), flags);
     }
+#endif
 
-    int drive_handle = dvdDevice.handle();
-
-    if (drive_handle == -1)
+    if (drive_handle < 0)
     {
+        VERBOSE(VB_IMPORTANT, LOC +
+                "Failed to open file descriptor for DVD." + ENO);
         Reset();
         return false;
     }
@@ -470,6 +496,7 @@
     if (status < 0)
     {
         Reset();
+        close(drive_handle);
         return false;
     }
 
@@ -483,6 +510,7 @@
         //  3 = not ready
         //
         Reset();
+        close(drive_handle);
         return false;
     }
 
@@ -493,11 +521,13 @@
         //  the disc has not changed. but if this is our
         //  first time running, we still need to check it
         //  so return whatever we returned before
+        close(drive_handle);
         return titles.size();
     }
 #endif
 
-    dvdDevice.close();
+    close(drive_handle);
+    drive_handle = -1;
 
     //
     //  Try to open the disc
Index: mythplugins/mythvideo/mythvideo/scripts/jamu.py
===================================================================
--- mythplugins/mythvideo/mythvideo/scripts/jamu.py	(revision 22751)
+++ mythplugins/mythvideo/mythvideo/scripts/jamu.py	(working copy)
@@ -1,32 +1,32 @@
-#!/usr/bin/env python 
+#!/usr/bin/env python
 # -*- coding: UTF-8 -*-
 # ----------------------
 # Name: jamu.py      Just.Another.Metadata.Utility
 # Python Script
 # Author: 	R.D. Vaughan
-# Purpose: 	This python script is intended to perform a variety of utility functions on mythvideo 
+# Purpose: 	This python script is intended to perform a variety of utility functions on mythvideo
 #           metadata and the associated video files.
 #
 #           The primary movie source for graphics and data is themoviedb.com wiki.
 #           The primary TV Series source for graphics and data is thetvdb.com wiki.
-#			Users of this script are encouraged to populate both themoviedb.com and thetvdb.com 
+#			Users of this script are encouraged to populate both themoviedb.com and thetvdb.com
 #           with posters, fan art and banners and meta data. The richer the source the more valuable
 #           the script.
-#			This script uses the python module tvdb_api.py (v0.6DEV or higher) found at 
-#			http://pypi.python.org/pypi?%3Aaction=search&term=tvnamer&submit=search thanks 
+#			This script uses the python module tvdb_api.py (v0.6DEV or higher) found at
+#			http://pypi.python.org/pypi?%3Aaction=search&term=tvnamer&submit=search thanks
 #			to the authors of this excellent module.
 #			The tvdb_api.py module uses the full access XML api published by thetvdb.com see:
 #			http://thetvdb.com/wiki/index.php?title=Programmers_API
 #			This python script's functionality is enhanced if you have installed "tvnamer.py" created by
-#           "dbr/Ben" who is also the author of the "tvdb_api.py" module. 
-#           "tvnamer.py" is used to rename avi files with series/episode information found at 
+#           "dbr/Ben" who is also the author of the "tvdb_api.py" module.
+#           "tvnamer.py" is used to rename avi files with series/episode information found at
 #           thetvdb.com
-#           Python access to the tmdb api started with a module from dbr/Ben and then enhanced for 
+#           Python access to the tmdb api started with a module from dbr/Ben and then enhanced for
 #           Jamu's needs.
 #           The routines to select video files was copied and modified from tvnamer.py mentioned above.
-#			The routine "_save_video_metadata_to_mythdb" has been taken and modified from 
+#			The routine "_save_video_metadata_to_mythdb" has been taken and modified from
 #			"find_meta.py" author Pekka Jääskeläinen.
-#           The routine "_addCastGenre" was taken and modified from "tvdb-bulk-update.py" by 
+#           The routine "_addCastGenre" was taken and modified from "tvdb-bulk-update.py" by
 #           author David Shilvock <davels@telus.net>.
 #
 # Command line examples:
@@ -38,28 +38,28 @@
 __title__ ="JAMU - Just.Another.Metadata.Utility";
 __author__="R.D.Vaughan"
 __purpose__='''
-This python script is intended to perform a variety of utility functions on mythvideo metadata 
+This python script is intended to perform a variety of utility functions on mythvideo metadata
 and the associated video files.
 
 The primary movie source for graphics and data is themoviedb.com wiki.
 The primary TV Series source for graphics and data is thetvdb.com wiki.
-Users of this script are encouraged to populate both themoviedb.com and thetvdb.com with posters, 
+Users of this script are encouraged to populate both themoviedb.com and thetvdb.com with posters,
 fan art and banners and meta data. The richer the source the more valuable the script.
 '''
 
-__version__=u"v0.5.5" 
- # 0.1.0 Initial development 
+__version__=u"v0.6.0"
+ # 0.1.0 Initial development
  # 0.2.0 Inital beta release
  # 0.3.0 Add mythvideo metadata updating including movie graphics through
  #       the use of tmdb.pl when the perl script exists
- # 0.3.1 Add mythvideo meta data add and update functionality. Intend use for 
- #       maintenance cron jobs. 
+ # 0.3.1 Add mythvideo meta data add and update functionality. Intend use for
+ #       maintenance cron jobs.
  #       Increase integration with mythtvideo download meta data and MythUI
  #       Added the ability to movie video files while maintaining the metadata
- # 0.3.2 Fixed bug where some poster downloads were unnecessary 
- #       Fixed bug where the mythtv database was updated for no reason 
- #       Fixed bug in jamu-example.conf "min_poster_size" variable had '=' not ':' 
- #       Fixed bug where a unicode URL would abort the script 
+ # 0.3.2 Fixed bug where some poster downloads were unnecessary
+ #       Fixed bug where the mythtv database was updated for no reason
+ #       Fixed bug in jamu-example.conf "min_poster_size" variable had '=' not ':'
+ #       Fixed bug where a unicode URL would abort the script
  #       Using ffmpeg added setting accurate video length in minutes. A hack but
  #       lacked python method to find audio/video properties.
  # 0.3.3 Add logic to skip any video with a inetref of '99999999'. Meta data and
@@ -69,24 +69,24 @@
  # 0.3.4 Added logic to skip any secondary source meta data plot less than 10 words.
  #       Properly initialized a new record so warning messages do not display.
  #       In plot meta data replace line-feeds with a space (e.g. Space Cowboys
- #       plot contains line-feeds). Mythvideo does not expect line-feeds in a plot. 
- #       Significant improvements in combining meta data between primary and 
+ #       plot contains line-feeds). Mythvideo does not expect line-feeds in a plot.
+ #       Significant improvements in combining meta data between primary and
  #       secondary data sources.
  #       Remove 'tmdb.pl' calls and use the tmdb api directly.
  #       Added detection of broken symbolic links and fixed those links.
- #       Fixed inconsistencies in graphics file extentions (as received from the 
- #       sources), made all extentions lowercase and changed ".jpeg" to ".jpg". 
+ #       Fixed inconsistencies in graphics file extentions (as received from the
+ #       sources), made all extentions lowercase and changed ".jpeg" to ".jpg".
  # 0.3.5 Fixed bug when themoviedb.com times out from an api request.
- #       A few documentation corrections. 
- #       Fixed a bug with utf8 directory names. 
+ #       A few documentation corrections.
+ #       Fixed a bug with utf8 directory names.
  #       Added code to not abort script when themoviedb.com has problems. The issue
- #       is reported but the scripts continues processing. 
+ #       is reported but the scripts continues processing.
  #       Added option "-W" to download graphics for Scheduled and Recorded videos.
  #       Change the "-J" Janitor function to avoid deleting graphics for Scheduled
  #		 and Recorded videos.
- #       Fixed bug where a TMDB Poster image was not found when it was really 
+ #       Fixed bug where a TMDB Poster image was not found when it was really
  #       available.
- # 0.3.6 Fixed bug when searching themoviedb.com for a movie by title or 
+ # 0.3.6 Fixed bug when searching themoviedb.com for a movie by title or
  #       alternate title.
  #       Increased accuracy of non-interactive TMDB movie searching and matching.
  #       Set up for transition to TMDB's beta v2.1 api which adds language support.
@@ -94,21 +94,21 @@
  #       If interactive mode is selected but an exact match is found for a movie
  #       then the exact match is chosen and no interative session is initiated.
  #       Added additional messages when access to MythTV python bindings has issues.
- # 0.3.7 Removed some redundant code. 
+ # 0.3.7 Removed some redundant code.
  #       Sync up with v1.0 of tvdb_api and new way to assign tvdb api key
  #       Added an option (-MG) to allow Jamu best guessing at a video's inetref
  #		 number. To guess accurately the video file name must be very close to
- #		 those found on tmdb or imdb and tvdb web sites. 
+ #		 those found on tmdb or imdb and tvdb web sites.
  #       Remove all use of the MythVideo.py "pruneMetadata" routine as it deletes
  #       records from the Mythvideo table for all video files with relative file
  #		 paths.
- #       Jamu will skip processing any videometadata which is using a Storage group. 						 
+ #       Jamu will skip processing any videometadata which is using a Storage group.
  #       Jamu will now restrict itself to updating only videometadata records whose
- #       video files reside on the current host machine. In the case where a user 
+ #       video files reside on the current host machine. In the case where a user
  #       has multiple backends jamu must run on each of those backends.
- #       The Janitor option (-MJ) now checks if the users has set the plugins 
+ #       The Janitor option (-MJ) now checks if the users has set the plugins
  #       MythGallery, MythGame and MythMusic to use the same graphics directories as
- #       MythVideo. If they share directories the Janitor option will exit 
+ #       MythVideo. If they share directories the Janitor option will exit
  #       without removing any graphics files. Messages indicating which directories
  #       are in conflict will be displayed.
  #       Added the detection of video or graphics on an NFS mount exiting jamu without
@@ -118,16 +118,16 @@
  #       Fixed a bug when TMDB does not have a 'year' for a movie (e.g. 'Bambi')
  #		 Added compatibility with or without the MythTV.py Ticket #6678
  #       Fixed a bug when ffmpeg cannot find the true length in minutes of a video
- #       Cleaned up documenation consistency with Warning and Error messages. 
- #       Added to the existing TV episode video file renaming (-MF) option. 
- #       Now movie video files can also be renamed to the format "title (year)" 
+ #       Cleaned up documenation consistency with Warning and Error messages.
+ #       Added to the existing TV episode video file renaming (-MF) option.
+ #       Now movie video files can also be renamed to the format "title (year)"
  #       e.g. "The Duchess (2008)". If tmdb.com has no year for the movie then only
  #		 the movie title will be used when renaming. Any existing metadata is
  #		 preserved.
- # 0.3.8 Made changes to sync up with MythTV trunk change set [r21138]. 
+ # 0.3.8 Made changes to sync up with MythTV trunk change set [r21138].
  #       Now handles TVDB's change from a 5 digit inetref number to 6 digits.
  # 0.3.9 Check accessability (Read and Write) to directories and files before
- #       including them in files/directories to process. 
+ #       including them in files/directories to process.
  #       Add the ability to process Storage Groups for all Videos and graphics.
  #       Jamu now uses MythVideo.py binding's Genre and Cast routines
  #       Fixed a unicode bug with file paths.
@@ -135,28 +135,28 @@
  #		 Fixed a bug were a bad image file could avbort the script.
  #		 Changed all subdirectory cover art to a copied graphic file "folder.jpg/png"
  #		 to conform to the Storage Group standard. This also works for local subdirs.
- #       Fixed a bug where a TV series with out a season specific poster or 
- #		 banner would get repeatedly download. 
+ #       Fixed a bug where a TV series with out a season specific poster or
+ #		 banner would get repeatedly download.
  # 0.4.0 Removed a few lines of debugging code which should never have been left in a
  #       distrubuted version.
  #		 Fixed the check that confirms that all Video and graphic directories are
  #       read and writable.
  #		 Fixed a bug where under rare circumstances a graphic would be repeatedly
- #		 downloaded.  
+ #		 downloaded.
  #		 Made the installation of the python IMDbPy library manditory.
- #       For all movies IMDB numbers will be used instead of converting to TMDB 
+ #       For all movies IMDB numbers will be used instead of converting to TMDB
  #       numbers. This is done to maintain consistency with MythVideo movie inetref
  #       numbers.
  # 0.4.1 Fixed an obscure video file rename (-F option) error
- # 0.4.2 Fixed a bug where bad data for either TMDB or TVDB would abort script 
- # 0.4.3 Recent changes in the MythVideo UI graphic hunts (cover art and fanart) 
- #       have made Jamu's creation of "folder.xxx" graphics redundant. This 
- #       feature has been turned off in Jamu. There is a new user option 
- #       "folderart" that can reactivate this feature through the Jamu 
+ # 0.4.2 Fixed a bug where bad data for either TMDB or TVDB would abort script
+ # 0.4.3 Recent changes in the MythVideo UI graphic hunts (cover art and fanart)
+ #       have made Jamu's creation of "folder.xxx" graphics redundant. This
+ #       feature has been turned off in Jamu. There is a new user option
+ #       "folderart" that can reactivate this feature through the Jamu
  #       configuration file.
  # 0.4.4 Changes to assist SG image hunting Jamu now adds the suffix "_coverart,
  #       _fanart, _banner, _screenshot" respectively to downloaded graphics.
- #       With the use of a graphic suffix the requirement for unique graphics 
+ #       With the use of a graphic suffix the requirement for unique graphics
  #       directories is gone. The check has been removed.
  # 0.4.5 Fixed a bug where lowercase tv video filenames caused graphics files to
  #       also be lowercase which can cause graphics to be downloaded twice.
@@ -166,16 +166,16 @@
  # 0.4.7 Fixed a bug where a 'recordedprogram' record is not properly paired with a
  #       'recorded' record. This results in no "airdate" information being available
  #       and a script abort. An airdate year of u'0000' will be assumed.
- #       Fix an abort bug when IMDB is having service problems and a list of 
+ #       Fix an abort bug when IMDB is having service problems and a list of
  #       movies cannot be retrieved.
- # 0.4.8 Fixed a bug in a -MJ option check that removing graphics would not 
+ # 0.4.8 Fixed a bug in a -MJ option check that removing graphics would not
  #       conflict with graphic directories for non-Mythvideo plugins.
  # 0.4.9 Combine the video file extentions found in the "videotypes" table with those
- #       in Jamu to avoid possible issues in the (-MJ) option and to have tighter 
- #       integration with MythVideo user file extention settings. 
+ #       in Jamu to avoid possible issues in the (-MJ) option and to have tighter
+ #       integration with MythVideo user file extention settings.
  # 0.5.0 Fixed a bug where a filename containing invalid characters caused an abort.
  #       Such invalid filenames are now skipped with an appropriate message.
- #       Added to the -MW option the fetching of graphics from TVDB and TMDB for 
+ #       Added to the -MW option the fetching of graphics from TVDB and TMDB for
  #       videos added by Miro Bridge to either Watched Recordings or MythVideo.
  #       If Miro Bridge is not being used no additional processing is performed.
  #       Two new sections ([mb_tv] and [mb_movies]) were added to the Jamu
@@ -191,32 +191,56 @@
  #       Fixed an abort where a TVDB TV series exists for a language but does not
  #       have a series name in other languages.
  # 0.5.1 Fixed an abort when a user specifies secondary source input parameters
- #       that cannot be parsed from the file name. This 
- #       covers secondary sources for metadata and graphics. 
+ #       that cannot be parsed from the file name. This
+ #       covers secondary sources for metadata and graphics.
  #       Fixed an abort when thetvdb.com cannot be contact due to network or
  #       site issues.
  #       Added detection of erroneous graphics file downloads that are actually HTML
  #       due to source Web site issues. Jamu's (-MJ) janitor option also detects,
  #       deletes these files and repairs the MythVideo record if necessary.
  #       For the -MW option any downloaded graphics names will use the title of the
- #       recorded program instead of that found on sources like TVDB and TMDB. This 
- #       resolves Watch Recordings image hunt issues when Schedule Direct uses a 
+ #       recorded program instead of that found on sources like TVDB and TMDB. This
+ #       resolves Watch Recordings image hunt issues when Schedule Direct uses a
  #       different program title then is on either TVDB or TMDB.
- #       Fixed an obscure bug where TVDB returns empty graphics URLs along with 
+ #       Fixed an obscure bug where TVDB returns empty graphics URLs along with
  #       proper URLs. The empty URLs are now ignored.
  #       Fixed a bug when a language was specified and there were no graphics
- #       for the specified language none were returned/downloaded. This even when 
+ #       for the specified language none were returned/downloaded. This even when
  #       graphics for other languages were available. Now if there are no selected
- #       language graphics English graphics are the fall back and if there are no 
+ #       language graphics English graphics are the fall back and if there are no
  #       English graphics then any available graphics will be returned.
- # 0.5.2 Fixed an abort when trying to add a storage group graphics without a 
- #       proper file path.  
+ # 0.5.2 Fixed an abort when trying to add a storage group graphics without a
+ #       proper file path.
  # 0.5.3 Fixed a bug where the filemarkup table is not cleaned up if Jamu renames
  #       a Miro movie trailer video file that the user wants to keep in MythVideo.
- #       Fixed a bug with Miro video file renaming of Miro Movie trailers 
+ #       Fixed a bug with Miro video file renaming of Miro Movie trailers
  #       for the same movie but which had different file extentions.
  # 0.5.4 Conform to changeset 22104 setting of SG graphics directories to default to SG Videos if not configured.
- # 0.5.5 Deal with TV Series and Movie titles with a "/" forward slash in their name e.g. "Face/Off" 
+ # 0.5.5 Deal with TV Series and Movie titles with a "/" forward slash in their name e.g. "Face/Off"
+ # 0.5.6 Correct an issue when a user has a mixture of local and SG video records in MythVideo. Jamu was
+ #		 adding a hostname when the video had an absolute path. This caused issues with playback.
+ #		 Added more informative error messages when TMDB is returning bad xml responses.
+ #		 Fixed an error in the graphic file naming convention when graphics share the same download directory.
+ # 0.5.7 Remove the override of the TVDB graphics URL to the mirror site. See Kobe's comment:
+ #       http://forums.thetvdb.com/viewtopic.php?f=4&t=2161#p9089
+ # 0.5.8 The issue fixed in v0.5.5 with invalid file name creation did not fully cover TV shows It does now.
+ # 0.5.9 Changed permissions checks on video directories to only require RW for the destination directories
+ #		 involved in the move. With this change if a user requested a file rename (-F) option and the video
+ #		 file does not have RW access the rename will be ignored.
+ #		 Uses that have their Video directories set to access and read-only can now use Jamu.
+ #       Added a stdout display of the directories that Jamu will use for processing. This information may help
+ #       users resolve issues. The display happens ONLY when the -V (verbose) option is used.
+ # 0.6.0 Changed The Janitor -J option to deal with graphics associated with a VIDEO_TS directory.
+ #		 Stopped Jamu from processing any files in a "VIDEO_TS" directory as it was leading to multiple
+ #       MythVideo entires for *.VOB files. Jamu does not process multi-part videos.
+ #       Added the use of PID files to prevent two instances of the same Jamu -M options running at the same
+ #       time. This deals with issues when a meta data source is off line for an extended
+ #       period of time and Jamu runs as a cronjob. Options effected are (-M, -MW and -MG).
+ #       Change to have jamu use the TMDB Movie title as is done in MythVideo rather than the file name.
+ #		 Fixed a bug when TMDB genres are filtered and none remain they were still being added. This bug was
+ #       spotted and correct by Mathieu Brabant (thanks).
+ #		 Added the ability for a user to filter additional characters from a file name this is important for
+ #		 users using MS-Windows file systems as a CIFS mount.
 
 
 usage_txt=u'''
@@ -226,12 +250,12 @@
 Here are the main uses for this utility:
 MythTV users should review the Jamu wiki page at http://www.mythtv.org/wiki/Jamu for details.
 
-1) Simple command line invocation to display or download data from thetvdb.com. 
-   Data can be one or more of: Posters/Cover art, Banners, Fan art, 
-   Episode Images and Episode meta data. use the command "jamu -e | less" to see 
+1) Simple command line invocation to display or download data from thetvdb.com.
+   Data can be one or more of: Posters/Cover art, Banners, Fan art,
+   Episode Images and Episode meta data. use the command "jamu -e | less" to see
    command line examples.
 2) Mass downloads of data matching your video files. **
-   This typically done once to download the information for your video collection. 
+   This typically done once to download the information for your video collection.
 3) Automated maintenance of the information in your video collection. **
 4) The creation of video file names which can be used to set the file name of your recorded TV shows.
    File names can be formated to the users preference with information like series name, season number,
@@ -251,10 +275,10 @@
 These examples are primarily for non-MythTV users of Jamu.
 
 jamu command line examples:
-NOTE: Included here are simple examples of jamu in action. 
+NOTE: Included here are simple examples of jamu in action.
       Please review jamu_README for advise on how to get the most out of jamu.
 
-( Display a TV series top rated poster fanart and banner URLs) 
+( Display a TV series top rated poster fanart and banner URLs)
 > jamu -tS PBF "Sanctuary"
 poster:http://www.thetvdb.com/banners/posters/80159-1.jpg
 fanart:http://www.thetvdb.com/banners/fanart/original/80159-2.jpg
@@ -307,8 +331,8 @@
 episodenumber:3
 episodename:Day 5: 9:00 A.M.-10:00 A.M.
 rating:None
-overview:Jack conceals himself inside the airport hanger and surveys the Russian separatists, feeding information to Curtis and his assault team. 
-The terrorists begin executing hostages in an attempt to make Logan cave into their demands. 
+overview:Jack conceals himself inside the airport hanger and surveys the Russian separatists, feeding information to Curtis and his assault team.
+The terrorists begin executing hostages in an attempt to make Logan cave into their demands.
 Martha discovers that all traces of her conversation with Palmer may not have been erased.
 director:Brad Turner
 writer:Manny Coto
@@ -390,7 +414,7 @@
 	import xml
 except Exception:
 	print '''The python module xml must be installed.'''
-	sys.exit(False)
+	sys.exit(1)
 if xml.__version__ < u'41660':
 	print '''
 \n! Warning - The module xml (v41660 or greater) must be installed. Your version is different (v%s) than what Jamu was tested with. Jamu may not work on your installation.\nIt is recommended that you upgrade.\n''' % xml.__version__
@@ -401,7 +425,7 @@
 except Exception:
 	print '''
 The module MySQLdb (v1.2.2 or greater) must be installed.'''
-	sys.exit(False)
+	sys.exit(1)
 if MySQLdb.__version__ < u'1.2.2':
 	print '''
 \n! Warning - The module MySQLdb (v1.2.2 or greater) must be installed. Your version is different (v%s) than what Jamu was tested with. Jamu may not work on your installation.\nIt is recommended that you upgrade.\n''' % MySQLdb.__version__
@@ -413,19 +437,26 @@
 	get the directories to store poster, fanart, banner and episode graphics.
 	'''
 	from MythTV import MythDB, MythVideo, MythTV
+	mythdb = None
+	mythvideo = None
+	mythtv = None
 	try:
 		'''Create an instance of each: MythTV, MythVideo and MythDB
 		'''
 		mythdb = MythDB()
 		mythvideo = MythVideo()
 		mythtv = MythTV()
+	except MythError, e:
+		print u'\n! Warning - %s' % e.message
+		filename = os.path.expanduser("~")+'/.mythtv/config.xml'
+		if not os.path.isfile(filename):
+			print u'\n! Warning - A correctly configured (%s) file must exist\n' % filename
+		else:
+			print u'\n! Warning - Check that (%s) is correctly configured\n' % filename
 	except Exception:
-		print "\n! Warning - Creating an instance caused and error for one of: MythTV, MythVideo or MythDB\n"
-		mythdb = None
-		mythvideo = None
-		mythtv = None
+		print u"\n! Warning - Creating an instance caused an error for one of: MythTV, MythVideo or MythDB\n"
 except Exception:
-	print "\n! Warning - MythTV python bindings could not be imported\n"
+	print u"\n! Warning - MythTV python bindings could not be imported\n"
 	mythdb = None
 	mythvideo = None
 	mythtv = None
@@ -448,25 +479,25 @@
 The modules tvdb_api.py (v1.0.0 or greater), tvdb_ui.py, tvdb_exceptions.py and cache.py must be
 in the same directory as ttvdb.py. They should have been included with the distribution of ttvdb.py.
 '''
-	sys.exit(False)
+	sys.exit(1)
 
-imdb_lib = True		
+imdb_lib = True
 try:			# Check if the installation is equiped to directly search IMDB for movies
 	import imdb
 except ImportError:
 	sys.stderr.write("\n! Error: To search for movies movies the IMDbPy library must be installed."\
 		"Check your installation's repository or check the following link."\
 		"from (http://imdbpy.sourceforge.net/?page=download)\n")
-	sys.exit(False)
+	sys.exit(1)
 
 if imdb_lib:
 	if imdb.__version__ < "3.8":
 		sys.stderr.write("\n! Error: You version the IMDbPy library (%s) is too old. You must use version 3.8 of higher." % imdb.__version__)
 		sys.stderr.write("Check your installation's repository or check the following link."\
 			"from (http://imdbpy.sourceforge.net/?page=download)\n")
-		sys.exit(False)
-		
-		
+		sys.exit(1)
+
+
 def isValidPosixFilename(name, NAME_MAX=255):
     """Checks for a valid POSIX filename
 
@@ -484,27 +515,13 @@
               _POSIX_NAME_MAX: Maximum number of bytes in a filename
                                (not including terminating null).
                                Value: 14
-                               
+
     More information on http://www.opengroup.org/onlinepubs/009695399/toc.htm
     """
     return 1<=len(name)<= NAME_MAX and "/" not in name and "\000" not in name
 # end isValidPosixFilename()
 
 
-def sanitiseFileName(name):
-	'''Take a file name and change it so that invalid or problematic characters are substituted with a "_" 
-	return a sanitised valid file name
-	'''
-	if name == None or name == u'':
-		return u'_'
-	for char in u"/%\000":
-		name = name.replace(char, u'_')
-	if name[0] == u'.':
-		name = u'_'+name[1:]
-	return name
-# end sanitiseFileName()
-
-
 # Two routines used for movie title search and matching
 def is_punct_char(char):
 	'''check if char is punctuation char
@@ -531,7 +548,7 @@
 
 def _getFileList(dst):
 	''' Create an array of fully qualified file names
-	return an array of file names 
+	return an array of file names
 	'''
 	file_list = []
 	names = []
@@ -556,9 +573,69 @@
 		else:
 			file_list.append(video_file)
 	return file_list
-# end _getFileList	
+# end _getFileList
 
 
+class singleinstance(object):
+	'''
+	singleinstance - based on Windows version by Dragan Jovelic this is a Linux
+					 version that accomplishes the same task: make sure that
+					 only a single instance of an application is running.
+	'''
+
+	def __init__(self, pidPath):
+		'''
+		pidPath - full path/filename where pid for running application is to be
+				  stored.  Often this is ./var/<pgmname>.pid
+		'''
+		from os import kill
+		self.pidPath=pidPath
+		#
+		# See if pidFile exists
+		#
+		if os.path.exists(pidPath):
+			#
+			# Make sure it is not a "stale" pidFile
+			#
+			try:
+				pid=int(open(pidPath, 'r').read().strip())
+				#
+				# Check list of running pids, if not running it is stale so
+				# overwrite
+				#
+				try:
+					kill(pid, 0)
+					pidRunning = 1
+				except OSError:
+					pidRunning = 0
+				if pidRunning:
+					self.lasterror=True
+				else:
+					self.lasterror=False
+			except:
+				self.lasterror=False
+		else:
+			self.lasterror=False
+
+		if not self.lasterror:
+			#
+			# Write my pid into pidFile to keep multiple copies of program from
+			# running.
+			#
+			fp=open(pidPath, 'w')
+			fp.write(str(os.getpid()))
+			fp.close()
+
+	def alreadyrunning(self):
+		return self.lasterror
+
+	def __del__(self):
+		if not self.lasterror:
+			import os
+			os.unlink(self.pidPath)
+	# end singleinstance()
+
+
 # Global variables
 graphicsDirectories = {'banner': u'bannerdir', 'screenshot': u'episodeimagedir', 'coverfile': u'posterdir', 'fanart': u'fanartdir'}
 dir_dict={'posterdir': "VideoArtworkDir", 'bannerdir': 'mythvideo.bannerDir', 'fanartdir': 'mythvideo.fanartDir', 'episodeimagedir': 'mythvideo.screenshotDir', 'mythvideo': 'VideoStartupDir'}
@@ -588,17 +665,24 @@
 		record = {}
 		i = 0
 		for elem in data_id:
-			if table_names[i] == 'groupname' or table_names[i] == 'hostname' or table_names[i] == 'dirname': 
+			if table_names[i] == 'groupname' or table_names[i] == 'hostname' or table_names[i] == 'dirname':
 				record[table_names[i]] = elem
 			i+=1
 		# Skip any storage group that does not belong to the local host
 		# Only include Video, coverfile, banner, fanart, screenshot and trailers storage groups
 		if record['hostname'].lower() == localhostname.lower() and record['groupname'] in storagegroupnames.keys():
+			try:
+				dirname = unicode(record['dirname'], 'utf8')
+			except (UnicodeDecodeError):
+				sys.stderr.write(u"\n! Error: The local Storage group (%s) directory contained\ncharacters that caused a UnicodeDecodeError. This storage group has been rejected.'\n" % (record['groupname']))
+				continue	# Skip any line that has non-utf8 characters in it
+			except (UnicodeEncodeError, TypeError):
+				pass
 			# Strip the trailing slash so it is consistent with all other directory paths in Jamu
-			if record['dirname'][-1:] == '/': 
-				storagegroups[storagegroupnames[record['groupname']]].append(record['dirname'][:-1])
+			if dirname[-1:] == u'/':
+				storagegroups[storagegroupnames[record['groupname']]].append(dirname[:-1])
 			else:
-				storagegroups[storagegroupnames[record['groupname']]].append(record['dirname'])
+				storagegroups[storagegroupnames[record['groupname']]].append(dirname)
 		continue
 	cur.close()
 
@@ -617,24 +701,24 @@
 		storagegroup_ok = True
 		for key in storagegroups.keys():
 			for directory in storagegroups[key]:
-				if not os.access(directory, os.F_OK | os.R_OK | os.W_OK):
-					sys.stderr.write(u"\n! Error: The local Storage group (%s) directory (%s) does not exist or there is a permissions restriction\n" % (key, directory))
+				if not os.access(directory, os.F_OK):
+					sys.stderr.write(u"\n! Error: The local Storage group (%s) directory (%s) does not exist\n" % (key, directory))
 					storagegroup_ok = False
 		if not storagegroup_ok:
-			sys.exit(False)
+			sys.exit(1)
 # end getStorageGroups
 
 # Start of code used to access themoviedb.com api
-class TmdBaseError(Exception): 
+class TmdBaseError(Exception):
 	pass
 
-class TmdHttpError(TmdBaseError): 
-	def __repr__(self):	# Display the type of error 
+class TmdHttpError(TmdBaseError):
+	def __repr__(self):	# Display the type of error
 		print u"TMDB Http Error"
 		return None
 	# end __repr__
 
-class TmdXmlError(TmdBaseError): 
+class TmdXmlError(TmdBaseError):
 	def __repr__(self):	# Display the type of error
 		print u"TMDB XML Error"
 		return None
@@ -698,12 +782,12 @@
 	def set(self, poster_et):
 		"""Takes an elementtree Element ('poster') and stores the poster,
 		using the size as the dict key.
-        
+
 		For example:
 		<backdrop size="original">
 			http://example.com/poster_original.jpg
 		</backdrop>
-        
+
 		..becomes:
 		poster['original'] = 'http://example.com/poster_original.jpg'
 		"""
@@ -738,14 +822,14 @@
 	def set(self, people_et):
 		"""Takes an element tree Element ('people') and stores a dictionary of roles,
 		for each person.
-        
+
 		For example:
 		<person job="director">
 			<name>Robert Rodriguez</name>
 			<role/>
 			<url>http://www.themoviedb.org/person/2294</url>
 		</person>
-        
+
 		..becomes:
 		self['people']['director'] = 'Robert Rodriguez'
 		"""
@@ -768,7 +852,7 @@
 
 class MovieDb:
 	"""Main interface to www.themoviedb.com
-    
+
 	The search() method searches for the film by title.
 	"""
 	# Local Variables
@@ -803,7 +887,7 @@
 				http://www.themoviedb.org/encyclopedia/category/6033
 			</url>
 		</category>
-        
+
 		..becomes:
 		'Literary Fiction'
 		"""
@@ -826,12 +910,12 @@
 		return comma seperated sting of film category names
 
 		For example:
-		<production_countries> 
-			<country> 
-				<name>United States of America</name> 
-				<url>http://www.../country/223</url> 
-			</country> 
-		</production_countries>        
+		<production_countries>
+			<country>
+				<name>United States of America</name>
+				<url>http://www.../country/223</url>
+			</country>
+		</production_countries>
 		..becomes:
 		'United States of America'
 		"""
@@ -904,8 +988,8 @@
 					continue
 			if key == u'imdb':
 				translated[key] = cur_movie[key][2:]
-				continue				
-			if key == u'release': 
+				continue
+			if key == u'release':
 				translated[u'year'] = cur_movie[key][:4]
 			if self.tmdb_config[u'translation'].has_key(key):
 				translated[self.tmdb_config[u'translation'][key]] = cur_movie[key]
@@ -930,7 +1014,7 @@
 
 	def searchTMDB(self, by_id, graphics=False, lang=u'en'):
 		"""Searches for a film by its TMDB id number.
-		Returns a movie data dictionary 
+		Returns a movie data dictionary
 		"""
 		id_url = urllib.quote(by_id.encode("utf-8"))
 		url = self.tmdb_config[u'urls'][u'tmdbid.search'] % (id_url)
@@ -946,12 +1030,11 @@
 
    	def searchIMDB(self, by_id, graphics=False, lang=u'en'):
 		"""Searches for a film by its IMDB number.
-		Returns a movie data dictionary 
+		Returns a movie data dictionary
 		"""
 		id_url = urllib.quote(by_id.encode("utf-8"))
 		url = self.tmdb_config[u'urls'][u'imdb.search'] % (id_url)
 		etree = XmlHandler(url).getEt()
-
 		if self._parseMovie(etree.find(u"moviematches").find(u"movie")).has_key(u'inetref'):
 			return self.searchTMDB(self._parseMovie(etree.find(u"moviematches").find(u"movie"))[u'inetref'], graphics=graphics)
 		else:
@@ -987,7 +1070,7 @@
 video_type = u''
 UI_title = u''
 UI_search_language = u''
-UI_selectedtitle = u'' 
+UI_selectedtitle = u''
 # List of language from http://www.thetvdb.com/api/0629B785CE550C8D/languages.xml
 # Hard-coded here as it is realtively static, and saves another HTTP request, as
 # recommended on http://thetvdb.com/wiki/index.php/API:languages.xml
@@ -1026,7 +1109,7 @@
 			if filter(is_not_punct_char, name.lower()).startswith(filter(is_not_punct_char, UI_title.lower())):
 				most_likely.append(name)
 
-		# IMDB can return titles that are a movies foriegn title. The titles that do not match 
+		# IMDB can return titles that are a movies foriegn title. The titles that do not match
 		# the requested title need to be added to the end of the most likely titles list.
 		if video_type == u'IMDB' and len(most_likely):
 			for name in tmp_names:
@@ -1037,7 +1120,7 @@
 
 		names = []
 		# Remove any name that does not start with a title like the TV Show/Movie (except for IMDB)
-		if len(most_likely): 
+		if len(most_likely):
 			for likely in most_likely:
 				names.append(likely)
 		else:
@@ -1049,7 +1132,7 @@
 		# reorder the list of series and sid's
 		new_array=[]
 		for key in names: # list all search results
-			new_array.append(allSeries[key]) 
+			new_array.append(allSeries[key])
 
 		# If there is only one to select and it is an exact match then return with no interface display
 		if len(new_array) == 1:
@@ -1101,7 +1184,7 @@
 		else:
 			reftype = u'Series id'
 			refsize = 5
-			refformat = u"%6d"	# Attempt to have the most likely TV/Movies at the top of the list 
+			refformat = u"%6d"	# Attempt to have the most likely TV/Movies at the top of the list
 
 		while True: # return breaks this loop
 			try:
@@ -1194,13 +1277,13 @@
 	"""
 	def __init__(self, interactive = False, debug = False):
 		"""Initialize default configuration settings
-		""" 
+		"""
 		self.config = {}
 		# Set all default variables
 		self.config['interactive'] = interactive
 		self.config['debug_enabled'] = debug
 		self.config['flags_options'] = False
-		self.config['local_language'] = u'en' 
+		self.config['local_language'] = u'en'
  		self.config['simulation'] = False
 		self.config['toprated'] = False
 		self.config['download'] = False
@@ -1240,7 +1323,7 @@
 
 		# The default format of the graphics file names (with and without seasons and/or episode names)
 		# The default is to use the URL's filename from thetvdb.com
-		self.config['g_defaultname']=True	
+		self.config['g_defaultname']=True
 		# e.g. "Fringe - 01.jpg"
 		self.config['g_series'] = u'%(series)s - %(seq)s.%(ext)s'
 		# e.g. "SG-1 - 07-02.jpg"
@@ -1263,7 +1346,9 @@
 		self.config['ffmpeg'] = True
 		self.config['folderart'] = False
 		self.config['metadata_exclude_as_update_trigger'] = ['intid', 'season', 'episode', 'showlevel', 'filename', 'coverfile', 'childid', 'browse', 'playcommand', 'trailer', 'host', 'screenshot', 'banner', 'fanart']
+		self.config['filename_char_filter'] = u"/%\000"
 
+
 		# Dictionaries for Miro Bridge metadata downlods
 		self.config['mb_tv_channels'] = {}
 		self.config['mb_movies'] = {}
@@ -1304,6 +1389,10 @@
 			# foo.0103*
 			re.compile(u'''^(.+)[ \._\-]([0-9]{2})([0-9]{2,3})[\._ -][^\\/]*$''' , re.UNICODE),
 		]
+
+		# Initalize a valriable used by the -MW option
+		self.program_seriesid = None
+		self.config[u'file_move_flag'] = False
 	# end __init__
 
 	# Local variable
@@ -1338,35 +1427,39 @@
 			sys.stderr.write(
 				"\n! Error: The specified user configuration file (%s) is not a file\n" % useroptions
 			)
-			sys.exit(False)
+			sys.exit(1)
 		cfg = ConfigParser.SafeConfigParser()
 		cfg.read(useroptions)
-		for section in cfg.sections(): 
+		for section in cfg.sections():
 			if section[:5] == 'File ':
 				self.config['config_file'] = section[5:]
 				continue
 			if section == 'variables':
 				# Change variables per user config file
-				for option in cfg.options(section): 
+				for option in cfg.options(section):
 					if option == 'video_file_exts' or option == 'tmdb_genre_filter' or option == 'metadata_exclude_as_update_trigger':
 						tmp_list = (cfg.get(section, option).rstrip()).split(',')
 						for i in range(len(tmp_list)): tmp_list[i] = (tmp_list[i].strip()).lower()
 						self.config[option] = tmp_list
 						continue
+					if option == 'filename_char_filter':
+						for char in cfg.get(section, option):
+							self.config['filename_char_filter']+=char
+						continue
 					# Ignore user settings for Myth Video and graphics file directories
-					# when the MythTV metadata option (-M) is selected 
+					# when the MythTV metadata option (-M) is selected
 					if self.config['mythtvmeta'] and option in ['posterdir', 'bannerdir', 'fanartdir', 'episodeimagedir', 'mythvideo']:
 						continue
 					self.config[option] = cfg.get(section, option)
 				continue
 			if section == 'regex':
 				# Change variables per user config file
-				for option in cfg.options(section): 
+				for option in cfg.options(section):
 					self.config['name_parse'].append(re.compile(unicode(cfg.get(section, option), 'utf8'), re.UNICODE))
 				continue
 			if section =='series_name_override':
 				overrides = {}
-				for option in cfg.options(section): 
+				for option in cfg.options(section):
 					overrides[option] = cfg.get(section, option)
 				if len(overrides) > 0:
 					self.config['series_name_override'] = overrides
@@ -1377,7 +1470,7 @@
 					tmp =cfg.get(section, option).split(',')
 					if len(tmp)%2 and len(cfg.get(section, option)) != 0:
 						sys.stderr.write(u"\n! Error: For (%s) 'ep_name_massage' values must be in pairs\n" % option)
-						sys.exit(False)
+						sys.exit(1)
 					tmp_array=[]
 					i=0
 					while i != len(tmp):
@@ -1413,19 +1506,19 @@
 			for sec in ['movies-secondary-sources', 'tv-secondary-sources']:
 				if section == sec:
 					secondary = {}
-					for option in cfg.options(section): 
+					for option in cfg.options(section):
 						secondary[option] = cfg.get(section, option)
 					if len(secondary) > 0:
 						self.config['myth_secondary_sources'][sec[:sec.index('-')]] = secondary
 				continue
 			if section == u'mb_tv':
 				# Add the channel names and their corresponding thetvdb.com id numbers
-				for option in cfg.options(section): 
+				for option in cfg.options(section):
 					self.config['mb_tv_channels'][filter(is_not_punct_char, option.lower())] = [cfg.get(section, option), u'']
 				continue
 			if section == u'mb_movies':
 				# Add the channel names for movie trailer Channels
-				for option in cfg.options(section): 
+				for option in cfg.options(section):
 					self.config['mb_movies'][filter(is_not_punct_char, option.lower())] = cfg.get(section, option)
 				continue
 
@@ -1441,7 +1534,7 @@
 
 	def displayOptions(self):
 		""" Display all of the configuration values. This is used to verify that the user has the
-		variables set as they want before running jamu live. 
+		variables set as they want before running jamu live.
 		"""
 		keys=self.config.keys()
 		keys.sort()
@@ -1449,7 +1542,7 @@
 ################### Used to create the example configuration file "jamu-example-conf"
 #		for key in keys:	# Used to create the example configuration file "jamu-example-conf"
 #			print "#%s: %s" % (key, self.config[key])
-#		sys.exit(True)
+#		sys.exit(0)
 ##################
 
 		for key in keys:
@@ -1458,7 +1551,7 @@
 			try:
 				if key == 'name_parse':
 					print u"%s (%d items)" % (key, len(self.config[key]))
-				else: 
+				else:
 					print u"%s (%s)" % (key, str(self.config[key]))
 			except:
 				try:
@@ -1490,7 +1583,7 @@
 			localip = gethostbyname(localhostname) # Get the local hosts IP address
 		except:
 			sys.stderr.write("\n! Error: There is no valid address-to-host mapping for the host (%s)\nThe Jamu Janitor (-MJ) option cannot be used while this issue remains un-resolved.\n" % localhostname)
-			sys.exit(False)
+			sys.exit(1)
 
 		# Get all curently mounted NFS shares
 		tmp_mounts = callCommandLine("mount -l | grep '//'").split('\n')
@@ -1535,7 +1628,7 @@
 
 
 	def _getMythtvDirectories(self):
-		"""Get all graphics directories found in the MythTV DB and change their corresponding 
+		"""Get all graphics directories found in the MythTV DB and change their corresponding
 		configuration values.  /media/video:/media/virtual/VB_Share/Review
 		"""
 		# Stop processing if this local host has any storage groups
@@ -1543,11 +1636,11 @@
 		# Make sure Jamu is being run on a MythTV backend
 		if not mythdb.getSetting('BackendServerIP', hostname = localhostname):
  			sys.stderr.write(u"\n! Error: Jamu must be run on a MythTV backend. Local host (%s) is not a MythTV backend.\n" % localhostname)
-			sys.exit(False)
-			
+			sys.exit(1)
+
 		global dir_dict
 		for key in dir_dict.keys():
-			graphics_dir = mythdb.getSetting(dir_dict[key], hostname = localhostname) 
+			graphics_dir = mythdb.getSetting(dir_dict[key], hostname = localhostname)
 			# Only use path from MythTV if one was found
 			self.config[key] = []
 			if key == 'mythvideo' and graphics_dir:
@@ -1560,17 +1653,50 @@
 								self.config[key].append(tmp_directories[i])
 								continue
 							else:
-						 		sys.stderr.write(u"\n! Warning: MythTV video directory (%s) is not set or does not exist(%s).\n" % (key, tmp_directories[i]))
+						 		sys.stderr.write(u"\n! Warning: MythTV video directory (%s) does not exist.\n" % (tmp_directories[i]))
+						 		continue
 
 			if key != 'mythvideo' and graphics_dir:
-				self.config[key] = [graphics_dir]
+				if os.path.os.access(graphics_dir, os.F_OK):
+					self.config[key] = [graphics_dir]
+				else:
+					sys.stderr.write(u"\n! Warning: MythTV (%s) directory (%s) does not exist.\n" % (key, graphics_dir))
 
-		# Get Storage Groups and override any FE directory settings 
+		# Save the FE path settings local to this backend
+		self.config['localpaths'] = {}
+		for key in dir_dict.keys():
+			self.config['localpaths'][key] = []
+			local_paths = []
+			if len(self.config[key]):
+				for path in self.config[key]:
+					local_paths.append(path)
+				self.config['localpaths'][key] = local_paths
+
+		# If there is a Videos SG then there is always a Graphics SG using Videos as a fallback
 		getStorageGroups()
-		for key in storagegroups.keys():
-			self.config[key] = storagegroups[key]
+		for key in dir_dict.keys():
+			if key == 'episodeimagedir' or key == 'mythvideo':
+				continue
+			if storagegroups.has_key(u'mythvideo') and not storagegroups.has_key(key):
+				storagegroups[key] = list(storagegroups[u'mythvideo'])		# Set fall back
 
+		# Use Storage Groups as the priority but append any FE directory settings that
+		# are local to this BE but are not already used as a storage group
+		if storagegroups.has_key(u'mythvideo'):
+			for key in storagegroups.keys():
+				self.config[key] = list(storagegroups[key])
+				for k in self.config['localpaths'][key]:
+					if not k in self.config[key]:
+						self.config[key].append(k)	# Add any FE settings local directories not already included
+					else:
+						if key == 'mythvideo':
+							sys.stdout.write(u"\n! Warning: You have a front end video directory path that is a duplicate of this backend's 'Videos' storage group.\nFront end directory (%s)\nThe Front end setting has been ignored.\nThis Front end video directory will cause duplicate entires in MythVideo.\n" % (k))
+						else:
+							sys.stdout.write(u"\n! Info: You have a front end directory path that is a duplicate of this backend's storage group.\nFront end directory (%s)\nThe Front end setting has been ignored.\n" % (k))
+					continue
+
 		# Make sure there is a directory set for Videos and other graphics directories on this host
+		exists = True
 		for key in dir_dict.keys():
 			if key == 'episodeimagedir': # Jamu does nothing with Screenshots
 				continue
@@ -1579,36 +1705,90 @@
 				self.config[key] = storagegroups[u'mythvideo']
 			if not len(self.config[key]):
 	 			sys.stderr.write(u"\n! Error: There must be a directory for Videos and each graphic type. The (%s) directory is missing.\n" % (key))
-				sys.exit(False)
+				exists = False
+		if not exists:
+			sys.exit(1)
 
-		# Make sure that the directory sets for Videos and other graphics directories are RW able
+		# Make sure that the directory set for Videos and other graphics directories have the proper permissions
 		accessable = True
 		for key in dir_dict.keys():
 			for directory in self.config[key]:
+				if key == 'episodeimagedir': # Jamu does nothing with Screenshots
+					continue
+				if key == 'mythvideo':
+					if not os.access(directory, os.F_OK | os.R_OK):
+			 			sys.stderr.write(u"\n! Error: This video directory must have read access for Jamu to function.\nThere is a permissions issue with (%s).\n" % (directory, ))
+						accessable = False
+					continue
 				if not os.access(directory, os.F_OK | os.R_OK | os.W_OK):
-		 			sys.stderr.write(u"\n! Error: Every Video and graphics directory must be read/writable for Jamu to function.\nThere is a permissions issue with (%s).\n" % (directory, ))
+		 			sys.stderr.write(u"\n! Error: The (%s) directory (%s) must be read/writable for Jamu to function.\n" % (key, directory, ))
 					accessable = False
 		if not accessable:
-			sys.exit(False)
+			sys.exit(1)
 
+		# Print out the video and image directories that will be used for processing
+		if self.config['mythtv_verbose']:
+			dir_types={'posterdir': "Cover art  ", 'bannerdir': 'Banners    ', 'fanartdir': 'Fan art    ', 'episodeimagedir': 'Screenshots', 'mythvideo': 'Video      '}
+			sys.stdout.write(u"\n==========================================================================================\n")
+			sys.stdout.write(u"Listed below are the types and base directories Jamu will use for processing.\nThe list reflects your current configuration for the '%s' back end\nand whether a directory is a 'SG' (storage group) or not.\n" % localhostname)
+			sys.stdout.write(u"Note: All directories are from settings in the MythDB specific to hostname (%s).\n" % localhostname)
+			sys.stdout.write(u"Note: Screenshot directories are not listed as Jamu does not process Screenshots.\n")
+			sys.stdout.write(u"------------------------------------------------------------------------------------------\n")
+			for key in dir_dict.keys():
+				if key == 'episodeimagedir':
+					continue
+				for directory in self.config[key]:
+					sg_flag = 'NO '
+					if storagegroups.has_key(key):
+						if directory in storagegroups[key]:
+							sg_flag = 'YES'
+					sys.stdout.write(u"Type: %s - SG-%s - Directory: (%s)\n" % (dir_types[key], sg_flag, directory))
+			sys.stdout.write(u"------------------------------------------------------------------------------------------\n")
+			sys.stdout.write(u"If a directory you set from a separate Front end is not displayed it means\nthat the directory is not accessible from this backend OR\nyou must add the missing directories using the Front end on this Back end.\nFront end settings are host machine specific.\n")
+			sys.stdout.write(u"==========================================================================================\n\n")
+
+		if self.config[u'file_move_flag']:	# verify the destination directory in a move is read/writable
+			index = 0
+			accessable = True
+			for arg in self.args:
+				if index % 2 == 0:
+					index+=1
+					continue
+				if not os.access(arg, os.F_OK):
+					for dirct in self.config['mythvideo']:
+						if arg.startswith(dirct):
+							if not os.access(dirct, os.F_OK | os.R_OK | os.W_OK):
+					 			sys.stderr.write(u"! Error: Your move destination root MythVideo directory (%s) must be read/writable for Jamu to function.\n\n" % (dirct, ))
+								accessable = False
+							break
+					else:
+			 			sys.stderr.write(u"! Error: Your move destination directory (%s) must be a MythVideo directory OR a subdirectory of a MythVideo directory.\n\n" % (arg, ))
+						accessable = False
+				elif not os.access(arg, os.F_OK | os.R_OK | os.W_OK):
+		 			sys.stderr.write(u"! Error: Your move destination directory (%s) must be read/writable for Jamu to function.\n\n" % (arg, ))
+					accessable = False
+				index+=1
+			if not accessable:
+				sys.exit(1)
+
 		# Check if any Video files are on a NFS shares
 		if not self.config['mythtvNFS']:	# Maybe the NFS check is to be skipped
-			if self._checkNFS(self.config['mythvideo'], self.config['video_file_exts']): 
+			if self._checkNFS(self.config['mythvideo'], self.config['video_file_exts']):
 				sys.stderr.write(u"\n! Error: Your video files reside on a NFS mount.\nIn the case where you have more than one MythTV backend using the same directories to store either video files\nor graphics any Jamu's option (-M) can adversly effect your MythTV database by mistakenly adding videos\nfor other backends or with the Janitor (-J) option mistakenly remove graphics files.\n\nIf you only have one backend or do not mix the Video or graphic file directories between backends and still want to use\nJamu add the options (N) to your option string e.g. (-MJN), which will skip this check.\n\n")
-				sys.exit(False)
+				sys.exit(1)
 	# end _getMythtvDirectories
 
 
 	def _JanitorConflicts(self):
-		'''Verify that there are no conflict between the graphics directories of MythVideo and 
+		'''Verify that there are no conflict between the graphics directories of MythVideo and
 		other MythTV plugins. Write an warning message if a conflict is found.
 		return True when there is a conflict
 		return False when there is no conflict
 		'''
-		# Except for the plugins below no other plugins have non-theme graphics 
-		# MythGallery: 
+		# Except for the plugins below no other plugins have non-theme graphics
+		# MythGallery:
 		# 	Table 'settings' fields 'GalleryDir', 'GalleryImportDirs', 'GalleryThumbnailLocation'
-		# MythGame: 
+		# MythGame:
 		#	Table 'settings' fields 'mythgame.screenshotDir', 'mythgame.fanartDir', 'mythgame.boxartDir'
 		# MythMusic:
 		#	Table 'settings' fields 'MusicLocation'
@@ -1626,7 +1806,7 @@
 				for directory in graphicsDirectories.keys():
 					if not self.config[graphicsDirectories[directory]]:
 						continue
-					# As the Janitor processes subdirectories matching must be a starts with check 
+					# As the Janitor processes subdirectories matching must be a starts with check
 					for direc in self.config[graphicsDirectories[directory]]:
 						if os.path.realpath(setting).startswith(os.path.realpath(direc)):
 							sys.stderr.write(u"\n! Error - The (%s) directory (%s) conflicts\nwith the MythVideo (%s) directory (%s).\nThe Jamu Janitor (-MJ) option cannot be used.\n\n" % (field, setting, direc, self.config[graphicsDirectories[directory]]) )
@@ -1658,7 +1838,7 @@
 				record[table_names[i]] = elem
 				i+=1
 			# Remove any extentions that are in Jamu's list but the user wants ignore
-			if record[u'f_ignore']: 
+			if record[u'f_ignore']:
 				if record[u'extension'] in self.config['video_file_exts']:
 					self.config['video_file_exts'].remove(record[u'extension'])
 				if record[u'extension'].lower() in self.config['video_file_exts']:
@@ -1689,39 +1869,46 @@
 		if self.config['mythtvmeta']:
 			if mythdb == None or mythvideo == None:
 				sys.stderr.write(u"\n! Error: The MythTV python interface is not installed or Cannot connect to MythTV Backend. MythTV meta data cannot be updated\n\n")
-				sys.exit(False)
+				sys.exit(1)
 			try:
 				import Image
 				self.config['image_library'] = Image
 			except:
-				sys.stderr.write(u"""\n! Error: Python Imaging Library is required for figuring out the sizes of 
+				sys.stderr.write(u"""\n! Error: Python Imaging Library is required for figuring out the sizes of
 the fetched poster images.
 
 In Debian/Ubuntu it is packaged as 'python-imaging'.
 http://www.pythonware.com/products/pil/\n""")
-				sys.exit(False)
+				sys.exit(1)
 
 		if not _can_int(self.config['min_poster_size']):
 			sys.stderr.write(u"\n! Error: The poster minimum value must be an integer (%s)\n" % self.config['min_poster_size'])
-			sys.exit(False)
+			sys.exit(1)
 		else:
 			self.config['min_poster_size'] = int(self.config['min_poster_size'])
 
 		if self.config['maximum'] != None:
 			if _can_int(self.config['maximum']) == False:
 				sys.stderr.write(u"\n! Error: Maximum option is not an integer (%s)\n" % self.config['maximum'])
-				sys.exit(False)
+				sys.exit(1)
 
+		# Detect if this is a move request
+		self.config[u'file_move_flag'] = False
+		if len(args) != 0:
+			if os.path.isfile(args[0]) or os.path.isdir(args[0]) or args[0][-1:] == '*':
+				self.config[u'file_move_flag'] = True
+				self.args = list(args)
+
 		if self.config['mythtvdir']:
 			if mythdb == None or mythvideo == None:
 	 			sys.stderr.write(u"\n! Error: MythTV python interface is not available\n")
-				sys.exit(False)
+				sys.exit(1)
 		if self.config['mythtvdir'] or self.config['mythtvmeta']:
 			self._addMythtvUserFileTypes() # add user filetypes from the "videotypes" table
 			self._getMythtvDirectories()
 		if self.config['mythtvjanitor']: # Check for graphic directory conflicts with other plugins
 			if self._JanitorConflicts():
-				sys.exit(False)
+				sys.exit(1)
 			if not self.config['mythtvNFS']:
 				global graphicsDirectories, image_extensions
 				dirs = []
@@ -1730,26 +1917,26 @@
 						for directory in self.config[graphicsDirectories[key]]:
 							dirs.append(directory)
 				# Check if any Graphics files are on NFS shares
-				if self._checkNFS(dirs, image_extensions): 
+				if self._checkNFS(dirs, image_extensions):
 					sys.stderr.write(u"\n! Error: Your metadata graphics reside on a NFS mount.\nIn the case where you have more than one MythTV backend using the same directories to store your graphics\nthe Jamu's Janitor option (-MJ) will be destructive removing graphics used by the other backend(s).\n\nIf you only have one backend or do not mix the graphics directories between backends and still want to use\nJamu's Janitor use the options (-MJN) which will skip this check.\n\n")
-					sys.exit(False)
+					sys.exit(1)
 
 		if self.config['posterresize'] != False or self.config['fanartresize'] != False:
 			if _useImageMagick("-version"):
 				sys.stderr.write(u"\n! Error: ImageMagick is not installed, graphics cannot be resized. posterresize(%s), fanartresize(%s)\n" % (str(self.config['posterresize']), str(self.config['fanartresize'])))
-				sys.exit(False)
+				sys.exit(1)
 
 		if self.config['mythtvmeta'] and len(args) == 0:
 			args=['']
 
 		if len(args) == 0:
 			sys.stderr.write(u"\n! Error: At least a video directory, SID or season name must be supplied\n")
-			sys.exit(False)
+			sys.exit(1)
 
 		if os.path.isfile(args[0]) or os.path.isdir(args[0]) or args[0][-1:] == '*':
 			self.config['video_dir'] = []
 			for arg in args:
-				self.config['video_dir'].append(unicode(arg,'utf8')) 
+				self.config['video_dir'].append(unicode(arg,'utf8'))
 		elif not self.config['mythtvmeta']:
 			if _can_int(args[0]) and len(args[0]) >= 5:
 				self.config['sid'] = unicode(args[0], 'utf8') # There is still a chance that this is a series name "90210"
@@ -1765,13 +1952,13 @@
 				if len(args) > 3:
 					sys.stderr.write("\n! Error: Too many arguments (%d), maximum is three.\n" % len(args))
 					print "! args:", args
-					sys.exit(False)
+					sys.exit(1)
 				if len(args) == 3 and _can_int(args[1]) and _can_int(args[2]):
 					self.config['season_num'] = args[1]
 					self.config['episode_num'] = args[2]
 				elif len(args) == 3:
 					sys.stderr.write(u"\n! Error: Season name(%s), season number(%s), episode number (%s) combination is invalid\n" % (args[0], args[1], args[2]))
-					sys.exit(False)
+					sys.exit(1)
 				elif len(args) == 2 and _can_int(args[1]):
 					self.config['season_num'] = args[1]
 				else:
@@ -1799,7 +1986,7 @@
 				for lang in valid_languages: valid_langs+= lang+', '
 				valid_langs=valid_langs[:-2]
 				sys.stderr.write(u"\n! Error: Specified language(%s) must match one of the following languages supported by thetvdb.com wiki:\n (%s)\n" % (self.config['local_language'], valid_langs))
-				sys.exit(False)
+				sys.exit(1)
 		global UI_search_language
 		UI_search_language = self.config['local_language']
 
@@ -1821,11 +2008,11 @@
 	"""Process direct thetvdb.com requests
 	"""
 	def __init__(self, configuration):
-		"""Retrieve all configuration options and get an instance of tvdb_api which is used to 
+		"""Retrieve all configuration options and get an instance of tvdb_api which is used to
 		access thetvdb.com wiki.
 		"""
 		self.config = configuration
-		cache_dir=u"/tmp/tvdb_api_%s/" % os.geteuid() 
+		cache_dir=u"/tmp/tvdb_api_%s/" % os.geteuid()
 		if self.config['interactive']:
 			self.config['tvdb_api'] = tvdb_api.Tvdb(banners=True, debug=self.config['debug_enabled'], interactive=True,  select_first=False, cache=cache_dir, actors = True, language = self.config['local_language'], custom_ui=jamu_ConsoleUI, apikey="0BB856A59C51D607")  # thetvdb.com API key requested by MythTV)
 		else:
@@ -1850,6 +2037,20 @@
 	banner_type=u'banner'
 	ep_image_type=u'filename'
 
+	def sanitiseFileName(self, name):
+		'''Take a file name and change it so that invalid or problematic characters are substituted with a "_"
+		return a sanitised valid file name
+		'''
+		if name == None or name == u'':
+			return u'_'
+		for char in self.config['filename_char_filter']:
+			name = name.replace(char, u'_')
+		if name[0] == u'.':
+			name = u'_'+name[1:]
+		return name
+	# end sanitiseFileName()
+
+
 	def _getSeriesBySid(self, sid):
 		"""Lookup a series via it's sid
 		return tvdb_api Show instance
@@ -1894,10 +2095,10 @@
 
 	def verifySeriesExists(self):
 		"""Verify that a:
-		Series or 
-		Series and Season or 
+		Series or
+		Series and Season or
 		Series and Season and Episode number or
-		Series and Episode name 
+		Series and Episode name
 		passed by the user exists on thetvdb.com
 		return False and display an appropriate error if the TV data was not found
 		return an tvdb_api instance of the TV show/season/episode data if it was found
@@ -1921,7 +2122,7 @@
 							if len(ep['episodename']) > (len(episode_name)+1):
 								# Skip episodes the are not part of a set of (1), (2) ... etc
 								if ep['episodename'][len(episode_name):len(episode_name)+2] != ' (':
-									continue	
+									continue
 								series_sid = ep['seriesid']
 								self.config['sid'] = ep['seriesid']
 								self.config['season_num'] = ep['seasonnumber']
@@ -1933,7 +2134,7 @@
 								self.config['season_num'] = ep['seasonnumber']
 								self.config['episode_num'] = ep['episodenumber']
 								return(ep)
-				raise tvdb_episodenotfound					
+				raise tvdb_episodenotfound
 			# Search for the series or series & season or series & season & episode
 			elif season:
 				if episode: 	# series & season & episode
@@ -1941,7 +2142,7 @@
 					self.config['sid'] = seriesfound['seriesid']
 					self.config['episode_name'] = seriesfound['episodename']
 				else:							# series & season
-					seriesfound=self._searchforSeries(series_name)[int(season)] 
+					seriesfound=self._searchforSeries(series_name)[int(season)]
 			else:
 				seriesfound=self._searchforSeries(series_name)	# Series only
 		except tvdb_shownotfound:
@@ -1956,7 +2157,7 @@
 			# Use the corrected show-name, but no episode name.
 			if series_name == None:
 				series_name = sid
-			if episode: 
+			if episode:
 				sys.stderr.write(u"\n! Warning: For Series (%s), season (%s) or Episode (%s) not found \n"
 				 % (series_name, season, episode )
 				)
@@ -2002,7 +2203,7 @@
 				u'\n! Warning: Resizing failed command (mogrify -resize %s "%s")\n' % (resize, filename)
 			)
 			return(False)
-		return True	
+		return True
 	# end _resizeGraphic
 
 	def _downloadURL(self, url, OutputFileName):
@@ -2030,7 +2231,7 @@
 			sys.stderr.write( u"\n! Warning: Download IOError on URL for Filename(%s)\nOrginal URL(%s)\nIOError urllib.quote URL(%s)\n" % (OutputFileName, org_url, url))
 			return False
 
-		target_socket = open(OutputFileName, "wb") 
+		target_socket = open(OutputFileName, "wb")
 		target_socket.write(dat)
 		target_socket.close()
 
@@ -2056,13 +2257,13 @@
 
 	def _setGraphicsFileNameFormat(self):
 		"""Return a file name format (e.g. seriesname - episode name.extention)
-		return a filename format string 
+		return a filename format string
 		"""
 		if self.config['g_defaultname']:
 			return u'%(url)s.%(ext)s'
 		cfile={}
 		cfile['seriesid']=self.config['sid']
-		cfile['series'] = sanitiseFileName(self.config['series_name'])
+		cfile['series'] = self.sanitiseFileName(self.config['series_name'])
 		if cfile['series'] != self.config['series_name']:
 			self.config['g_series'] = self.config['g_series'].replace(self.config['series_name'], cfile['series'])
 		if self.config['season_num']:
@@ -2079,7 +2280,7 @@
 
 		if self.config['season_num']:
 			return self.config['g_season'] % cfile
-			
+
 		return self.config['g_series'] % cfile
 	# end _setGraphicsFileNameFormat
 
@@ -2090,6 +2291,8 @@
 		return False  if the any of the urls are corrupt
 		return file name of the LAST file downloaded (special for MythTV data base updates)
 		"""
+		global graphicsDirectories
+
 		if urls == None: return None
 		if urls == '': return None
 		tmp_list=urls.split('\n')
@@ -2098,7 +2301,7 @@
 			x = x.rstrip()
 			if x != '':
 				url_list.append(x)
-		if not len(url_list):		
+		if not len(url_list):
 			return None			# There were no URLs in the list
 		url_dict={}
 		for x in url_list:
@@ -2113,18 +2316,18 @@
 			if url_dict.has_key(x[:i]):
 				temp_array = [x[i+1:],'']
 				url_dict[x[:i]].append(temp_array)# Collect a list of the same graphics type of URLs
-			else: # The first URL of a new graphics type
-				url_dict[x[:i]]=[[(x[i+1:]).replace(u"http://www.thetvdb.com",u"http://images.thetvdb.com"),'']]
+			else: # The first URL of a new graphics type. Also URL replacement code left in place just in case
+				url_dict[x[:i]]=[[(x[i+1:]).replace(u"http://www.thetvdb.com",u"http://www.thetvdb.com"),'']]
 
 		unique_dir={u'poster': ['posterdir', True], u'banner': ['bannerdir', True], u'fanart': ['fanartdir', True], u'filename': ['episodeimagedir', True]}
-		# If a graphics directory was not specified then default to the 'allgraphics' directory 
+		# If a graphics directory was not specified then default to the 'allgraphics' directory
 		if not self.config['posterdir']: self.config['posterdir'] = self.config['allgraphicsdir']
 		if not self.config['bannerdir']: self.config['bannerdir'] = self.config['allgraphicsdir']
 		if not self.config['fanartdir']: self.config['fanartdir'] = self.config['allgraphicsdir']
 		if not self.config['episodeimagedir']: self.config['episodeimagedir'] = self.config['allgraphicsdir']
 
 		# Check if any of the downloaded graphics will share the same directory
-		for key in unique_dir.keys(): 
+		for key in unique_dir.keys():
 			for k in unique_dir.keys():
 				if key != k:
 					if self.config[unique_dir[key][0]] == self.config[unique_dir[k][0]]:
@@ -2140,14 +2343,24 @@
 		# Set the graphics fully qualified filenames matched to a URL
 		for URLtype in url_dict:
 			if mythtv:
-				directory = dirs[URLtype][0]
-			else:	 
+				if self.absolutepath:
+					if URLtype == 'poster':
+						tmpgraphicdir = graphicsDirectories['coverfile']
+					else:
+						tmpgraphicdir = graphicsDirectories[URLtype]
+					if not len(self.config['localpaths'][tmpgraphicdir]):
+						return None
+					else:
+						directory = self.config['localpaths'][tmpgraphicdir][0]
+				else:
+					directory = dirs[URLtype][0]
+			else:
 				directory = dirs[URLtype]
 			seq_num = 0
 			for url in url_dict[URLtype]:
 				(dirName, fileName) = os.path.split(url[0])
 				(fileBaseName, fileExtension)=os.path.splitext(fileName)
-				fileBaseName = sanitiseFileName(fileBaseName)
+				fileBaseName = self.sanitiseFileName(fileBaseName)
 				# Fix file extentions in all caps or 4 character JPEG extentions
 				fileExtension = fileExtension.lower()
 				if fileExtension == '.jpeg':
@@ -2155,15 +2368,18 @@
 				cfile={u'url': fileBaseName, u'seq': seq_num, u'ext': fileExtension[1:]}
 				if not isValidPosixFilename(self.config['series_name']):
 					if file_format.startswith(self.config['series_name']):
-						file_format = file_format.replace(self.config['series_name'], sanitiseFileName(self.config['series_name']))
-				cfile['series'] = sanitiseFileName(self.config['series_name'])
+						file_format = file_format.replace(self.config['series_name'], self.sanitiseFileName(self.config['series_name']))
+				cfile['series'] = self.sanitiseFileName(self.config['series_name'])
 				cfile['seriesid'] = self.config['sid']
-				
+
 				if URLtype != 'filename':
 					if unique_dir[URLtype][1]:
 						url_dict[URLtype][seq_num][1] = directory+'/'+file_format % cfile
 					else:
-						url_dict[URLtype][seq_num][1] = directory+'/'+URLtype.capitalize()+' - '+file_format % cfile
+						if mythtv:
+							url_dict[URLtype][seq_num][1] = directory+'/'+file_format % cfile
+						else:
+							url_dict[URLtype][seq_num][1] = directory+'/'+URLtype.capitalize()+' - '+file_format % cfile
 				else:
 					if self.config['season_num']:
 						cfile['seasonnumber']=int(self.config['season_num'])
@@ -2173,7 +2389,7 @@
 						cfile['episodenumber']=int(self.config['episode_num'])
 					else:
 						cfile['episodenumber'] = 0
-					cfile['episodename'] = sanitiseFileName(self.config['episode_name'])
+					cfile['episodename'] = self.sanitiseFileName(self.config['episode_name'])
 					url_dict[URLtype][seq_num][1] = directory+'/'+self.config['ep_metadata'] % cfile
 				seq_num+=1
 
@@ -2185,7 +2401,7 @@
 				if self._downloadURL(pairs[0], pairs[1]):
 					if URLtype == u'poster' and self.config['posterresize']:
 						self._resizeGraphic(pairs[1], self.config['posterresize'])
-					elif URLtype == u'fanart' and self.config['fanartresize']: 
+					elif URLtype == u'fanart' and self.config['fanartresize']:
 						self._resizeGraphic(pairs[1], self.config['fanartresize'])
 				elif not os.path.isfile(pairs[1]): # Check if the file already was downloaded
 					failed_download = True # The download failed
@@ -2193,7 +2409,7 @@
 						sys.stderr.write(u'\nA graphics file failed to be downloaded. A file issue or a corrupt (HTML) file.(%s)\n' % pairs[1])
 				seq_num+=1
 				if self.config['maximum']:	# Has the maximum number of graphics been downloaded?
-					if seq_num == int(self.config['maximum']): 
+					if seq_num == int(self.config['maximum']):
 						break
 		if failed_download:
 			return None
@@ -2240,14 +2456,14 @@
 				try:
 					self.config['log'].debug(u'Checking for Series Banner graphics')
 					graphics=[b for b in
-							self._searchforSeries(series_name).data[banners][self.banner_key][self.banner_series_key].values()] 
+							self._searchforSeries(series_name).data[banners][self.banner_key][self.banner_series_key].values()]
 				except:
 					return None
 			elif graphics_type == self.poster_type:		# Series Posters
 				try:
 					self.config['log'].debug(u'Checking for Series Poster graphics')
 					graphics=[b for b in
-							self._searchforSeries(series_name).data[banners][self.poster_key][self.poster_series_key].values()] 
+							self._searchforSeries(series_name).data[banners][self.poster_key][self.poster_series_key].values()]
 				except:
 					return None
 		else:
@@ -2255,7 +2471,7 @@
 				try:
 					self.config['log'].debug(u'Checking for Season Banner graphics')
 					graphics=[b for b in
-							self._searchforSeries(series_name).data[banners][self.season_key][self.banner_season_key].values() 
+							self._searchforSeries(series_name).data[banners][self.season_key][self.banner_season_key].values()
 							if b[self.season_key] == season]
 				except:
 					return None
@@ -2263,7 +2479,7 @@
 				try:
 					self.config['log'].debug(u'Checking for Season Poster graphics')
 					graphics=[b for b in
-							self._searchforSeries(series_name).data[banners][self.season_key][self.poster_season_key].values() 
+							self._searchforSeries(series_name).data[banners][self.season_key][self.poster_season_key].values()
 							if b[self.season_key] == season]
 				except:
 					return None
@@ -2273,7 +2489,7 @@
 					if episode_name:		# Find an exact match for the series and episode name
 						graphics=self._searchforSeries(series_name).search(episode_name)
 					else:
-						graphics= self._searchforSeries(series_name)[int(season)][int(episode)] 
+						graphics= self._searchforSeries(series_name)[int(season)][int(episode)]
 				except:
 					return None
 
@@ -2291,7 +2507,7 @@
 			if graphics_type == 'filename':
 				if URL[graphics_type] == None:
 					continue
-			if lang:		# Is there a language to filter URLs on? 
+			if lang:		# Is there a language to filter URLs on?
 				if lang == URL['language']:
 					if graphics_type != self.ep_image_type:
 						graphicsURLs+=key_tag+URL['_bannerpath']+'\n'
@@ -2318,7 +2534,7 @@
 			wasanythingadded = len(graphicsURLs)
 			count+=1
 			if self.config['maximum']:	# Has the maximum number of graphics been downloaded?
-				if count == int(self.config['maximum']): 
+				if count == int(self.config['maximum']):
 					break
 
 		if not len(graphicsURLs):
@@ -2331,7 +2547,7 @@
 			print "\nGraphics:\n", graphicsURLs
 
 		if not len(graphicsURLs):			# Are there any graphics?
-			return None			
+			return None
 
 		if len(graphicsURLs) == 1 and graphicsURLs[0] == graphics_type+':':
 			return None						# Due to the language filter there may not be any URLs
@@ -2355,7 +2571,7 @@
 				toprated=(self._searchforSeries(series_name)[graphics_type])+'\n'
 			else:
 				toprated=(u'%s:%s\n' % (graphics_type, self._searchforSeries(series_name)[graphics_type]))
-		return toprated				
+		return toprated
 	# end getTopRatedGraphics
 
 	def _downloadEpisodeData(self,ep_data):
@@ -2413,7 +2629,7 @@
 					tmp_dict[u'ext']=fileExtension[1:]
 					image_filename = "%s/%s" % (self.config['episodeimagedir'], self.config['ep_metadata'] % tmp_dict)
 			# Only download a file if it does not exist or the option overwrite is selected
-			# or the option update is selected and the local meta data file is 
+			# or the option update is selected and the local meta data file is
 			# older than the episode data on thetvdb.com wiki
 			outofdate = False
 			if self.config['update'] and tmp_dict.has_key('lastupdated') and os.path.isfile(filename):
@@ -2456,7 +2672,7 @@
 			if self.config['get_ep_image'] and tmp_dict.has_key('filename'):
 				if tmp_dict['filename'] != 'None':
 					self._downloadGraphics('filename:'+tmp_dict['filename'])
-				
+
 			# Write out an episode meta data file
 			if 	self.config['get_ep_meta']:
 				fHandle = codecs.open(filename, 'w', 'utf8')
@@ -2491,7 +2707,7 @@
 		return an empy sting of no episode meta data was found
 		reurn a string containing key value pairs of episode meta data
 		"""
-		sid=self.config['sid']		
+		sid=self.config['sid']
 		series_name=self.config['series_name']
 		season_num=self.config['season_num']
 		episode_num=self.config['episode_num']
@@ -2554,7 +2770,7 @@
 				ep_data[u'gueststars']=''
 				for key in available_keys:
 					if self._searchforSeries(series_name)[season][episode][key] == None:
-						continue	
+						continue
 					# Massage meta data
 					text = self._searchforSeries(series_name)[season][episode][key]
 					text = self._changeAmp(text)
@@ -2589,7 +2805,7 @@
 		or naming/renaming a video file after a TV show recording.
 		return False and out put an error if there not either a series id (SID) or series name
 		return False and out put an error if there proper episode information (numbers or name)
-		return False if the option (-MGF) used and there is not exact TV series name match 
+		return False if the option (-MGF) used and there is not exact TV series name match
 		return a specific episode filename
 		"""
 		sid=self.config['sid']
@@ -2610,7 +2826,7 @@
 			sys.stderr.write(
 				u'\n! Error: There must be at least "season and episode numbers" or "episode name" to request a filename\n'
 			)
-			sys.exit(False)
+			sys.exit(1)
 
 		# Special logic must be used if the (-MG) guessing option has been requested
 		if not self.config['sid'] and self.config['mythtv_guess']:
@@ -2632,9 +2848,9 @@
 			sys.stderr.write(
 				u'\n! Error: The episode was not found for series(%s), Episode name(%s)\n' % (series_name, episode_name)
 			)
-			sys.exit(False)
+			sys.exit(1)
 
-		sid=self.config['sid']		
+		sid=self.config['sid']
 
 		if UI_selectedtitle and self.config['mythtv_inetref']:
 			self.config['series_name'] = UI_selectedtitle
@@ -2650,8 +2866,8 @@
 		for key in ['seasonnumber', 'episodenumber']:
 			if tmp_dict.has_key(key):
 				tmp_dict[key] = int(tmp_dict[key])
-		
-		return sanitiseFileName(u"%s" % (self.config['ep_metadata'] % tmp_dict)[:-1])
+
+		return self.sanitiseFileName(u"%s" % (self.config['ep_metadata'] % tmp_dict)[:-1])
 	# end returnFilename
 
 	def processTVdatabaseRequests(self):
@@ -2661,12 +2877,12 @@
 		return a string for display or further processing that satisfies the reqested actions
 		"""
 		if self.verifySeriesExists():# Getting a filename is a single event nothing else is returned
-			if self.config['ret_filename']:	
+			if self.config['ret_filename']:
 				return self.returnFilename()
 		else:
 			return None
 
-		types={'get_fanart': self.fanart_type, 'get_poster': self.poster_type, 'get_banner': self.banner_type}	
+		types={'get_fanart': self.fanart_type, 'get_poster': self.poster_type, 'get_banner': self.banner_type}
 		if self.config['toprated']:
 			typegetGraphics=self.getTopRatedGraphics
 		else:
@@ -2691,7 +2907,7 @@
 							url_string+=string
 				if url_string != '':
 					results+=url_string	# Add graphic URLs to returned results
-			
+
 			# Should episode meta data or episode image be processed?
 			if self.config['get_ep_meta'] or self.config['get_ep_image']:
 				if self.config['download']:	# Deal only with episode data display or download
@@ -2711,7 +2927,7 @@
 				return results[:len(results)-1]
 			else:
 				return results
-		else:	
+		else:
 			return None
 	# end processTVdatabaseRequests
 
@@ -2723,14 +2939,14 @@
 
 
 class VideoFiles(Tvdatabase):
-	"""Process all video file and/or directories containing video files. These TV Series video 
+	"""Process all video file and/or directories containing video files. These TV Series video
 	files must be named so that a "series name or sid" and/or "season and episode number"
     can be extracted from the video file name. It is best to have renamed the TV series video files with
 	tvnamer before using these files with jamu. Any video file without season and episode numbers is
 	assumed to be a movie.	Files that do not match the previously described criterion will be skipped.
 	tvnamer can be found at:
 	http://pypi.python.org/pypi?%3Aaction=search&term=tvnamer&submit=search
-	""" 
+	"""
 	def __init__(self, configuration):
 		"""Retrieve the configuration options
 		"""
@@ -2749,14 +2965,18 @@
 		allfiles = []
 
 		for cfile in args: # Directories must exist and be both readable and writable
-			if os.path.isdir(cfile) and not os.access(cfile, os.F_OK | os.R_OK | os.W_OK): 
-				sys.stderr.write(u"\n! Error: Video directory (%s) does not exist or the permissions are not read and writable.\n" % (cfile))
+			if os.path.isdir(cfile) and not os.access(cfile, os.F_OK | os.R_OK):
+				sys.stderr.write(u"\n! Error: Video directory (%s) does not exist or the permissions are not at least readable. Skipping this directory.\n" % (cfile))
 				continue
-			if os.path.isdir(cfile) and os.access(cfile, os.F_OK | os.R_OK | os.W_OK):
+			if os.path.isdir(cfile):
+				index = cfile.find(u'VIDEO_TS')
+				if index != -1:
+					sys.stderr.write(u"\n! Warning: Jamu does not process multi-part video files, video directory (%s).\nSkipping this directory. Use MythVideo to retrieve meta data for these video files.\n" % (cfile))
+					continue
 				try:
 					cfile = unicode(cfile, u'utf8')
 				except (UnicodeEncodeError, TypeError):
-					pass		
+					pass
 				for sf in os.listdir(cfile):
 					try:
 						newpath = os.path.join(cfile, sf)
@@ -2775,8 +2995,10 @@
 						#end if recursive
 					#end if isfile
 				#end for sf
-			elif os.path.isfile(cfile) and os.access(cfile, os.F_OK | os.R_OK | os.W_OK):
-				allfiles.append(cfile) # Files must exist and be both readable and writable
+			elif self.config[u'file_move_flag'] and not os.access(cfile, os.F_OK | os.R_OK | os.W_OK):
+				sys.stderr.write(u"\n! Error: The Video file (%s) to be moved must have the read and write permissions. Skipping this video file.\n" % (cfile))
+			elif os.path.isfile(cfile) and os.access(cfile, os.F_OK | os.R_OK):
+				allfiles.append(cfile) # Files must exist and be at least readable
 			#end if isdir
 		#end for cfile
 		return allfiles
@@ -2799,11 +3021,11 @@
 			if not ext.lower() in self.config[u'video_file_exts']:
 				for key in self.image_extensions:
 					if key == ext:
-						break	
+						break
 				else:
 					sys.stderr.write(u"\n! Warning: Skipping non-video file name: (%s)\n" % (f))
 				continue
-	
+
 			for r in self.config['name_parse']:
 				match = r.match(filename)
 				categories=''
@@ -2816,7 +3038,7 @@
 
 					if self.config['series_name_override']:
 						if self.config['series_name_override'].has_key(seriesname.lower()):
-							if len((self.config['series_name_override'][seriesname.lower()]).strip()) == 7:								
+							if len((self.config['series_name_override'][seriesname.lower()]).strip()) == 7:
 								categories+=u', Movie'
 								movie = filename
 								if movie.endswith(self.config['hd_dvd']):
@@ -2922,14 +3144,14 @@
 		return False and an error message and exist the script if there are no video files to process
 		return None when all processing was complete
 		return a string of file names if the "Filename" process option was True
-		'''	
+		'''
 		filenames=''
 		allFiles = self._findFiles(self.config['video_dir'], self.config['recursive'] , verbose = self.config['debug_enabled'])
 		validFiles = self._processNames(allFiles, verbose = self.config['debug_enabled'])
 
 		if len(validFiles) == 0:
 			sys.stderr.write(u"\n! Error: No valid video files found\n")
-			sys.exit(False)
+			sys.exit(1)
 
 		path_flag = self.config['metadatadir']
 		for cfile in validFiles:
@@ -2947,9 +3169,9 @@
 					returned = self.processTVdatabaseRequests()
 					if returned != None and returned != False:
 						filenames+=returned+'\n'
-				else:			
+				else:
 					self.processTVdatabaseRequests()
-			else:				
+			else:
 				sys.stderr.write(u"\n! Warning: Did not find series(%s) season(%s) episode(%s)\n" % (self.config['series_name'], self.config['season_num'], self.config['episode_num']))
 			self.config['log'].debug("# Done")
 		if len(filenames) == 0:
@@ -2958,7 +3180,7 @@
 			return filenames[:-1] # drop the last '\n'
 	# end processFileOrDirectory
 
-	def __repr__(self):	# Just a place holder 
+	def __repr__(self):	# Just a place holder
 		return self.config
 	# end __repr__
 
@@ -2966,8 +3188,8 @@
 
 
 class MythTvMetaData(VideoFiles):
-	"""Process all mythvideo video files, update the video files associated MythTV meta data. 
-	Download graphics for those video files from either thetvdb.com or themovie.com. Video file names 
+	"""Process all mythvideo video files, update the video files associated MythTV meta data.
+	Download graphics for those video files from either thetvdb.com or themovie.com. Video file names
 	for TV episodes must series name, season and episode numbers. The video file's movie name must be
     an exact match with a movie title in themoviedb.com or the MythTV database must have an entry for
     the video file with a TMDB or an IMDB number (db field 'intref').
@@ -2982,7 +3204,7 @@
 	# A dictionary of meta data keys and initialized values
 	global graphicsDirectories
 	movie_file_format=u"%s/%s.%s"
-	initialize_record = {u'subtitle': u'', u'director': u'Unknown', u'rating': u'NR', u'inetref': u'00000000', u'year': 1895, u'userrating': 0.0, u'length': 0, u'showlevel': 1, u'coverfile': u'No Cover', u'host': u'',}
+	initialize_record = {u'title': u'', u'subtitle': u'', u'director': u'Unknown', u'rating': u'NR', u'inetref': u'00000000', u'year': 1895, u'userrating': 0.0, u'length': 0, u'showlevel': 1, u'coverfile': u'No Cover', u'host': u'',}
 	graphic_suffix = {u'coverfile': u'_coverart', u'fanart': u'_fanart', u'banner': u'_banner'}
 	graphic_name_suffix = u"%s/%s%s.%s"
 	graphic_name_season_suffix = u"%s/%s Season %d%s.%s"
@@ -2992,7 +3214,7 @@
 		'''Get the MythTV subtitle (episode name)
 		return None
 		return episode name string
-		''' 
+		'''
 		self.config['sid']=None
 		self.config['episode_name'] = None
 		self.config['series_name']=cfile['file_seriesname']
@@ -3012,13 +3234,15 @@
 		if abpath == None:
 			return abpath
 
-		# There is a chance that this is already a relative path or there is no Storage group for file type 
-		if not len(storagegroups) or not storagegroups.has_key(filetype) or abpath[0] != '/':
+		# There is a chance that this is already a relative path or there is no Storage group for file type
+		if not len(storagegroups):
 			return abpath
+		if not storagegroups.has_key(filetype) or abpath[0] != '/':
+			return abpath
 
-		# The file must already be in one of the the directories specified by the file type's storage group
+		# The file must already be in one of the directories specified by the file type's storage group
 		for directory in storagegroups[filetype]:
-			if abpath.startswith(directory): 
+			if abpath.startswith(directory):
 				return abpath[len(directory)+1:]
 		else:
 			return abpath
@@ -3037,7 +3261,14 @@
 		if relpath[0] == u'/':
 			return relpath
 
-		for directory in self.config[filetype]:
+		if self.absolutepath:
+			if not len(self.config['localpaths'][filetype]):
+				return relpath
+			directories = self.config['localpaths'][filetype]
+		else:
+			directories = self.config[filetype]
+
+		for directory in directories:
 			abpath = u"%s/%s" % (directory, relpath)
 			if os.path.isfile(abpath): # The file must actually exist locally
 				return abpath
@@ -3075,6 +3306,9 @@
 				results = mdb.searchTMDB(IMDB)
 			else:
 				results = mdb.searchTitle(tmp_title)
+		except Exception, errormsg:
+			self._displayMessage(u"themoviedb.com error for Movie(%s) invalid data error (%s)" % (title, errormsg))
+			return False
 		except:
 			self._displayMessage(u"themoviedb.com error for Movie(%s)" % title)
 			return False
@@ -3138,7 +3372,7 @@
 						else:
 							TMDB_movies.append({'name': "%s" % (movie['alternative_title'], ), u'sid': movie[u'imdb']})
 							continue
-	
+
 		# When there is only one match but NO year to confirm then it is OK to assume an exact match
 		if len(TMDB_movies) == 1 and year == '':
 			if rtnyear:
@@ -3174,11 +3408,11 @@
 								return u"%07d" % int(movie) # Pad out IMDB# with leading zeroes
 				IMDB_movies.append({'name': tmp_movies[movie], u'sid': movie})
 
-		if len(IMDB_movies) == 1: # If this is the only choice and titles matched then auto pick it 
+		if len(IMDB_movies) == 1: # If this is the only choice and titles matched then auto pick it
 			if filter(is_not_punct_char, IMDB_movies[0]['name'][:-7]).lower() == filter(is_not_punct_char, name):
 				if rtnyear:
 					return IMDB_movies[0]
-				else:	
+				else:
 					return u"%07d" % int(IMDB_movies[0][u'sid'])
 
 		# Does IMDB list this movie?
@@ -3186,7 +3420,7 @@
 			return False
 
 		# Did the user want an interactive interface?
-		if not self.config['interactive']: 
+		if not self.config['interactive']:
 			return False
 
 		# Force only an IMDB look up for a movie
@@ -3273,7 +3507,10 @@
 
 		self.config['sid']=None
 		if watched:
-			self.config['g_series'] = cfile['file_seriesname']+self.graphic_suffix[rel_type]+u'.%(ext)s'
+			if self.program_seriesid == None:
+				self.config['g_series'] = self.sanitiseFileName(cfile['file_seriesname'])+self.graphic_suffix[rel_type]+u'.%(ext)s'
+			else:
+				self.config['g_series'] = self.sanitiseFileName(self.program_seriesid)+self.graphic_suffix[rel_type]+u'.%(ext)s'
 		else:
 			self.config['g_series'] = cfile['inetref']+self.graphic_suffix[rel_type]+u'.%(ext)s'
 		if graphic_type == '-P':
@@ -3289,7 +3526,7 @@
 		graphic_file = u"http://"+urllib.quote(tmp_URL.encode("utf-8"))
 		value = self._downloadGraphics(u"%s:%s" % (g_type, graphic_file), mythtv=True)
 
-		self.config['overwrite'] = False # Turn off overwriting 
+		self.config['overwrite'] = False # Turn off overwriting
 
 		if value == None:
 			self._displayMessage(u"2-tmdb %s for Movie not found(%s)(%s)" % (graphic_name, cfile['filename'], cfile['inetref']))
@@ -3322,7 +3559,7 @@
 							results = mdb.searchTMDB(cfile['inetref'])
 						except:
 							self._displayMessage(u"\n! Warning: Secondary themoviedb.com error for Movie(%s) graphics(%s)" % (cfile['file_seriesname'], graphic_type))
-							return None					
+							return None
 						if results == None:
 							return None
 						if not results.has_key('imdb'):
@@ -3344,7 +3581,7 @@
 		self.config['series_name']=cfile['file_seriesname']
 
 		if self.config['simulation']:
-			sys.stdout.write(u"Simulating - downloading Secondary Source graphic (%s)\n" % cfile['file_seriesname']) 
+			sys.stdout.write(u"Simulating - downloading Secondary Source graphic (%s)\n" % cfile['file_seriesname'])
 			return u"Simulated Secondary Source graphic filename place holder"
 
 		# Test that the secondary's required data has been passed
@@ -3368,14 +3605,17 @@
 			tmp_files=tmp_array[0].replace(u'file://', u'')
 			if not os.path.isfile(tmp_files):
 				sys.stderr.write(u'\n! Error: The graphic file does not exist (%s)\n' % tmp_files)
-				sys.exit(False)
+				sys.exit(1)
 
 			# Fix file extentions in all caps or 4 character JPEG extentions
 			fileExtension = (_getExtention(tmp_files)).lower()
 			if fileExtension == u'jpeg':
 				fileExtension = u'jpg'
 			if watched:
-				filename = u'%s/%s%s.%s' % (self.config['posterdir'][0], sanitiseFileName(cfile['file_seriesname']), self.graphic_suffix[rel_type], fileExtension)
+				if self.program_seriesid == None:
+					filename = u'%s/%s%s.%s' % (self.config['posterdir'][0], self.sanitiseFileName(cfile['file_seriesname']), self.graphic_suffix[rel_type], fileExtension)
+				else:
+					filename = u'%s/%s%s.%s' % (self.config['posterdir'][0], self.sanitiseFileName(self.program_seriesid), self.graphic_suffix[rel_type], fileExtension)
 			else:
 				filename = u'%s/%s%s.%s' % (self.config['posterdir'][0], cfile['inetref'], self.graphic_suffix[rel_type], fileExtension)
 
@@ -3406,9 +3646,12 @@
 
 			self.config['sid']=None
 			if watched:
-				self.config['g_series'] = cfile['file_seriesname']+self.graphic_suffix[rel_type]+'.%(ext)s'
+				if self.program_seriesid == None:
+					self.config['g_series'] = self.sanitiseFileName(cfile['file_seriesname'])+self.graphic_suffix[rel_type]+'.%(ext)s'
+				else:
+					self.config['g_series'] = self.sanitiseFileName(self.program_seriesid)+self.graphic_suffix[rel_type]+'.%(ext)s'
 			else:
-				self.config['g_series'] = cfile['inetref']+self.graphic_suffix[rel_type]+'.%(ext)s'
+				self.config['g_series'] = self.sanitiseFileName(cfile['inetref'])+self.graphic_suffix[rel_type]+'.%(ext)s'
 			g_type = graphic_type
 
 			self.config['season_num']= None	# Needed to get graphics named in 'g_series' format
@@ -3419,7 +3662,7 @@
 			graphic_file = u"http://"+urllib.quote(tmp_URL.encode("utf-8"))
 			value = self._downloadGraphics(u"%s:%s" % (g_type, graphic_file), mythtv=True)
 
-			self.config['overwrite'] = False # Turn off overwriting 
+			self.config['overwrite'] = False # Turn off overwriting
 			if value == None:
 				self._displayMessage(u"Secondary source %s not found(%s)(%s)" % (graphic_file, cfile['filename'], cfile['inetref']))
 				return None
@@ -3434,36 +3677,38 @@
 		'''
 		# Combine meta data
 		for key in meta_dict.keys():
-			try:
-				dummy = self.config['metadata_exclude_as_update_trigger'].index(key)
+			if key in self.config['metadata_exclude_as_update_trigger']:
 				continue
-			except:
+			else:
 				if key == 'inetref' and available_metadata[key] != meta_dict[key]:
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'userrating' and available_metadata[key] == 0.0:
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'length' and available_metadata[key] == 0:
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'rating' and (available_metadata[key] == 'NR' or available_metadata[key] == 'Unknown'):
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'year' and available_metadata[key] == 1895:
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'category' and available_metadata[key] == 0:
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'inetref' and available_metadata[key] == '00000000':
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
+				if key == 'title':
+					available_metadata[key] = meta_dict[key]
+					continue
 				if vid_type and key == 'subtitle': # There are no subtitles in movies
 					continue
 				if key == 'plot': # Remove any line-feeds from the plot. Mythvideo does not expect them.
 					meta_dict[key] = meta_dict[key].replace('\n', ' ')
-				if (vid_type and key == 'plot') and (meta_dict[key].find('@') != -1 or len(meta_dict[key].split(' ')) < 10): 
+				if (vid_type and key == 'plot') and (meta_dict[key].find('@') != -1 or len(meta_dict[key].split(' ')) < 10):
 					continue
 				if vid_type and key == 'plot':
 					if available_metadata[key] != None:
@@ -3471,10 +3716,10 @@
 							available_metadata[key] = meta_dict[key]
 							continue
 				if not available_metadata.has_key(key): # Mainly for Genre and Cast
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if available_metadata[key] == None or available_metadata[key] == '' or available_metadata[key] == 'None' or available_metadata[key] == 'Unknown':
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 		return available_metadata
 	# end combineMetaData
@@ -3542,7 +3787,10 @@
 			element = (element.rstrip('\n')).strip()
 			if element == '' or element == None:
 				continue
-			index = element.index(':')
+			try:
+				index = element.index(':')
+			except:
+				continue
 			key = element[:index].lower()
 			data = element[index+1:]
 			if data == None or data == '':
@@ -3622,16 +3870,14 @@
 			data = self._changeAmp(data)
 			data = self._changeToCommas(data)
 			if key == 'genres':
-				genres=''	
-				genre_array = data.split(',')			
-				for i in range(len(genre_array)): 
+				genres=''
+				genre_array = data.split(',')
+				for i in range(len(genre_array)):
 					genre_array[i] = (genre_array[i].strip()).lower()
-					try:
-						self.config['tmdb_genre_filter'].index(genre_array[i])
+					if genre_array[i] in self.config['tmdb_genre_filter']:
 						genres+=genre_array[i].title()+','
-					except:
-						pass
 				if genres == '':
+					meta_dict[key] = u''
 					continue
 				else:
 					meta_dict[key] = genres[:-1]
@@ -3655,10 +3901,10 @@
 				except:
 					pass
 				continue
-
 		if meta_dict.has_key('rating'):
 			if meta_dict['rating'] == '':
-				meta_dict['rating'] = 'Unknown' 
+				meta_dict['rating'] = 'Unknown'
+
 		if len(meta_dict):
 			available_metadata = self.combineMetaData(available_metadata, meta_dict, vid_type=True)
 			return self._getSecondarySourceMetadata(cfile, available_metadata)
@@ -3712,12 +3958,16 @@
 				self._displayMessage(u"tvdb Series not found(%s)" % cfile['filename'])
 				return None
 
-		if watched: 
-			self.config['g_series'] = cfile['file_seriesname']+self.graphic_suffix[rel_type]+u'.%(ext)s'
-			self.config['g_season'] = cfile['file_seriesname']+u' Season %(seasonnumber)d'+self.graphic_suffix[rel_type]+u'.%(ext)s'
+		if watched:
+			if self.program_seriesid == None:
+				self.config['g_series'] = self.sanitiseFileName(cfile['file_seriesname'])+self.graphic_suffix[rel_type]+u'.%(ext)s'
+				self.config['g_season'] = self.sanitiseFileName(cfile['file_seriesname'])+u' Season %(seasonnumber)d'+self.graphic_suffix[rel_type]+u'.%(ext)s'
+			else:
+				self.config['g_series'] = self.sanitiseFileName(self.program_seriesid)+self.graphic_suffix[rel_type]+u'.%(ext)s'
+				self.config['g_season'] = self.sanitiseFileName(self.program_seriesid)+u' Season %(seasonnumber)d'+self.graphic_suffix[rel_type]+u'.%(ext)s'
 		else:
-			self.config['g_series'] = self.config['series_name']+self.graphic_suffix[rel_type]+u'.%(ext)s'
-			self.config['g_season'] = self.config['series_name']+u' Season %(seasonnumber)d'+self.graphic_suffix[rel_type]+u'.%(ext)s'
+			self.config['g_series'] = self.sanitiseFileName(self.config['series_name'])+self.graphic_suffix[rel_type]+u'.%(ext)s'
+			self.config['g_season'] = self.sanitiseFileName(self.config['series_name'])+u' Season %(seasonnumber)d'+self.graphic_suffix[rel_type]+u'.%(ext)s'
 		if toprated:
 			typegetGraphics=self.getTopRatedGraphics
 			self.config['season_num']= None	# Needed to get toprated graphics named in 'g_series' format
@@ -3732,7 +3982,7 @@
 		else:
 			return self.rtnRelativePath(value, graphicsDirectories[rel_type])
 	# end _getTvdbGraphics
-	
+
 	def _getTvdbMetadata(self, cfile, available_metadata):
 		'''Download thetvdb.com meta data
 		return what was input or results from a secondary source
@@ -3866,20 +4116,20 @@
 			text = text.replace(u'\u201d', u'"')
 		except UnicodeDecodeError:
 			pass
-			
+
 		return text
 	# end make_db_ready
 
 	def _addCastGenre(self, data_string, intid, cast_genres_type):
-		'''From a comma delimited string of cast members or genres add the ones 
-		not already in the myth db and update the video's meta data 
+		'''From a comma delimited string of cast members or genres add the ones
+		not already in the myth db and update the video's meta data
 		return True when successfull
 		return False if failed
 		'''
 		if data_string == '':
 			return True
 		data = data_string.split(',')
-		for i in range(len(data)): 
+		for i in range(len(data)):
 			data[i]=data[i].strip()
 		try:
 			data.remove('')
@@ -3919,7 +4169,7 @@
 		else:
 			if os.path.isfile(src):
 				(src, fileName) = os.path.split(src)
-				names = [fileName] 
+				names = [fileName]
 			else:
 				try:
 					names = os.listdir(unicode(src, 'utf8'))
@@ -3945,8 +4195,9 @@
 				continue
 			srcname = os.path.join(src, name)
 			dstname = os.path.join(dst, name)
-	
+
 			if not os.access(srcname, os.F_OK | os.R_OK | os.W_OK): # Skip any file that is not RW able
+				sys.stderr.write(u"\n! Error: The Source video directory or file (%s) must have read and write permissions for be moved. File or directory has been skipped\n" % (srcname))
 				continue
 			try:
 				if symlinks and os.path.islink(srcname):
@@ -3967,25 +4218,25 @@
 				else:
 					if self.config['simulation']:
 						if wild_card:
-							if srcname.startswith(org_src[:-1]): 
+							if srcname.startswith(org_src[:-1]):
 								sys.stdout.write(u"Simulation move wild card file from\n(%s) to\n(%s)\n" % (srcname, dstname))
 								self.num_moved_video_files+=1
 								self.new_names.append(dstname)
 							else:
-								self._displayMessage(u"Simulation of wildcard skipping file(%s)" % (srcname,)) 
+								self._displayMessage(u"Simulation of wildcard skipping file(%s)" % (srcname,))
 						else:
 							sys.stdout.write(u"Simulation move file from\n(%s) to\n(%s)\n" % (srcname, dstname))
 							self.num_moved_video_files+=1
 							self.new_names.append(dstname)
 					else:
 						if wild_card:
-							if srcname.startswith(org_src[:-1]): 
+							if srcname.startswith(org_src[:-1]):
 								self._displayMessage(u"Move wild card file from\n(%s) to\n(%s)\n" % (srcname, dstname))
 								shutil.move(srcname, dstname)
 								self.num_moved_video_files+=1
 								self.new_names.append(dstname)
 							else:
-								self._displayMessage(u"Wildcard skipping file(%s)" % (srcname,)) 
+								self._displayMessage(u"Wildcard skipping file(%s)" % (srcname,))
 						else:
 							self._displayMessage(u"Move file from\n(%s) to\n(%s)\n" % (srcname, dstname))
 							shutil.move(srcname, dstname)
@@ -4003,28 +4254,28 @@
 	# end _moveDirectoryTree
 
 	# local variable for move stats
-	num_moved_video_files=0	
-	num_created_video_subdirectories=0	
+	num_moved_video_files=0
+	num_created_video_subdirectories=0
 	num_symbolic_links=0
 
 	def _moveVideoFiles(self, target_destination_array):
 		"""Copy files or directories to a destination directory.
-		If the -F filename option is set then rename TV series during the move process. The move will 
+		If the -F filename option is set then rename TV series during the move process. The move will
 		be interactive for identifying a movie's IMDB number or TV series if the -i option was also set.
 		If there is a problem error message are displayed and the script exists. After processing
 		print a statistics report.
 		return a array of video file dictionaries to update in Mythvideo data base
 		"""
 		global UI_selectedtitle
-		# Validate that the targets and destinations actually exist. 
+		# Validate that the targets and destinations actually exist.
 		count=1
 		for file_dir in target_destination_array:
-			if os.access(file_dir, os.F_OK | os.R_OK | os.W_OK):
+			if os.access(file_dir, os.F_OK | os.R_OK):
 				if count % 2 == 0:
 					# Destinations must all be directories
 					if not os.path.isdir(file_dir):
 						sys.stderr.write(u"\n! Error: Destinations must all be directories.\nThis destination is not a directory (%s)\n" % (file_dir,))
-						sys.exit(False)
+						sys.exit(1)
 					else:
 						tmp_dir = file_dir
 						for directory in self.config['mythvideo']:
@@ -4033,10 +4284,10 @@
 								break
 						else:
 							sys.stderr.write(u"\n! Error: Destinations must all be a mythvideo directory or subdirectory.\nThis destination (%s) is not one of the Mythvideo directories(%s)\n" % (file_dir, self.config['mythvideo'], ))
-							sys.exit(False)
+							sys.exit(1)
 				# Verify that a target file is really a video file.
 				if file_dir[-1:] != '*': # Skip wildcard file name targets
-					if os.access(file_dir, os.F_OK | os.R_OK | os.W_OK):	# Confirm that the file actually exists
+					if os.access(file_dir, os.F_OK | os.R_OK):	# Confirm that the file actually exists
 						if not os.path.isdir(file_dir):
 							ext = _getExtention(file_dir)
 							for tmp_ext in self.config['video_file_exts']:
@@ -4044,7 +4295,7 @@
 									break
 							else:
 								sys.stderr.write(u"\n! Error: Target files must be video files(%s).\nSupported video file extentions(%s)\n" % (file_dir, self.config['video_file_exts'],))
-								sys.exit(False)
+								sys.exit(1)
 					count+=1
 
 		# Stats counters
@@ -4069,12 +4320,12 @@
 			else:
 				results = self._moveDirectoryTree(src, dst, symlinks=False, ignore=None)
 			if len(results[1]):			# Check if there are any errors
-				sys.stderr.write(u"\n! Warning: There where errors during moving, with these directories/files\n")
+				sys.stderr.write(u"\n! Warning: There were errors during moving, with these directories/files\n")
 				for error in results[1]:
 					sys.stderr.write(u'\n! Warning: Source(%s), Destination(%s), Reason:(%s)\n' % (error[0], error[1], error[2]))
 			tmp_cfile_array=[]
 			for name in results[0]:
-				file_name = os.path.join(dst, name)				
+				file_name = os.path.join(dst, name)
 				if os.path.isdir(file_name):
 					for dictionary in self._processNames(_getFileList([file_name]), verbose = self.config['debug_enabled'], movies=True):
 						tmp_cfile_array.append(dictionary)
@@ -4087,7 +4338,7 @@
 			for directory in self.config['mythvideo']:
 				if src.startswith(directory):
 					for cfile in tmp_cfile_array:
-						tmp_path = src+cfile['filepath'].replace(dst, '')
+						tmp_path = src+cfile['filepath'].replace(dst, u'')
 						video_file = self.rtnRelativePath(self.movie_file_format % (tmp_path, cfile['filename'], cfile['ext']), 'mythvideo')
 						tmp_filename = self.rtnRelativePath(self.movie_file_format % (cfile['filepath'], cfile['filename'], cfile['ext']), 'mythvideo')
 						intid = mythvideo.getMetadataId(video_file, localhostname.lower())
@@ -4097,8 +4348,11 @@
 							metadata = mythvideo.getMetadataDictionary(intid)
 							if tmp_filename[0] == '/':
 								host = u''
+								self.absolutepath = True
 							else:
 								host = localhostname.lower()
+								self.absolutepath = False
+
 							if self.config['simulation']:
 								sys.stdout.write(u"Simulation Mythdb update for old file:\n(%s) new:\n(%s)\n" % (video_file, tmp_filename))
 							else:
@@ -4109,7 +4363,7 @@
 			else:
 				pass
 			cfile_array.extend(tmp_cfile_array)
-			i+=2		# Increment by 2 because array is int pairs of target and destination	 
+			i+=2		# Increment by 2 because array is int pairs of target and destination
 
 		# Attempt to rename the video file
 		if self.config['ret_filename']:
@@ -4127,7 +4381,7 @@
 						data = self._getTmdbIMDB(cfile['file_seriesname'], rtnyear=True)
 						if data:
 							sid = data[u'sid']
-							new_filename = sanitiseFileName(data[u'name'])
+							new_filename = self.sanitiseFileName(data[u'name'])
 						else:
 							continue
 					else:
@@ -4137,12 +4391,12 @@
 							if data.has_key('long imdb title'):
 								new_filename = data['long imdb title']
 							elif data.has_key('title'):
-								new_filename = sanitiseFileName(namedata['title'])
+								new_filename = self.sanitiseFileName(namedata['title'])
 							else:
 								continue
 						except imdb._exceptions.IMDbDataAccessError:
 							continue
-						
+
 					if not sid:	# Cannot find this movie skip the renaming
 						continue
 					inetref = sid
@@ -4174,6 +4428,9 @@
 					if self.config['simulation']:
 						sys.stdout.write(u"Simulation file renamed from(%s) to(%s)\n" % (video_file, tmp_filename))
 					else:
+						if not os.access(video_file, os.F_OK | os.R_OK | os.W_OK):
+							sys.stdout.write(u"Cannot rename this file as it does not have read/write permissions set (%s)\n" % video_file)
+							continue
 						self._displayMessage(u"File renamed from(%s) to(%s)\n" % (video_file, tmp_filename))
 						os.rename(video_file, tmp_filename)
 					num_renamed_files+=1
@@ -4184,8 +4441,10 @@
 						intid = mythvideo.getMetadataId(self.movie_file_format % (cfile['filepath'], cfile['filename'], cfile['ext']), localhostname.lower())
 					if tmp_filename[0] == '/':
 						host = u''
+						self.absolutepath = True
 					else:
 						host = localhostname.lower()
+						self.absolutepath = False
 					if intid:
 						metadata = mythvideo.getMetadataDictionary(intid)
 						if self.config['simulation']:
@@ -4215,7 +4474,7 @@
 	# end _moveVideoFiles
 
 	def _displayMessage(self, message):
-		"""Displays messages through stdout. Usually used with MythTv metadata updates in -V 
+		"""Displays messages through stdout. Usually used with MythTv metadata updates in -V
 		verbose mode.
 		returns nothing
 		"""
@@ -4234,7 +4493,7 @@
 
 		if not len(directories):
 			sys.stderr.write(u"\n! Error: There must be a video directory specified in MythTv\n")
-			sys.exit(False)
+			sys.exit(1)
 
 		allFiles = self._findFiles(directories, self.config['recursive'] , verbose = self.config['debug_enabled'])
 		validFiles = self._processNames(allFiles, verbose = self.config['debug_enabled'], movies=True)
@@ -4245,7 +4504,7 @@
 		for cfile in validFiles:
 			try:
 				videopath = self.movie_file_format % (cfile['filepath'], cfile['filename'], cfile['ext'])
-			except UnicodeDecodeError: 
+			except UnicodeDecodeError:
 				videopath = os.path.join(unicode(cfile['filepath'],'utf8'), unicode(cfile['filename'],'utf8')+u'.'+cfile['ext'])
 
 			# Find the MythTV meta data
@@ -4260,7 +4519,7 @@
 					if not mythvideo.hasMetadata(meta_dict[u'filename'], meta_dict[u'host']):
 						missing_list.append(cfile)
 						continue
-				# There must be an Internet reference number. Get one for new records. 
+				# There must be an Internet reference number. Get one for new records.
 				if _can_int(meta_dict['inetref']) and not meta_dict['inetref'] == u'00000000'  and not meta_dict['inetref'] == '':
 					continue
 				missing_list.append(cfile)
@@ -4315,38 +4574,31 @@
 		mythvideometa records. Remove any graphics that are not referenced at least once. Print a
 		report.
 		'''
+		global localhostname
 		num_total = 0
 		num_deleted = 1
 		num_new_total = 2
 		stats = {'coverfile': [0,0,0], 'banner': [0,0,0], 'fanart': [0,0,0]}
 
-		validFiles = self._processNames(self._findFiles(self.config['mythvideo'], self.config['recursive'] , verbose = False), verbose = False, movies=True)
-		
-		if not len(validFiles):
-			sys.stderr.write(u"\n! Warning: Janitor - did not find any video files to proccess\n")
-			return
-
 		graphics_file_dict={}
+		all_graphics_file_list=[]
 		for directory in graphicsDirectories.keys():
 			if directory == 'screenshot':
 				continue
 			file_list = _getFileList(self.config[graphicsDirectories[directory]])
 			if not len(file_list):
 				continue
-			tmp_list = []
-			for fle in file_list: # Make a copy of file_list
-				tmp_list.append(fle)
-			for g_file in tmp_list:		# Cull the list removing dirs and non-graphics files
+			for g_file in list(file_list):		# Cull the list removing dirs and non-graphics files
 				if os.path.isdir(g_file):
 					file_list.remove(g_file)
 					continue
 				g_ext = _getExtention(g_file)
-				for ext in self.image_extensions:
-					if ext == g_ext:
-						break
-				else:
+				if not g_ext in self.image_extensions:
 					file_list.remove(g_file)
 					continue
+			for filel in file_list:
+				if not filel in all_graphics_file_list:
+					all_graphics_file_list.append(filel)
 			graphics_file_dict[directory] = file_list
 
 		for key in graphicsDirectories.keys():	# Set initial totals
@@ -4354,49 +4606,72 @@
 				continue
 			stats[key][num_total] = len(graphics_file_dict[key])
 
-		# Remove MythVideo files from the graphics delete list
-		for cfile in validFiles:
-			videopath = self.movie_file_format % (cfile['filepath'], cfile['filename'], cfile['ext'])
+		# Start reading videometadata records to remove their graphics from the image orphan list
+		c = mythdb.cursor()
+		c.execute(u"""
+				SELECT host, coverfile, banner, fanart, filename, intid
+				FROM videometadata""")
 
-			# Find the MythTV meta data
-			intid = mythvideo.getMetadataId(videopath, localhostname.lower())
-			if not intid:
-				intid = mythvideo.getMetadataId(self.rtnRelativePath(videopath, 'mythvideo'), localhostname.lower())
-			if intid == None: # Skip video files that are not yet in the MythDB
-				continue
-			meta_dict=mythvideo.getMetadataDictionary(intid)
-			for key in graphicsDirectories.keys():
-				if key == 'screenshot':
+		atleast_one_video_file = False
+		while True:
+			row = c.fetchone()
+			if not row:
+				break
+			atleast_one_video_file = True
+			meta_dict = {'host': row[0], 'coverfile': row[1], 'banner': row[2], 'fanart': row[3], 'filename': row[4], 'intid': row[5], }
+			if meta_dict['host'] != u'':	# Skip any videometadata record that is not for this host
+				if meta_dict['host'].lower() != localhostname.lower():
 					continue
-				if meta_dict[key] == None or meta_dict[key] == '' or meta_dict[key] == 'None' or meta_dict[key] == 'Unknown':
+			for key in meta_dict.keys(): # Start removing any graphics in this videometadata record
+				if key in ['host','filename','intid']:
 					continue
+				if meta_dict[key] in [None, u'', u'None', u'No Cover', u'Unknown']:
+					continue
 
 				# Deal with videometadata record using storage groups
+				if meta_dict['filename'] != None:
+					if meta_dict['filename'][0] == u'/':
+						self.absolutepath = True
+					else:
+						self.absolutepath = False
 				if meta_dict[key][0] != '/':
 					meta_dict[key] = self.rtnAbsolutePath(meta_dict[key], graphicsDirectories[key])
+					if meta_dict[key][0] != '/': # There is not a storage group for this relative file name
+						continue
 
 				# Deal with TV series level graphics
 				(dirName, fileName) = os.path.split(meta_dict[key])
 				(fileBaseName, fileExtension)=os.path.splitext(fileName)
 				index = fileBaseName.find(u' Season ')
+				intid = meta_dict['intid']
 				if index != -1: # Was a season string found?
 					filename = os.path.join(dirName, u'%s%s' % (fileBaseName[:index], fileExtension))
 					if filename in graphics_file_dict[key]: # No suffix
 						if self._checkValidGraphicFile(filename, graphicstype=key, vidintid=intid) == True:
 							graphics_file_dict[key].remove(filename)
+							all_graphics_file_list.remove(filename)
 					filename = os.path.join(dirName, u'%s%s%s' % (fileBaseName[:index], self.graphic_suffix[key], fileExtension))
 					if filename in graphics_file_dict[key]: # With suffix
 						if self._checkValidGraphicFile(filename, graphicstype=key, vidintid=intid) == True:
 							graphics_file_dict[key].remove(filename)
+							all_graphics_file_list.remove(filename)
 
 				if meta_dict[key] in graphics_file_dict[key]: # No suffix
 					if self._checkValidGraphicFile(meta_dict[key], graphicstype=key, vidintid=intid) == True:
 						graphics_file_dict[key].remove(meta_dict[key])
+						all_graphics_file_list.remove(meta_dict[key])
 				filename = os.path.join(dirName, u'%s%s%s' % (fileBaseName, self.graphic_suffix[key], fileExtension))
 				if filename in graphics_file_dict[key]: # With suffix
 					if self._checkValidGraphicFile(filename, graphicstype=key, vidintid=intid) == True:
 						graphics_file_dict[key].remove(filename)
+						all_graphics_file_list.remove(filename)
 
+		c.close()
+		if not atleast_one_video_file:
+			sys.stderr.write(u"\n! Error: Janitor - did not find any video files to process so skipping\nimage clean up to protect your image files, in case this is an configuration or NFS error.\nIf you do not use MythVideo then the Janitor option (-MJ) is not of value to you on this MythTV back end.\n")
+			return
+		# end reading videometadata records to remove their graphics from the image orphan list
+
 		# Get Scheduled and Recorded program list
 		programs = self._getScheduledRecordedProgramList()
 
@@ -4417,33 +4692,37 @@
 							if fileBaseName.lower().startswith(program['seriesid'].lower()):
 								remove.append(graphic)
 								break
-							
+
 				for rem in remove:
 					if self._checkValidGraphicFile(rem, graphicstype=u'', vidintid=False) == True:
 						graphics_file_dict[field].remove(rem)
+						try:
+							all_graphics_file_list.remove(rem)
+						except ValueError:
+							pass
 
 		for key in graphicsDirectories.keys():	# Set deleted files totals
 			if key == 'screenshot':
 				continue
+			file_list = list(graphics_file_dict[key])
+			for filel in file_list:
+				if not filel in all_graphics_file_list:
+					graphics_file_dict[key].remove(filel)
 			stats[key][num_deleted] = len(graphics_file_dict[key])
 
 		# Delete all graphics files still on the delete list
-		for field in graphicsDirectories.keys():
-			if field == 'screenshot':
-				continue
+		for filel in all_graphics_file_list:
+			if self.config['simulation']:
+				sys.stdout.write(
+					u"Simulation deleting (%s)\n" % (filel)
+				)
+			else:
+				try:
+					os.remove(filel)
+				except OSError:
+					pass
+				self._displayMessage(u"(%s) Has been deleted\n" % (filel))
 
-			for graphic in graphics_file_dict[field]:
-				if self.config['simulation']:
-					sys.stdout.write(
-						u"Simulation deleting %s (%s)\n" % (field, graphic)
-					)
-				else:
-					try:
-						os.remove(graphic)
-					except OSError:
-						pass
-					self._displayMessage(u"%s (%s) Has been deleted\n" % (field, graphic))
-				
 		for key in graphicsDirectories.keys():	# Set new files totals
 			if key == 'screenshot':
 				continue
@@ -4516,7 +4795,7 @@
 
 	def removeMythvideoSeekTable(self, filename):
 		'''Remove seektable entries for a Mythvideo from the "filemarkup" table. Entries may of may not
-		exist. The deletes need to remove entries for both an absolute file path and a Storage Groups 
+		exist. The deletes need to remove entries for both an absolute file path and a Storage Groups
 		"myth://..." file name definition.
 		return nothing
 		'''
@@ -4573,7 +4852,7 @@
 		except MySQLdb.Error, e:
 			logger.error(u"SELECT intid FROM videometadata WHERE inetref = 99999999 and category = %d failed: %d: %s" % (category_id, e.args[0], e.args[1]))
 			c.close()
-			sys.exit(False)
+			sys.exit(1)
 		intids=[]
 		while True:
 			row = c.fetchone()
@@ -4594,7 +4873,7 @@
 			return videometadatarecords
 		else:
 			return None
-		# end _getMiroVideometadataRecords() 
+		# end _getMiroVideometadataRecords()
 
 	def _getExtraMiroDetails(self, mythvideorec, vidtype):
 		'''Find the extra details required for Miro MythVideo record processing
@@ -4613,6 +4892,10 @@
 				extradata[key] = False
 				continue
 			elif key == u'coverfile': # Look for undersized coverart
+				if mythvideorec[u'filename'][0] == u'/':
+					self.absolutepath = True
+				else:
+					self.absolutepath = False
 				filename = self.rtnAbsolutePath(mythvideorec[key], graphicsDirectories[key])
 				try:
 					(width, height) = self.config['image_library'].open(filename).size
@@ -4631,6 +4914,10 @@
 				continue
 
 		if vidtype == u'movies': # Data specific to Movie Trailers
+			if mythvideorec[u'filename'][0] == u'/':
+				self.absolutepath = True
+			else:
+				self.absolutepath = False
 			extradata[u'filename'] = mythvideorec[u'filename']
 			extradata[u'pathfilename'] = self.rtnAbsolutePath(mythvideorec[u'filename'], u'mythvideo')
 			if os.path.islink(extradata[u'pathfilename']):
@@ -4640,7 +4927,7 @@
 			moviename = mythvideorec['subtitle']
 			if not moviename:
 				moviename = ''
-			else: 
+			else:
 				index = moviename.find(self.config[u'mb_movies'][filter(is_not_punct_char, mythvideorec[u'title'].lower())])
 				if index != -1:
 					moviename = moviename[:index].strip()
@@ -4650,7 +4937,7 @@
 				lastyear = int(datetime.datetime.now().strftime(u"%Y"))
 				years = []
 				i = 0
-				while i < 5: # Check for a Movie that will be released this year or the next four years 
+				while i < 5: # Check for a Movie that will be released this year or the next four years
 					years.append(u"%d" % ((lastyear+i)))
 					i+=1
 				imdb_access = imdb.IMDb()
@@ -4687,17 +4974,15 @@
 		mirodetails = program[u'miro']
 
 		for intid in mirodetails[u'intid']:
-			changed_fields = {} 
+			changed_fields = {}
 			for key in graphicsDirectories.keys():
 				if key == u'screenshot':
 					continue
-				if mirodetails[key] != True and mirodetails[key] != False and mirodetails[key] != None and mirodetails[key] != u'Simulated Secondary Source graphic filename place holder': 
+				if mirodetails[key] != True and mirodetails[key] != False and mirodetails[key] != None and mirodetails[key] != u'Simulated Secondary Source graphic filename place holder':
 					# A graphics was downloaded
 					changed_fields[key] = mirodetails[key]
-					if changed_fields[key][0] != u'/':
-						changed_fields[u'host'] = localhostname.lower()
 
-			if not mirodetails[u'tv'] and not mirodetails[u'symlink'] and os.path.isfile(mirodetails[u'pathfilename']):
+			if not mirodetails[u'tv'] and not mirodetails[u'symlink'] and os.access(mirodetails[u'pathfilename'], os.F_OK | os.R_OK | os.W_OK):
 				changed_fields[u'inetref'] = mirodetails[u'inetref']
 				changed_fields[u'subtitle'] = u''
 				changed_fields[u'year'] = mirodetails[u'year']
@@ -4710,9 +4995,9 @@
 					dir_list = os.listdir(dirName)
 				index = 1
 				while index != 0:
-					filename = sanitiseFileName(u'%s - Trailer %d' % (mirodetails[u'moviename'], index))
+					filename = self.sanitiseFileName(u'%s - Trailer %d' % (mirodetails[u'moviename'], index))
 					fullfilename = u'%s/%s%s' % (dirName, filename, fileExtension)
-					for flenme in dir_list: 
+					for flenme in dir_list:
 						if fnmatch.fnmatch(flenme.lower(), u'%s.*' % filename.lower()):
 							break
 					else:
@@ -4724,6 +5009,16 @@
 							os.rename(mirodetails[u'pathfilename'], fullfilename)
 							self.removeMythvideoSeekTable(mirodetails[u'pathfilename'])
 						changed_fields[u'filename'] = self.rtnRelativePath(fullfilename, u'mythvideo')
+						if changed_fields[u'filename'][0] != u'/':
+							changed_fields[u'host'] = localhostname.lower()
+						else:	# Deal with the whole mixing Video SG and local with SG graphics mess
+							for key in graphicsDirectories.keys():
+								if key == u'screenshot' or not changed_fields.has_key(key):
+									continue
+								if changed_fields[key][0] == u'/':
+									continue
+								else:
+									changed_fields.remove(key)
 						break
 					index+=1
 
@@ -4786,7 +5081,7 @@
 			for elem in data_id:
 				if table_names[i] == u'chanid' and elem == 9999:
 					recorded[u'miro_tv'] = True
-				if table_names[i] == 'title' or table_names[i] == 'subtitle' or table_names[i] == 'seriesid': 
+				if table_names[i] == 'title' or table_names[i] == 'subtitle' or table_names[i] == 'seriesid':
 					recorded[table_names[i]] = elem
 				i+=1
 
@@ -4816,7 +5111,7 @@
 			recorded = {}
 			i = 0
 			for elem in data_id:
-				if table_names[i] == 'title' or table_names[i] == 'subtitle' or table_names[i] == 'airdate': 
+				if table_names[i] == 'title' or table_names[i] == 'subtitle' or table_names[i] == 'airdate':
 					recorded[table_names[i]] = elem
 				i+=1
 
@@ -4885,7 +5180,7 @@
 						moviename = record['subtitle']
 						if not moviename:
 							moviename = ''
-						else:  
+						else:
 							index = moviename.find(self.config['mb_movies'][filter(is_not_punct_char, program[u'title'].lower())])
 							if index != -1:
 								moviename = moviename[:index].strip()
@@ -4931,6 +5226,7 @@
 		self.config['season_num'] = None
 		self.config['episode_num'] = None
 		series_graphics = self.getGraphics(graphics_type)
+
 		if series_graphics != None:
 			cfile = { 'file_seriesname': program['title'],
 					'inetref': self.config['sid'],
@@ -4948,7 +5244,7 @@
 	def _downloadScheduledRecordedGraphics(self):
 		'''Get Scheduled and Recorded programs and Miro vidoes get their graphics if not already
 		downloaded
-		return (nothing is returned) 
+		return (nothing is returned)
 		'''
 		global localhostname
 
@@ -4995,7 +5291,7 @@
 			program['need'] = False	# Initalize that this program does not need graphic(s) downloaded
 			mirodetails = None
 			if not program.has_key(u'miro'):
-				if program['subtitle']:				
+				if program['subtitle']:
 					graphics_name = program['title']
 				else:
 					if program['originalairdate'] == u'0000':
@@ -5008,6 +5304,9 @@
 					graphics_name = program['title']
 				else:
 					graphics_name = mirodetails[u'inetref']
+
+			self.absolutepath = False		# All Scheduled Recorded and Miro videos start in the SG "Default"
+
 			# Search for graphics that are already downloaded
 			for directory in graphicsDirectories.keys():
 				if directory == 'screenshot':	# There is no downloading of screenshots required
@@ -5026,9 +5325,12 @@
 					filename = program['title']
 				else:
 					filename = mirodetails[u'inetref']
-					
+
+				# Deal with TV series names that would generate invalid file names for images TV and movies
+				self.program_seriesid = None
 				if not isValidPosixFilename(filename) and program['seriesid'] != u'':
 					filename = program['seriesid']
+					self.program_seriesid = program['seriesid']
 
 				# Actual check for existing graphics
 				for dirct in self.config[graphicsDirectories[directory]]:
@@ -5036,14 +5338,14 @@
 						dir_list = os.listdir(unicode(dirct, 'utf8'))
 					except (UnicodeEncodeError, TypeError):
 						dir_list = os.listdir(dirct)
-					for flenme in dir_list: 
+					for flenme in dir_list:
 						if fnmatch.fnmatch(flenme.lower(), u'%s*.*' % filename.lower()):
 							program[directory] = True
 							if directory == 'coverfile':
 								total_posters_found +=1
 							elif directory == 'banner':
 								total_banners_found +=1
-							else: 
+							else:
 								total_fanart_found +=1
 							if mirodetails: # Update the Miro MythVideo records with any existing graphics
 								mirodetails[directory] = self.rtnRelativePath(u'%s/%s' % (dirct, flenme), directory)
@@ -5099,16 +5401,6 @@
 							filename = program['title']
 						else:
 							filename = mirodetails[u'moviename']
-						if not isValidPosixFilename(filename) and program['seriesid'] != u'' and not self.config['simulation']:
-							abs_results = self.rtnAbsolutePath(results, graphicsDirectories[key])
-							(dirName, fileName) = os.path.split(abs_results)
-							(fileBaseName, fileExtension) = os.path.splitext(fileName)
-							# Take graphics name apart and get new name with seriesid
-							newfilename = u"%s/%s%s" % (dirName, program['seriesid'], fileExtension)
-							if not os.path.isfile(newfilename):
-								os.rename(abs_results, newfilename)
-								results = self.rtnRelativePath(newfilename, graphicsDirectories[key])
-							
 						if key == 'coverfile':
 							total_posters_downloaded +=1
 						elif key == 'banner':
@@ -5142,16 +5434,6 @@
 					if not results:
 						results = self._getSecondarySourceGraphics(cfile, key, watched=True)
 					if results:
-						if not miromovieflag:
-							if not isValidPosixFilename(title) and program['seriesid'] != u'' and not self.config['simulation']:
-								abs_results = self.rtnAbsolutePath(results, graphicsDirectories[key])
-								(dirName, fileName) = os.path.split(abs_results)
-								(fileBaseName, fileExtension) = os.path.splitext(fileName)
-								# Take graphics name apart and get new name with seriesid
-								newfilename = u"%s/%s%s" % (dirName, program['seriesid'], fileExtension)
-								if not os.path.isfile(newfilename):
-									os.rename(abs_results, newfilename)
-									results = self.rtnRelativePath(newfilename, graphicsDirectories[key])
 						if key == 'coverfile':
 							total_posters_downloaded +=1
 						elif key == 'banner':
@@ -5172,7 +5454,7 @@
 
 		# Print statistics
 		sys.stdout.write(u'\n-----Scheduled & Recorded Statistics-------\nNumber of Scheduled & Recorded ......(% 5d)\nNumber of Fanart graphics found .....(% 5d)\nNumber of Poster graphics found .....(% 5d)\nNumber of Banner graphics found .....(% 5d)\nNumber of Fanart graphics downloaded (% 5d)\nNumber of Poster graphics downloaded (% 5d)\nNumber of Banner graphics downloaded (% 5d)\nNumber of Miro TV Shows ............ (% 5d)\nNumber of Miro Movie Trailers ...... (% 5d)\n' % (total_progs_checked, total_fanart_found, total_posters_found, total_banners_found, total_fanart_downloaded, total_posters_downloaded, total_banners_downloaded, total_miro_tv, total_miro_movies))
-		
+
 		if len(programs):
 			sys.stdout.write(u'\n-------------Scheduled & Recorded----------\n')
 			for program in programs:
@@ -5202,7 +5484,7 @@
 		'''
 		(dirName, fileName) = os.path.split(filename)
 		(fileBaseName, fileExtension) = os.path.splitext(fileName)
-		if fuzzy_match: # Match even when the names are not exactly the same by removing punctuation 
+		if fuzzy_match: # Match even when the names are not exactly the same by removing punctuation
 			for dirct in directories:
 				try:
 					dir_list = os.listdir(unicode(dirct, 'utf8'))
@@ -5229,7 +5511,7 @@
 						return u'%s/%s' % (dirct, dir_list[match_list.index(file_path)])
 			else:
 				return False
-		else: # Find an exact match 
+		else: # Find an exact match
 			for directory in directories:
 				if filename[0] != u'/' and dirName != u'':
 					dir_name = u"%s/%s" % (directory, dirName)
@@ -5261,26 +5543,27 @@
 	num_secondary_source_metadata_downloaded=0
 
 	def processMythTvMetaData(self):
-		'''Check each video file in the mythvideo directories download graphics files and meta data then 
+		'''Check each video file in the mythvideo directories download graphics files and meta data then
 		update MythTV data base meta data with any new information.
 		'''
 		# If there were directories specified move them and update the MythTV db meta data accordingly
 		if self.config['video_dir']:
 			if len(self.config['video_dir']) % 2 == 0:
 				validFiles = self._moveVideoFiles(self.config['video_dir'])
+				self.config[u'file_move_flag'] = False
 			else:
 				sys.stderr.write(u"\n! Error: When specifying target (file or directory) to move to a destination (directory) they must always be in pairs (target and destination directory).\nYou specified an uneven number of variables (%d) for target and destination pairs.\nVariable count (%s)\n" % (len(self.config['video_dir']), self.config['video_dir']))
-				sys.exit(False)
+				sys.exit(1)
 
 		# Check if only missing inetref video's should be processed
 		if self.config['mythtv_inetref']:
 			validFiles = self._findMissingInetref()
 			if validFiles == None:
 				sys.stderr.write(u"\n! Warning: There were no missing interef video files found.\n\n")
-				sys.exit(True)
+				sys.exit(0)
 			elif not len(validFiles):
 				sys.stderr.write(u"\n! Warning: There were no missing interef video files found.\n\n")
-				sys.exit(True)
+				sys.exit(0)
 
 		# Verify that the proper fields are present
 		db_version = mythdb.getSetting('DBSchemaVer')
@@ -5288,26 +5571,26 @@
 		for field in ['season', 'episode', 'coverfile', 'screenshot', 'banner', 'fanart']:
 			if not field in field_names:
 				sys.stderr.write(u"\n! Error: Your MythTv data base scheme version (%s) does not have the necessary fields at least (%s) is missing\n\n" % (db_version, field))
-				sys.exit(False)
+				sys.exit(1)
 
 		# Check if this is a Scheduled and Recorded graphics download request
 		if self.config['mythtv_watched']:
 			self._downloadScheduledRecordedGraphics()
-			sys.exit(True)
+			sys.exit(0)
 
 		# Check if this is just a Janitor (clean up unused graphics files) request
 		if self.config['mythtvjanitor']:
 			self._graphicsCleanup()
-			sys.exit(True)
+			sys.exit(0)
 
 		directories=self.config['mythvideo']
 
 		if not len(directories):
 			sys.stderr.write(u"\n! Error: There must be a video directory specified in MythTv\n")
-			sys.exit(False)
+			sys.exit(1)
 
 		# Set statistics
-		num_processed=0 			
+		num_processed=0
 		num_fanart_downloads=0
 		num_posters_downloads=0
 		num_banners_downloads=0
@@ -5329,7 +5612,7 @@
 
 		if len(validFiles) == 0:
 			sys.stderr.write(u"\n! Error: No valid video files found\n")
-			sys.exit(False)
+			sys.exit(1)
 
 		tv_series_season_format=u"%s/%s Season %d.%s"
 		tv_series_format=u"%s/%s.%s"
@@ -5350,7 +5633,7 @@
 				# Unless explicitly requested with options -MI or -MG do not add missing videos to DB
 				if not self.config['interactive'] and not self.config['mythtv_guess']:
 					continue
-				# Create a new empty entry 
+				# Create a new empty entry
 				sys.stdout.write(u"\n\nEntry does not exist in MythDB.  Adding (%s).\n" % cfile['filename'])
 				self.initialize_record['title'] = cfile['file_seriesname']
 				self.initialize_record['filename'] = self.rtnRelativePath(videopath, u'mythvideo')
@@ -5380,18 +5663,26 @@
 
 			available_metadata['season']=cfile['seasno']
 			available_metadata['episode']=cfile['epno']
-			available_metadata['title'] = cfile['file_seriesname']
 
-			# There must be an Internet reference number. Get one for new records. 
+			if available_metadata['title'] == u'':
+				available_metadata['title'] = cfile['file_seriesname']
+
+			# Set whether a video file is stored in a Storage Group or not
+			if available_metadata['filename'][0] == u'/':
+				self.absolutepath = True
+			else:
+				self.absolutepath = False
+
+			# There must be an Internet reference number. Get one for new records.
 			if _can_int(meta_dict['inetref']) and not meta_dict['inetref'] == u'00000000' and not meta_dict['inetref'] == '':
-				if meta_dict['inetref'] == '99999999': # Records that are not updated by Jamu 
+				if meta_dict['inetref'] == '99999999': # Records that are not updated by Jamu
 					continue
 				inetref = meta_dict['inetref']
 				cfile['inetref'] = meta_dict['inetref']
 			else:
 				if movie:
 					if not self.config['interactive'] and not self.config['mythtv_guess']:
-						sys.stderr.write(u'\n! Warning: Skipping "%s" as there is no IMDB number for this movie.\nUse interactive option (-i) or (-I) to select the IMDB number.\n\n' % (cfile['file_seriesname'])) 
+						sys.stderr.write(u'\n! Warning: Skipping "%s" as there is no IMDB number for this movie.\nUse interactive option (-i) or (-I) to select the IMDB number.\n\n' % (cfile['file_seriesname']))
 						continue
 					inetref = self._getTmdbIMDB(available_metadata['title'])
 					cfile['inetref'] = inetref
@@ -5424,7 +5715,7 @@
 					available_metadata['title'] = self.config['series_name']
 					cfile['file_seriesname'] = self.config['series_name']
 
-			'''# Check if current inetref is a IMDB# 
+			'''# Check if current inetref is a IMDB#
 			# If so then check it could be changed to tmdb#
 			# If it can be changed then rename any graphics and update meta data
 			if movie and len(inetref) == 7:
@@ -5462,10 +5753,17 @@
 			# START of metadata Graphics logic - Checking, downloading, renaming
 			###############################################################################
 			for graphic_type in ['coverfile', 'banner', 'fanart']:
-				graphicsdirs = self.config[graphicsDirectories[graphic_type]]
 				###############################################################################
 				# START of MOVIE graphics updating
 				###############################################################################
+				# Check that there are local graphics path for abs path video
+				# An abs path video can only use the FE specified graphic directories
+				if self.absolutepath:
+					if not len(self.config['localpaths'][graphicsDirectories[graphic_type]]):
+						continue
+					graphicsdirs = self.config['localpaths'][graphicsDirectories[graphic_type]]
+				else:
+					graphicsdirs = self.config[graphicsDirectories[graphic_type]]
 				if movie:
 					if graphic_type == 'banner':
 						continue
@@ -5532,7 +5830,7 @@
 					if need_graphic or new_format: # Graphic does not exist or is in an old format
 						for ext in self.image_extensions:
 							for graphicsdir in graphicsdirs:
-								filename=self.findFileInDir(u"%s Season %d.%s" % (sanitiseFileName(available_metadata['title']), available_metadata['season'], ext), [graphicsdir], suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
+								filename=self.findFileInDir(u"%s Season %d.%s" % (self.sanitiseFileName(available_metadata['title']), available_metadata['season'], ext), [graphicsdir], suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
 								if filename:
 									available_metadata[graphic_type]=self.rtnRelativePath(filename,  graphicsDirectories[graphic_type])
 									need_graphic = False
@@ -5562,13 +5860,13 @@
 								if graphic_file.find(u' Season ') == -1: # Check for Season
 									must_rename = True
 									season_missing = True
-								if graphic_file.find(self.graphic_suffix[graphic_type]) == -1: 
+								if graphic_file.find(self.graphic_suffix[graphic_type]) == -1:
 									must_rename = True
 									suffix_missing = True
 								if must_rename:
 									filepath, filename = os.path.split(graphic_file)
 									baseFilename, ext = os.path.splitext( filename )
-									baseFilename = sanitiseFileName(baseFilename)
+									baseFilename = self.sanitiseFileName(baseFilename)
 									if season_missing and suffix_missing:
 										newFilename = u"%s/%s Season %d%s%s" % (filepath, baseFilename, available_metadata['season'], self.graphic_suffix[graphic_type], ext)
 									elif suffix_missing:
@@ -5586,7 +5884,7 @@
 								else:
 									available_metadata[graphic_type]= self.rtnRelativePath(graphic_file,  graphicsDirectories[graphic_type])
 							else: # Must see if a graphic is on thetvdb wiki
-								if graphic_type == 'coverfile' or graphic_type == 'banner': 
+								if graphic_type == 'coverfile' or graphic_type == 'banner':
 									available_metadata[graphic_type] = self.rtnRelativePath(self._getTvdbGraphics(cfile, graphic_type),  graphicsDirectories[graphic_type])
 									if available_metadata[graphic_type] == None:
 										tmp = self._getTvdbGraphics(cfile, graphic_type, toprated=True)
@@ -5594,7 +5892,7 @@
 											tmp_fullfilename = self.rtnAbsolutePath(tmp, graphicsDirectories[graphic_type])
 											filepath, filename = os.path.split(tmp_fullfilename)
 											baseFilename, ext = os.path.splitext( filename )
-											baseFilename = sanitiseFileName(baseFilename)
+											baseFilename = self.sanitiseFileName(baseFilename)
 											baseFilename = baseFilename.replace(self.graphic_suffix[graphic_type], u'')
 											newFilename = u"%s/%s Season %d%s%s" % (filepath, baseFilename, available_metadata['season'], self.graphic_suffix[graphic_type], ext)
 											if self.config['simulation']:
@@ -5626,7 +5924,7 @@
 									if tmp!= None:
 										filepath, filename = os.path.split(tmp)
 										baseFilename, ext = os.path.splitext( filename )
-										baseFilename = sanitiseFileName(baseFilename)
+										baseFilename = self.sanitiseFileName(baseFilename)
 										baseFilename = baseFilename.replace(self.graphic_suffix[graphic_type], u'')
 										newFilename = u"%s/%s Season %d%s%s" % (filepath, baseFilename, available_metadata['season'], self.graphic_suffix[graphic_type], ext)
 										if self.config['simulation']:
@@ -5645,9 +5943,9 @@
 					else:
 						if graphic_type == 'coverfile' or graphic_type == 'banner':
 							for ext in self.image_extensions:
-								filename = self.findFileInDir(u"%s.%s" % (sanitiseFileName(available_metadata['title']), ext), self.config[graphicsDirectories[graphic_type]], suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
+								filename = self.findFileInDir(u"%s.%s" % (self.sanitiseFileName(available_metadata['title']), ext), graphicsdirs, suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
 								if filename:
-									size = self.findFileInDir(u"%s Season %d.%s" % (sanitiseFileName(available_metadata['title']), available_metadata['season'], ext), self.config[graphicsDirectories[graphic_type]], suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
+									size = self.findFileInDir(u"%s Season %d.%s" % (self.sanitiseFileName(available_metadata['title']), available_metadata['season'], ext), graphicsdirs, suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
 									if not size:
 										continue
 									if os.path.getsize(size) == os.path.getsize(filename):
@@ -5685,7 +5983,7 @@
 															num_banners_downloads+=1
 									break
 					for ext in self.image_extensions:
-						dest = self.findFileInDir(u"%s.%s" % (sanitiseFileName(available_metadata['title']), ext), graphicsdirs, suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
+						dest = self.findFileInDir(u"%s.%s" % (self.sanitiseFileName(available_metadata['title']), ext), graphicsdirs, suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
 						if dest:
 							break
 					else:
@@ -5716,10 +6014,9 @@
 			# Check if any meta data needs updating
 			metadata_update = True
 			for key in available_metadata.keys():
-				try:
-					dummy = self.config['metadata_exclude_as_update_trigger'].index(key)
+				if key in self.config['metadata_exclude_as_update_trigger']:
 					continue
-				except:
+				else:
 					if key == 'rating' and (available_metadata[key] == 'NR' or available_metadata[key] ==  '' or available_metadata[key] == 'Unknown'):
 						self._displayMessage(
 						u"At least (%s) needs updating\n" % (key))
@@ -5778,17 +6075,15 @@
 				else:
 					tmp_dict = self._getTvdbMetadata(cfile, copy)
 				num_episode_metadata_downloads+=1
-				# Update meta data 
+				# Update meta data
 				if tmp_dict:
-					tmp_dict['title'] = cfile['file_seriesname']
 					for key in ['genres', 'cast']:
 						if tmp_dict.has_key(key):
 							genres_cast[key] = tmp_dict[key]
 					for key in available_metadata.keys():
-						try:
-							dummy = self.config['metadata_exclude_as_update_trigger'].index(key)
+						if key in self.config['metadata_exclude_as_update_trigger']:
 							continue
-						except:
+						else:
 							if not tmp_dict.has_key(key):
 								continue
 							if key == 'userrating' and available_metadata[key] == 0.0:
@@ -5825,17 +6120,28 @@
 				self._displayMessage(u"Changed category from 0 to 1 for (%s)" % available_metadata['title'])
 				available_metadata['category'] = 1
 
-			# Make sure host name is set if any relative paths were used
-			for key in [u'filename', u'coverfile', u'trailer', u'screenshot', u'banner', u'fanart']:
-				if available_metadata[key] != None and available_metadata[key] != u'No Cover' and available_metadata[key] != u'':
-					if available_metadata[key][0] != u'/':
-						available_metadata[u'host'] = localhostname.lower()
+			# Make sure graphics relative/absolute paths are set PROPERLY based
+			# on the 'filename' field being a relative or absolute path. A filename with an absolite path
+			# CAN ONLY have graphics baed on absolute paths.
+			# A filename with a relative path can have mixed absolute and relative path graphic files
+			if available_metadata[u'filename'][0] == u'/':
+				available_metadata[u'host'] = u''
+				for key in [u'coverfile', u'banner', u'fanart']:
+					if available_metadata[key] != None and available_metadata[key] != u'No Cover' and available_metadata[key] != u'':
+						if available_metadata[key][0] != u'/':
+							tmp = self.rtnAbsolutePath(available_metadata[key], graphicsDirectories[key])
+							if tmp[0] != u'/':
+								if key == u'coverfile':
+									available_metadata[key] = u'No Cover'
+								else:
+									available_metadata[key] = u''
+			else:
+				available_metadata[u'host'] = localhostname.lower()
 
 			###############################################################################
 			# END of metadata text logic - Checking, downloading, renaming
 			###############################################################################
 
-
 			###############################################################################
 			# START of metadata updating the MythVideo record when graphics or text has changed
 			###############################################################################
@@ -5886,6 +6192,9 @@
 		# Fix all the directory cover images
 		if self.config['folderart']:
 			for cfile in validFiles:
+				# Skip directories that do not have RW access because folder art files cannot be created
+				if not os.access(cfile['filepath'], os.F_OK | os.R_OK | os.W_OK):
+					continue
 				videopath = tv_series_format % (cfile['filepath'], cfile['filename'], cfile['ext'])
 				# Find the MythTV meta data
 				intid = mythvideo.getMetadataId(videopath, localhostname.lower())
@@ -5907,7 +6216,14 @@
 				# Get a dictionary of the existing meta data
 				meta_dict=mythvideo.getMetadataDictionary(intid)
 
-				# There must be an Internet reference number. Get one for new records. 
+				if meta_dict['filename'][0] == u'/':
+					if not len(self.config['localpaths']['posters']):
+						continue
+					posterdirs = self.config['localpaths']['posters']
+				else:
+					posterdirs = self.config['posters']
+
+				# There must be an Internet reference number. Get one for new records.
 				if _can_int(meta_dict['inetref']) and not meta_dict['inetref'] == u'00000000' and not meta_dict['inetref'] == u'':
 					if meta_dict['inetref'] == u'99999999':
 						continue
@@ -5940,7 +6256,7 @@
 				for d in sub_path.split(u'/'):
 					dir_array.append([u"%s/%s" % (base_dir+dir_subs, d), d])
 					dir_subs+=u'/'+d
-			
+
 				for directory in dir_array:
 					for ext in self.image_extensions:
 						tmp_file = u"%s/%s.%s" % (directory[0], directory[1], ext)
@@ -5958,17 +6274,17 @@
 						if os.path.isfile(tmp_file):
 							if os.path.isfile(os.path.realpath(tmp_file)): # Check for broken symbolic links
 								os.rename(tmp_file, folder_name)
-								break 
+								break
 						if os.path.isfile(folder_name):
 							if os.path.isfile(os.path.realpath(folder_name)): # Check for broken symbolic links
-								break 
+								break
 					else:
 						for pattern in self.config['season_dir_pattern']:
-							match = pattern.match(directory[1]) 
+							match = pattern.match(directory[1])
 							if match:
 								season_num = int((match.groups())[0])
 								for ext in self.image_extensions:
-									filename = self.findFileInDir(u"%s Season %d.%s" % (sanitiseFileName(cfile['file_seriesname']), season_num, ext), self.config['posterdir'])
+									filename = self.findFileInDir(u"%s Season %d.%s" % (self.sanitiseFileName(cfile['file_seriesname']), season_num, ext), posterdirs)
 									if filename:
 										if self.config['simulation']:
 											sys.stdout.write(
@@ -5984,11 +6300,11 @@
 										break
 						else:
 							if movie:
-								name = inetref							
+								name = inetref
 							else:
-								name = sanitiseFileName(cfile['file_seriesname'])
+								name = self.sanitiseFileName(cfile['file_seriesname'])
 							for ext in self.image_extensions:
-								filename = self.findFileInDir(u"%s.%s" % (name, ext), self.config['posterdir'])
+								filename = self.findFileInDir(u"%s.%s" % (name, ext), posterdirs)
 								if filename:
 									if self.config['simulation']:
 										sys.stdout.write(
@@ -6011,7 +6327,7 @@
 
 		# Print statistics
 		sys.stdout.write(u'\n------------------Statistics---------------\nNumber of video files processed .....(% 5d)\nNumber of Fanart graphics downloaded (% 5d)\nNumber of Poster graphics downloaded (% 5d)\nNumber of Banner graphics downloaded (% 5d)\nNumber of 2nd source graphics downld (% 5d)\nNumber of metadata downloads.........(% 5d)\nNumber of 2nd source metadata found .(% 5d)\nNumber of symbolic links created.....(% 5d)\nNumber of Myth database updates......(% 5d)\nNumber of undersized posters ........(% 5d)\n' % (num_processed, num_fanart_downloads, num_posters_downloads, num_banners_downloads, self.num_secondary_source_graphics_downloaded, num_episode_metadata_downloads, self.num_secondary_source_metadata_downloaded, num_symlinks_created, num_mythdb_updates, num_posters_below_min_size))
-		
+
 		if len(videos_updated_metadata):
 			sys.stdout.write(u'\n--------------Updated Video Files----------\n' )
 			for videofile in videos_updated_metadata:
@@ -6028,7 +6344,7 @@
 		return None
 	# end processMythTvMetaData
 
-	def __repr__(self):	# Just a place holder 
+	def __repr__(self):	# Just a place holder
 		return self.config
 	# end __repr__
 
@@ -6036,7 +6352,7 @@
 
 def simple_example():
 	"""Simple example of using jamu
-	Displays the poster graphics URL(s) and episode meta data for the TV series Sanctuary, season 1 
+	Displays the poster graphics URL(s) and episode meta data for the TV series Sanctuary, season 1
 	episode 3
 	returns None if there was no data found for the request TV series
 	returns False if there is no TV series as specified
@@ -6063,7 +6379,7 @@
 
 def main():
 	"""Support jamu from the command line
-	returns True 
+	returns True
 	"""
  	parser = OptionParser(usage=u"%prog usage: jamu -hbueviflstdnmoCRFUDSGN [parameters]\n <series name/SID or 'series/SID and season number' or 'series/SID and season number and episode number' or 'series/SID and episode name' or video file/directory paired with destination directory'>")
 
@@ -6131,17 +6447,44 @@
 
 	if opts.usage:					# Display usage information
 		sys.stdout.write(usage_txt+'\n')
-		sys.exit(True)
+		sys.exit(0)
 
 	if opts.examples:					# Display example information
 		sys.stdout.write(examples_txt+'\n')
-		sys.exit(True)
+		sys.exit(0)
 
 	if opts.version == True:		# Display program information
 		sys.stdout.write(u"\nTitle: (%s); Version: (%s); Author: (%s)\n%s\n" % (
 		__title__, __version__, __author__, __purpose__ ))
-		sys.exit(True)
+		sys.exit(0)
 
+    # Verify that only one instance of the following options is running at any one time
+    # Options (-M, -MW and -MG)
+	options = u''
+	if opts.mythtvmeta:
+		options+=u'M'
+	if opts.mythtvmeta and opts.mythtv_watched:
+		options+=u'W'
+	if opts.mythtvmeta and opts.mythtv_guess:
+		options+=u'G'
+	if opts.mythtvmeta and opts.mythtvjanitor:  # No instance check with the janitor option
+		options+=u'J'
+	if opts.mythtvmeta and opts.mythtv_inetref: # No instance check with the interactive mode option
+		options+=u'I'
+	if options in [u'M', u'MW', u'MG']:
+		jamu_instance = singleinstance(u'/tmp/Jamu_%s_instance.pid' % options)
+		#
+		# check is another instance of Jamu is running
+		#
+		if jamu_instance.alreadyrunning():
+		    print u'\n! Error: An instance of Jamu (-%s) is already running only one instance can run at a time.\nOne of the meta data sources may be off-line or very slow.\n' % options
+		    sys.exit(1)
+
+	# Message the user that they are using incompatible options with the -MW option
+	if opts.mythtvmeta and opts.mythtv_watched and (opts.mythtv_inetref or opts.interactive):
+	    print u'\n! Error: There us no Interactive mode (-I or -i) for the Jamu (-MW) option.\nPlease change your options and try again.\n'
+	    sys.exit(1)
+
 	# Apply any command line switches
 	configuration.changeVariable('local_language', opts.language)
 	configuration.changeVariable('simulation', opts.simulation)
@@ -6178,7 +6521,7 @@
 		else:
 			configuration.validate_setVariables(['FAKE SERIES NAME','FAKE EPISODE NAME'])
 		configuration.displayOptions()
-		sys.exit(True)
+		sys.exit(0)
 
 	# Validate specific variables
 	configuration.validate_setVariables(series_season_ep)
Index: mythplugins/mythvideo/mythvideo/scripts/jamu-example.conf
===================================================================
--- mythplugins/mythvideo/mythvideo/scripts/jamu-example.conf	(revision 22751)
+++ mythplugins/mythvideo/mythvideo/scripts/jamu-example.conf	(working copy)
@@ -12,15 +12,17 @@
 # Version: 0.3.4 - Added a IMDB variable as a second source parameter
 # Version: 0.3.5 - Added a folderart option to turn Jamu's creation of folder cover art on.
 # Version: 0.3.6 - Added sections [mb_tv] and [mb_movies] for the -MW to get graphics for Miro videos.
-# Version: 0.3.7 - Prepopulated the following sections with values to help new users: 
-#                  "season/movie name overrides section", "episode name massaging section" and 
+# Version: 0.3.7 - Prepopulated the following sections with values to help new users:
+#                  "season/movie name overrides section", "episode name massaging section" and
 #                  Miro additional graphics section". Also updated the docunentation for secondary
 #                  sources.
+# Version: 0.3.8 - Added the 'filename_char_filter' variable to allow additional characters to be replaced
+#				   by a '_' in file names.
 #
 # License:Creative Commons GNU GPL v2
 # (http://creativecommons.org/licenses/GPL/2.0/)
 #-------------------------------------
-# This config file contains variables the user can modify through option "-C" configuration filename. 
+# This config file contains variables the user can modify through option "-C" configuration filename.
 # To see all variable names and their current values run "jamu -f" from the command line.
 # Once you make changes, verify those changes by running "jamu -f" again.
 # This file is an example, copy and rename (e.g. jamu.conf) so that the next distribution does
@@ -30,21 +32,21 @@
 #
 # START  variables section---------------------------------------------------------------------------
 # All variables a user can modify are listed below with their default values. To change a variable
-# remove the leading '#' and change the value (after the ':'). Limited editing of the values is 
+# remove the leading '#' and change the value (after the ':'). Limited editing of the values is
 # performed so be careful. Without caution you can certainly cause jamu to fail/abort.
 # NOTE: Do not surround any value data with quotes even if it contains spaces.
 #       e.g. the directory name "/home/my dir/my posters" is expressed as value /home/my dir/my posters
 #
-[variables] 
+[variables]
 # 'allgraphicsdir' contains the default directory for any downloaded data that is not specifically
 #                  specified. The default for this variable is the current directory.
 #allgraphicsdir: < the current directory the script is being started from >
 
-# "bannerdir" is the directory that banner graphics will be downloaded. Default is the current directory. 
+# "bannerdir" is the directory that banner graphics will be downloaded. Default is the current directory.
 # (Options) None or a directory path without the trailing "/" character
 #bannerdir: None
 
-# "data_flags" indicates one or more types of data that needs to be processed 
+# "data_flags" indicates one or more types of data that needs to be processed
 # (Options) PBFIE - P-posters, B-banners, F-fanart, I-episode image, E-episode meta data
 #data_flags: None
 
@@ -56,50 +58,63 @@
 # (Options) True or False. Default is False
 #download: False
 
-# 'ep_metadata' is the filename format for episode meta data downloaded files. 
+# 'ep_metadata' is the filename format for episode meta data downloaded files.
 # Valid variables are sid, series, seasonnumber, episodenumber. episodename. You can replace ext with
 # your own hard coded value e,g replace "%%(ext)s" with "myextention"
 # Default is the value of 'with_ep_name' (which is displayed below)
 #ep_metadata: %%(series)s - S%%(seasonnumber)02dE%%(episodenumber)02d - %%(episodename)s.%%(ext)s
 
-# "episodeimagedir" is the directory that episode image graphics will be downloaded. Default is the 
-#                   current directory. 
+# "episodeimagedir" is the directory that episode image graphics will be downloaded. Default is the
+#                   current directory.
 # (Options) None or a directory without the trailing "/" character
 #episodeimagedir: None
 
-# "fanartdir" is the directory that fanart graphics will be downloaded. Default is the 
-#                   current directory. 
+# "fanartdir" is the directory that fanart graphics will be downloaded. Default is the
+#                   current directory.
 # (Options) None or a directory without the trailing "/" character
 #fanartdir: None
 
-# 'fanartresize' is the indicator and value used to resize downloaded fanart graphics with 
+# 'fanartresize' is the indicator and value used to resize downloaded fanart graphics with
 #                using ImageMagick's utility 'mogrify'. Default is no resizing (False).
 # (Options) False when no resizing. a percent size change e.g. 50%% smaller or widthxheight e,g, 1280x720
 #fanartresize: False
 
+# 'filename_char_filter' Jamu sanitises file name (video and images) to the POSIX standard which does not allow
+#			"/" or null. When an invalid character is found an underscore "_" is used in its place. People
+#           that use a Windows file system for video and/or images require additional characters to be filtered.
+#           This variable allows a user to add additional file name filter characters ALL of which will be
+#           turned into underscores "_".
+#           NOTE: the "%" character is also filtered as it is a string format character in python.
+#           NOTE: Invalid MS-Windows file system characters are: \/:*?"<>|
+#                 The forward slash '/' is already a default.
+#           NOTE: Do not put spaces between the chracters or quotes around the chracters.
+#           Default: /%\000		The last \000 is the representation of a null character
+# (Options) characters that will be added to the Default filter characters.
+#filename_char_filter: \:*?"<>|
+
 # 'folderart' Changes in the MythVideo UI graphic hunts (cover art and fanart) have made Jamu's
 #             creation of "folder.xxx" graphics redundant. This feature has been turned off in Jamu.
 #             This user option reactivates this feature. Default is no folder cover art creation (False).
 # (Options) False Jamu will NOT create folder cover art; True Jamu will creating folder cover art
 #folderart: True
 
-# 'g_defaultname' downloaded graphics filename format. True means to use the same file name as 
+# 'g_defaultname' downloaded graphics filename format. True means to use the same file name as
 #                 on thetvdb.com wiki. Default is True. If this value is changed to False then either
 #                 the 'g_season' or 'g_series' file name formats will be used.
 # (Options) True or False
 #g_defaultname: True
 
-# 'g_season' is the file name format of poster, fanart or banner season level graphics. The 'seq' is a 
+# 'g_season' is the file name format of poster, fanart or banner season level graphics. The 'seq' is a
 #            sequence number added that deals issues when there are multiple files of the same type.
 #  (Options) sid, series, seasonnumber, seq, ext
 #g_season: %%(series)s - %%(seasonnumber)02d-%%(seq)s.%%(ext)s
 
-# 'g_series' is the file name format of poster, fanart or banner series level graphics. The 'seq' is a 
+# 'g_series' is the file name format of poster, fanart or banner series level graphics. The 'seq' is a
 #            sequence number added that deals issues when there are multiple files of the same type.
 #  (Options) sid, series, seq, ext
 #g_series: %%(series)s - %%(seq)s.%%(ext)s
 
-# 'interactive' is used to indicate if the series are chosen interactively from a list of possible 
+# 'interactive' is used to indicate if the series are chosen interactively from a list of possible
 #               series names found on thetvdb.com. Default is False which means that the first matching
 #               series name is assumed to be the one that is required.
 # (Options) True or False
@@ -112,7 +127,7 @@
 # (Options) da, fi, nl, de, it, es, fr,pl, hu,el,tr, ru,he,ja,pt,zh,cs,sl, hr,ko,en,sv,no
 #local_language: en
 
-# 'maximum' indicates a numerical limit to the amount of graphics per type to display or download. 
+# 'maximum' indicates a numerical limit to the amount of graphics per type to display or download.
 #           If not specified all graphics for a per type are displayed or downloaded. This is the same
 #           as the command line option -m. Default is None
 # (Options) None or an integer e,g. 4
@@ -120,28 +135,28 @@
 
 # 'metadata_exclude_as_update_trigger' indicates mythvideo metadata fields that should be excluded from
 #           triggering a search for new meta data. The fields that are dealt with in seperate processing
-#           so are not require as a trigger are season and episode numbers and graphics (coverfile, 
+#           so are not require as a trigger are season and episode numbers and graphics (coverfile,
 #           screenshot, banner and fanart).
-#           You may want to add more fields to this list if you find that meta data updates are being 
-#           triggered for unimportant missing data e.g. director, userrating ... etc. 
+#           You may want to add more fields to this list if you find that meta data updates are being
+#           triggered for unimportant missing data e.g. director, userrating ... etc.
 #           Fields that are NOT excluded are: 'subtitle', 'director', 'plot', 'rating', 'inetref',
-#                                             'year', 'userrating', 'length', 'category'   
+#                                             'year', 'userrating', 'length', 'category'
 # (Options) The defaults are the list of fields below.
 #metadata_exclude_as_update_trigger: intid, season, episode, showlevel, filename, coverfile, childid, browse, playcommand, trailer, host, screenshot, banner, fanart
 
-# "metadatadir" is the directory that episode metadata will be downloaded. Default is the 
-#               current directory. 
+# "metadatadir" is the directory that episode metadata will be downloaded. Default is the
+#               current directory.
 # (Options) None or a directory path without the trailing "/" character
 #metadatadir: None
 
-# "min_poster_size" is the minimum width size in pixels for a poster graphic. 
-#               If the current poster size is less than that then a replacement poster is downloaded. 
+# "min_poster_size" is the minimum width size in pixels for a poster graphic.
+#               If the current poster size is less than that then a replacement poster is downloaded.
 # (Options) Default is 200 must be an integer.
 min_poster_size: 200
 
 # "mythtvdir" indicate that the poster, fanart, banner and episode image directories should be retrieved
-#             from the MythTV DB. To use this option the MythTV python interface must be installed and 
-#             the values for the directories must have been input into the MythTV database. Default is 
+#             from the MythTV DB. To use this option the MythTV python interface must be installed and
+#             the values for the directories must have been input into the MythTV database. Default is
 #             not to use the values in MythTV database.
 # NOTE: The ability to specify fanart, banner and episode image directories is only enabled in MythTV
 #       trunk SVN 0.22 revision 20176 or higher.
@@ -149,7 +164,7 @@
 #mythtvdir: False
 
 # 'mythtvmeta' Update the MythTV data base with links to posters, banners, fanart,
-#              episode images, season and episode number. Optionally download missing 
+#              episode images, season and episode number. Optionally download missing
 #              graphics if they exist. This feature can be used for mass updates and regular maintenance.
 # (Options) True or False
 #mythtvmeta: False
@@ -167,16 +182,16 @@
 #overwrite: False
 
 # "posterdir" is the directory that poster graphics will be downloaded. Default is the current
-#             directory. 
+#             directory.
 # (Options) None or a directory path without the trailing "/" character
 #posterdir: None
 
-# 'posterresize' is the indicator and value used to resize downloaded poster graphics with 
+# 'posterresize' is the indicator and value used to resize downloaded poster graphics with
 #                using ImageMagick's utility 'mogrify'. Default is no resizing (False).
 # (Options) False when no resizing. a percent size change e.g. 50%% smaller or widthxheight e,g, 1280x720
 #posterresize: False
 
-# 'recursive' indicates to process files recursively in directories when looking for video files. The 
+# 'recursive' indicates to process files recursively in directories when looking for video files. The
 #             Default is True.
 # (Options) True or False
 #recursive: True
@@ -202,16 +217,16 @@
 # 'tmdb_genre_filter' indicates which genres you want included from those provided by themoviedb.com
 #                     The data with the key "Genres:" is a
 #                     mish-mash of information. The values supplied here restricts what would be
-#                     added to the Myth data base. This configuration option is only active when 
+#                     added to the Myth data base. This configuration option is only active when
 #                     the option Mythmetadata (-M) is also used. The defaults are those found below.
 #                     NOTE: thetvdb.com is much more restricted and therefore does not have a filter.
 #tmdb_genre_filter:Action Film, Adventure Film, Comedy, Crime Film, Disaster Film, Documentary Film, Drama Film, Eastern, Environmental, Fantasy Film, Historical Film. Horror Film, Musical Film, Mystery, Mystery Film, Road Movie, Science Fiction Film, Sport, Thriller. Western, Film Noir, Cult Movie, neo-noir, Guy Movie,
 
-# 'update' indicates that if the local episode meta data or episode image files are older than the 
+# 'update' indicates that if the local episode meta data or episode image files are older than the
 #          same episode data on thetvdb.com then re-download the meta data or episode image graphics.
-#          This option is good for keeping your local files current and is most applicable to an 
+#          This option is good for keeping your local files current and is most applicable to an
 #          overnight cron job. It only applies to episodes.
-#          Default False. 
+#          Default False.
 # (Options) True or False
 #update: False
 
@@ -220,13 +235,13 @@
 # (Options) file extensions that you want processed
 #video_file_exts: 3gp, asf, asx, avi, mkv, mov, mp4, mpg, qt, rm, swf, wmv
 
-# 'with_ep_name' indicates the file name format for meta data and episode image files when an 
+# 'with_ep_name' indicates the file name format for meta data and episode image files when an
 #                 episode name is not available.
 # Valid variables are sid, series, seasonnumber, episodenumber. episodename. You can replace ext with
 # your own hard coded value e,g replace "%%(ext)s" with "myextention". Default extension is "meta"
 #with_ep_name: %(series)s - S%(seasonnumber)02dE%(episodenumber)02d - %(episodename)s.%(ext)s
 
-# 'without_ep_name' indicates the file name format for meta data and episode image files when an 
+# 'without_ep_name' indicates the file name format for meta data and episode image files when an
 #                   episode name is not available.
 # Valid variables are sid, series, seasonnumber, episodenumber. You can replace ext with
 # your own hard coded value e,g replace "%%(ext)s" with "myextention". Default extension is "meta"
@@ -251,9 +266,9 @@
 # This section is used to specifying which episode meta data you want displayed or included in an
 # episode data file (if you set the download flag to True). The order of the
 # episode data keys is also the order that the meta data will be displayed or written to file.
-# NOTE: You should at least include "series, seasonnumber, episodenumber and episodename" that is 
+# NOTE: You should at least include "series, seasonnumber, episodenumber and episodename" that is
 #       the minimum information used in an episode meta data or image graphic file name.
-# NOTE: seriesid is the field that contains the SID for a TV show. 
+# NOTE: seriesid is the field that contains the SID for a TV show.
 #
 [ep_metadata_to_download]
 #ep_include_data: series, seasonnumber, episodenumber, episodename, rating, overview, director, writer, cast, gueststars, imdb_id, filename, epimgflag, language, runtime, firstaired, genres, lastupdated, productioncode, id, seriesid, seasonid, absolute_number, combined_season, combined_episodenumber, dvd_season, dvd_discid, dvd_chapter, dvd_episodenumber
@@ -270,21 +285,21 @@
 # Any blank line is ignored
 # All other lines must have two fields in this specific order:
 # 1st) The series/movie name or the %TITLE% field as passed by MythTV and a trailing ':' character
-# 2nd) The thetvdb.com series id (SID) or themoviedb.com imdb number as specified for the 
-#       series/movie on thetvdb.com or themoviedb.com wiki. This will override the series/movie 
-#       name to eliminate the need for manual interaction.  
+# 2nd) The thetvdb.com series id (SID) or themoviedb.com imdb number as specified for the
+#       series/movie on thetvdb.com or themoviedb.com wiki. This will override the series/movie
+#       name to eliminate the need for manual interaction.
 # NOTE: Included here, are examples of current (2009) TV shows that Schedule Direct
-#       has different TV series names than what is on thetvdb.com wiki. If you are searching for 
+#       has different TV series names than what is on thetvdb.com wiki. If you are searching for
 #       series based on the Schedule Direct names as MythTV does then the wrong TV series will be
-#       identified. You can pick the correct series by using interactive mode but this does not 
+#       identified. You can pick the correct series by using interactive mode but this does not
 #       help with unattended processing. This section allows you to specify the correct TV series
 #       on thetvbd.com despite the name in Schedule Direct. Luckily there are not many TV series
 #       that require overrides.
-#       The only time themoviedb.com is referenced is when the (-M) option is used and a 
+#       The only time themoviedb.com is referenced is when the (-M) option is used and a
 #       video files name does not have season and episode numbers. Those video files are
-#       assumed to be movies. 
+#       assumed to be movies.
 #####
-[series_name_override] 
+[series_name_override]
 # Schedule Direct vs thetvdb.com TV series naming differences
 The No. 1 Ladies' Detective Agency:81606
 
@@ -298,23 +313,23 @@
 
 House of Saddam:82624
 
-# Specify recorded "Life On Mars" shows as the US version  
+# Specify recorded "Life On Mars" shows as the US version
 Life on Mars:82289
 Life on Mars (US):82289
 
-# Specify recorded "Eleventh Hour" shows as the US version  
+# Specify recorded "Eleventh Hour" shows as the US version
 Eleventh Hour:83066
 Eleventh Hour (US):83066
 
-# Specify recorded "Frontline" or "Frontline/World" shows as the "Frontline PBS" version  
+# Specify recorded "Frontline" or "Frontline/World" shows as the "Frontline PBS" version
 Frontline/World:80646
 Frontline:80646
 
-# Specify recorded "The Beast" shows are the 2009 version  
+# Specify recorded "The Beast" shows are the 2009 version
 The Beast:83805
 The Beast (2009):83805
 
-# Specify recorded "Castle" shows are the 2009 version  
+# Specify recorded "Castle" shows are the 2009 version
 Castle:83462
 Castle (2009):83462
 
@@ -351,13 +366,13 @@
 # All other lines must in the following format:
 # 1st) The series name or the %TITLE% field as passed by MythTV and a trailing ':' character
 # 2nd) Pairs of values separated by commas. The first value is the search text to match to text within
-#      the episode name such as the %SUBTITLE% field passed by MythTV and the text to replace the 
+#      the episode name such as the %SUBTITLE% field passed by MythTV and the text to replace the
 #      matched searched text. If the replacement text contains a space then surround that text with
-#      the '"' double quotation characters. 
+#      the '"' double quotation characters.
 #      E.g. "24": PM," PM", AM, " AM" will turn the episode name
 #      "Day 7: 11:00AM to 12:00PM" into "Day 7: 11:00 AM to 12:00 PM"
-#      This feature helps reduce or eliminates the need for manual interaction. 
-# NOTE: At this time ONLY the TV Series 24 needs this option. Your collection may be different. 
+#      This feature helps reduce or eliminates the need for manual interaction.
+# NOTE: At this time ONLY the TV Series 24 needs this option. Your collection may be different.
 #####
 [ep_name_massage]
 24: PM," PM", AM, " AM",M-,"M - "
@@ -365,8 +380,8 @@
 
 
 # START  Miro additional graphics section -----------------------------------------------------------
-# By default mirobridge exclusively uses the Miro meta data and graphics (Channel icon or 
-# video icon and video screenshot), when adding a Miro video to either MythTV and MythVideo. 
+# By default mirobridge exclusively uses the Miro meta data and graphics (Channel icon or
+# video icon and video screenshot), when adding a Miro video to either MythTV and MythVideo.
 # In a very few instances there may be graphics (Posters, Banners and/or Fan art) that are available
 # and relevant to a Miro video. These instances consist of Movie Trailers and video casts for TV shows.
 # Recently some Vidcasts have been added to TVDB e.g. "HD Nation".
@@ -374,21 +389,21 @@
 # thetvdb.com
 # In this section:
 #     For TV shows you can specify a Channel name and thetvdb.com reference number. The TV series "Nova"
-#     "Nature" examples have been provided. 
+#     "Nature" examples have been provided.
 #     For movie trailers just the Channel name is required plus the channels movie title delimiter
 #     character.
 #
 # When a Channel has been specified in either the Movie or TV sections Jamu's -MW option will check the
 # relevant source (themoviedb.com or thetvdb.com) for better graphics. If found they will be downloaded
-# and used in place of the lower quality Miro graphics. 
+# and used in place of the lower quality Miro graphics.
 # To utilize this feature the you must run the Jamu option -MW.
 #
 # The examples below are already activated. If you are not using Miro no additional processing happens.
 # The Channel names MUST be exactly as you have specified in
 # your Miro configuration. These examples may not match the Channel names in your Miro configuration.
-# For Movie trailers there will be a maximum of three attempts to find the correct movie. 
-# The first attempt will assume that the movie is to be released in the current year. If there is no 
-# match the second and third attempts will assume the movie will be released in the coming years. 
+# For Movie trailers there will be a maximum of three attempts to find the correct movie.
+# The first attempt will assume that the movie is to be released in the current year. If there is no
+# match the second and third attempts will assume the movie will be released in the coming years.
 #
 # To add more channels the format is always channel title then a ":"
 # Each Channel requires its own line, you cannot have multiple Channels per line.
@@ -400,7 +415,7 @@
 #          The delimeter character for the movie titles from Timo's is a "-"
 #       2) HD-Trailers.net Blog "Surrogates (Trailer 2)"
 #         The delimeter character for the movie titles from HD-Trailer.net is a "("
-# 
+#
 # The TV format is Channel name ":" then thetvdb.com reference number
 [mb_tv]
 # Real TV show equivelents to these Vidcasts
@@ -440,27 +455,27 @@
 # START Secondary sources section--------------------------------------------------------------------
 # NOTE: This section is only active in conjunction with the Mythmetadata (-M) option
 # Purpose:
-# The primary sources of graphics and meta data for Tv Series and Movies are thetvdb.com and 
+# The primary sources of graphics and meta data for Tv Series and Movies are thetvdb.com and
 # themoviedb.com respectively. Sometimes these sources do not have the requested metadata or graphics.
 # This section allows you to add secondary sources when the primary come up empty.
 # Secondary source requirements:
-# 1) A secondary source must have a command line interface such as "fetch_poster.py". 
+# 1) A secondary source must have a command line interface such as "fetch_poster.py".
 # 2) The format of the returned values (through stdout) must match that of the existing grabber
 #    scripts such as tmdb.pl and ttvdb.py.
 # 3) You must specify the fully qualified name of the secondary source (path and filename)
 # 4) You must specify the command line switches that the secondary source requires to get specific data
-# 5) You must specify the dynamic data required by the secondary sources. Dynamic data is from a 
+# 5) You must specify the dynamic data required by the secondary sources. Dynamic data is from a
 #    restricted set specified below.
 #
 # NOTE: The secondary source for meta data (textual data) is used as an attempt to fill in missing
 #       data for a video file. The primary source and the secondary source data is combined
-#       to complete as much information as is available between the two sources. The primary 
+#       to complete as much information as is available between the two sources. The primary
 #       source always takes precedence.
 #
 # Dynamic data:
-# %%(inetref)s      - This can be a thetvdb.com series id, TMDB number, IMDB ...etc. This is equal to 
+# %%(inetref)s      - This can be a thetvdb.com series id, TMDB number, IMDB ...etc. This is equal to
 #                     the mythdb table 'videometadata' field 'inetref'.
-# %%(imdb)s         - Specifies an IMDB number whether or not the inetref is already an IMDB number. 
+# %%(imdb)s         - Specifies an IMDB number whether or not the inetref is already an IMDB number.
 #                     This variable is required as in most cases the inetref will be a TMDB number but
 #                     most secondary sources still require an IMDB number. NOTE: Despite the source
 #                     of the graphics files the naming convention is always "inetref.ext". This value
@@ -471,12 +486,12 @@
 # %%(seasno)d       - This is a TV series season number
 # %%(epno)d    		- This is a TV series episode number
 # %%(filename)s     - This is the video file name as found on your computer
-# %%(filepath)s 	- This is the fully qualified video path (mainly for user scripts) 
-# %%(ext)s 			- This is the video file extention (e.g. "mkv") with no "." 
+# %%(filepath)s 	- This is the fully qualified video path (mainly for user scripts)
+# %%(ext)s 			- This is the video file extention (e.g. "mkv") with no "."
 #
 # The secondary sources are split into a movie section and a TV series section.
 # Tv series are defined as any video file names that contain season and episode numbers.
-# The type of data is specified by the key value. 
+# The type of data is specified by the key value.
 # Valid keys are:
 # poster   - This is also know as a cover art or a cover image
 # fanart
@@ -485,32 +500,31 @@
 # metadate - The video file's text description e.g. plot, director ... etc
 #
 # NOTE: At this time there is no TV Secondary source scripts available unless you write your own.
-#       
+#
 [movies-secondary-sources]
 #poster: /usr/local/share/mythtv/mythvideo/scripts/fetch_poster.py -P %%(imdb)s
-#fanart: 
+#fanart:
 #metadata: /usr/local/share/mythtv/mythvideo/scripts/imdbpy.py -D %%(imdb)s
 
 [tv-secondary-sources]
 #poster:
-#fanart: 
+#fanart:
 #banner:
 #metadata:
 # END   Secondary sources section--------------------------------------------------------------------
 
 # START regex section------------------------------------------------------------------------------
-# NOTE: If you do not understand regex expressions DO NOT USE this section. 
+# NOTE: If you do not understand regex expressions DO NOT USE this section.
 # This section adds to the default regex strings used to parse file names when extracting
 # the following: series name, season number, episode number
 # NOTE: The "% (self.config['valid_filename_chars_regex'])" part of the string is assumed
 # NOTE: ANY % percent sign in the expression must be doubled (e.g. a % must be changed to %% )
 # NOTE: The key value (e.g. "regex01") must be unique for each value.
 # NOTE: DO NOT surround the regex pattern string with the traditional ''' three single quotes
-#       
-[regex] 
+#
+[regex]
 # This is an example video file name "foo_S01_12" where:
 # series name is "foo", season number starts at "S" and episode number starts after '_'
 # foo_S01_12
 #regex01: ^(.+?)[ \._\-][Ss]([0-9]+)_([0-9]+)[^\\/]*$
 # END   regex section------------------------------------------------------------------------------
-
Index: mythplugins/mythvideo/mythvideo/scripts/ttvdb.py
===================================================================
--- mythplugins/mythvideo/mythvideo/scripts/ttvdb.py	(revision 22751)
+++ mythplugins/mythvideo/mythvideo/scripts/ttvdb.py	(working copy)
@@ -99,18 +99,20 @@
 							#              Added a tvdb_api version check and abort if not at least v1.0
 							#              Changed to new tvdb_api's method of assigning the tvdb api key
 							# Version .9.7 Account for TVDB increasing the number of digits in their
-							#              SID number (now greater then 5 
+							#              SID number (now greater then 5
 							#              e,g, "Defying Gravity" is SID 104581)
-							# Version .9.8 Added a (-S) option for requesting a thetvdb  
+							# Version .9.8 Added a (-S) option for requesting a thetvdb
 							#              episode screen shot
 							# Version .9.9 Fixed the -S option when NO episode image exists
-							# Version 1.0. Removed LF and replace with a space for all TVDB metatdata 
+							# Version 1.0. Removed LF and replace with a space for all TVDB metatdata
                             #              fields
-							# Version 1.0.1 Return all graphics (series and season) in the order 
-							#               highest to lowest as rated by users 
-							# Version 1.0.2 Added better error messages to config file checking. Updated to 
+							# Version 1.0.1 Return all graphics (series and season) in the order
+							#               highest to lowest as rated by users
+							# Version 1.0.2 Added better error messages to config file checking. Updated to
 							#				v1.0.2 tvdb_api which contained fixes for concurrent instances
 							#               of ttvdb.py generated by MythVideo.
+# Post MythTV 0.22 release changes (ttvdb.py release numbers will not be changed tracking is by SVN number):
+# Fixed error in the detection of available images when there are only season level images
 
 usage_txt='''
 This script fetches TV series information from theTVdb.com web site. The script conforms to MythTV's
@@ -418,7 +420,7 @@
 
 	This interface will be improved in future versions.
 	Changed in this interface is that a list or URLs is created to preserve the user rating order from
-	top rated to lowest rated. 
+	top rated to lowest rated.
 	"""
 
 	self.log.debug('Getting season banners for %s' % (sid))
@@ -1025,9 +1027,9 @@
 	global SID
 	SID = False
 	if _can_int(series_season_ep[0]): # if it is numeric then assume it is a series ID number
-			SID = True
+		SID = True
 	else:
-			SID = False
+		SID = False
 
 	if opts.debug == True:
 		print "# ..got tvdb mirrors"
@@ -1135,26 +1137,6 @@
 		print "# Checking if Posters, Fanart or Banners are available"
 		print "#"*20
 
-	if opts.configure != "" and override.has_key(series_season_ep[0].lower()):
-		banners_keys = search_for_series(t, override[series_season_ep[0].lower()][0])['_banners'].keys()
-	else:
-		banners_keys = search_for_series(t, series_season_ep[0])['_banners'].keys()
-	banner= False
-	poster= False
-	fanart= False
-
-	for x in banners_keys: # Determine what type of graphics is available
-		if x == fanart_key:
-			fanart=True
-		elif x== poster_key:
-			poster=True
-		elif x==season_key or x==banner_key:
-			banner=True
-
-	# Make sure that some graphics URL(s) (Posters, FanArt or Banners) are available
-	if ( fanart!=True and poster!=True and banner!=True ):
-		sys.exit(True)
-
 	if opts.debug == True:
 		print "#"*20
 		print "# One or more of Posters, Fanart or Banners are available"
@@ -1199,7 +1181,7 @@
 					print u"Banner:%s" % (search_for_series(t, series_name)['banner']).replace(http_find, http_replace)
 		sys.exit(True) # Only the top rated for a TV Series is returned
 
-	if (poster==True and opts.poster==True and opts.raw!=True): # Get posters and send to stdout
+	if (opts.poster==True and opts.raw!=True): # Get posters and send to stdout
 		season_poster_found = False
 		if opts.mythvideo:
 			if len(series_season_ep) < 2:
@@ -1214,13 +1196,14 @@
 				series_name=override[series_season_ep[0].lower()][0] # Override series name
 			else:
 				series_name=series_season_ep[0] # Leave the series name alone
-			print (search_for_series(t, series_name)['poster']).replace(http_find, http_replace)
+			if search_for_series(t, series_name)['poster']:
+				print (search_for_series(t, series_name)['poster']).replace(http_find, http_replace)
 
-	if (fanart==True and opts.fanart==True and opts.raw!=True): # Get Fan Art and send to stdout
+	if (opts.fanart==True and opts.raw!=True): # Get Fan Art and send to stdout
 		for f in get_graphics(t, opts, series_season_ep, fanart_type, single_option, opts.language):
 			print f
 
-	if (banner==True and opts.banner==True and opts.raw!=True): # Get Banners and send to stdout
+	if (opts.banner==True and opts.raw!=True): # Get Banners and send to stdout
 		season_banner_found = False
 		if opts.mythvideo:
 			if len(series_season_ep) < 2:
@@ -1235,7 +1218,7 @@
 				series_name=override[series_season_ep[0].lower()][0] # Override series name
 			else:
 				series_name=series_season_ep[0] # Leave the series name alone
-			if search_for_series(t, series_name)['banner'] != None:
+			if search_for_series(t, series_name)['banner']:
 				print (search_for_series(t, series_name)['banner']).replace(http_find, http_replace)
 
 	if opts.debug == True:
Index: mythplugins/mythvideo/mythvideo/videodlg.cpp
===================================================================
--- mythplugins/mythvideo/mythvideo/videodlg.cpp	(revision 22751)
+++ mythplugins/mythvideo/mythvideo/videodlg.cpp	(working copy)
@@ -4234,7 +4234,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                         QStringList(m_d->m_artDir), cover_file,
                         metadata->GetTitle(), metadata->GetSeason(),
-                        metadata->GetHost(), "Coverart"))
+                        metadata->GetHost(), "Coverart", metadata->GetEpisode()))
         {
             metadata->SetCoverFile(cover_file);
         }
@@ -4253,7 +4253,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                         QStringList(m_d->m_fanDir), fanart_file,
                         metadata->GetTitle(), metadata->GetSeason(),
-                        metadata->GetHost(), "Fanart"))
+                        metadata->GetHost(), "Fanart", metadata->GetEpisode()))
         {
             metadata->SetFanart(fanart_file);
         }
@@ -4262,7 +4262,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                         QStringList(m_d->m_banDir), banner_file,
                         metadata->GetTitle(), metadata->GetSeason(),
-                        metadata->GetHost(), "Banners"))
+                        metadata->GetHost(), "Banners", metadata->GetEpisode()))
         {
             metadata->SetBanner(banner_file);
         }
@@ -4292,7 +4292,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                                 cover_dirs, cover_file, metadata->GetTitle(),
                                 metadata->GetSeason(), metadata->GetHost(),
-                                "Coverart"))
+                                "Coverart", metadata->GetEpisode()))
         {
             metadata->SetCoverFile(cover_file);
             OnVideoImageSetDone(metadata);
@@ -4318,7 +4318,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                                 fanart_dirs, fanart_file, metadata->GetTitle(),
                                 metadata->GetSeason(), metadata->GetHost(),
-                                "Fanart"))
+                                "Fanart", metadata->GetEpisode()))
         {
             metadata->SetFanart(fanart_file);
             OnVideoImageSetDone(metadata);
@@ -4344,7 +4344,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                                 banner_dirs, banner_file, metadata->GetTitle(),
                                 metadata->GetSeason(), metadata->GetHost(),
-                                "Banners"))
+                                "Banners", metadata->GetEpisode()))
         {
             metadata->SetBanner(banner_file);
             OnVideoImageSetDone(metadata);
@@ -4460,6 +4460,20 @@
                 else
                     title = QString("%1 Season %2_%3").arg(metadata->GetTitle())
                             .arg(season).arg(suffix);
+
+                title.remove('?');
+                title.remove('<');
+                title.remove('>');
+                title.remove('/');
+                title.remove('\\');
+                title.remove('|');
+                title.remove('*');
+                title.remove('[');
+                title.remove(']');
+                title.remove(':');
+                title.remove('"');
+                title.remove('^');
+
                 if (!host.isEmpty())
                 {
                     QString combFileName = QString("%1.%2").arg(title)
Index: mythplugins/mythvideo/mythvideo/videolist.cpp
===================================================================
--- mythplugins/mythvideo/mythvideo/videolist.cpp	(revision 22751)
+++ mythplugins/mythvideo/mythvideo/videolist.cpp	(working copy)
@@ -1231,6 +1231,10 @@
     prefix_to_node_map ptnm;
 
     QStringList dirs = GetVideoDirs();
+
+    if (!dirs.size())
+        return;
+
     QString test_prefix(dirs[0]);
 
     meta_dir_node *video_root = &m_metadata_tree;
Index: mythplugins/mythvideo/mythvideo/main.cpp
===================================================================
--- mythplugins/mythvideo/mythvideo/main.cpp	(revision 23433)
+++ mythplugins/mythvideo/mythvideo/main.cpp	(working copy)
@@ -517,6 +517,7 @@
         {
             if (LCD *lcd = LCD::Get())
             {
+                lcd->setFunctionLEDs(FUNC_MOVIE, false);
                 lcd->switchToTime();
             }
             GetMythMainWindow()->GetMainStack()->AddScreen(diag);
Index: mythplugins/mythvideo/mythvideo/playercommand.cpp
===================================================================
--- mythplugins/mythvideo/mythvideo/playercommand.cpp	(revision 23433)
+++ mythplugins/mythvideo/mythvideo/playercommand.cpp	(working copy)
@@ -5,6 +5,7 @@
 #include <mythtv/libmythui/mythmainwindow.h>
 #include <mythtv/libmythui/mythsystem.h>
 #include <mythtv/libmyth/remoteutil.h>
+#include <mythtv/lcddevice.h>
 
 #include "dbaccess.h"
 #include "metadata.h"
@@ -391,11 +392,19 @@
 
 void VideoPlayerCommand::Play() const
 {
+    class LCD *lcd = LCD::Get();
+
+    if (lcd) {
+        lcd->setFunctionLEDs(FUNC_TV, false);
+        lcd->setFunctionLEDs(FUNC_MOVIE, true);
+    }
     m_d->Play();
     gContext->GetMainWindow()->raise();
     gContext->GetMainWindow()->activateWindow();
     if (gContext->GetMainWindow()->currentWidget())
         gContext->GetMainWindow()->currentWidget()->setFocus();
+    if (lcd)
+        lcd->setFunctionLEDs(FUNC_MOVIE, false);
 }
 
 QString VideoPlayerCommand::GetCommandDisplayName() const
Index: mythplugins/mythnews/mythnews/newssite.cpp
===================================================================
--- mythplugins/mythnews/mythnews/newssite.cpp	(revision 22751)
+++ mythplugins/mythnews/mythnews/newssite.cpp	(working copy)
@@ -314,6 +314,7 @@
         QDomNode enclosureNode = itemNode.namedItem("enclosure");
         QString enclosure = QString::null;
         QString enclosure_type = QString::null;
+        QString thumbnail = QString::null;
         if (!enclosureNode.isNull())
         {
             QDomAttr enclosureURL = enclosureNode.toElement()
@@ -324,8 +325,16 @@
 
             QDomAttr enclosureType = enclosureNode.toElement()
                 .attributeNode("type");
-            if (!enclosureType.isNull())
+            if (!enclosureType.isNull()) 
+            {
                 enclosure_type  = enclosureType.value();
+
+                if (enclosure_type == "image/jpeg")
+                {
+                    thumbnail = enclosure;
+                    enclosure = QString::null;
+                }
+            }
         }
 
         //////////////////////////////////////////////////////////////
@@ -341,7 +350,6 @@
             itemNode = mediaGroup;
 
         QDomNode thumbNode = itemNode.namedItem("media:thumbnail");
-        QString thumbnail = QString::null;
         if (!thumbNode.isNull())
         {
             QDomAttr thumburl = thumbNode.toElement().attributeNode("url");
Index: mythplugins/mythnews/mythnews/mythnews.cpp
===================================================================
--- mythplugins/mythnews/mythnews/mythnews.cpp	(revision 22751)
+++ mythplugins/mythnews/mythnews/mythnews.cpp	(working copy)
@@ -103,16 +103,16 @@
     bool err = false;
     UIUtilE::Assign(this, m_sitesList, "siteslist", &err);
     UIUtilE::Assign(this, m_articlesList, "articleslist", &err);
-
-    UIUtilW::Assign(this, m_nositesText, "nosites", &err);
-    UIUtilE::Assign(this, m_updatedText, "updated", &err);
     UIUtilE::Assign(this, m_titleText, "title", &err);
     UIUtilE::Assign(this, m_descText, "description", &err);
 
-    UIUtilE::Assign(this, m_thumbnailImage, "thumbnail", &err);
-    UIUtilE::Assign(this, m_enclosureImage, "enclosures", &err);
-    UIUtilE::Assign(this, m_downloadImage, "download", &err);
-    UIUtilE::Assign(this, m_podcastImage, "ispodcast", &err);
+    // these are all optional
+    UIUtilW::Assign(this, m_nositesText, "nosites", &err);
+    UIUtilW::Assign(this, m_updatedText, "updated", &err);
+    UIUtilW::Assign(this, m_thumbnailImage, "thumbnail", &err);
+    UIUtilW::Assign(this, m_enclosureImage, "enclosures", &err);
+    UIUtilW::Assign(this, m_downloadImage, "download", &err);
+    UIUtilW::Assign(this, m_podcastImage, "ispodcast", &err);
 
     if (err)
     {
@@ -156,12 +156,19 @@
 
     m_titleText->SetText("");
     m_descText->SetText("");
+
     if (m_updatedText)
         m_updatedText->SetText("");
 
-    m_downloadImage->Hide();
-    m_enclosureImage->Hide();
-    m_podcastImage->Hide();
+    if (m_downloadImage)
+        m_downloadImage->Hide();
+
+    if (m_enclosureImage)
+        m_enclosureImage->Hide();
+
+    if (m_podcastImage)
+        m_podcastImage->Hide();
+
     if (m_thumbnailImage)
         m_thumbnailImage->Hide();
 }
@@ -315,6 +322,9 @@
             }
             else
             {
+                if (m_thumbnailImage)
+                    m_thumbnailImage->Hide();
+
                 if (!site->imageURL().isEmpty())
                 {
                     QString fileprefix = GetConfDir();
@@ -352,31 +362,43 @@
                 }
             }
 
-            if (!article.enclosure().isEmpty())
+            if (m_downloadImage)
             {
-                if (!m_downloadImage->IsVisible())
-                    m_downloadImage->Show();
+                if (!article.enclosure().isEmpty())
+                {
+                    if (!m_downloadImage->IsVisible())
+                        m_downloadImage->Show();
+                }
+                else
+                    m_downloadImage->Hide();
             }
-            else
-                m_downloadImage->Hide();
 
-            if (!article.enclosure().isEmpty())
+            if (m_enclosureImage)
             {
-                if (!m_enclosureImage->IsVisible())
-                    m_enclosureImage->Show();
+                if (!article.enclosure().isEmpty())
+                {
+                    if (!m_enclosureImage->IsVisible())
+                        m_enclosureImage->Show();
+                }
+                else
+                    m_enclosureImage->Hide();
             }
-            else
-                m_enclosureImage->Hide();
 
-            m_podcastImage->Hide();
+            if (m_podcastImage)
+                m_podcastImage->Hide();
         }
     }
     else
     {
-        m_downloadImage->Hide();
-        m_enclosureImage->Hide();
-        m_podcastImage->Hide();
+        if (m_downloadImage)
+            m_downloadImage->Hide();
 
+        if (m_enclosureImage)
+            m_enclosureImage->Hide();
+
+        if (m_podcastImage)
+            m_podcastImage->Hide();
+
         if (site)
         {
             if (m_titleText)
@@ -388,7 +410,7 @@
             if (m_thumbnailImage && m_thumbnailImage->IsVisible())
                 m_thumbnailImage->Hide();
 
-            if (site->podcast() == 1)
+            if (m_podcastImage && site->podcast() == 1)
                 m_podcastImage->Show();
 
             if (!site->imageURL().isEmpty())
@@ -715,7 +737,8 @@
                         .arg(formatSize(progress, 2))
                         .arg(formatSize(total, 2))
                         .arg(floor(fProgress*100));
-                m_updatedText->SetText(text);
+                if (m_updatedText)
+                    m_updatedText->SetText(text);
             }
             qApp->processEvents();
             usleep(100000);
Index: mythplugins/mythmusic/mythmusic/main.cpp
===================================================================
--- mythplugins/mythmusic/mythmusic/main.cpp	(revision 23433)
+++ mythplugins/mythmusic/mythmusic/main.cpp	(working copy)
@@ -21,6 +21,7 @@
 #include <mythtv/compat.h>
 #include <mythtv/libmythui/mythuihelper.h>
 #include <mythtv/libmythui/mythprogressdialog.h>
+#include <mythtv/lcddevice.h>
 
 // MythMusic headers
 #include "decoder.h"
@@ -527,6 +528,11 @@
     gMusicData->startdir = startdir;
     gMusicData->all_playlists = all_playlists;
     gMusicData->all_music = all_music;
+
+    if (LCD *lcd = LCD::Get())
+    {
+        lcd->setFunctionLEDs(FUNC_MUSIC, true);
+    }
 }
 
 static void postMusic()
@@ -548,6 +554,11 @@
     gMusicData->all_music = NULL;
     delete gMusicData->all_playlists;
     gMusicData->all_playlists = NULL;
+
+    if (LCD *lcd = LCD::Get())
+    {
+        lcd->setFunctionLEDs(FUNC_MUSIC, false);
+    }
 }
 
 int mythplugin_run(void)
Index: mythplugins/mythgallery/mythgallery/imageview.cpp
===================================================================
--- mythplugins/mythgallery/mythgallery/imageview.cpp	(revision 23433)
+++ mythplugins/mythgallery/mythgallery/imageview.cpp	(working copy)
@@ -152,9 +152,11 @@
 
     if (!item)
     {
+        lcd->setFunctionLEDs(FUNC_PHOTO, false);
         lcd->switchToTime();
         return;
     }
+    lcd->setFunctionLEDs(FUNC_PHOTO, true);
 
     QString name = item->GetName();
     QString desc = QString::number(m_pos + 1) + " / " +
