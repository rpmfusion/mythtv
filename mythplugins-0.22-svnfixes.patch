Index: mythplugins/mythvideo/mythvideo/scripts/jamu.py
===================================================================
--- mythplugins/mythvideo/mythvideo/scripts/jamu.py	(revision 22751)
+++ mythplugins/mythvideo/mythvideo/scripts/jamu.py	(working copy)
@@ -1,32 +1,32 @@
-#!/usr/bin/env python 
+#!/usr/bin/env python
 # -*- coding: UTF-8 -*-
 # ----------------------
 # Name: jamu.py      Just.Another.Metadata.Utility
 # Python Script
 # Author: 	R.D. Vaughan
-# Purpose: 	This python script is intended to perform a variety of utility functions on mythvideo 
+# Purpose: 	This python script is intended to perform a variety of utility functions on mythvideo
 #           metadata and the associated video files.
 #
 #           The primary movie source for graphics and data is themoviedb.com wiki.
 #           The primary TV Series source for graphics and data is thetvdb.com wiki.
-#			Users of this script are encouraged to populate both themoviedb.com and thetvdb.com 
+#			Users of this script are encouraged to populate both themoviedb.com and thetvdb.com
 #           with posters, fan art and banners and meta data. The richer the source the more valuable
 #           the script.
-#			This script uses the python module tvdb_api.py (v0.6DEV or higher) found at 
-#			http://pypi.python.org/pypi?%3Aaction=search&term=tvnamer&submit=search thanks 
+#			This script uses the python module tvdb_api.py (v0.6DEV or higher) found at
+#			http://pypi.python.org/pypi?%3Aaction=search&term=tvnamer&submit=search thanks
 #			to the authors of this excellent module.
 #			The tvdb_api.py module uses the full access XML api published by thetvdb.com see:
 #			http://thetvdb.com/wiki/index.php?title=Programmers_API
 #			This python script's functionality is enhanced if you have installed "tvnamer.py" created by
-#           "dbr/Ben" who is also the author of the "tvdb_api.py" module. 
-#           "tvnamer.py" is used to rename avi files with series/episode information found at 
+#           "dbr/Ben" who is also the author of the "tvdb_api.py" module.
+#           "tvnamer.py" is used to rename avi files with series/episode information found at
 #           thetvdb.com
-#           Python access to the tmdb api started with a module from dbr/Ben and then enhanced for 
+#           Python access to the tmdb api started with a module from dbr/Ben and then enhanced for
 #           Jamu's needs.
 #           The routines to select video files was copied and modified from tvnamer.py mentioned above.
-#			The routine "_save_video_metadata_to_mythdb" has been taken and modified from 
+#			The routine "_save_video_metadata_to_mythdb" has been taken and modified from
 #			"find_meta.py" author Pekka Jääskeläinen.
-#           The routine "_addCastGenre" was taken and modified from "tvdb-bulk-update.py" by 
+#           The routine "_addCastGenre" was taken and modified from "tvdb-bulk-update.py" by
 #           author David Shilvock <davels@telus.net>.
 #
 # Command line examples:
@@ -38,28 +38,28 @@
 __title__ ="JAMU - Just.Another.Metadata.Utility";
 __author__="R.D.Vaughan"
 __purpose__='''
-This python script is intended to perform a variety of utility functions on mythvideo metadata 
+This python script is intended to perform a variety of utility functions on mythvideo metadata
 and the associated video files.
 
 The primary movie source for graphics and data is themoviedb.com wiki.
 The primary TV Series source for graphics and data is thetvdb.com wiki.
-Users of this script are encouraged to populate both themoviedb.com and thetvdb.com with posters, 
+Users of this script are encouraged to populate both themoviedb.com and thetvdb.com with posters,
 fan art and banners and meta data. The richer the source the more valuable the script.
 '''
 
-__version__=u"v0.5.5" 
- # 0.1.0 Initial development 
+__version__=u"v0.5.9"
+ # 0.1.0 Initial development
  # 0.2.0 Inital beta release
  # 0.3.0 Add mythvideo metadata updating including movie graphics through
  #       the use of tmdb.pl when the perl script exists
- # 0.3.1 Add mythvideo meta data add and update functionality. Intend use for 
- #       maintenance cron jobs. 
+ # 0.3.1 Add mythvideo meta data add and update functionality. Intend use for
+ #       maintenance cron jobs.
  #       Increase integration with mythtvideo download meta data and MythUI
  #       Added the ability to movie video files while maintaining the metadata
- # 0.3.2 Fixed bug where some poster downloads were unnecessary 
- #       Fixed bug where the mythtv database was updated for no reason 
- #       Fixed bug in jamu-example.conf "min_poster_size" variable had '=' not ':' 
- #       Fixed bug where a unicode URL would abort the script 
+ # 0.3.2 Fixed bug where some poster downloads were unnecessary
+ #       Fixed bug where the mythtv database was updated for no reason
+ #       Fixed bug in jamu-example.conf "min_poster_size" variable had '=' not ':'
+ #       Fixed bug where a unicode URL would abort the script
  #       Using ffmpeg added setting accurate video length in minutes. A hack but
  #       lacked python method to find audio/video properties.
  # 0.3.3 Add logic to skip any video with a inetref of '99999999'. Meta data and
@@ -69,24 +69,24 @@
  # 0.3.4 Added logic to skip any secondary source meta data plot less than 10 words.
  #       Properly initialized a new record so warning messages do not display.
  #       In plot meta data replace line-feeds with a space (e.g. Space Cowboys
- #       plot contains line-feeds). Mythvideo does not expect line-feeds in a plot. 
- #       Significant improvements in combining meta data between primary and 
+ #       plot contains line-feeds). Mythvideo does not expect line-feeds in a plot.
+ #       Significant improvements in combining meta data between primary and
  #       secondary data sources.
  #       Remove 'tmdb.pl' calls and use the tmdb api directly.
  #       Added detection of broken symbolic links and fixed those links.
- #       Fixed inconsistencies in graphics file extentions (as received from the 
- #       sources), made all extentions lowercase and changed ".jpeg" to ".jpg". 
+ #       Fixed inconsistencies in graphics file extentions (as received from the
+ #       sources), made all extentions lowercase and changed ".jpeg" to ".jpg".
  # 0.3.5 Fixed bug when themoviedb.com times out from an api request.
- #       A few documentation corrections. 
- #       Fixed a bug with utf8 directory names. 
+ #       A few documentation corrections.
+ #       Fixed a bug with utf8 directory names.
  #       Added code to not abort script when themoviedb.com has problems. The issue
- #       is reported but the scripts continues processing. 
+ #       is reported but the scripts continues processing.
  #       Added option "-W" to download graphics for Scheduled and Recorded videos.
  #       Change the "-J" Janitor function to avoid deleting graphics for Scheduled
  #		 and Recorded videos.
- #       Fixed bug where a TMDB Poster image was not found when it was really 
+ #       Fixed bug where a TMDB Poster image was not found when it was really
  #       available.
- # 0.3.6 Fixed bug when searching themoviedb.com for a movie by title or 
+ # 0.3.6 Fixed bug when searching themoviedb.com for a movie by title or
  #       alternate title.
  #       Increased accuracy of non-interactive TMDB movie searching and matching.
  #       Set up for transition to TMDB's beta v2.1 api which adds language support.
@@ -94,21 +94,21 @@
  #       If interactive mode is selected but an exact match is found for a movie
  #       then the exact match is chosen and no interative session is initiated.
  #       Added additional messages when access to MythTV python bindings has issues.
- # 0.3.7 Removed some redundant code. 
+ # 0.3.7 Removed some redundant code.
  #       Sync up with v1.0 of tvdb_api and new way to assign tvdb api key
  #       Added an option (-MG) to allow Jamu best guessing at a video's inetref
  #		 number. To guess accurately the video file name must be very close to
- #		 those found on tmdb or imdb and tvdb web sites. 
+ #		 those found on tmdb or imdb and tvdb web sites.
  #       Remove all use of the MythVideo.py "pruneMetadata" routine as it deletes
  #       records from the Mythvideo table for all video files with relative file
  #		 paths.
- #       Jamu will skip processing any videometadata which is using a Storage group. 						 
+ #       Jamu will skip processing any videometadata which is using a Storage group.
  #       Jamu will now restrict itself to updating only videometadata records whose
- #       video files reside on the current host machine. In the case where a user 
+ #       video files reside on the current host machine. In the case where a user
  #       has multiple backends jamu must run on each of those backends.
- #       The Janitor option (-MJ) now checks if the users has set the plugins 
+ #       The Janitor option (-MJ) now checks if the users has set the plugins
  #       MythGallery, MythGame and MythMusic to use the same graphics directories as
- #       MythVideo. If they share directories the Janitor option will exit 
+ #       MythVideo. If they share directories the Janitor option will exit
  #       without removing any graphics files. Messages indicating which directories
  #       are in conflict will be displayed.
  #       Added the detection of video or graphics on an NFS mount exiting jamu without
@@ -118,16 +118,16 @@
  #       Fixed a bug when TMDB does not have a 'year' for a movie (e.g. 'Bambi')
  #		 Added compatibility with or without the MythTV.py Ticket #6678
  #       Fixed a bug when ffmpeg cannot find the true length in minutes of a video
- #       Cleaned up documenation consistency with Warning and Error messages. 
- #       Added to the existing TV episode video file renaming (-MF) option. 
- #       Now movie video files can also be renamed to the format "title (year)" 
+ #       Cleaned up documenation consistency with Warning and Error messages.
+ #       Added to the existing TV episode video file renaming (-MF) option.
+ #       Now movie video files can also be renamed to the format "title (year)"
  #       e.g. "The Duchess (2008)". If tmdb.com has no year for the movie then only
  #		 the movie title will be used when renaming. Any existing metadata is
  #		 preserved.
- # 0.3.8 Made changes to sync up with MythTV trunk change set [r21138]. 
+ # 0.3.8 Made changes to sync up with MythTV trunk change set [r21138].
  #       Now handles TVDB's change from a 5 digit inetref number to 6 digits.
  # 0.3.9 Check accessability (Read and Write) to directories and files before
- #       including them in files/directories to process. 
+ #       including them in files/directories to process.
  #       Add the ability to process Storage Groups for all Videos and graphics.
  #       Jamu now uses MythVideo.py binding's Genre and Cast routines
  #       Fixed a unicode bug with file paths.
@@ -135,28 +135,28 @@
  #		 Fixed a bug were a bad image file could avbort the script.
  #		 Changed all subdirectory cover art to a copied graphic file "folder.jpg/png"
  #		 to conform to the Storage Group standard. This also works for local subdirs.
- #       Fixed a bug where a TV series with out a season specific poster or 
- #		 banner would get repeatedly download. 
+ #       Fixed a bug where a TV series with out a season specific poster or
+ #		 banner would get repeatedly download.
  # 0.4.0 Removed a few lines of debugging code which should never have been left in a
  #       distrubuted version.
  #		 Fixed the check that confirms that all Video and graphic directories are
  #       read and writable.
  #		 Fixed a bug where under rare circumstances a graphic would be repeatedly
- #		 downloaded.  
+ #		 downloaded.
  #		 Made the installation of the python IMDbPy library manditory.
- #       For all movies IMDB numbers will be used instead of converting to TMDB 
+ #       For all movies IMDB numbers will be used instead of converting to TMDB
  #       numbers. This is done to maintain consistency with MythVideo movie inetref
  #       numbers.
  # 0.4.1 Fixed an obscure video file rename (-F option) error
- # 0.4.2 Fixed a bug where bad data for either TMDB or TVDB would abort script 
- # 0.4.3 Recent changes in the MythVideo UI graphic hunts (cover art and fanart) 
- #       have made Jamu's creation of "folder.xxx" graphics redundant. This 
- #       feature has been turned off in Jamu. There is a new user option 
- #       "folderart" that can reactivate this feature through the Jamu 
+ # 0.4.2 Fixed a bug where bad data for either TMDB or TVDB would abort script
+ # 0.4.3 Recent changes in the MythVideo UI graphic hunts (cover art and fanart)
+ #       have made Jamu's creation of "folder.xxx" graphics redundant. This
+ #       feature has been turned off in Jamu. There is a new user option
+ #       "folderart" that can reactivate this feature through the Jamu
  #       configuration file.
  # 0.4.4 Changes to assist SG image hunting Jamu now adds the suffix "_coverart,
  #       _fanart, _banner, _screenshot" respectively to downloaded graphics.
- #       With the use of a graphic suffix the requirement for unique graphics 
+ #       With the use of a graphic suffix the requirement for unique graphics
  #       directories is gone. The check has been removed.
  # 0.4.5 Fixed a bug where lowercase tv video filenames caused graphics files to
  #       also be lowercase which can cause graphics to be downloaded twice.
@@ -166,16 +166,16 @@
  # 0.4.7 Fixed a bug where a 'recordedprogram' record is not properly paired with a
  #       'recorded' record. This results in no "airdate" information being available
  #       and a script abort. An airdate year of u'0000' will be assumed.
- #       Fix an abort bug when IMDB is having service problems and a list of 
+ #       Fix an abort bug when IMDB is having service problems and a list of
  #       movies cannot be retrieved.
- # 0.4.8 Fixed a bug in a -MJ option check that removing graphics would not 
+ # 0.4.8 Fixed a bug in a -MJ option check that removing graphics would not
  #       conflict with graphic directories for non-Mythvideo plugins.
  # 0.4.9 Combine the video file extentions found in the "videotypes" table with those
- #       in Jamu to avoid possible issues in the (-MJ) option and to have tighter 
- #       integration with MythVideo user file extention settings. 
+ #       in Jamu to avoid possible issues in the (-MJ) option and to have tighter
+ #       integration with MythVideo user file extention settings.
  # 0.5.0 Fixed a bug where a filename containing invalid characters caused an abort.
  #       Such invalid filenames are now skipped with an appropriate message.
- #       Added to the -MW option the fetching of graphics from TVDB and TMDB for 
+ #       Added to the -MW option the fetching of graphics from TVDB and TMDB for
  #       videos added by Miro Bridge to either Watched Recordings or MythVideo.
  #       If Miro Bridge is not being used no additional processing is performed.
  #       Two new sections ([mb_tv] and [mb_movies]) were added to the Jamu
@@ -191,32 +191,45 @@
  #       Fixed an abort where a TVDB TV series exists for a language but does not
  #       have a series name in other languages.
  # 0.5.1 Fixed an abort when a user specifies secondary source input parameters
- #       that cannot be parsed from the file name. This 
- #       covers secondary sources for metadata and graphics. 
+ #       that cannot be parsed from the file name. This
+ #       covers secondary sources for metadata and graphics.
  #       Fixed an abort when thetvdb.com cannot be contact due to network or
  #       site issues.
  #       Added detection of erroneous graphics file downloads that are actually HTML
  #       due to source Web site issues. Jamu's (-MJ) janitor option also detects,
  #       deletes these files and repairs the MythVideo record if necessary.
  #       For the -MW option any downloaded graphics names will use the title of the
- #       recorded program instead of that found on sources like TVDB and TMDB. This 
- #       resolves Watch Recordings image hunt issues when Schedule Direct uses a 
+ #       recorded program instead of that found on sources like TVDB and TMDB. This
+ #       resolves Watch Recordings image hunt issues when Schedule Direct uses a
  #       different program title then is on either TVDB or TMDB.
- #       Fixed an obscure bug where TVDB returns empty graphics URLs along with 
+ #       Fixed an obscure bug where TVDB returns empty graphics URLs along with
  #       proper URLs. The empty URLs are now ignored.
  #       Fixed a bug when a language was specified and there were no graphics
- #       for the specified language none were returned/downloaded. This even when 
+ #       for the specified language none were returned/downloaded. This even when
  #       graphics for other languages were available. Now if there are no selected
- #       language graphics English graphics are the fall back and if there are no 
+ #       language graphics English graphics are the fall back and if there are no
  #       English graphics then any available graphics will be returned.
- # 0.5.2 Fixed an abort when trying to add a storage group graphics without a 
- #       proper file path.  
+ # 0.5.2 Fixed an abort when trying to add a storage group graphics without a
+ #       proper file path.
  # 0.5.3 Fixed a bug where the filemarkup table is not cleaned up if Jamu renames
  #       a Miro movie trailer video file that the user wants to keep in MythVideo.
- #       Fixed a bug with Miro video file renaming of Miro Movie trailers 
+ #       Fixed a bug with Miro video file renaming of Miro Movie trailers
  #       for the same movie but which had different file extentions.
  # 0.5.4 Conform to changeset 22104 setting of SG graphics directories to default to SG Videos if not configured.
- # 0.5.5 Deal with TV Series and Movie titles with a "/" forward slash in their name e.g. "Face/Off" 
+ # 0.5.5 Deal with TV Series and Movie titles with a "/" forward slash in their name e.g. "Face/Off"
+ # 0.5.6 Correct an issue when a user has a mixture of local and SG video records in MythVideo. Jamu was
+ #		 adding a hostname when the video had an absolute path. This caused issues with playback.
+ #		 Added more informative error messages when TMDB is returning bad xml responses.
+ #		 Fixed an error in the graphic file naming convention when graphics share the same download directory.
+ # 0.5.7 Remove the override of the TVDB graphics URL to the mirror site. See Kobe's comment:
+ #       http://forums.thetvdb.com/viewtopic.php?f=4&t=2161#p9089
+ # 0.5.8 The issue fixed in v0.5.5 with invalid file name creation did not fully cover TV shows It does now.
+ # 0.5.9 Changed permissions checks on video directories to only require RW for the destination directories
+ #		 involved in the move. With this change if a user requested a file rename (-F) option and the video
+ #		 file does not have RW access the rename will be ignored.
+ #		 Uses that have their Video directories set to access and read-only can now use Jamu.
+ #       Added a stdout display of the directories that Jamu will use for processing. This information may help
+ #       users resolve issues. The display happens ONLY when the -V (verbose) option is used.
 
 
 usage_txt=u'''
@@ -226,12 +239,12 @@
 Here are the main uses for this utility:
 MythTV users should review the Jamu wiki page at http://www.mythtv.org/wiki/Jamu for details.
 
-1) Simple command line invocation to display or download data from thetvdb.com. 
-   Data can be one or more of: Posters/Cover art, Banners, Fan art, 
-   Episode Images and Episode meta data. use the command "jamu -e | less" to see 
+1) Simple command line invocation to display or download data from thetvdb.com.
+   Data can be one or more of: Posters/Cover art, Banners, Fan art,
+   Episode Images and Episode meta data. use the command "jamu -e | less" to see
    command line examples.
 2) Mass downloads of data matching your video files. **
-   This typically done once to download the information for your video collection. 
+   This typically done once to download the information for your video collection.
 3) Automated maintenance of the information in your video collection. **
 4) The creation of video file names which can be used to set the file name of your recorded TV shows.
    File names can be formated to the users preference with information like series name, season number,
@@ -251,10 +264,10 @@
 These examples are primarily for non-MythTV users of Jamu.
 
 jamu command line examples:
-NOTE: Included here are simple examples of jamu in action. 
+NOTE: Included here are simple examples of jamu in action.
       Please review jamu_README for advise on how to get the most out of jamu.
 
-( Display a TV series top rated poster fanart and banner URLs) 
+( Display a TV series top rated poster fanart and banner URLs)
 > jamu -tS PBF "Sanctuary"
 poster:http://www.thetvdb.com/banners/posters/80159-1.jpg
 fanart:http://www.thetvdb.com/banners/fanart/original/80159-2.jpg
@@ -307,8 +320,8 @@
 episodenumber:3
 episodename:Day 5: 9:00 A.M.-10:00 A.M.
 rating:None
-overview:Jack conceals himself inside the airport hanger and surveys the Russian separatists, feeding information to Curtis and his assault team. 
-The terrorists begin executing hostages in an attempt to make Logan cave into their demands. 
+overview:Jack conceals himself inside the airport hanger and surveys the Russian separatists, feeding information to Curtis and his assault team.
+The terrorists begin executing hostages in an attempt to make Logan cave into their demands.
 Martha discovers that all traces of her conversation with Palmer may not have been erased.
 director:Brad Turner
 writer:Manny Coto
@@ -390,7 +403,7 @@
 	import xml
 except Exception:
 	print '''The python module xml must be installed.'''
-	sys.exit(False)
+	sys.exit(1)
 if xml.__version__ < u'41660':
 	print '''
 \n! Warning - The module xml (v41660 or greater) must be installed. Your version is different (v%s) than what Jamu was tested with. Jamu may not work on your installation.\nIt is recommended that you upgrade.\n''' % xml.__version__
@@ -401,7 +414,7 @@
 except Exception:
 	print '''
 The module MySQLdb (v1.2.2 or greater) must be installed.'''
-	sys.exit(False)
+	sys.exit(1)
 if MySQLdb.__version__ < u'1.2.2':
 	print '''
 \n! Warning - The module MySQLdb (v1.2.2 or greater) must be installed. Your version is different (v%s) than what Jamu was tested with. Jamu may not work on your installation.\nIt is recommended that you upgrade.\n''' % MySQLdb.__version__
@@ -413,19 +426,26 @@
 	get the directories to store poster, fanart, banner and episode graphics.
 	'''
 	from MythTV import MythDB, MythVideo, MythTV
+	mythdb = None
+	mythvideo = None
+	mythtv = None
 	try:
 		'''Create an instance of each: MythTV, MythVideo and MythDB
 		'''
 		mythdb = MythDB()
 		mythvideo = MythVideo()
 		mythtv = MythTV()
+	except MythError, e:
+		print u'\n! Warning - %s' % e.message
+		filename = os.path.expanduser("~")+'/.mythtv/config.xml'
+		if not os.path.isfile(filename):
+			print u'\n! Warning - A correctly configured (%s) file must exist\n' % filename
+		else:
+			print u'\n! Warning - Check that (%s) is correctly configured\n' % filename
 	except Exception:
-		print "\n! Warning - Creating an instance caused and error for one of: MythTV, MythVideo or MythDB\n"
-		mythdb = None
-		mythvideo = None
-		mythtv = None
+		print u"\n! Warning - Creating an instance caused an error for one of: MythTV, MythVideo or MythDB\n"
 except Exception:
-	print "\n! Warning - MythTV python bindings could not be imported\n"
+	print u"\n! Warning - MythTV python bindings could not be imported\n"
 	mythdb = None
 	mythvideo = None
 	mythtv = None
@@ -448,25 +468,25 @@
 The modules tvdb_api.py (v1.0.0 or greater), tvdb_ui.py, tvdb_exceptions.py and cache.py must be
 in the same directory as ttvdb.py. They should have been included with the distribution of ttvdb.py.
 '''
-	sys.exit(False)
+	sys.exit(1)
 
-imdb_lib = True		
+imdb_lib = True
 try:			# Check if the installation is equiped to directly search IMDB for movies
 	import imdb
 except ImportError:
 	sys.stderr.write("\n! Error: To search for movies movies the IMDbPy library must be installed."\
 		"Check your installation's repository or check the following link."\
 		"from (http://imdbpy.sourceforge.net/?page=download)\n")
-	sys.exit(False)
+	sys.exit(1)
 
 if imdb_lib:
 	if imdb.__version__ < "3.8":
 		sys.stderr.write("\n! Error: You version the IMDbPy library (%s) is too old. You must use version 3.8 of higher." % imdb.__version__)
 		sys.stderr.write("Check your installation's repository or check the following link."\
 			"from (http://imdbpy.sourceforge.net/?page=download)\n")
-		sys.exit(False)
-		
-		
+		sys.exit(1)
+
+
 def isValidPosixFilename(name, NAME_MAX=255):
     """Checks for a valid POSIX filename
 
@@ -484,7 +504,7 @@
               _POSIX_NAME_MAX: Maximum number of bytes in a filename
                                (not including terminating null).
                                Value: 14
-                               
+
     More information on http://www.opengroup.org/onlinepubs/009695399/toc.htm
     """
     return 1<=len(name)<= NAME_MAX and "/" not in name and "\000" not in name
@@ -492,7 +512,7 @@
 
 
 def sanitiseFileName(name):
-	'''Take a file name and change it so that invalid or problematic characters are substituted with a "_" 
+	'''Take a file name and change it so that invalid or problematic characters are substituted with a "_"
 	return a sanitised valid file name
 	'''
 	if name == None or name == u'':
@@ -531,7 +551,7 @@
 
 def _getFileList(dst):
 	''' Create an array of fully qualified file names
-	return an array of file names 
+	return an array of file names
 	'''
 	file_list = []
 	names = []
@@ -556,7 +576,7 @@
 		else:
 			file_list.append(video_file)
 	return file_list
-# end _getFileList	
+# end _getFileList
 
 
 # Global variables
@@ -588,17 +608,24 @@
 		record = {}
 		i = 0
 		for elem in data_id:
-			if table_names[i] == 'groupname' or table_names[i] == 'hostname' or table_names[i] == 'dirname': 
+			if table_names[i] == 'groupname' or table_names[i] == 'hostname' or table_names[i] == 'dirname':
 				record[table_names[i]] = elem
 			i+=1
 		# Skip any storage group that does not belong to the local host
 		# Only include Video, coverfile, banner, fanart, screenshot and trailers storage groups
 		if record['hostname'].lower() == localhostname.lower() and record['groupname'] in storagegroupnames.keys():
+			try:
+				dirname = unicode(record['dirname'], 'utf8')
+			except (UnicodeDecodeError):
+				sys.stderr.write(u"\n! Error: The local Storage group (%s) directory contained\ncharacters that caused a UnicodeDecodeError. This storage group has been rejected.'\n" % (record['groupname']))
+				continue	# Skip any line that has non-utf8 characters in it
+			except (UnicodeEncodeError, TypeError):
+				pass
 			# Strip the trailing slash so it is consistent with all other directory paths in Jamu
-			if record['dirname'][-1:] == '/': 
-				storagegroups[storagegroupnames[record['groupname']]].append(record['dirname'][:-1])
+			if dirname[-1:] == u'/':
+				storagegroups[storagegroupnames[record['groupname']]].append(dirname[:-1])
 			else:
-				storagegroups[storagegroupnames[record['groupname']]].append(record['dirname'])
+				storagegroups[storagegroupnames[record['groupname']]].append(dirname)
 		continue
 	cur.close()
 
@@ -617,24 +644,24 @@
 		storagegroup_ok = True
 		for key in storagegroups.keys():
 			for directory in storagegroups[key]:
-				if not os.access(directory, os.F_OK | os.R_OK | os.W_OK):
-					sys.stderr.write(u"\n! Error: The local Storage group (%s) directory (%s) does not exist or there is a permissions restriction\n" % (key, directory))
+				if not os.access(directory, os.F_OK):
+					sys.stderr.write(u"\n! Error: The local Storage group (%s) directory (%s) does not exist\n" % (key, directory))
 					storagegroup_ok = False
 		if not storagegroup_ok:
-			sys.exit(False)
+			sys.exit(1)
 # end getStorageGroups
 
 # Start of code used to access themoviedb.com api
-class TmdBaseError(Exception): 
+class TmdBaseError(Exception):
 	pass
 
-class TmdHttpError(TmdBaseError): 
-	def __repr__(self):	# Display the type of error 
+class TmdHttpError(TmdBaseError):
+	def __repr__(self):	# Display the type of error
 		print u"TMDB Http Error"
 		return None
 	# end __repr__
 
-class TmdXmlError(TmdBaseError): 
+class TmdXmlError(TmdBaseError):
 	def __repr__(self):	# Display the type of error
 		print u"TMDB XML Error"
 		return None
@@ -698,12 +725,12 @@
 	def set(self, poster_et):
 		"""Takes an elementtree Element ('poster') and stores the poster,
 		using the size as the dict key.
-        
+
 		For example:
 		<backdrop size="original">
 			http://example.com/poster_original.jpg
 		</backdrop>
-        
+
 		..becomes:
 		poster['original'] = 'http://example.com/poster_original.jpg'
 		"""
@@ -738,14 +765,14 @@
 	def set(self, people_et):
 		"""Takes an element tree Element ('people') and stores a dictionary of roles,
 		for each person.
-        
+
 		For example:
 		<person job="director">
 			<name>Robert Rodriguez</name>
 			<role/>
 			<url>http://www.themoviedb.org/person/2294</url>
 		</person>
-        
+
 		..becomes:
 		self['people']['director'] = 'Robert Rodriguez'
 		"""
@@ -768,7 +795,7 @@
 
 class MovieDb:
 	"""Main interface to www.themoviedb.com
-    
+
 	The search() method searches for the film by title.
 	"""
 	# Local Variables
@@ -803,7 +830,7 @@
 				http://www.themoviedb.org/encyclopedia/category/6033
 			</url>
 		</category>
-        
+
 		..becomes:
 		'Literary Fiction'
 		"""
@@ -826,12 +853,12 @@
 		return comma seperated sting of film category names
 
 		For example:
-		<production_countries> 
-			<country> 
-				<name>United States of America</name> 
-				<url>http://www.../country/223</url> 
-			</country> 
-		</production_countries>        
+		<production_countries>
+			<country>
+				<name>United States of America</name>
+				<url>http://www.../country/223</url>
+			</country>
+		</production_countries>
 		..becomes:
 		'United States of America'
 		"""
@@ -904,8 +931,8 @@
 					continue
 			if key == u'imdb':
 				translated[key] = cur_movie[key][2:]
-				continue				
-			if key == u'release': 
+				continue
+			if key == u'release':
 				translated[u'year'] = cur_movie[key][:4]
 			if self.tmdb_config[u'translation'].has_key(key):
 				translated[self.tmdb_config[u'translation'][key]] = cur_movie[key]
@@ -930,7 +957,7 @@
 
 	def searchTMDB(self, by_id, graphics=False, lang=u'en'):
 		"""Searches for a film by its TMDB id number.
-		Returns a movie data dictionary 
+		Returns a movie data dictionary
 		"""
 		id_url = urllib.quote(by_id.encode("utf-8"))
 		url = self.tmdb_config[u'urls'][u'tmdbid.search'] % (id_url)
@@ -946,12 +973,11 @@
 
    	def searchIMDB(self, by_id, graphics=False, lang=u'en'):
 		"""Searches for a film by its IMDB number.
-		Returns a movie data dictionary 
+		Returns a movie data dictionary
 		"""
 		id_url = urllib.quote(by_id.encode("utf-8"))
 		url = self.tmdb_config[u'urls'][u'imdb.search'] % (id_url)
 		etree = XmlHandler(url).getEt()
-
 		if self._parseMovie(etree.find(u"moviematches").find(u"movie")).has_key(u'inetref'):
 			return self.searchTMDB(self._parseMovie(etree.find(u"moviematches").find(u"movie"))[u'inetref'], graphics=graphics)
 		else:
@@ -987,7 +1013,7 @@
 video_type = u''
 UI_title = u''
 UI_search_language = u''
-UI_selectedtitle = u'' 
+UI_selectedtitle = u''
 # List of language from http://www.thetvdb.com/api/0629B785CE550C8D/languages.xml
 # Hard-coded here as it is realtively static, and saves another HTTP request, as
 # recommended on http://thetvdb.com/wiki/index.php/API:languages.xml
@@ -1026,7 +1052,7 @@
 			if filter(is_not_punct_char, name.lower()).startswith(filter(is_not_punct_char, UI_title.lower())):
 				most_likely.append(name)
 
-		# IMDB can return titles that are a movies foriegn title. The titles that do not match 
+		# IMDB can return titles that are a movies foriegn title. The titles that do not match
 		# the requested title need to be added to the end of the most likely titles list.
 		if video_type == u'IMDB' and len(most_likely):
 			for name in tmp_names:
@@ -1037,7 +1063,7 @@
 
 		names = []
 		# Remove any name that does not start with a title like the TV Show/Movie (except for IMDB)
-		if len(most_likely): 
+		if len(most_likely):
 			for likely in most_likely:
 				names.append(likely)
 		else:
@@ -1049,7 +1075,7 @@
 		# reorder the list of series and sid's
 		new_array=[]
 		for key in names: # list all search results
-			new_array.append(allSeries[key]) 
+			new_array.append(allSeries[key])
 
 		# If there is only one to select and it is an exact match then return with no interface display
 		if len(new_array) == 1:
@@ -1101,7 +1127,7 @@
 		else:
 			reftype = u'Series id'
 			refsize = 5
-			refformat = u"%6d"	# Attempt to have the most likely TV/Movies at the top of the list 
+			refformat = u"%6d"	# Attempt to have the most likely TV/Movies at the top of the list
 
 		while True: # return breaks this loop
 			try:
@@ -1194,13 +1220,13 @@
 	"""
 	def __init__(self, interactive = False, debug = False):
 		"""Initialize default configuration settings
-		""" 
+		"""
 		self.config = {}
 		# Set all default variables
 		self.config['interactive'] = interactive
 		self.config['debug_enabled'] = debug
 		self.config['flags_options'] = False
-		self.config['local_language'] = u'en' 
+		self.config['local_language'] = u'en'
  		self.config['simulation'] = False
 		self.config['toprated'] = False
 		self.config['download'] = False
@@ -1240,7 +1266,7 @@
 
 		# The default format of the graphics file names (with and without seasons and/or episode names)
 		# The default is to use the URL's filename from thetvdb.com
-		self.config['g_defaultname']=True	
+		self.config['g_defaultname']=True
 		# e.g. "Fringe - 01.jpg"
 		self.config['g_series'] = u'%(series)s - %(seq)s.%(ext)s'
 		# e.g. "SG-1 - 07-02.jpg"
@@ -1304,6 +1330,10 @@
 			# foo.0103*
 			re.compile(u'''^(.+)[ \._\-]([0-9]{2})([0-9]{2,3})[\._ -][^\\/]*$''' , re.UNICODE),
 		]
+
+		# Initalize a valriable used by the -MW option
+		self.program_seriesid = None
+		self.config[u'file_move_flag'] = False
 	# end __init__
 
 	# Local variable
@@ -1338,35 +1368,35 @@
 			sys.stderr.write(
 				"\n! Error: The specified user configuration file (%s) is not a file\n" % useroptions
 			)
-			sys.exit(False)
+			sys.exit(1)
 		cfg = ConfigParser.SafeConfigParser()
 		cfg.read(useroptions)
-		for section in cfg.sections(): 
+		for section in cfg.sections():
 			if section[:5] == 'File ':
 				self.config['config_file'] = section[5:]
 				continue
 			if section == 'variables':
 				# Change variables per user config file
-				for option in cfg.options(section): 
+				for option in cfg.options(section):
 					if option == 'video_file_exts' or option == 'tmdb_genre_filter' or option == 'metadata_exclude_as_update_trigger':
 						tmp_list = (cfg.get(section, option).rstrip()).split(',')
 						for i in range(len(tmp_list)): tmp_list[i] = (tmp_list[i].strip()).lower()
 						self.config[option] = tmp_list
 						continue
 					# Ignore user settings for Myth Video and graphics file directories
-					# when the MythTV metadata option (-M) is selected 
+					# when the MythTV metadata option (-M) is selected
 					if self.config['mythtvmeta'] and option in ['posterdir', 'bannerdir', 'fanartdir', 'episodeimagedir', 'mythvideo']:
 						continue
 					self.config[option] = cfg.get(section, option)
 				continue
 			if section == 'regex':
 				# Change variables per user config file
-				for option in cfg.options(section): 
+				for option in cfg.options(section):
 					self.config['name_parse'].append(re.compile(unicode(cfg.get(section, option), 'utf8'), re.UNICODE))
 				continue
 			if section =='series_name_override':
 				overrides = {}
-				for option in cfg.options(section): 
+				for option in cfg.options(section):
 					overrides[option] = cfg.get(section, option)
 				if len(overrides) > 0:
 					self.config['series_name_override'] = overrides
@@ -1377,7 +1407,7 @@
 					tmp =cfg.get(section, option).split(',')
 					if len(tmp)%2 and len(cfg.get(section, option)) != 0:
 						sys.stderr.write(u"\n! Error: For (%s) 'ep_name_massage' values must be in pairs\n" % option)
-						sys.exit(False)
+						sys.exit(1)
 					tmp_array=[]
 					i=0
 					while i != len(tmp):
@@ -1413,19 +1443,19 @@
 			for sec in ['movies-secondary-sources', 'tv-secondary-sources']:
 				if section == sec:
 					secondary = {}
-					for option in cfg.options(section): 
+					for option in cfg.options(section):
 						secondary[option] = cfg.get(section, option)
 					if len(secondary) > 0:
 						self.config['myth_secondary_sources'][sec[:sec.index('-')]] = secondary
 				continue
 			if section == u'mb_tv':
 				# Add the channel names and their corresponding thetvdb.com id numbers
-				for option in cfg.options(section): 
+				for option in cfg.options(section):
 					self.config['mb_tv_channels'][filter(is_not_punct_char, option.lower())] = [cfg.get(section, option), u'']
 				continue
 			if section == u'mb_movies':
 				# Add the channel names for movie trailer Channels
-				for option in cfg.options(section): 
+				for option in cfg.options(section):
 					self.config['mb_movies'][filter(is_not_punct_char, option.lower())] = cfg.get(section, option)
 				continue
 
@@ -1441,7 +1471,7 @@
 
 	def displayOptions(self):
 		""" Display all of the configuration values. This is used to verify that the user has the
-		variables set as they want before running jamu live. 
+		variables set as they want before running jamu live.
 		"""
 		keys=self.config.keys()
 		keys.sort()
@@ -1449,7 +1479,7 @@
 ################### Used to create the example configuration file "jamu-example-conf"
 #		for key in keys:	# Used to create the example configuration file "jamu-example-conf"
 #			print "#%s: %s" % (key, self.config[key])
-#		sys.exit(True)
+#		sys.exit(0)
 ##################
 
 		for key in keys:
@@ -1458,7 +1488,7 @@
 			try:
 				if key == 'name_parse':
 					print u"%s (%d items)" % (key, len(self.config[key]))
-				else: 
+				else:
 					print u"%s (%s)" % (key, str(self.config[key]))
 			except:
 				try:
@@ -1490,7 +1520,7 @@
 			localip = gethostbyname(localhostname) # Get the local hosts IP address
 		except:
 			sys.stderr.write("\n! Error: There is no valid address-to-host mapping for the host (%s)\nThe Jamu Janitor (-MJ) option cannot be used while this issue remains un-resolved.\n" % localhostname)
-			sys.exit(False)
+			sys.exit(1)
 
 		# Get all curently mounted NFS shares
 		tmp_mounts = callCommandLine("mount -l | grep '//'").split('\n')
@@ -1535,7 +1565,7 @@
 
 
 	def _getMythtvDirectories(self):
-		"""Get all graphics directories found in the MythTV DB and change their corresponding 
+		"""Get all graphics directories found in the MythTV DB and change their corresponding
 		configuration values.  /media/video:/media/virtual/VB_Share/Review
 		"""
 		# Stop processing if this local host has any storage groups
@@ -1543,11 +1573,11 @@
 		# Make sure Jamu is being run on a MythTV backend
 		if not mythdb.getSetting('BackendServerIP', hostname = localhostname):
  			sys.stderr.write(u"\n! Error: Jamu must be run on a MythTV backend. Local host (%s) is not a MythTV backend.\n" % localhostname)
-			sys.exit(False)
-			
+			sys.exit(1)
+
 		global dir_dict
 		for key in dir_dict.keys():
-			graphics_dir = mythdb.getSetting(dir_dict[key], hostname = localhostname) 
+			graphics_dir = mythdb.getSetting(dir_dict[key], hostname = localhostname)
 			# Only use path from MythTV if one was found
 			self.config[key] = []
 			if key == 'mythvideo' and graphics_dir:
@@ -1560,17 +1590,50 @@
 								self.config[key].append(tmp_directories[i])
 								continue
 							else:
-						 		sys.stderr.write(u"\n! Warning: MythTV video directory (%s) is not set or does not exist(%s).\n" % (key, tmp_directories[i]))
+						 		sys.stderr.write(u"\n! Warning: MythTV video directory (%s) does not exist.\n" % (tmp_directories[i]))
+						 		continue
 
 			if key != 'mythvideo' and graphics_dir:
-				self.config[key] = [graphics_dir]
+				if os.path.os.access(graphics_dir, os.F_OK):
+					self.config[key] = [graphics_dir]
+				else:
+					sys.stderr.write(u"\n! Warning: MythTV (%s) directory (%s) does not exist.\n" % (key, tmp_directories[i]))
 
-		# Get Storage Groups and override any FE directory settings 
+		# Save the FE path settings local to this backend
+		self.config['localpaths'] = {}
+		for key in dir_dict.keys():
+			self.config['localpaths'][key] = []
+			local_paths = []
+			if len(self.config[key]):
+				for path in self.config[key]:
+					local_paths.append(path)
+				self.config['localpaths'][key] = local_paths
+
+		# If there is a Videos SG then there is always a Graphics SG using Videos as a fallback
 		getStorageGroups()
-		for key in storagegroups.keys():
-			self.config[key] = storagegroups[key]
+		for key in dir_dict.keys():
+			if key == 'episodeimagedir' or key == 'mythvideo':
+				continue
+			if storagegroups.has_key(u'mythvideo') and not storagegroups.has_key(key):
+				storagegroups[key] = list(storagegroups[u'mythvideo'])		# Set fall back
 
+		# Use Storage Groups as the priority but append any FE directory settings that
+		# are local to this BE but are not already used as a storage group
+		if storagegroups.has_key(u'mythvideo'):
+			for key in storagegroups.keys():
+				self.config[key] = list(storagegroups[key])
+				for k in self.config['localpaths'][key]:
+					if not k in self.config[key]:
+						self.config[key].append(k)	# Add any FE settings local directories not already included
+					else:
+						if key == 'mythvideo':
+							sys.stdout.write(u"\n! Warning: You have a front end video directory path that is a duplicate of this backend's 'Videos' storage group.\nFront end directory (%s)\nThe Front end setting has been ignored.\nThis Front end video directory will cause duplicate entires in MythVideo.\n" % (k))
+						else:
+							sys.stdout.write(u"\n! Info: You have a front end directory path that is a duplicate of this backend's storage group.\nFront end directory (%s)\nThe Front end setting has been ignored.\n" % (k))
+					continue
+
 		# Make sure there is a directory set for Videos and other graphics directories on this host
+		exists = True
 		for key in dir_dict.keys():
 			if key == 'episodeimagedir': # Jamu does nothing with Screenshots
 				continue
@@ -1579,36 +1642,90 @@
 				self.config[key] = storagegroups[u'mythvideo']
 			if not len(self.config[key]):
 	 			sys.stderr.write(u"\n! Error: There must be a directory for Videos and each graphic type. The (%s) directory is missing.\n" % (key))
-				sys.exit(False)
+				exists = False
+		if not exists:
+			sys.exit(1)
 
-		# Make sure that the directory sets for Videos and other graphics directories are RW able
+		# Make sure that the directory set for Videos and other graphics directories have the proper permissions
 		accessable = True
 		for key in dir_dict.keys():
 			for directory in self.config[key]:
+				if key == 'episodeimagedir': # Jamu does nothing with Screenshots
+					continue
+				if key == 'mythvideo':
+					if not os.access(directory, os.F_OK | os.R_OK):
+			 			sys.stderr.write(u"\n! Error: This video directory must have read access for Jamu to function.\nThere is a permissions issue with (%s).\n" % (directory, ))
+						accessable = False
+					continue
 				if not os.access(directory, os.F_OK | os.R_OK | os.W_OK):
-		 			sys.stderr.write(u"\n! Error: Every Video and graphics directory must be read/writable for Jamu to function.\nThere is a permissions issue with (%s).\n" % (directory, ))
+		 			sys.stderr.write(u"\n! Error: The (%s) directory (%s) must be read/writable for Jamu to function.\n" % (key, directory, ))
 					accessable = False
 		if not accessable:
-			sys.exit(False)
+			sys.exit(1)
 
+		# Print out the video and image directories that will be used for processing
+		if self.config['mythtv_verbose']:
+			dir_types={'posterdir': "Cover art  ", 'bannerdir': 'Banners    ', 'fanartdir': 'Fan art    ', 'episodeimagedir': 'Screenshots', 'mythvideo': 'Video      '}
+			sys.stdout.write(u"\n==========================================================================================\n")
+			sys.stdout.write(u"Listed below are the types and base directories Jamu will use for processing.\nThe list reflects your current configuration for the '%s' back end\nand whether a directory is a 'SG' (storage group) or not.\n" % localhostname)
+			sys.stdout.write(u"Note: All directories are from settings in the MythDB specific to hostname (%s).\n" % localhostname)
+			sys.stdout.write(u"Note: Screenshot directories are not listed as Jamu does not process Screenshots.\n")
+			sys.stdout.write(u"------------------------------------------------------------------------------------------\n")
+			for key in dir_dict.keys():
+				if key == 'episodeimagedir':
+					continue
+				for directory in self.config[key]:
+					sg_flag = 'NO '
+					if storagegroups.has_key(key):
+						if directory in storagegroups[key]:
+							sg_flag = 'YES'
+					sys.stdout.write(u"Type: %s - SG-%s - Directory: (%s)\n" % (dir_types[key], sg_flag, directory))
+			sys.stdout.write(u"------------------------------------------------------------------------------------------\n")
+			sys.stdout.write(u"If a directory you set from a separate Front end is not displayed it means\nthat the directory is not accessible from this backend OR\nyou must add the missing directories using the Front end on this Back end.\nFront end settings are host machine specific.\n")
+			sys.stdout.write(u"==========================================================================================\n\n")
+
+		if self.config[u'file_move_flag']:	# verify the destination directory in a move is read/writable
+			index = 0
+			accessable = True
+			for arg in self.args:
+				if index % 2 == 0:
+					index+=1
+					continue
+				if not os.access(arg, os.F_OK):
+					for dirct in self.config['mythvideo']:
+						if arg.startswith(dirct):
+							if not os.access(dirct, os.F_OK | os.R_OK | os.W_OK):
+					 			sys.stderr.write(u"! Error: Your move destination root MythVideo directory (%s) must be read/writable for Jamu to function.\n\n" % (dirct, ))
+								accessable = False
+							break
+					else:
+			 			sys.stderr.write(u"! Error: Your move destination directory (%s) must be a MythVideo directory OR a subdirectory of a MythVideo directory.\n\n" % (arg, ))
+						accessable = False
+				elif not os.access(arg, os.F_OK | os.R_OK | os.W_OK):
+		 			sys.stderr.write(u"! Error: Your move destination directory (%s) must be read/writable for Jamu to function.\n\n" % (arg, ))
+					accessable = False
+				index+=1
+			if not accessable:
+				sys.exit(1)
+
 		# Check if any Video files are on a NFS shares
 		if not self.config['mythtvNFS']:	# Maybe the NFS check is to be skipped
-			if self._checkNFS(self.config['mythvideo'], self.config['video_file_exts']): 
+			if self._checkNFS(self.config['mythvideo'], self.config['video_file_exts']):
 				sys.stderr.write(u"\n! Error: Your video files reside on a NFS mount.\nIn the case where you have more than one MythTV backend using the same directories to store either video files\nor graphics any Jamu's option (-M) can adversly effect your MythTV database by mistakenly adding videos\nfor other backends or with the Janitor (-J) option mistakenly remove graphics files.\n\nIf you only have one backend or do not mix the Video or graphic file directories between backends and still want to use\nJamu add the options (N) to your option string e.g. (-MJN), which will skip this check.\n\n")
-				sys.exit(False)
+				sys.exit(1)
 	# end _getMythtvDirectories
 
 
 	def _JanitorConflicts(self):
-		'''Verify that there are no conflict between the graphics directories of MythVideo and 
+		'''Verify that there are no conflict between the graphics directories of MythVideo and
 		other MythTV plugins. Write an warning message if a conflict is found.
 		return True when there is a conflict
 		return False when there is no conflict
 		'''
-		# Except for the plugins below no other plugins have non-theme graphics 
-		# MythGallery: 
+		# Except for the plugins below no other plugins have non-theme graphics
+		# MythGallery:
 		# 	Table 'settings' fields 'GalleryDir', 'GalleryImportDirs', 'GalleryThumbnailLocation'
-		# MythGame: 
+		# MythGame:
 		#	Table 'settings' fields 'mythgame.screenshotDir', 'mythgame.fanartDir', 'mythgame.boxartDir'
 		# MythMusic:
 		#	Table 'settings' fields 'MusicLocation'
@@ -1626,7 +1743,7 @@
 				for directory in graphicsDirectories.keys():
 					if not self.config[graphicsDirectories[directory]]:
 						continue
-					# As the Janitor processes subdirectories matching must be a starts with check 
+					# As the Janitor processes subdirectories matching must be a starts with check
 					for direc in self.config[graphicsDirectories[directory]]:
 						if os.path.realpath(setting).startswith(os.path.realpath(direc)):
 							sys.stderr.write(u"\n! Error - The (%s) directory (%s) conflicts\nwith the MythVideo (%s) directory (%s).\nThe Jamu Janitor (-MJ) option cannot be used.\n\n" % (field, setting, direc, self.config[graphicsDirectories[directory]]) )
@@ -1658,7 +1775,7 @@
 				record[table_names[i]] = elem
 				i+=1
 			# Remove any extentions that are in Jamu's list but the user wants ignore
-			if record[u'f_ignore']: 
+			if record[u'f_ignore']:
 				if record[u'extension'] in self.config['video_file_exts']:
 					self.config['video_file_exts'].remove(record[u'extension'])
 				if record[u'extension'].lower() in self.config['video_file_exts']:
@@ -1689,39 +1806,46 @@
 		if self.config['mythtvmeta']:
 			if mythdb == None or mythvideo == None:
 				sys.stderr.write(u"\n! Error: The MythTV python interface is not installed or Cannot connect to MythTV Backend. MythTV meta data cannot be updated\n\n")
-				sys.exit(False)
+				sys.exit(1)
 			try:
 				import Image
 				self.config['image_library'] = Image
 			except:
-				sys.stderr.write(u"""\n! Error: Python Imaging Library is required for figuring out the sizes of 
+				sys.stderr.write(u"""\n! Error: Python Imaging Library is required for figuring out the sizes of
 the fetched poster images.
 
 In Debian/Ubuntu it is packaged as 'python-imaging'.
 http://www.pythonware.com/products/pil/\n""")
-				sys.exit(False)
+				sys.exit(1)
 
 		if not _can_int(self.config['min_poster_size']):
 			sys.stderr.write(u"\n! Error: The poster minimum value must be an integer (%s)\n" % self.config['min_poster_size'])
-			sys.exit(False)
+			sys.exit(1)
 		else:
 			self.config['min_poster_size'] = int(self.config['min_poster_size'])
 
 		if self.config['maximum'] != None:
 			if _can_int(self.config['maximum']) == False:
 				sys.stderr.write(u"\n! Error: Maximum option is not an integer (%s)\n" % self.config['maximum'])
-				sys.exit(False)
+				sys.exit(1)
 
+		# Detect if this is a move request
+		self.config[u'file_move_flag'] = False
+		if len(args) != 0:
+			if os.path.isfile(args[0]) or os.path.isdir(args[0]) or args[0][-1:] == '*':
+				self.config[u'file_move_flag'] = True
+				self.args = list(args)
+
 		if self.config['mythtvdir']:
 			if mythdb == None or mythvideo == None:
 	 			sys.stderr.write(u"\n! Error: MythTV python interface is not available\n")
-				sys.exit(False)
+				sys.exit(1)
 		if self.config['mythtvdir'] or self.config['mythtvmeta']:
 			self._addMythtvUserFileTypes() # add user filetypes from the "videotypes" table
 			self._getMythtvDirectories()
 		if self.config['mythtvjanitor']: # Check for graphic directory conflicts with other plugins
 			if self._JanitorConflicts():
-				sys.exit(False)
+				sys.exit(1)
 			if not self.config['mythtvNFS']:
 				global graphicsDirectories, image_extensions
 				dirs = []
@@ -1730,26 +1854,26 @@
 						for directory in self.config[graphicsDirectories[key]]:
 							dirs.append(directory)
 				# Check if any Graphics files are on NFS shares
-				if self._checkNFS(dirs, image_extensions): 
+				if self._checkNFS(dirs, image_extensions):
 					sys.stderr.write(u"\n! Error: Your metadata graphics reside on a NFS mount.\nIn the case where you have more than one MythTV backend using the same directories to store your graphics\nthe Jamu's Janitor option (-MJ) will be destructive removing graphics used by the other backend(s).\n\nIf you only have one backend or do not mix the graphics directories between backends and still want to use\nJamu's Janitor use the options (-MJN) which will skip this check.\n\n")
-					sys.exit(False)
+					sys.exit(1)
 
 		if self.config['posterresize'] != False or self.config['fanartresize'] != False:
 			if _useImageMagick("-version"):
 				sys.stderr.write(u"\n! Error: ImageMagick is not installed, graphics cannot be resized. posterresize(%s), fanartresize(%s)\n" % (str(self.config['posterresize']), str(self.config['fanartresize'])))
-				sys.exit(False)
+				sys.exit(1)
 
 		if self.config['mythtvmeta'] and len(args) == 0:
 			args=['']
 
 		if len(args) == 0:
 			sys.stderr.write(u"\n! Error: At least a video directory, SID or season name must be supplied\n")
-			sys.exit(False)
+			sys.exit(1)
 
 		if os.path.isfile(args[0]) or os.path.isdir(args[0]) or args[0][-1:] == '*':
 			self.config['video_dir'] = []
 			for arg in args:
-				self.config['video_dir'].append(unicode(arg,'utf8')) 
+				self.config['video_dir'].append(unicode(arg,'utf8'))
 		elif not self.config['mythtvmeta']:
 			if _can_int(args[0]) and len(args[0]) >= 5:
 				self.config['sid'] = unicode(args[0], 'utf8') # There is still a chance that this is a series name "90210"
@@ -1765,13 +1889,13 @@
 				if len(args) > 3:
 					sys.stderr.write("\n! Error: Too many arguments (%d), maximum is three.\n" % len(args))
 					print "! args:", args
-					sys.exit(False)
+					sys.exit(1)
 				if len(args) == 3 and _can_int(args[1]) and _can_int(args[2]):
 					self.config['season_num'] = args[1]
 					self.config['episode_num'] = args[2]
 				elif len(args) == 3:
 					sys.stderr.write(u"\n! Error: Season name(%s), season number(%s), episode number (%s) combination is invalid\n" % (args[0], args[1], args[2]))
-					sys.exit(False)
+					sys.exit(1)
 				elif len(args) == 2 and _can_int(args[1]):
 					self.config['season_num'] = args[1]
 				else:
@@ -1799,7 +1923,7 @@
 				for lang in valid_languages: valid_langs+= lang+', '
 				valid_langs=valid_langs[:-2]
 				sys.stderr.write(u"\n! Error: Specified language(%s) must match one of the following languages supported by thetvdb.com wiki:\n (%s)\n" % (self.config['local_language'], valid_langs))
-				sys.exit(False)
+				sys.exit(1)
 		global UI_search_language
 		UI_search_language = self.config['local_language']
 
@@ -1821,11 +1945,11 @@
 	"""Process direct thetvdb.com requests
 	"""
 	def __init__(self, configuration):
-		"""Retrieve all configuration options and get an instance of tvdb_api which is used to 
+		"""Retrieve all configuration options and get an instance of tvdb_api which is used to
 		access thetvdb.com wiki.
 		"""
 		self.config = configuration
-		cache_dir=u"/tmp/tvdb_api_%s/" % os.geteuid() 
+		cache_dir=u"/tmp/tvdb_api_%s/" % os.geteuid()
 		if self.config['interactive']:
 			self.config['tvdb_api'] = tvdb_api.Tvdb(banners=True, debug=self.config['debug_enabled'], interactive=True,  select_first=False, cache=cache_dir, actors = True, language = self.config['local_language'], custom_ui=jamu_ConsoleUI, apikey="0BB856A59C51D607")  # thetvdb.com API key requested by MythTV)
 		else:
@@ -1894,10 +2018,10 @@
 
 	def verifySeriesExists(self):
 		"""Verify that a:
-		Series or 
-		Series and Season or 
+		Series or
+		Series and Season or
 		Series and Season and Episode number or
-		Series and Episode name 
+		Series and Episode name
 		passed by the user exists on thetvdb.com
 		return False and display an appropriate error if the TV data was not found
 		return an tvdb_api instance of the TV show/season/episode data if it was found
@@ -1921,7 +2045,7 @@
 							if len(ep['episodename']) > (len(episode_name)+1):
 								# Skip episodes the are not part of a set of (1), (2) ... etc
 								if ep['episodename'][len(episode_name):len(episode_name)+2] != ' (':
-									continue	
+									continue
 								series_sid = ep['seriesid']
 								self.config['sid'] = ep['seriesid']
 								self.config['season_num'] = ep['seasonnumber']
@@ -1933,7 +2057,7 @@
 								self.config['season_num'] = ep['seasonnumber']
 								self.config['episode_num'] = ep['episodenumber']
 								return(ep)
-				raise tvdb_episodenotfound					
+				raise tvdb_episodenotfound
 			# Search for the series or series & season or series & season & episode
 			elif season:
 				if episode: 	# series & season & episode
@@ -1941,7 +2065,7 @@
 					self.config['sid'] = seriesfound['seriesid']
 					self.config['episode_name'] = seriesfound['episodename']
 				else:							# series & season
-					seriesfound=self._searchforSeries(series_name)[int(season)] 
+					seriesfound=self._searchforSeries(series_name)[int(season)]
 			else:
 				seriesfound=self._searchforSeries(series_name)	# Series only
 		except tvdb_shownotfound:
@@ -1956,7 +2080,7 @@
 			# Use the corrected show-name, but no episode name.
 			if series_name == None:
 				series_name = sid
-			if episode: 
+			if episode:
 				sys.stderr.write(u"\n! Warning: For Series (%s), season (%s) or Episode (%s) not found \n"
 				 % (series_name, season, episode )
 				)
@@ -2002,7 +2126,7 @@
 				u'\n! Warning: Resizing failed command (mogrify -resize %s "%s")\n' % (resize, filename)
 			)
 			return(False)
-		return True	
+		return True
 	# end _resizeGraphic
 
 	def _downloadURL(self, url, OutputFileName):
@@ -2030,7 +2154,7 @@
 			sys.stderr.write( u"\n! Warning: Download IOError on URL for Filename(%s)\nOrginal URL(%s)\nIOError urllib.quote URL(%s)\n" % (OutputFileName, org_url, url))
 			return False
 
-		target_socket = open(OutputFileName, "wb") 
+		target_socket = open(OutputFileName, "wb")
 		target_socket.write(dat)
 		target_socket.close()
 
@@ -2056,7 +2180,7 @@
 
 	def _setGraphicsFileNameFormat(self):
 		"""Return a file name format (e.g. seriesname - episode name.extention)
-		return a filename format string 
+		return a filename format string
 		"""
 		if self.config['g_defaultname']:
 			return u'%(url)s.%(ext)s'
@@ -2079,7 +2203,7 @@
 
 		if self.config['season_num']:
 			return self.config['g_season'] % cfile
-			
+
 		return self.config['g_series'] % cfile
 	# end _setGraphicsFileNameFormat
 
@@ -2090,6 +2214,8 @@
 		return False  if the any of the urls are corrupt
 		return file name of the LAST file downloaded (special for MythTV data base updates)
 		"""
+		global graphicsDirectories
+
 		if urls == None: return None
 		if urls == '': return None
 		tmp_list=urls.split('\n')
@@ -2098,7 +2224,7 @@
 			x = x.rstrip()
 			if x != '':
 				url_list.append(x)
-		if not len(url_list):		
+		if not len(url_list):
 			return None			# There were no URLs in the list
 		url_dict={}
 		for x in url_list:
@@ -2113,18 +2239,18 @@
 			if url_dict.has_key(x[:i]):
 				temp_array = [x[i+1:],'']
 				url_dict[x[:i]].append(temp_array)# Collect a list of the same graphics type of URLs
-			else: # The first URL of a new graphics type
-				url_dict[x[:i]]=[[(x[i+1:]).replace(u"http://www.thetvdb.com",u"http://images.thetvdb.com"),'']]
+			else: # The first URL of a new graphics type. Also URL replacement code left in place just in case
+				url_dict[x[:i]]=[[(x[i+1:]).replace(u"http://www.thetvdb.com",u"http://www.thetvdb.com"),'']]
 
 		unique_dir={u'poster': ['posterdir', True], u'banner': ['bannerdir', True], u'fanart': ['fanartdir', True], u'filename': ['episodeimagedir', True]}
-		# If a graphics directory was not specified then default to the 'allgraphics' directory 
+		# If a graphics directory was not specified then default to the 'allgraphics' directory
 		if not self.config['posterdir']: self.config['posterdir'] = self.config['allgraphicsdir']
 		if not self.config['bannerdir']: self.config['bannerdir'] = self.config['allgraphicsdir']
 		if not self.config['fanartdir']: self.config['fanartdir'] = self.config['allgraphicsdir']
 		if not self.config['episodeimagedir']: self.config['episodeimagedir'] = self.config['allgraphicsdir']
 
 		# Check if any of the downloaded graphics will share the same directory
-		for key in unique_dir.keys(): 
+		for key in unique_dir.keys():
 			for k in unique_dir.keys():
 				if key != k:
 					if self.config[unique_dir[key][0]] == self.config[unique_dir[k][0]]:
@@ -2140,8 +2266,18 @@
 		# Set the graphics fully qualified filenames matched to a URL
 		for URLtype in url_dict:
 			if mythtv:
-				directory = dirs[URLtype][0]
-			else:	 
+				if self.absolutepath:
+					if URLtype == 'poster':
+						tmpgraphicdir = graphicsDirectories['coverfile']
+					else:
+						tmpgraphicdir = graphicsDirectories[URLtype]
+					if not len(self.config['localpaths'][tmpgraphicdir]):
+						return None
+					else:
+						directory = self.config['localpaths'][tmpgraphicdir][0]
+				else:
+					directory = dirs[URLtype][0]
+			else:
 				directory = dirs[URLtype]
 			seq_num = 0
 			for url in url_dict[URLtype]:
@@ -2158,12 +2294,15 @@
 						file_format = file_format.replace(self.config['series_name'], sanitiseFileName(self.config['series_name']))
 				cfile['series'] = sanitiseFileName(self.config['series_name'])
 				cfile['seriesid'] = self.config['sid']
-				
+
 				if URLtype != 'filename':
 					if unique_dir[URLtype][1]:
 						url_dict[URLtype][seq_num][1] = directory+'/'+file_format % cfile
 					else:
-						url_dict[URLtype][seq_num][1] = directory+'/'+URLtype.capitalize()+' - '+file_format % cfile
+						if mythtv:
+							url_dict[URLtype][seq_num][1] = directory+'/'+file_format % cfile
+						else:
+							url_dict[URLtype][seq_num][1] = directory+'/'+URLtype.capitalize()+' - '+file_format % cfile
 				else:
 					if self.config['season_num']:
 						cfile['seasonnumber']=int(self.config['season_num'])
@@ -2185,7 +2324,7 @@
 				if self._downloadURL(pairs[0], pairs[1]):
 					if URLtype == u'poster' and self.config['posterresize']:
 						self._resizeGraphic(pairs[1], self.config['posterresize'])
-					elif URLtype == u'fanart' and self.config['fanartresize']: 
+					elif URLtype == u'fanart' and self.config['fanartresize']:
 						self._resizeGraphic(pairs[1], self.config['fanartresize'])
 				elif not os.path.isfile(pairs[1]): # Check if the file already was downloaded
 					failed_download = True # The download failed
@@ -2193,7 +2332,7 @@
 						sys.stderr.write(u'\nA graphics file failed to be downloaded. A file issue or a corrupt (HTML) file.(%s)\n' % pairs[1])
 				seq_num+=1
 				if self.config['maximum']:	# Has the maximum number of graphics been downloaded?
-					if seq_num == int(self.config['maximum']): 
+					if seq_num == int(self.config['maximum']):
 						break
 		if failed_download:
 			return None
@@ -2240,14 +2379,14 @@
 				try:
 					self.config['log'].debug(u'Checking for Series Banner graphics')
 					graphics=[b for b in
-							self._searchforSeries(series_name).data[banners][self.banner_key][self.banner_series_key].values()] 
+							self._searchforSeries(series_name).data[banners][self.banner_key][self.banner_series_key].values()]
 				except:
 					return None
 			elif graphics_type == self.poster_type:		# Series Posters
 				try:
 					self.config['log'].debug(u'Checking for Series Poster graphics')
 					graphics=[b for b in
-							self._searchforSeries(series_name).data[banners][self.poster_key][self.poster_series_key].values()] 
+							self._searchforSeries(series_name).data[banners][self.poster_key][self.poster_series_key].values()]
 				except:
 					return None
 		else:
@@ -2255,7 +2394,7 @@
 				try:
 					self.config['log'].debug(u'Checking for Season Banner graphics')
 					graphics=[b for b in
-							self._searchforSeries(series_name).data[banners][self.season_key][self.banner_season_key].values() 
+							self._searchforSeries(series_name).data[banners][self.season_key][self.banner_season_key].values()
 							if b[self.season_key] == season]
 				except:
 					return None
@@ -2263,7 +2402,7 @@
 				try:
 					self.config['log'].debug(u'Checking for Season Poster graphics')
 					graphics=[b for b in
-							self._searchforSeries(series_name).data[banners][self.season_key][self.poster_season_key].values() 
+							self._searchforSeries(series_name).data[banners][self.season_key][self.poster_season_key].values()
 							if b[self.season_key] == season]
 				except:
 					return None
@@ -2273,7 +2412,7 @@
 					if episode_name:		# Find an exact match for the series and episode name
 						graphics=self._searchforSeries(series_name).search(episode_name)
 					else:
-						graphics= self._searchforSeries(series_name)[int(season)][int(episode)] 
+						graphics= self._searchforSeries(series_name)[int(season)][int(episode)]
 				except:
 					return None
 
@@ -2291,7 +2430,7 @@
 			if graphics_type == 'filename':
 				if URL[graphics_type] == None:
 					continue
-			if lang:		# Is there a language to filter URLs on? 
+			if lang:		# Is there a language to filter URLs on?
 				if lang == URL['language']:
 					if graphics_type != self.ep_image_type:
 						graphicsURLs+=key_tag+URL['_bannerpath']+'\n'
@@ -2318,7 +2457,7 @@
 			wasanythingadded = len(graphicsURLs)
 			count+=1
 			if self.config['maximum']:	# Has the maximum number of graphics been downloaded?
-				if count == int(self.config['maximum']): 
+				if count == int(self.config['maximum']):
 					break
 
 		if not len(graphicsURLs):
@@ -2331,7 +2470,7 @@
 			print "\nGraphics:\n", graphicsURLs
 
 		if not len(graphicsURLs):			# Are there any graphics?
-			return None			
+			return None
 
 		if len(graphicsURLs) == 1 and graphicsURLs[0] == graphics_type+':':
 			return None						# Due to the language filter there may not be any URLs
@@ -2355,7 +2494,7 @@
 				toprated=(self._searchforSeries(series_name)[graphics_type])+'\n'
 			else:
 				toprated=(u'%s:%s\n' % (graphics_type, self._searchforSeries(series_name)[graphics_type]))
-		return toprated				
+		return toprated
 	# end getTopRatedGraphics
 
 	def _downloadEpisodeData(self,ep_data):
@@ -2413,7 +2552,7 @@
 					tmp_dict[u'ext']=fileExtension[1:]
 					image_filename = "%s/%s" % (self.config['episodeimagedir'], self.config['ep_metadata'] % tmp_dict)
 			# Only download a file if it does not exist or the option overwrite is selected
-			# or the option update is selected and the local meta data file is 
+			# or the option update is selected and the local meta data file is
 			# older than the episode data on thetvdb.com wiki
 			outofdate = False
 			if self.config['update'] and tmp_dict.has_key('lastupdated') and os.path.isfile(filename):
@@ -2456,7 +2595,7 @@
 			if self.config['get_ep_image'] and tmp_dict.has_key('filename'):
 				if tmp_dict['filename'] != 'None':
 					self._downloadGraphics('filename:'+tmp_dict['filename'])
-				
+
 			# Write out an episode meta data file
 			if 	self.config['get_ep_meta']:
 				fHandle = codecs.open(filename, 'w', 'utf8')
@@ -2491,7 +2630,7 @@
 		return an empy sting of no episode meta data was found
 		reurn a string containing key value pairs of episode meta data
 		"""
-		sid=self.config['sid']		
+		sid=self.config['sid']
 		series_name=self.config['series_name']
 		season_num=self.config['season_num']
 		episode_num=self.config['episode_num']
@@ -2554,7 +2693,7 @@
 				ep_data[u'gueststars']=''
 				for key in available_keys:
 					if self._searchforSeries(series_name)[season][episode][key] == None:
-						continue	
+						continue
 					# Massage meta data
 					text = self._searchforSeries(series_name)[season][episode][key]
 					text = self._changeAmp(text)
@@ -2589,7 +2728,7 @@
 		or naming/renaming a video file after a TV show recording.
 		return False and out put an error if there not either a series id (SID) or series name
 		return False and out put an error if there proper episode information (numbers or name)
-		return False if the option (-MGF) used and there is not exact TV series name match 
+		return False if the option (-MGF) used and there is not exact TV series name match
 		return a specific episode filename
 		"""
 		sid=self.config['sid']
@@ -2610,7 +2749,7 @@
 			sys.stderr.write(
 				u'\n! Error: There must be at least "season and episode numbers" or "episode name" to request a filename\n'
 			)
-			sys.exit(False)
+			sys.exit(1)
 
 		# Special logic must be used if the (-MG) guessing option has been requested
 		if not self.config['sid'] and self.config['mythtv_guess']:
@@ -2632,9 +2771,9 @@
 			sys.stderr.write(
 				u'\n! Error: The episode was not found for series(%s), Episode name(%s)\n' % (series_name, episode_name)
 			)
-			sys.exit(False)
+			sys.exit(1)
 
-		sid=self.config['sid']		
+		sid=self.config['sid']
 
 		if UI_selectedtitle and self.config['mythtv_inetref']:
 			self.config['series_name'] = UI_selectedtitle
@@ -2650,7 +2789,7 @@
 		for key in ['seasonnumber', 'episodenumber']:
 			if tmp_dict.has_key(key):
 				tmp_dict[key] = int(tmp_dict[key])
-		
+
 		return sanitiseFileName(u"%s" % (self.config['ep_metadata'] % tmp_dict)[:-1])
 	# end returnFilename
 
@@ -2661,12 +2800,12 @@
 		return a string for display or further processing that satisfies the reqested actions
 		"""
 		if self.verifySeriesExists():# Getting a filename is a single event nothing else is returned
-			if self.config['ret_filename']:	
+			if self.config['ret_filename']:
 				return self.returnFilename()
 		else:
 			return None
 
-		types={'get_fanart': self.fanart_type, 'get_poster': self.poster_type, 'get_banner': self.banner_type}	
+		types={'get_fanart': self.fanart_type, 'get_poster': self.poster_type, 'get_banner': self.banner_type}
 		if self.config['toprated']:
 			typegetGraphics=self.getTopRatedGraphics
 		else:
@@ -2691,7 +2830,7 @@
 							url_string+=string
 				if url_string != '':
 					results+=url_string	# Add graphic URLs to returned results
-			
+
 			# Should episode meta data or episode image be processed?
 			if self.config['get_ep_meta'] or self.config['get_ep_image']:
 				if self.config['download']:	# Deal only with episode data display or download
@@ -2711,7 +2850,7 @@
 				return results[:len(results)-1]
 			else:
 				return results
-		else:	
+		else:
 			return None
 	# end processTVdatabaseRequests
 
@@ -2723,14 +2862,14 @@
 
 
 class VideoFiles(Tvdatabase):
-	"""Process all video file and/or directories containing video files. These TV Series video 
+	"""Process all video file and/or directories containing video files. These TV Series video
 	files must be named so that a "series name or sid" and/or "season and episode number"
     can be extracted from the video file name. It is best to have renamed the TV series video files with
 	tvnamer before using these files with jamu. Any video file without season and episode numbers is
 	assumed to be a movie.	Files that do not match the previously described criterion will be skipped.
 	tvnamer can be found at:
 	http://pypi.python.org/pypi?%3Aaction=search&term=tvnamer&submit=search
-	""" 
+	"""
 	def __init__(self, configuration):
 		"""Retrieve the configuration options
 		"""
@@ -2749,14 +2888,14 @@
 		allfiles = []
 
 		for cfile in args: # Directories must exist and be both readable and writable
-			if os.path.isdir(cfile) and not os.access(cfile, os.F_OK | os.R_OK | os.W_OK): 
-				sys.stderr.write(u"\n! Error: Video directory (%s) does not exist or the permissions are not read and writable.\n" % (cfile))
+			if os.path.isdir(cfile) and not os.access(cfile, os.F_OK | os.R_OK):
+				sys.stderr.write(u"\n! Error: Video directory (%s) does not exist or the permissions are not at least readable. Skipping this directory.\n" % (cfile))
 				continue
-			if os.path.isdir(cfile) and os.access(cfile, os.F_OK | os.R_OK | os.W_OK):
+			if os.path.isdir(cfile):
 				try:
 					cfile = unicode(cfile, u'utf8')
 				except (UnicodeEncodeError, TypeError):
-					pass		
+					pass
 				for sf in os.listdir(cfile):
 					try:
 						newpath = os.path.join(cfile, sf)
@@ -2775,8 +2914,10 @@
 						#end if recursive
 					#end if isfile
 				#end for sf
-			elif os.path.isfile(cfile) and os.access(cfile, os.F_OK | os.R_OK | os.W_OK):
-				allfiles.append(cfile) # Files must exist and be both readable and writable
+			elif self.config[u'file_move_flag'] and not os.access(cfile, os.F_OK | os.R_OK | os.W_OK):
+				sys.stderr.write(u"\n! Error: The Video file (%s) to be moved must have the read and write permissions. Skipping this video file.\n" % (cfile))
+			elif os.path.isfile(cfile) and os.access(cfile, os.F_OK | os.R_OK):
+				allfiles.append(cfile) # Files must exist and be at least readable
 			#end if isdir
 		#end for cfile
 		return allfiles
@@ -2799,11 +2940,11 @@
 			if not ext.lower() in self.config[u'video_file_exts']:
 				for key in self.image_extensions:
 					if key == ext:
-						break	
+						break
 				else:
 					sys.stderr.write(u"\n! Warning: Skipping non-video file name: (%s)\n" % (f))
 				continue
-	
+
 			for r in self.config['name_parse']:
 				match = r.match(filename)
 				categories=''
@@ -2816,7 +2957,7 @@
 
 					if self.config['series_name_override']:
 						if self.config['series_name_override'].has_key(seriesname.lower()):
-							if len((self.config['series_name_override'][seriesname.lower()]).strip()) == 7:								
+							if len((self.config['series_name_override'][seriesname.lower()]).strip()) == 7:
 								categories+=u', Movie'
 								movie = filename
 								if movie.endswith(self.config['hd_dvd']):
@@ -2922,14 +3063,14 @@
 		return False and an error message and exist the script if there are no video files to process
 		return None when all processing was complete
 		return a string of file names if the "Filename" process option was True
-		'''	
+		'''
 		filenames=''
 		allFiles = self._findFiles(self.config['video_dir'], self.config['recursive'] , verbose = self.config['debug_enabled'])
 		validFiles = self._processNames(allFiles, verbose = self.config['debug_enabled'])
 
 		if len(validFiles) == 0:
 			sys.stderr.write(u"\n! Error: No valid video files found\n")
-			sys.exit(False)
+			sys.exit(1)
 
 		path_flag = self.config['metadatadir']
 		for cfile in validFiles:
@@ -2947,9 +3088,9 @@
 					returned = self.processTVdatabaseRequests()
 					if returned != None and returned != False:
 						filenames+=returned+'\n'
-				else:			
+				else:
 					self.processTVdatabaseRequests()
-			else:				
+			else:
 				sys.stderr.write(u"\n! Warning: Did not find series(%s) season(%s) episode(%s)\n" % (self.config['series_name'], self.config['season_num'], self.config['episode_num']))
 			self.config['log'].debug("# Done")
 		if len(filenames) == 0:
@@ -2958,7 +3099,7 @@
 			return filenames[:-1] # drop the last '\n'
 	# end processFileOrDirectory
 
-	def __repr__(self):	# Just a place holder 
+	def __repr__(self):	# Just a place holder
 		return self.config
 	# end __repr__
 
@@ -2966,8 +3107,8 @@
 
 
 class MythTvMetaData(VideoFiles):
-	"""Process all mythvideo video files, update the video files associated MythTV meta data. 
-	Download graphics for those video files from either thetvdb.com or themovie.com. Video file names 
+	"""Process all mythvideo video files, update the video files associated MythTV meta data.
+	Download graphics for those video files from either thetvdb.com or themovie.com. Video file names
 	for TV episodes must series name, season and episode numbers. The video file's movie name must be
     an exact match with a movie title in themoviedb.com or the MythTV database must have an entry for
     the video file with a TMDB or an IMDB number (db field 'intref').
@@ -2982,7 +3123,7 @@
 	# A dictionary of meta data keys and initialized values
 	global graphicsDirectories
 	movie_file_format=u"%s/%s.%s"
-	initialize_record = {u'subtitle': u'', u'director': u'Unknown', u'rating': u'NR', u'inetref': u'00000000', u'year': 1895, u'userrating': 0.0, u'length': 0, u'showlevel': 1, u'coverfile': u'No Cover', u'host': u'',}
+	initialize_record = {u'title': u'', u'subtitle': u'', u'director': u'Unknown', u'rating': u'NR', u'inetref': u'00000000', u'year': 1895, u'userrating': 0.0, u'length': 0, u'showlevel': 1, u'coverfile': u'No Cover', u'host': u'',}
 	graphic_suffix = {u'coverfile': u'_coverart', u'fanart': u'_fanart', u'banner': u'_banner'}
 	graphic_name_suffix = u"%s/%s%s.%s"
 	graphic_name_season_suffix = u"%s/%s Season %d%s.%s"
@@ -2992,7 +3133,7 @@
 		'''Get the MythTV subtitle (episode name)
 		return None
 		return episode name string
-		''' 
+		'''
 		self.config['sid']=None
 		self.config['episode_name'] = None
 		self.config['series_name']=cfile['file_seriesname']
@@ -3012,13 +3153,15 @@
 		if abpath == None:
 			return abpath
 
-		# There is a chance that this is already a relative path or there is no Storage group for file type 
-		if not len(storagegroups) or not storagegroups.has_key(filetype) or abpath[0] != '/':
+		# There is a chance that this is already a relative path or there is no Storage group for file type
+		if not len(storagegroups):
 			return abpath
+		if not storagegroups.has_key(filetype) or abpath[0] != '/':
+			return abpath
 
-		# The file must already be in one of the the directories specified by the file type's storage group
+		# The file must already be in one of the directories specified by the file type's storage group
 		for directory in storagegroups[filetype]:
-			if abpath.startswith(directory): 
+			if abpath.startswith(directory):
 				return abpath[len(directory)+1:]
 		else:
 			return abpath
@@ -3037,7 +3180,14 @@
 		if relpath[0] == u'/':
 			return relpath
 
-		for directory in self.config[filetype]:
+		if self.absolutepath:
+			if not len(self.config['localpaths'][filetype]):
+				return relpath
+			directories = self.config['localpaths'][filetype]
+		else:
+			directories = self.config[filetype]
+
+		for directory in directories:
 			abpath = u"%s/%s" % (directory, relpath)
 			if os.path.isfile(abpath): # The file must actually exist locally
 				return abpath
@@ -3075,6 +3225,9 @@
 				results = mdb.searchTMDB(IMDB)
 			else:
 				results = mdb.searchTitle(tmp_title)
+		except Exception, errormsg:
+			self._displayMessage(u"themoviedb.com error for Movie(%s) invalid data error (%s)" % (title, errormsg))
+			return False
 		except:
 			self._displayMessage(u"themoviedb.com error for Movie(%s)" % title)
 			return False
@@ -3138,7 +3291,7 @@
 						else:
 							TMDB_movies.append({'name': "%s" % (movie['alternative_title'], ), u'sid': movie[u'imdb']})
 							continue
-	
+
 		# When there is only one match but NO year to confirm then it is OK to assume an exact match
 		if len(TMDB_movies) == 1 and year == '':
 			if rtnyear:
@@ -3174,11 +3327,11 @@
 								return u"%07d" % int(movie) # Pad out IMDB# with leading zeroes
 				IMDB_movies.append({'name': tmp_movies[movie], u'sid': movie})
 
-		if len(IMDB_movies) == 1: # If this is the only choice and titles matched then auto pick it 
+		if len(IMDB_movies) == 1: # If this is the only choice and titles matched then auto pick it
 			if filter(is_not_punct_char, IMDB_movies[0]['name'][:-7]).lower() == filter(is_not_punct_char, name):
 				if rtnyear:
 					return IMDB_movies[0]
-				else:	
+				else:
 					return u"%07d" % int(IMDB_movies[0][u'sid'])
 
 		# Does IMDB list this movie?
@@ -3186,7 +3339,7 @@
 			return False
 
 		# Did the user want an interactive interface?
-		if not self.config['interactive']: 
+		if not self.config['interactive']:
 			return False
 
 		# Force only an IMDB look up for a movie
@@ -3273,7 +3426,10 @@
 
 		self.config['sid']=None
 		if watched:
-			self.config['g_series'] = cfile['file_seriesname']+self.graphic_suffix[rel_type]+u'.%(ext)s'
+			if self.program_seriesid == None:
+				self.config['g_series'] = sanitiseFileName(cfile['file_seriesname'])+self.graphic_suffix[rel_type]+u'.%(ext)s'
+			else:
+				self.config['g_series'] = sanitiseFileName(self.program_seriesid)+self.graphic_suffix[rel_type]+u'.%(ext)s'
 		else:
 			self.config['g_series'] = cfile['inetref']+self.graphic_suffix[rel_type]+u'.%(ext)s'
 		if graphic_type == '-P':
@@ -3289,7 +3445,7 @@
 		graphic_file = u"http://"+urllib.quote(tmp_URL.encode("utf-8"))
 		value = self._downloadGraphics(u"%s:%s" % (g_type, graphic_file), mythtv=True)
 
-		self.config['overwrite'] = False # Turn off overwriting 
+		self.config['overwrite'] = False # Turn off overwriting
 
 		if value == None:
 			self._displayMessage(u"2-tmdb %s for Movie not found(%s)(%s)" % (graphic_name, cfile['filename'], cfile['inetref']))
@@ -3322,7 +3478,7 @@
 							results = mdb.searchTMDB(cfile['inetref'])
 						except:
 							self._displayMessage(u"\n! Warning: Secondary themoviedb.com error for Movie(%s) graphics(%s)" % (cfile['file_seriesname'], graphic_type))
-							return None					
+							return None
 						if results == None:
 							return None
 						if not results.has_key('imdb'):
@@ -3344,7 +3500,7 @@
 		self.config['series_name']=cfile['file_seriesname']
 
 		if self.config['simulation']:
-			sys.stdout.write(u"Simulating - downloading Secondary Source graphic (%s)\n" % cfile['file_seriesname']) 
+			sys.stdout.write(u"Simulating - downloading Secondary Source graphic (%s)\n" % cfile['file_seriesname'])
 			return u"Simulated Secondary Source graphic filename place holder"
 
 		# Test that the secondary's required data has been passed
@@ -3368,14 +3524,17 @@
 			tmp_files=tmp_array[0].replace(u'file://', u'')
 			if not os.path.isfile(tmp_files):
 				sys.stderr.write(u'\n! Error: The graphic file does not exist (%s)\n' % tmp_files)
-				sys.exit(False)
+				sys.exit(1)
 
 			# Fix file extentions in all caps or 4 character JPEG extentions
 			fileExtension = (_getExtention(tmp_files)).lower()
 			if fileExtension == u'jpeg':
 				fileExtension = u'jpg'
 			if watched:
-				filename = u'%s/%s%s.%s' % (self.config['posterdir'][0], sanitiseFileName(cfile['file_seriesname']), self.graphic_suffix[rel_type], fileExtension)
+				if self.program_seriesid == None:
+					filename = u'%s/%s%s.%s' % (self.config['posterdir'][0], sanitiseFileName(cfile['file_seriesname']), self.graphic_suffix[rel_type], fileExtension)
+				else:
+					filename = u'%s/%s%s.%s' % (self.config['posterdir'][0], sanitiseFileName(self.program_seriesid), self.graphic_suffix[rel_type], fileExtension)
 			else:
 				filename = u'%s/%s%s.%s' % (self.config['posterdir'][0], cfile['inetref'], self.graphic_suffix[rel_type], fileExtension)
 
@@ -3406,9 +3565,12 @@
 
 			self.config['sid']=None
 			if watched:
-				self.config['g_series'] = cfile['file_seriesname']+self.graphic_suffix[rel_type]+'.%(ext)s'
+				if self.program_seriesid == None:
+					self.config['g_series'] = sanitiseFileName(cfile['file_seriesname'])+self.graphic_suffix[rel_type]+'.%(ext)s'
+				else:
+					self.config['g_series'] = sanitiseFileName(self.program_seriesid)+self.graphic_suffix[rel_type]+'.%(ext)s'
 			else:
-				self.config['g_series'] = cfile['inetref']+self.graphic_suffix[rel_type]+'.%(ext)s'
+				self.config['g_series'] = sanitiseFileName(cfile['inetref'])+self.graphic_suffix[rel_type]+'.%(ext)s'
 			g_type = graphic_type
 
 			self.config['season_num']= None	# Needed to get graphics named in 'g_series' format
@@ -3419,7 +3581,7 @@
 			graphic_file = u"http://"+urllib.quote(tmp_URL.encode("utf-8"))
 			value = self._downloadGraphics(u"%s:%s" % (g_type, graphic_file), mythtv=True)
 
-			self.config['overwrite'] = False # Turn off overwriting 
+			self.config['overwrite'] = False # Turn off overwriting
 			if value == None:
 				self._displayMessage(u"Secondary source %s not found(%s)(%s)" % (graphic_file, cfile['filename'], cfile['inetref']))
 				return None
@@ -3439,31 +3601,31 @@
 				continue
 			except:
 				if key == 'inetref' and available_metadata[key] != meta_dict[key]:
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'userrating' and available_metadata[key] == 0.0:
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'length' and available_metadata[key] == 0:
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'rating' and (available_metadata[key] == 'NR' or available_metadata[key] == 'Unknown'):
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'year' and available_metadata[key] == 1895:
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'category' and available_metadata[key] == 0:
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if key == 'inetref' and available_metadata[key] == '00000000':
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if vid_type and key == 'subtitle': # There are no subtitles in movies
 					continue
 				if key == 'plot': # Remove any line-feeds from the plot. Mythvideo does not expect them.
 					meta_dict[key] = meta_dict[key].replace('\n', ' ')
-				if (vid_type and key == 'plot') and (meta_dict[key].find('@') != -1 or len(meta_dict[key].split(' ')) < 10): 
+				if (vid_type and key == 'plot') and (meta_dict[key].find('@') != -1 or len(meta_dict[key].split(' ')) < 10):
 					continue
 				if vid_type and key == 'plot':
 					if available_metadata[key] != None:
@@ -3471,10 +3633,10 @@
 							available_metadata[key] = meta_dict[key]
 							continue
 				if not available_metadata.has_key(key): # Mainly for Genre and Cast
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 				if available_metadata[key] == None or available_metadata[key] == '' or available_metadata[key] == 'None' or available_metadata[key] == 'Unknown':
-					available_metadata[key] = meta_dict[key] 
+					available_metadata[key] = meta_dict[key]
 					continue
 		return available_metadata
 	# end combineMetaData
@@ -3542,7 +3704,10 @@
 			element = (element.rstrip('\n')).strip()
 			if element == '' or element == None:
 				continue
-			index = element.index(':')
+			try:
+				index = element.index(':')
+			except:
+				continue
 			key = element[:index].lower()
 			data = element[index+1:]
 			if data == None or data == '':
@@ -3622,9 +3787,9 @@
 			data = self._changeAmp(data)
 			data = self._changeToCommas(data)
 			if key == 'genres':
-				genres=''	
-				genre_array = data.split(',')			
-				for i in range(len(genre_array)): 
+				genres=''
+				genre_array = data.split(',')
+				for i in range(len(genre_array)):
 					genre_array[i] = (genre_array[i].strip()).lower()
 					try:
 						self.config['tmdb_genre_filter'].index(genre_array[i])
@@ -3658,7 +3823,7 @@
 
 		if meta_dict.has_key('rating'):
 			if meta_dict['rating'] == '':
-				meta_dict['rating'] = 'Unknown' 
+				meta_dict['rating'] = 'Unknown'
 		if len(meta_dict):
 			available_metadata = self.combineMetaData(available_metadata, meta_dict, vid_type=True)
 			return self._getSecondarySourceMetadata(cfile, available_metadata)
@@ -3712,12 +3877,16 @@
 				self._displayMessage(u"tvdb Series not found(%s)" % cfile['filename'])
 				return None
 
-		if watched: 
-			self.config['g_series'] = cfile['file_seriesname']+self.graphic_suffix[rel_type]+u'.%(ext)s'
-			self.config['g_season'] = cfile['file_seriesname']+u' Season %(seasonnumber)d'+self.graphic_suffix[rel_type]+u'.%(ext)s'
+		if watched:
+			if self.program_seriesid == None:
+				self.config['g_series'] = sanitiseFileName(cfile['file_seriesname'])+self.graphic_suffix[rel_type]+u'.%(ext)s'
+				self.config['g_season'] = sanitiseFileName(cfile['file_seriesname'])+u' Season %(seasonnumber)d'+self.graphic_suffix[rel_type]+u'.%(ext)s'
+			else:
+				self.config['g_series'] = sanitiseFileName(self.program_seriesid)+self.graphic_suffix[rel_type]+u'.%(ext)s'
+				self.config['g_season'] = sanitiseFileName(self.program_seriesid)+u' Season %(seasonnumber)d'+self.graphic_suffix[rel_type]+u'.%(ext)s'
 		else:
-			self.config['g_series'] = self.config['series_name']+self.graphic_suffix[rel_type]+u'.%(ext)s'
-			self.config['g_season'] = self.config['series_name']+u' Season %(seasonnumber)d'+self.graphic_suffix[rel_type]+u'.%(ext)s'
+			self.config['g_series'] = sanitiseFileName(self.config['series_name'])+self.graphic_suffix[rel_type]+u'.%(ext)s'
+			self.config['g_season'] = sanitiseFileName(self.config['series_name'])+u' Season %(seasonnumber)d'+self.graphic_suffix[rel_type]+u'.%(ext)s'
 		if toprated:
 			typegetGraphics=self.getTopRatedGraphics
 			self.config['season_num']= None	# Needed to get toprated graphics named in 'g_series' format
@@ -3732,7 +3901,7 @@
 		else:
 			return self.rtnRelativePath(value, graphicsDirectories[rel_type])
 	# end _getTvdbGraphics
-	
+
 	def _getTvdbMetadata(self, cfile, available_metadata):
 		'''Download thetvdb.com meta data
 		return what was input or results from a secondary source
@@ -3866,20 +4035,20 @@
 			text = text.replace(u'\u201d', u'"')
 		except UnicodeDecodeError:
 			pass
-			
+
 		return text
 	# end make_db_ready
 
 	def _addCastGenre(self, data_string, intid, cast_genres_type):
-		'''From a comma delimited string of cast members or genres add the ones 
-		not already in the myth db and update the video's meta data 
+		'''From a comma delimited string of cast members or genres add the ones
+		not already in the myth db and update the video's meta data
 		return True when successfull
 		return False if failed
 		'''
 		if data_string == '':
 			return True
 		data = data_string.split(',')
-		for i in range(len(data)): 
+		for i in range(len(data)):
 			data[i]=data[i].strip()
 		try:
 			data.remove('')
@@ -3919,7 +4088,7 @@
 		else:
 			if os.path.isfile(src):
 				(src, fileName) = os.path.split(src)
-				names = [fileName] 
+				names = [fileName]
 			else:
 				try:
 					names = os.listdir(unicode(src, 'utf8'))
@@ -3945,8 +4114,9 @@
 				continue
 			srcname = os.path.join(src, name)
 			dstname = os.path.join(dst, name)
-	
+
 			if not os.access(srcname, os.F_OK | os.R_OK | os.W_OK): # Skip any file that is not RW able
+				sys.stderr.write(u"\n! Error: The Source video directory or file (%s) must have read and write permissions for be moved. File or directory has been skipped\n" % (srcname))
 				continue
 			try:
 				if symlinks and os.path.islink(srcname):
@@ -3967,25 +4137,25 @@
 				else:
 					if self.config['simulation']:
 						if wild_card:
-							if srcname.startswith(org_src[:-1]): 
+							if srcname.startswith(org_src[:-1]):
 								sys.stdout.write(u"Simulation move wild card file from\n(%s) to\n(%s)\n" % (srcname, dstname))
 								self.num_moved_video_files+=1
 								self.new_names.append(dstname)
 							else:
-								self._displayMessage(u"Simulation of wildcard skipping file(%s)" % (srcname,)) 
+								self._displayMessage(u"Simulation of wildcard skipping file(%s)" % (srcname,))
 						else:
 							sys.stdout.write(u"Simulation move file from\n(%s) to\n(%s)\n" % (srcname, dstname))
 							self.num_moved_video_files+=1
 							self.new_names.append(dstname)
 					else:
 						if wild_card:
-							if srcname.startswith(org_src[:-1]): 
+							if srcname.startswith(org_src[:-1]):
 								self._displayMessage(u"Move wild card file from\n(%s) to\n(%s)\n" % (srcname, dstname))
 								shutil.move(srcname, dstname)
 								self.num_moved_video_files+=1
 								self.new_names.append(dstname)
 							else:
-								self._displayMessage(u"Wildcard skipping file(%s)" % (srcname,)) 
+								self._displayMessage(u"Wildcard skipping file(%s)" % (srcname,))
 						else:
 							self._displayMessage(u"Move file from\n(%s) to\n(%s)\n" % (srcname, dstname))
 							shutil.move(srcname, dstname)
@@ -4003,28 +4173,28 @@
 	# end _moveDirectoryTree
 
 	# local variable for move stats
-	num_moved_video_files=0	
-	num_created_video_subdirectories=0	
+	num_moved_video_files=0
+	num_created_video_subdirectories=0
 	num_symbolic_links=0
 
 	def _moveVideoFiles(self, target_destination_array):
 		"""Copy files or directories to a destination directory.
-		If the -F filename option is set then rename TV series during the move process. The move will 
+		If the -F filename option is set then rename TV series during the move process. The move will
 		be interactive for identifying a movie's IMDB number or TV series if the -i option was also set.
 		If there is a problem error message are displayed and the script exists. After processing
 		print a statistics report.
 		return a array of video file dictionaries to update in Mythvideo data base
 		"""
 		global UI_selectedtitle
-		# Validate that the targets and destinations actually exist. 
+		# Validate that the targets and destinations actually exist.
 		count=1
 		for file_dir in target_destination_array:
-			if os.access(file_dir, os.F_OK | os.R_OK | os.W_OK):
+			if os.access(file_dir, os.F_OK | os.R_OK):
 				if count % 2 == 0:
 					# Destinations must all be directories
 					if not os.path.isdir(file_dir):
 						sys.stderr.write(u"\n! Error: Destinations must all be directories.\nThis destination is not a directory (%s)\n" % (file_dir,))
-						sys.exit(False)
+						sys.exit(1)
 					else:
 						tmp_dir = file_dir
 						for directory in self.config['mythvideo']:
@@ -4033,10 +4203,10 @@
 								break
 						else:
 							sys.stderr.write(u"\n! Error: Destinations must all be a mythvideo directory or subdirectory.\nThis destination (%s) is not one of the Mythvideo directories(%s)\n" % (file_dir, self.config['mythvideo'], ))
-							sys.exit(False)
+							sys.exit(1)
 				# Verify that a target file is really a video file.
 				if file_dir[-1:] != '*': # Skip wildcard file name targets
-					if os.access(file_dir, os.F_OK | os.R_OK | os.W_OK):	# Confirm that the file actually exists
+					if os.access(file_dir, os.F_OK | os.R_OK):	# Confirm that the file actually exists
 						if not os.path.isdir(file_dir):
 							ext = _getExtention(file_dir)
 							for tmp_ext in self.config['video_file_exts']:
@@ -4044,7 +4214,7 @@
 									break
 							else:
 								sys.stderr.write(u"\n! Error: Target files must be video files(%s).\nSupported video file extentions(%s)\n" % (file_dir, self.config['video_file_exts'],))
-								sys.exit(False)
+								sys.exit(1)
 					count+=1
 
 		# Stats counters
@@ -4069,12 +4239,12 @@
 			else:
 				results = self._moveDirectoryTree(src, dst, symlinks=False, ignore=None)
 			if len(results[1]):			# Check if there are any errors
-				sys.stderr.write(u"\n! Warning: There where errors during moving, with these directories/files\n")
+				sys.stderr.write(u"\n! Warning: There were errors during moving, with these directories/files\n")
 				for error in results[1]:
 					sys.stderr.write(u'\n! Warning: Source(%s), Destination(%s), Reason:(%s)\n' % (error[0], error[1], error[2]))
 			tmp_cfile_array=[]
 			for name in results[0]:
-				file_name = os.path.join(dst, name)				
+				file_name = os.path.join(dst, name)
 				if os.path.isdir(file_name):
 					for dictionary in self._processNames(_getFileList([file_name]), verbose = self.config['debug_enabled'], movies=True):
 						tmp_cfile_array.append(dictionary)
@@ -4087,7 +4257,7 @@
 			for directory in self.config['mythvideo']:
 				if src.startswith(directory):
 					for cfile in tmp_cfile_array:
-						tmp_path = src+cfile['filepath'].replace(dst, '')
+						tmp_path = src+cfile['filepath'].replace(dst, u'')
 						video_file = self.rtnRelativePath(self.movie_file_format % (tmp_path, cfile['filename'], cfile['ext']), 'mythvideo')
 						tmp_filename = self.rtnRelativePath(self.movie_file_format % (cfile['filepath'], cfile['filename'], cfile['ext']), 'mythvideo')
 						intid = mythvideo.getMetadataId(video_file, localhostname.lower())
@@ -4097,8 +4267,11 @@
 							metadata = mythvideo.getMetadataDictionary(intid)
 							if tmp_filename[0] == '/':
 								host = u''
+								self.absolutepath = True
 							else:
 								host = localhostname.lower()
+								self.absolutepath = False
+
 							if self.config['simulation']:
 								sys.stdout.write(u"Simulation Mythdb update for old file:\n(%s) new:\n(%s)\n" % (video_file, tmp_filename))
 							else:
@@ -4109,7 +4282,7 @@
 			else:
 				pass
 			cfile_array.extend(tmp_cfile_array)
-			i+=2		# Increment by 2 because array is int pairs of target and destination	 
+			i+=2		# Increment by 2 because array is int pairs of target and destination
 
 		# Attempt to rename the video file
 		if self.config['ret_filename']:
@@ -4142,7 +4315,7 @@
 								continue
 						except imdb._exceptions.IMDbDataAccessError:
 							continue
-						
+
 					if not sid:	# Cannot find this movie skip the renaming
 						continue
 					inetref = sid
@@ -4174,6 +4347,9 @@
 					if self.config['simulation']:
 						sys.stdout.write(u"Simulation file renamed from(%s) to(%s)\n" % (video_file, tmp_filename))
 					else:
+						if not os.access(video_file, os.F_OK | os.R_OK | os.W_OK):
+							sys.stdout.write(u"Cannot rename this file as it does not have read/write permissions set (%s)\n" % video_file)
+							continue
 						self._displayMessage(u"File renamed from(%s) to(%s)\n" % (video_file, tmp_filename))
 						os.rename(video_file, tmp_filename)
 					num_renamed_files+=1
@@ -4184,8 +4360,10 @@
 						intid = mythvideo.getMetadataId(self.movie_file_format % (cfile['filepath'], cfile['filename'], cfile['ext']), localhostname.lower())
 					if tmp_filename[0] == '/':
 						host = u''
+						self.absolutepath = True
 					else:
 						host = localhostname.lower()
+						self.absolutepath = False
 					if intid:
 						metadata = mythvideo.getMetadataDictionary(intid)
 						if self.config['simulation']:
@@ -4215,7 +4393,7 @@
 	# end _moveVideoFiles
 
 	def _displayMessage(self, message):
-		"""Displays messages through stdout. Usually used with MythTv metadata updates in -V 
+		"""Displays messages through stdout. Usually used with MythTv metadata updates in -V
 		verbose mode.
 		returns nothing
 		"""
@@ -4234,7 +4412,7 @@
 
 		if not len(directories):
 			sys.stderr.write(u"\n! Error: There must be a video directory specified in MythTv\n")
-			sys.exit(False)
+			sys.exit(1)
 
 		allFiles = self._findFiles(directories, self.config['recursive'] , verbose = self.config['debug_enabled'])
 		validFiles = self._processNames(allFiles, verbose = self.config['debug_enabled'], movies=True)
@@ -4245,7 +4423,7 @@
 		for cfile in validFiles:
 			try:
 				videopath = self.movie_file_format % (cfile['filepath'], cfile['filename'], cfile['ext'])
-			except UnicodeDecodeError: 
+			except UnicodeDecodeError:
 				videopath = os.path.join(unicode(cfile['filepath'],'utf8'), unicode(cfile['filename'],'utf8')+u'.'+cfile['ext'])
 
 			# Find the MythTV meta data
@@ -4260,7 +4438,7 @@
 					if not mythvideo.hasMetadata(meta_dict[u'filename'], meta_dict[u'host']):
 						missing_list.append(cfile)
 						continue
-				# There must be an Internet reference number. Get one for new records. 
+				# There must be an Internet reference number. Get one for new records.
 				if _can_int(meta_dict['inetref']) and not meta_dict['inetref'] == u'00000000'  and not meta_dict['inetref'] == '':
 					continue
 				missing_list.append(cfile)
@@ -4321,12 +4499,13 @@
 		stats = {'coverfile': [0,0,0], 'banner': [0,0,0], 'fanart': [0,0,0]}
 
 		validFiles = self._processNames(self._findFiles(self.config['mythvideo'], self.config['recursive'] , verbose = False), verbose = False, movies=True)
-		
+
 		if not len(validFiles):
 			sys.stderr.write(u"\n! Warning: Janitor - did not find any video files to proccess\n")
 			return
 
 		graphics_file_dict={}
+		all_graphics_file_list=[]
 		for directory in graphicsDirectories.keys():
 			if directory == 'screenshot':
 				continue
@@ -4347,6 +4526,9 @@
 				else:
 					file_list.remove(g_file)
 					continue
+			for filel in file_list:
+				if not filel in all_graphics_file_list:
+					all_graphics_file_list.append(filel)
 			graphics_file_dict[directory] = file_list
 
 		for key in graphicsDirectories.keys():	# Set initial totals
@@ -4365,10 +4547,14 @@
 			if intid == None: # Skip video files that are not yet in the MythDB
 				continue
 			meta_dict=mythvideo.getMetadataDictionary(intid)
+			if meta_dict['filename'][0] == u'/':
+				self.absolutepath = True
+			else:
+				self.absolutepath = False
 			for key in graphicsDirectories.keys():
 				if key == 'screenshot':
 					continue
-				if meta_dict[key] == None or meta_dict[key] == '' or meta_dict[key] == 'None' or meta_dict[key] == 'Unknown':
+				if meta_dict[key] == None or meta_dict[key] == '' or meta_dict[key] == 'None' or meta_dict[key] == 'Unknown' or meta_dict[key] == 'No Cover':
 					continue
 
 				# Deal with videometadata record using storage groups
@@ -4384,18 +4570,22 @@
 					if filename in graphics_file_dict[key]: # No suffix
 						if self._checkValidGraphicFile(filename, graphicstype=key, vidintid=intid) == True:
 							graphics_file_dict[key].remove(filename)
+							all_graphics_file_list.remove(filename)
 					filename = os.path.join(dirName, u'%s%s%s' % (fileBaseName[:index], self.graphic_suffix[key], fileExtension))
 					if filename in graphics_file_dict[key]: # With suffix
 						if self._checkValidGraphicFile(filename, graphicstype=key, vidintid=intid) == True:
 							graphics_file_dict[key].remove(filename)
+							all_graphics_file_list.remove(filename)
 
 				if meta_dict[key] in graphics_file_dict[key]: # No suffix
 					if self._checkValidGraphicFile(meta_dict[key], graphicstype=key, vidintid=intid) == True:
 						graphics_file_dict[key].remove(meta_dict[key])
+						all_graphics_file_list.remove(meta_dict[key])
 				filename = os.path.join(dirName, u'%s%s%s' % (fileBaseName, self.graphic_suffix[key], fileExtension))
 				if filename in graphics_file_dict[key]: # With suffix
 					if self._checkValidGraphicFile(filename, graphicstype=key, vidintid=intid) == True:
 						graphics_file_dict[key].remove(filename)
+						all_graphics_file_list.remove(filename)
 
 		# Get Scheduled and Recorded program list
 		programs = self._getScheduledRecordedProgramList()
@@ -4417,33 +4607,37 @@
 							if fileBaseName.lower().startswith(program['seriesid'].lower()):
 								remove.append(graphic)
 								break
-							
+
 				for rem in remove:
 					if self._checkValidGraphicFile(rem, graphicstype=u'', vidintid=False) == True:
 						graphics_file_dict[field].remove(rem)
+						try:
+							all_graphics_file_list.remove(rem)
+						except ValueError:
+							pass
 
 		for key in graphicsDirectories.keys():	# Set deleted files totals
 			if key == 'screenshot':
 				continue
+			file_list = list(graphics_file_dict[key])
+			for filel in file_list:
+				if not filel in all_graphics_file_list:
+					graphics_file_dict[key].remove(filel)
 			stats[key][num_deleted] = len(graphics_file_dict[key])
 
 		# Delete all graphics files still on the delete list
-		for field in graphicsDirectories.keys():
-			if field == 'screenshot':
-				continue
+		for filel in all_graphics_file_list:
+			if self.config['simulation']:
+				sys.stdout.write(
+					u"Simulation deleting (%s)\n" % (filel)
+				)
+			else:
+				try:
+					os.remove(filel)
+				except OSError:
+					pass
+				self._displayMessage(u"(%s) Has been deleted\n" % (filel))
 
-			for graphic in graphics_file_dict[field]:
-				if self.config['simulation']:
-					sys.stdout.write(
-						u"Simulation deleting %s (%s)\n" % (field, graphic)
-					)
-				else:
-					try:
-						os.remove(graphic)
-					except OSError:
-						pass
-					self._displayMessage(u"%s (%s) Has been deleted\n" % (field, graphic))
-				
 		for key in graphicsDirectories.keys():	# Set new files totals
 			if key == 'screenshot':
 				continue
@@ -4516,7 +4710,7 @@
 
 	def removeMythvideoSeekTable(self, filename):
 		'''Remove seektable entries for a Mythvideo from the "filemarkup" table. Entries may of may not
-		exist. The deletes need to remove entries for both an absolute file path and a Storage Groups 
+		exist. The deletes need to remove entries for both an absolute file path and a Storage Groups
 		"myth://..." file name definition.
 		return nothing
 		'''
@@ -4573,7 +4767,7 @@
 		except MySQLdb.Error, e:
 			logger.error(u"SELECT intid FROM videometadata WHERE inetref = 99999999 and category = %d failed: %d: %s" % (category_id, e.args[0], e.args[1]))
 			c.close()
-			sys.exit(False)
+			sys.exit(1)
 		intids=[]
 		while True:
 			row = c.fetchone()
@@ -4594,7 +4788,7 @@
 			return videometadatarecords
 		else:
 			return None
-		# end _getMiroVideometadataRecords() 
+		# end _getMiroVideometadataRecords()
 
 	def _getExtraMiroDetails(self, mythvideorec, vidtype):
 		'''Find the extra details required for Miro MythVideo record processing
@@ -4613,6 +4807,10 @@
 				extradata[key] = False
 				continue
 			elif key == u'coverfile': # Look for undersized coverart
+				if mythvideorec[u'filename'][0] == u'/':
+					self.absolutepath = True
+				else:
+					self.absolutepath = False
 				filename = self.rtnAbsolutePath(mythvideorec[key], graphicsDirectories[key])
 				try:
 					(width, height) = self.config['image_library'].open(filename).size
@@ -4631,6 +4829,10 @@
 				continue
 
 		if vidtype == u'movies': # Data specific to Movie Trailers
+			if mythvideorec[u'filename'][0] == u'/':
+				self.absolutepath = True
+			else:
+				self.absolutepath = False
 			extradata[u'filename'] = mythvideorec[u'filename']
 			extradata[u'pathfilename'] = self.rtnAbsolutePath(mythvideorec[u'filename'], u'mythvideo')
 			if os.path.islink(extradata[u'pathfilename']):
@@ -4640,7 +4842,7 @@
 			moviename = mythvideorec['subtitle']
 			if not moviename:
 				moviename = ''
-			else: 
+			else:
 				index = moviename.find(self.config[u'mb_movies'][filter(is_not_punct_char, mythvideorec[u'title'].lower())])
 				if index != -1:
 					moviename = moviename[:index].strip()
@@ -4650,7 +4852,7 @@
 				lastyear = int(datetime.datetime.now().strftime(u"%Y"))
 				years = []
 				i = 0
-				while i < 5: # Check for a Movie that will be released this year or the next four years 
+				while i < 5: # Check for a Movie that will be released this year or the next four years
 					years.append(u"%d" % ((lastyear+i)))
 					i+=1
 				imdb_access = imdb.IMDb()
@@ -4687,17 +4889,15 @@
 		mirodetails = program[u'miro']
 
 		for intid in mirodetails[u'intid']:
-			changed_fields = {} 
+			changed_fields = {}
 			for key in graphicsDirectories.keys():
 				if key == u'screenshot':
 					continue
-				if mirodetails[key] != True and mirodetails[key] != False and mirodetails[key] != None and mirodetails[key] != u'Simulated Secondary Source graphic filename place holder': 
+				if mirodetails[key] != True and mirodetails[key] != False and mirodetails[key] != None and mirodetails[key] != u'Simulated Secondary Source graphic filename place holder':
 					# A graphics was downloaded
 					changed_fields[key] = mirodetails[key]
-					if changed_fields[key][0] != u'/':
-						changed_fields[u'host'] = localhostname.lower()
 
-			if not mirodetails[u'tv'] and not mirodetails[u'symlink'] and os.path.isfile(mirodetails[u'pathfilename']):
+			if not mirodetails[u'tv'] and not mirodetails[u'symlink'] and os.access(mirodetails[u'pathfilename'], os.F_OK | os.R_OK | os.W_OK):
 				changed_fields[u'inetref'] = mirodetails[u'inetref']
 				changed_fields[u'subtitle'] = u''
 				changed_fields[u'year'] = mirodetails[u'year']
@@ -4712,7 +4912,7 @@
 				while index != 0:
 					filename = sanitiseFileName(u'%s - Trailer %d' % (mirodetails[u'moviename'], index))
 					fullfilename = u'%s/%s%s' % (dirName, filename, fileExtension)
-					for flenme in dir_list: 
+					for flenme in dir_list:
 						if fnmatch.fnmatch(flenme.lower(), u'%s.*' % filename.lower()):
 							break
 					else:
@@ -4724,6 +4924,16 @@
 							os.rename(mirodetails[u'pathfilename'], fullfilename)
 							self.removeMythvideoSeekTable(mirodetails[u'pathfilename'])
 						changed_fields[u'filename'] = self.rtnRelativePath(fullfilename, u'mythvideo')
+						if changed_fields[u'filename'][0] != u'/':
+							changed_fields[u'host'] = localhostname.lower()
+						else:	# Deal with the whole mixing Video SG and local with SG graphics mess
+							for key in graphicsDirectories.keys():
+								if key == u'screenshot' or not changed_fields.has_key(key):
+									continue
+								if changed_fields[key][0] == u'/':
+									continue
+								else:
+									changed_fields.remove(key)
 						break
 					index+=1
 
@@ -4786,7 +4996,7 @@
 			for elem in data_id:
 				if table_names[i] == u'chanid' and elem == 9999:
 					recorded[u'miro_tv'] = True
-				if table_names[i] == 'title' or table_names[i] == 'subtitle' or table_names[i] == 'seriesid': 
+				if table_names[i] == 'title' or table_names[i] == 'subtitle' or table_names[i] == 'seriesid':
 					recorded[table_names[i]] = elem
 				i+=1
 
@@ -4816,7 +5026,7 @@
 			recorded = {}
 			i = 0
 			for elem in data_id:
-				if table_names[i] == 'title' or table_names[i] == 'subtitle' or table_names[i] == 'airdate': 
+				if table_names[i] == 'title' or table_names[i] == 'subtitle' or table_names[i] == 'airdate':
 					recorded[table_names[i]] = elem
 				i+=1
 
@@ -4885,7 +5095,7 @@
 						moviename = record['subtitle']
 						if not moviename:
 							moviename = ''
-						else:  
+						else:
 							index = moviename.find(self.config['mb_movies'][filter(is_not_punct_char, program[u'title'].lower())])
 							if index != -1:
 								moviename = moviename[:index].strip()
@@ -4931,6 +5141,7 @@
 		self.config['season_num'] = None
 		self.config['episode_num'] = None
 		series_graphics = self.getGraphics(graphics_type)
+
 		if series_graphics != None:
 			cfile = { 'file_seriesname': program['title'],
 					'inetref': self.config['sid'],
@@ -4948,7 +5159,7 @@
 	def _downloadScheduledRecordedGraphics(self):
 		'''Get Scheduled and Recorded programs and Miro vidoes get their graphics if not already
 		downloaded
-		return (nothing is returned) 
+		return (nothing is returned)
 		'''
 		global localhostname
 
@@ -4995,7 +5206,7 @@
 			program['need'] = False	# Initalize that this program does not need graphic(s) downloaded
 			mirodetails = None
 			if not program.has_key(u'miro'):
-				if program['subtitle']:				
+				if program['subtitle']:
 					graphics_name = program['title']
 				else:
 					if program['originalairdate'] == u'0000':
@@ -5008,6 +5219,9 @@
 					graphics_name = program['title']
 				else:
 					graphics_name = mirodetails[u'inetref']
+
+			self.absolutepath = False		# All Scheduled Recorded and Miro videos start in the SG "Default"
+
 			# Search for graphics that are already downloaded
 			for directory in graphicsDirectories.keys():
 				if directory == 'screenshot':	# There is no downloading of screenshots required
@@ -5026,9 +5240,12 @@
 					filename = program['title']
 				else:
 					filename = mirodetails[u'inetref']
-					
+
+				# Deal with TV series names that would generate invalid file names for images TV and movies
+				self.program_seriesid = None
 				if not isValidPosixFilename(filename) and program['seriesid'] != u'':
 					filename = program['seriesid']
+					self.program_seriesid = program['seriesid']
 
 				# Actual check for existing graphics
 				for dirct in self.config[graphicsDirectories[directory]]:
@@ -5036,14 +5253,14 @@
 						dir_list = os.listdir(unicode(dirct, 'utf8'))
 					except (UnicodeEncodeError, TypeError):
 						dir_list = os.listdir(dirct)
-					for flenme in dir_list: 
+					for flenme in dir_list:
 						if fnmatch.fnmatch(flenme.lower(), u'%s*.*' % filename.lower()):
 							program[directory] = True
 							if directory == 'coverfile':
 								total_posters_found +=1
 							elif directory == 'banner':
 								total_banners_found +=1
-							else: 
+							else:
 								total_fanart_found +=1
 							if mirodetails: # Update the Miro MythVideo records with any existing graphics
 								mirodetails[directory] = self.rtnRelativePath(u'%s/%s' % (dirct, flenme), directory)
@@ -5099,16 +5316,6 @@
 							filename = program['title']
 						else:
 							filename = mirodetails[u'moviename']
-						if not isValidPosixFilename(filename) and program['seriesid'] != u'' and not self.config['simulation']:
-							abs_results = self.rtnAbsolutePath(results, graphicsDirectories[key])
-							(dirName, fileName) = os.path.split(abs_results)
-							(fileBaseName, fileExtension) = os.path.splitext(fileName)
-							# Take graphics name apart and get new name with seriesid
-							newfilename = u"%s/%s%s" % (dirName, program['seriesid'], fileExtension)
-							if not os.path.isfile(newfilename):
-								os.rename(abs_results, newfilename)
-								results = self.rtnRelativePath(newfilename, graphicsDirectories[key])
-							
 						if key == 'coverfile':
 							total_posters_downloaded +=1
 						elif key == 'banner':
@@ -5142,16 +5349,6 @@
 					if not results:
 						results = self._getSecondarySourceGraphics(cfile, key, watched=True)
 					if results:
-						if not miromovieflag:
-							if not isValidPosixFilename(title) and program['seriesid'] != u'' and not self.config['simulation']:
-								abs_results = self.rtnAbsolutePath(results, graphicsDirectories[key])
-								(dirName, fileName) = os.path.split(abs_results)
-								(fileBaseName, fileExtension) = os.path.splitext(fileName)
-								# Take graphics name apart and get new name with seriesid
-								newfilename = u"%s/%s%s" % (dirName, program['seriesid'], fileExtension)
-								if not os.path.isfile(newfilename):
-									os.rename(abs_results, newfilename)
-									results = self.rtnRelativePath(newfilename, graphicsDirectories[key])
 						if key == 'coverfile':
 							total_posters_downloaded +=1
 						elif key == 'banner':
@@ -5172,7 +5369,7 @@
 
 		# Print statistics
 		sys.stdout.write(u'\n-----Scheduled & Recorded Statistics-------\nNumber of Scheduled & Recorded ......(% 5d)\nNumber of Fanart graphics found .....(% 5d)\nNumber of Poster graphics found .....(% 5d)\nNumber of Banner graphics found .....(% 5d)\nNumber of Fanart graphics downloaded (% 5d)\nNumber of Poster graphics downloaded (% 5d)\nNumber of Banner graphics downloaded (% 5d)\nNumber of Miro TV Shows ............ (% 5d)\nNumber of Miro Movie Trailers ...... (% 5d)\n' % (total_progs_checked, total_fanart_found, total_posters_found, total_banners_found, total_fanart_downloaded, total_posters_downloaded, total_banners_downloaded, total_miro_tv, total_miro_movies))
-		
+
 		if len(programs):
 			sys.stdout.write(u'\n-------------Scheduled & Recorded----------\n')
 			for program in programs:
@@ -5202,7 +5399,7 @@
 		'''
 		(dirName, fileName) = os.path.split(filename)
 		(fileBaseName, fileExtension) = os.path.splitext(fileName)
-		if fuzzy_match: # Match even when the names are not exactly the same by removing punctuation 
+		if fuzzy_match: # Match even when the names are not exactly the same by removing punctuation
 			for dirct in directories:
 				try:
 					dir_list = os.listdir(unicode(dirct, 'utf8'))
@@ -5229,7 +5426,7 @@
 						return u'%s/%s' % (dirct, dir_list[match_list.index(file_path)])
 			else:
 				return False
-		else: # Find an exact match 
+		else: # Find an exact match
 			for directory in directories:
 				if filename[0] != u'/' and dirName != u'':
 					dir_name = u"%s/%s" % (directory, dirName)
@@ -5261,26 +5458,27 @@
 	num_secondary_source_metadata_downloaded=0
 
 	def processMythTvMetaData(self):
-		'''Check each video file in the mythvideo directories download graphics files and meta data then 
+		'''Check each video file in the mythvideo directories download graphics files and meta data then
 		update MythTV data base meta data with any new information.
 		'''
 		# If there were directories specified move them and update the MythTV db meta data accordingly
 		if self.config['video_dir']:
 			if len(self.config['video_dir']) % 2 == 0:
 				validFiles = self._moveVideoFiles(self.config['video_dir'])
+				self.config[u'file_move_flag'] = False
 			else:
 				sys.stderr.write(u"\n! Error: When specifying target (file or directory) to move to a destination (directory) they must always be in pairs (target and destination directory).\nYou specified an uneven number of variables (%d) for target and destination pairs.\nVariable count (%s)\n" % (len(self.config['video_dir']), self.config['video_dir']))
-				sys.exit(False)
+				sys.exit(1)
 
 		# Check if only missing inetref video's should be processed
 		if self.config['mythtv_inetref']:
 			validFiles = self._findMissingInetref()
 			if validFiles == None:
 				sys.stderr.write(u"\n! Warning: There were no missing interef video files found.\n\n")
-				sys.exit(True)
+				sys.exit(0)
 			elif not len(validFiles):
 				sys.stderr.write(u"\n! Warning: There were no missing interef video files found.\n\n")
-				sys.exit(True)
+				sys.exit(0)
 
 		# Verify that the proper fields are present
 		db_version = mythdb.getSetting('DBSchemaVer')
@@ -5288,26 +5486,26 @@
 		for field in ['season', 'episode', 'coverfile', 'screenshot', 'banner', 'fanart']:
 			if not field in field_names:
 				sys.stderr.write(u"\n! Error: Your MythTv data base scheme version (%s) does not have the necessary fields at least (%s) is missing\n\n" % (db_version, field))
-				sys.exit(False)
+				sys.exit(1)
 
 		# Check if this is a Scheduled and Recorded graphics download request
 		if self.config['mythtv_watched']:
 			self._downloadScheduledRecordedGraphics()
-			sys.exit(True)
+			sys.exit(0)
 
 		# Check if this is just a Janitor (clean up unused graphics files) request
 		if self.config['mythtvjanitor']:
 			self._graphicsCleanup()
-			sys.exit(True)
+			sys.exit(0)
 
 		directories=self.config['mythvideo']
 
 		if not len(directories):
 			sys.stderr.write(u"\n! Error: There must be a video directory specified in MythTv\n")
-			sys.exit(False)
+			sys.exit(1)
 
 		# Set statistics
-		num_processed=0 			
+		num_processed=0
 		num_fanart_downloads=0
 		num_posters_downloads=0
 		num_banners_downloads=0
@@ -5329,7 +5527,7 @@
 
 		if len(validFiles) == 0:
 			sys.stderr.write(u"\n! Error: No valid video files found\n")
-			sys.exit(False)
+			sys.exit(1)
 
 		tv_series_season_format=u"%s/%s Season %d.%s"
 		tv_series_format=u"%s/%s.%s"
@@ -5350,7 +5548,7 @@
 				# Unless explicitly requested with options -MI or -MG do not add missing videos to DB
 				if not self.config['interactive'] and not self.config['mythtv_guess']:
 					continue
-				# Create a new empty entry 
+				# Create a new empty entry
 				sys.stdout.write(u"\n\nEntry does not exist in MythDB.  Adding (%s).\n" % cfile['filename'])
 				self.initialize_record['title'] = cfile['file_seriesname']
 				self.initialize_record['filename'] = self.rtnRelativePath(videopath, u'mythvideo')
@@ -5382,16 +5580,22 @@
 			available_metadata['episode']=cfile['epno']
 			available_metadata['title'] = cfile['file_seriesname']
 
-			# There must be an Internet reference number. Get one for new records. 
+			# Set whether a video file is stored in a Storage Group or not
+			if available_metadata['filename'][0] == u'/':
+				self.absolutepath = True
+			else:
+				self.absolutepath = False
+
+			# There must be an Internet reference number. Get one for new records.
 			if _can_int(meta_dict['inetref']) and not meta_dict['inetref'] == u'00000000' and not meta_dict['inetref'] == '':
-				if meta_dict['inetref'] == '99999999': # Records that are not updated by Jamu 
+				if meta_dict['inetref'] == '99999999': # Records that are not updated by Jamu
 					continue
 				inetref = meta_dict['inetref']
 				cfile['inetref'] = meta_dict['inetref']
 			else:
 				if movie:
 					if not self.config['interactive'] and not self.config['mythtv_guess']:
-						sys.stderr.write(u'\n! Warning: Skipping "%s" as there is no IMDB number for this movie.\nUse interactive option (-i) or (-I) to select the IMDB number.\n\n' % (cfile['file_seriesname'])) 
+						sys.stderr.write(u'\n! Warning: Skipping "%s" as there is no IMDB number for this movie.\nUse interactive option (-i) or (-I) to select the IMDB number.\n\n' % (cfile['file_seriesname']))
 						continue
 					inetref = self._getTmdbIMDB(available_metadata['title'])
 					cfile['inetref'] = inetref
@@ -5424,7 +5628,7 @@
 					available_metadata['title'] = self.config['series_name']
 					cfile['file_seriesname'] = self.config['series_name']
 
-			'''# Check if current inetref is a IMDB# 
+			'''# Check if current inetref is a IMDB#
 			# If so then check it could be changed to tmdb#
 			# If it can be changed then rename any graphics and update meta data
 			if movie and len(inetref) == 7:
@@ -5462,10 +5666,17 @@
 			# START of metadata Graphics logic - Checking, downloading, renaming
 			###############################################################################
 			for graphic_type in ['coverfile', 'banner', 'fanart']:
-				graphicsdirs = self.config[graphicsDirectories[graphic_type]]
 				###############################################################################
 				# START of MOVIE graphics updating
 				###############################################################################
+				# Check that there are local graphics path for abs path video
+				# An abs path video can only use the FE specified graphic directories
+				if self.absolutepath:
+					if not len(self.config['localpaths'][graphicsDirectories[graphic_type]]):
+						continue
+					graphicsdirs = self.config['localpaths'][graphicsDirectories[graphic_type]]
+				else:
+					graphicsdirs = self.config[graphicsDirectories[graphic_type]]
 				if movie:
 					if graphic_type == 'banner':
 						continue
@@ -5562,7 +5773,7 @@
 								if graphic_file.find(u' Season ') == -1: # Check for Season
 									must_rename = True
 									season_missing = True
-								if graphic_file.find(self.graphic_suffix[graphic_type]) == -1: 
+								if graphic_file.find(self.graphic_suffix[graphic_type]) == -1:
 									must_rename = True
 									suffix_missing = True
 								if must_rename:
@@ -5586,7 +5797,7 @@
 								else:
 									available_metadata[graphic_type]= self.rtnRelativePath(graphic_file,  graphicsDirectories[graphic_type])
 							else: # Must see if a graphic is on thetvdb wiki
-								if graphic_type == 'coverfile' or graphic_type == 'banner': 
+								if graphic_type == 'coverfile' or graphic_type == 'banner':
 									available_metadata[graphic_type] = self.rtnRelativePath(self._getTvdbGraphics(cfile, graphic_type),  graphicsDirectories[graphic_type])
 									if available_metadata[graphic_type] == None:
 										tmp = self._getTvdbGraphics(cfile, graphic_type, toprated=True)
@@ -5645,9 +5856,9 @@
 					else:
 						if graphic_type == 'coverfile' or graphic_type == 'banner':
 							for ext in self.image_extensions:
-								filename = self.findFileInDir(u"%s.%s" % (sanitiseFileName(available_metadata['title']), ext), self.config[graphicsDirectories[graphic_type]], suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
+								filename = self.findFileInDir(u"%s.%s" % (sanitiseFileName(available_metadata['title']), ext), graphicsdirs, suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
 								if filename:
-									size = self.findFileInDir(u"%s Season %d.%s" % (sanitiseFileName(available_metadata['title']), available_metadata['season'], ext), self.config[graphicsDirectories[graphic_type]], suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
+									size = self.findFileInDir(u"%s Season %d.%s" % (sanitiseFileName(available_metadata['title']), available_metadata['season'], ext), graphicsdirs, suffix=self.graphic_suffix[graphic_type], fuzzy_match=True)
 									if not size:
 										continue
 									if os.path.getsize(size) == os.path.getsize(filename):
@@ -5716,10 +5927,9 @@
 			# Check if any meta data needs updating
 			metadata_update = True
 			for key in available_metadata.keys():
-				try:
-					dummy = self.config['metadata_exclude_as_update_trigger'].index(key)
+				if key in self.config['metadata_exclude_as_update_trigger']:
 					continue
-				except:
+				else:
 					if key == 'rating' and (available_metadata[key] == 'NR' or available_metadata[key] ==  '' or available_metadata[key] == 'Unknown'):
 						self._displayMessage(
 						u"At least (%s) needs updating\n" % (key))
@@ -5778,7 +5988,7 @@
 				else:
 					tmp_dict = self._getTvdbMetadata(cfile, copy)
 				num_episode_metadata_downloads+=1
-				# Update meta data 
+				# Update meta data
 				if tmp_dict:
 					tmp_dict['title'] = cfile['file_seriesname']
 					for key in ['genres', 'cast']:
@@ -5825,17 +6035,28 @@
 				self._displayMessage(u"Changed category from 0 to 1 for (%s)" % available_metadata['title'])
 				available_metadata['category'] = 1
 
-			# Make sure host name is set if any relative paths were used
-			for key in [u'filename', u'coverfile', u'trailer', u'screenshot', u'banner', u'fanart']:
-				if available_metadata[key] != None and available_metadata[key] != u'No Cover' and available_metadata[key] != u'':
-					if available_metadata[key][0] != u'/':
-						available_metadata[u'host'] = localhostname.lower()
+			# Make sure graphics relative/absolute paths are set PROPERLY based
+			# on the 'filename' field being a relative or absolute path. A filename with an absolite path
+			# CAN ONLY have graphics baed on absolute paths.
+			# A filename with a relative path can have mixed absolute and relative path graphic files
+			if available_metadata[u'filename'][0] == u'/':
+				available_metadata[u'host'] = u''
+				for key in [u'coverfile', u'banner', u'fanart']:
+					if available_metadata[key] != None and available_metadata[key] != u'No Cover' and available_metadata[key] != u'':
+						if available_metadata[key][0] != u'/':
+							tmp = self.rtnAbsolutePath(available_metadata[key], graphicsDirectories[key])
+							if tmp[0] != u'/':
+								if key == u'coverfile':
+									available_metadata[key] = u'No Cover'
+								else:
+									available_metadata[key] = u''
+			else:
+				available_metadata[u'host'] = localhostname.lower()
 
 			###############################################################################
 			# END of metadata text logic - Checking, downloading, renaming
 			###############################################################################
 
-
 			###############################################################################
 			# START of metadata updating the MythVideo record when graphics or text has changed
 			###############################################################################
@@ -5886,6 +6107,9 @@
 		# Fix all the directory cover images
 		if self.config['folderart']:
 			for cfile in validFiles:
+				# Skip directories that do not have RW access because folder art files cannot be created
+				if not os.access(cfile['filepath'], os.F_OK | os.R_OK | os.W_OK):
+					continue
 				videopath = tv_series_format % (cfile['filepath'], cfile['filename'], cfile['ext'])
 				# Find the MythTV meta data
 				intid = mythvideo.getMetadataId(videopath, localhostname.lower())
@@ -5907,7 +6131,14 @@
 				# Get a dictionary of the existing meta data
 				meta_dict=mythvideo.getMetadataDictionary(intid)
 
-				# There must be an Internet reference number. Get one for new records. 
+				if meta_dict['filename'][0] == u'/':
+					if not len(self.config['localpaths']['posters']):
+						continue
+					posterdirs = self.config['localpaths']['posters']
+				else:
+					posterdirs = self.config['posters']
+
+				# There must be an Internet reference number. Get one for new records.
 				if _can_int(meta_dict['inetref']) and not meta_dict['inetref'] == u'00000000' and not meta_dict['inetref'] == u'':
 					if meta_dict['inetref'] == u'99999999':
 						continue
@@ -5940,7 +6171,7 @@
 				for d in sub_path.split(u'/'):
 					dir_array.append([u"%s/%s" % (base_dir+dir_subs, d), d])
 					dir_subs+=u'/'+d
-			
+
 				for directory in dir_array:
 					for ext in self.image_extensions:
 						tmp_file = u"%s/%s.%s" % (directory[0], directory[1], ext)
@@ -5958,17 +6189,17 @@
 						if os.path.isfile(tmp_file):
 							if os.path.isfile(os.path.realpath(tmp_file)): # Check for broken symbolic links
 								os.rename(tmp_file, folder_name)
-								break 
+								break
 						if os.path.isfile(folder_name):
 							if os.path.isfile(os.path.realpath(folder_name)): # Check for broken symbolic links
-								break 
+								break
 					else:
 						for pattern in self.config['season_dir_pattern']:
-							match = pattern.match(directory[1]) 
+							match = pattern.match(directory[1])
 							if match:
 								season_num = int((match.groups())[0])
 								for ext in self.image_extensions:
-									filename = self.findFileInDir(u"%s Season %d.%s" % (sanitiseFileName(cfile['file_seriesname']), season_num, ext), self.config['posterdir'])
+									filename = self.findFileInDir(u"%s Season %d.%s" % (sanitiseFileName(cfile['file_seriesname']), season_num, ext), posterdirs)
 									if filename:
 										if self.config['simulation']:
 											sys.stdout.write(
@@ -5984,11 +6215,11 @@
 										break
 						else:
 							if movie:
-								name = inetref							
+								name = inetref
 							else:
 								name = sanitiseFileName(cfile['file_seriesname'])
 							for ext in self.image_extensions:
-								filename = self.findFileInDir(u"%s.%s" % (name, ext), self.config['posterdir'])
+								filename = self.findFileInDir(u"%s.%s" % (name, ext), posterdirs)
 								if filename:
 									if self.config['simulation']:
 										sys.stdout.write(
@@ -6011,7 +6242,7 @@
 
 		# Print statistics
 		sys.stdout.write(u'\n------------------Statistics---------------\nNumber of video files processed .....(% 5d)\nNumber of Fanart graphics downloaded (% 5d)\nNumber of Poster graphics downloaded (% 5d)\nNumber of Banner graphics downloaded (% 5d)\nNumber of 2nd source graphics downld (% 5d)\nNumber of metadata downloads.........(% 5d)\nNumber of 2nd source metadata found .(% 5d)\nNumber of symbolic links created.....(% 5d)\nNumber of Myth database updates......(% 5d)\nNumber of undersized posters ........(% 5d)\n' % (num_processed, num_fanart_downloads, num_posters_downloads, num_banners_downloads, self.num_secondary_source_graphics_downloaded, num_episode_metadata_downloads, self.num_secondary_source_metadata_downloaded, num_symlinks_created, num_mythdb_updates, num_posters_below_min_size))
-		
+
 		if len(videos_updated_metadata):
 			sys.stdout.write(u'\n--------------Updated Video Files----------\n' )
 			for videofile in videos_updated_metadata:
@@ -6028,7 +6259,7 @@
 		return None
 	# end processMythTvMetaData
 
-	def __repr__(self):	# Just a place holder 
+	def __repr__(self):	# Just a place holder
 		return self.config
 	# end __repr__
 
@@ -6036,7 +6267,7 @@
 
 def simple_example():
 	"""Simple example of using jamu
-	Displays the poster graphics URL(s) and episode meta data for the TV series Sanctuary, season 1 
+	Displays the poster graphics URL(s) and episode meta data for the TV series Sanctuary, season 1
 	episode 3
 	returns None if there was no data found for the request TV series
 	returns False if there is no TV series as specified
@@ -6063,7 +6294,7 @@
 
 def main():
 	"""Support jamu from the command line
-	returns True 
+	returns True
 	"""
  	parser = OptionParser(usage=u"%prog usage: jamu -hbueviflstdnmoCRFUDSGN [parameters]\n <series name/SID or 'series/SID and season number' or 'series/SID and season number and episode number' or 'series/SID and episode name' or video file/directory paired with destination directory'>")
 
@@ -6131,16 +6362,16 @@
 
 	if opts.usage:					# Display usage information
 		sys.stdout.write(usage_txt+'\n')
-		sys.exit(True)
+		sys.exit(0)
 
 	if opts.examples:					# Display example information
 		sys.stdout.write(examples_txt+'\n')
-		sys.exit(True)
+		sys.exit(0)
 
 	if opts.version == True:		# Display program information
 		sys.stdout.write(u"\nTitle: (%s); Version: (%s); Author: (%s)\n%s\n" % (
 		__title__, __version__, __author__, __purpose__ ))
-		sys.exit(True)
+		sys.exit(0)
 
 	# Apply any command line switches
 	configuration.changeVariable('local_language', opts.language)
@@ -6178,7 +6409,7 @@
 		else:
 			configuration.validate_setVariables(['FAKE SERIES NAME','FAKE EPISODE NAME'])
 		configuration.displayOptions()
-		sys.exit(True)
+		sys.exit(0)
 
 	# Validate specific variables
 	configuration.validate_setVariables(series_season_ep)
Index: mythplugins/mythvideo/mythvideo/scripts/ttvdb.py
===================================================================
--- mythplugins/mythvideo/mythvideo/scripts/ttvdb.py	(revision 22751)
+++ mythplugins/mythvideo/mythvideo/scripts/ttvdb.py	(working copy)
@@ -99,18 +99,20 @@
 							#              Added a tvdb_api version check and abort if not at least v1.0
 							#              Changed to new tvdb_api's method of assigning the tvdb api key
 							# Version .9.7 Account for TVDB increasing the number of digits in their
-							#              SID number (now greater then 5 
+							#              SID number (now greater then 5
 							#              e,g, "Defying Gravity" is SID 104581)
-							# Version .9.8 Added a (-S) option for requesting a thetvdb  
+							# Version .9.8 Added a (-S) option for requesting a thetvdb
 							#              episode screen shot
 							# Version .9.9 Fixed the -S option when NO episode image exists
-							# Version 1.0. Removed LF and replace with a space for all TVDB metatdata 
+							# Version 1.0. Removed LF and replace with a space for all TVDB metatdata
                             #              fields
-							# Version 1.0.1 Return all graphics (series and season) in the order 
-							#               highest to lowest as rated by users 
-							# Version 1.0.2 Added better error messages to config file checking. Updated to 
+							# Version 1.0.1 Return all graphics (series and season) in the order
+							#               highest to lowest as rated by users
+							# Version 1.0.2 Added better error messages to config file checking. Updated to
 							#				v1.0.2 tvdb_api which contained fixes for concurrent instances
 							#               of ttvdb.py generated by MythVideo.
+# Post MythTV 0.22 release changes (ttvdb.py release numbers will not be changed tracking is by SVN number):
+# Fixed error in the detection of available images when there are only season level images
 
 usage_txt='''
 This script fetches TV series information from theTVdb.com web site. The script conforms to MythTV's
@@ -418,7 +420,7 @@
 
 	This interface will be improved in future versions.
 	Changed in this interface is that a list or URLs is created to preserve the user rating order from
-	top rated to lowest rated. 
+	top rated to lowest rated.
 	"""
 
 	self.log.debug('Getting season banners for %s' % (sid))
@@ -1025,9 +1027,9 @@
 	global SID
 	SID = False
 	if _can_int(series_season_ep[0]): # if it is numeric then assume it is a series ID number
-			SID = True
+		SID = True
 	else:
-			SID = False
+		SID = False
 
 	if opts.debug == True:
 		print "# ..got tvdb mirrors"
@@ -1135,26 +1137,6 @@
 		print "# Checking if Posters, Fanart or Banners are available"
 		print "#"*20
 
-	if opts.configure != "" and override.has_key(series_season_ep[0].lower()):
-		banners_keys = search_for_series(t, override[series_season_ep[0].lower()][0])['_banners'].keys()
-	else:
-		banners_keys = search_for_series(t, series_season_ep[0])['_banners'].keys()
-	banner= False
-	poster= False
-	fanart= False
-
-	for x in banners_keys: # Determine what type of graphics is available
-		if x == fanart_key:
-			fanart=True
-		elif x== poster_key:
-			poster=True
-		elif x==season_key or x==banner_key:
-			banner=True
-
-	# Make sure that some graphics URL(s) (Posters, FanArt or Banners) are available
-	if ( fanart!=True and poster!=True and banner!=True ):
-		sys.exit(True)
-
 	if opts.debug == True:
 		print "#"*20
 		print "# One or more of Posters, Fanart or Banners are available"
@@ -1199,7 +1181,7 @@
 					print u"Banner:%s" % (search_for_series(t, series_name)['banner']).replace(http_find, http_replace)
 		sys.exit(True) # Only the top rated for a TV Series is returned
 
-	if (poster==True and opts.poster==True and opts.raw!=True): # Get posters and send to stdout
+	if (opts.poster==True and opts.raw!=True): # Get posters and send to stdout
 		season_poster_found = False
 		if opts.mythvideo:
 			if len(series_season_ep) < 2:
@@ -1214,13 +1196,14 @@
 				series_name=override[series_season_ep[0].lower()][0] # Override series name
 			else:
 				series_name=series_season_ep[0] # Leave the series name alone
-			print (search_for_series(t, series_name)['poster']).replace(http_find, http_replace)
+			if search_for_series(t, series_name)['poster']:
+				print (search_for_series(t, series_name)['poster']).replace(http_find, http_replace)
 
-	if (fanart==True and opts.fanart==True and opts.raw!=True): # Get Fan Art and send to stdout
+	if (opts.fanart==True and opts.raw!=True): # Get Fan Art and send to stdout
 		for f in get_graphics(t, opts, series_season_ep, fanart_type, single_option, opts.language):
 			print f
 
-	if (banner==True and opts.banner==True and opts.raw!=True): # Get Banners and send to stdout
+	if (opts.banner==True and opts.raw!=True): # Get Banners and send to stdout
 		season_banner_found = False
 		if opts.mythvideo:
 			if len(series_season_ep) < 2:
@@ -1235,7 +1218,7 @@
 				series_name=override[series_season_ep[0].lower()][0] # Override series name
 			else:
 				series_name=series_season_ep[0] # Leave the series name alone
-			if search_for_series(t, series_name)['banner'] != None:
+			if search_for_series(t, series_name)['banner']:
 				print (search_for_series(t, series_name)['banner']).replace(http_find, http_replace)
 
 	if opts.debug == True:
Index: mythplugins/mythvideo/mythvideo/videodlg.cpp
===================================================================
--- mythplugins/mythvideo/mythvideo/videodlg.cpp	(revision 22751)
+++ mythplugins/mythvideo/mythvideo/videodlg.cpp	(working copy)
@@ -4234,7 +4234,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                         QStringList(m_d->m_artDir), cover_file,
                         metadata->GetTitle(), metadata->GetSeason(),
-                        metadata->GetHost(), "Coverart"))
+                        metadata->GetHost(), "Coverart", metadata->GetEpisode()))
         {
             metadata->SetCoverFile(cover_file);
         }
@@ -4253,7 +4253,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                         QStringList(m_d->m_fanDir), fanart_file,
                         metadata->GetTitle(), metadata->GetSeason(),
-                        metadata->GetHost(), "Fanart"))
+                        metadata->GetHost(), "Fanart", metadata->GetEpisode()))
         {
             metadata->SetFanart(fanart_file);
         }
@@ -4262,7 +4262,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                         QStringList(m_d->m_banDir), banner_file,
                         metadata->GetTitle(), metadata->GetSeason(),
-                        metadata->GetHost(), "Banners"))
+                        metadata->GetHost(), "Banners", metadata->GetEpisode()))
         {
             metadata->SetBanner(banner_file);
         }
@@ -4292,7 +4292,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                                 cover_dirs, cover_file, metadata->GetTitle(),
                                 metadata->GetSeason(), metadata->GetHost(),
-                                "Coverart"))
+                                "Coverart", metadata->GetEpisode()))
         {
             metadata->SetCoverFile(cover_file);
             OnVideoImageSetDone(metadata);
@@ -4318,7 +4318,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                                 fanart_dirs, fanart_file, metadata->GetTitle(),
                                 metadata->GetSeason(), metadata->GetHost(),
-                                "Fanart"))
+                                "Fanart", metadata->GetEpisode()))
         {
             metadata->SetFanart(fanart_file);
             OnVideoImageSetDone(metadata);
@@ -4344,7 +4344,7 @@
         if (GetLocalVideoImage(metadata->GetInetRef(), metadata->GetFilename(),
                                 banner_dirs, banner_file, metadata->GetTitle(),
                                 metadata->GetSeason(), metadata->GetHost(),
-                                "Banners"))
+                                "Banners", metadata->GetEpisode()))
         {
             metadata->SetBanner(banner_file);
             OnVideoImageSetDone(metadata);
@@ -4460,6 +4460,20 @@
                 else
                     title = QString("%1 Season %2_%3").arg(metadata->GetTitle())
                             .arg(season).arg(suffix);
+
+                title.remove('?');
+                title.remove('<');
+                title.remove('>');
+                title.remove('/');
+                title.remove('\\');
+                title.remove('|');
+                title.remove('*');
+                title.remove('[');
+                title.remove(']');
+                title.remove(':');
+                title.remove('"');
+                title.remove('^');
+
                 if (!host.isEmpty())
                 {
                     QString combFileName = QString("%1.%2").arg(title)
Index: mythplugins/mythvideo/mythvideo/main.cpp
===================================================================
--- mythplugins/mythvideo/mythvideo/main.cpp	(revision 22880)
+++ mythplugins/mythvideo/mythvideo/main.cpp	(working copy)
@@ -517,6 +517,7 @@
         {
             if (LCD *lcd = LCD::Get())
             {
+                lcd->setFunctionLEDs(FUNC_MOVIE, false);
                 lcd->switchToTime();
             }
             GetMythMainWindow()->GetMainStack()->AddScreen(diag);
Index: mythplugins/mythvideo/mythvideo/playercommand.cpp
===================================================================
--- mythplugins/mythvideo/mythvideo/playercommand.cpp	(revision 22880)
+++ mythplugins/mythvideo/mythvideo/playercommand.cpp	(working copy)
@@ -5,6 +5,7 @@
 #include <mythtv/libmythui/mythmainwindow.h>
 #include <mythtv/libmythui/mythsystem.h>
 #include <mythtv/libmyth/remoteutil.h>
+#include <mythtv/lcddevice.h>
 
 #include "dbaccess.h"
 #include "metadata.h"
@@ -391,11 +392,19 @@
 
 void VideoPlayerCommand::Play() const
 {
+    class LCD *lcd = LCD::Get();
+
+    if (lcd) {
+        lcd->setFunctionLEDs(FUNC_TV, false);
+        lcd->setFunctionLEDs(FUNC_MOVIE, true);
+    }
     m_d->Play();
     gContext->GetMainWindow()->raise();
     gContext->GetMainWindow()->activateWindow();
     if (gContext->GetMainWindow()->currentWidget())
         gContext->GetMainWindow()->currentWidget()->setFocus();
+    if (lcd)
+        lcd->setFunctionLEDs(FUNC_MOVIE, false);
 }
 
 QString VideoPlayerCommand::GetCommandDisplayName() const
Index: mythplugins/mythnews/mythnews/mythnews.cpp
===================================================================
--- mythplugins/mythnews/mythnews/mythnews.cpp	(revision 22751)
+++ mythplugins/mythnews/mythnews/mythnews.cpp	(working copy)
@@ -103,16 +103,16 @@
     bool err = false;
     UIUtilE::Assign(this, m_sitesList, "siteslist", &err);
     UIUtilE::Assign(this, m_articlesList, "articleslist", &err);
-
-    UIUtilW::Assign(this, m_nositesText, "nosites", &err);
-    UIUtilE::Assign(this, m_updatedText, "updated", &err);
     UIUtilE::Assign(this, m_titleText, "title", &err);
     UIUtilE::Assign(this, m_descText, "description", &err);
 
-    UIUtilE::Assign(this, m_thumbnailImage, "thumbnail", &err);
-    UIUtilE::Assign(this, m_enclosureImage, "enclosures", &err);
-    UIUtilE::Assign(this, m_downloadImage, "download", &err);
-    UIUtilE::Assign(this, m_podcastImage, "ispodcast", &err);
+    // these are all optional
+    UIUtilW::Assign(this, m_nositesText, "nosites", &err);
+    UIUtilW::Assign(this, m_updatedText, "updated", &err);
+    UIUtilW::Assign(this, m_thumbnailImage, "thumbnail", &err);
+    UIUtilW::Assign(this, m_enclosureImage, "enclosures", &err);
+    UIUtilW::Assign(this, m_downloadImage, "download", &err);
+    UIUtilW::Assign(this, m_podcastImage, "ispodcast", &err);
 
     if (err)
     {
@@ -156,12 +156,19 @@
 
     m_titleText->SetText("");
     m_descText->SetText("");
+
     if (m_updatedText)
         m_updatedText->SetText("");
 
-    m_downloadImage->Hide();
-    m_enclosureImage->Hide();
-    m_podcastImage->Hide();
+    if (m_downloadImage)
+        m_downloadImage->Hide();
+
+    if (m_enclosureImage)
+        m_enclosureImage->Hide();
+
+    if (m_podcastImage)
+        m_podcastImage->Hide();
+
     if (m_thumbnailImage)
         m_thumbnailImage->Hide();
 }
@@ -352,31 +359,43 @@
                 }
             }
 
-            if (!article.enclosure().isEmpty())
+            if (m_downloadImage)
             {
-                if (!m_downloadImage->IsVisible())
-                    m_downloadImage->Show();
+                if (!article.enclosure().isEmpty())
+                {
+                    if (!m_downloadImage->IsVisible())
+                        m_downloadImage->Show();
+                }
+                else
+                    m_downloadImage->Hide();
             }
-            else
-                m_downloadImage->Hide();
 
-            if (!article.enclosure().isEmpty())
+            if (m_enclosureImage)
             {
-                if (!m_enclosureImage->IsVisible())
-                    m_enclosureImage->Show();
+                if (!article.enclosure().isEmpty())
+                {
+                    if (!m_enclosureImage->IsVisible())
+                        m_enclosureImage->Show();
+                }
+                else
+                    m_enclosureImage->Hide();
             }
-            else
-                m_enclosureImage->Hide();
 
-            m_podcastImage->Hide();
+            if (m_podcastImage)
+                m_podcastImage->Hide();
         }
     }
     else
     {
-        m_downloadImage->Hide();
-        m_enclosureImage->Hide();
-        m_podcastImage->Hide();
+        if (m_downloadImage)
+            m_downloadImage->Hide();
 
+        if (m_enclosureImage)
+            m_enclosureImage->Hide();
+
+        if (m_podcastImage)
+            m_podcastImage->Hide();
+
         if (site)
         {
             if (m_titleText)
@@ -388,7 +407,7 @@
             if (m_thumbnailImage && m_thumbnailImage->IsVisible())
                 m_thumbnailImage->Hide();
 
-            if (site->podcast() == 1)
+            if (m_podcastImage && site->podcast() == 1)
                 m_podcastImage->Show();
 
             if (!site->imageURL().isEmpty())
@@ -715,7 +734,8 @@
                         .arg(formatSize(progress, 2))
                         .arg(formatSize(total, 2))
                         .arg(floor(fProgress*100));
-                m_updatedText->SetText(text);
+                if (m_updatedText)
+                    m_updatedText->SetText(text);
             }
             qApp->processEvents();
             usleep(100000);
Index: mythplugins/mythmusic/mythmusic/main.cpp
===================================================================
--- mythplugins/mythmusic/mythmusic/main.cpp	(revision 22880)
+++ mythplugins/mythmusic/mythmusic/main.cpp	(working copy)
@@ -21,6 +21,7 @@
 #include <mythtv/compat.h>
 #include <mythtv/libmythui/mythuihelper.h>
 #include <mythtv/libmythui/mythprogressdialog.h>
+#include <mythtv/lcddevice.h>
 
 // MythMusic headers
 #include "decoder.h"
@@ -527,6 +528,11 @@
     gMusicData->startdir = startdir;
     gMusicData->all_playlists = all_playlists;
     gMusicData->all_music = all_music;
+
+    if (LCD *lcd = LCD::Get())
+    {
+        lcd->setFunctionLEDs(FUNC_MUSIC, true);
+    }
 }
 
 static void postMusic()
@@ -548,6 +554,11 @@
     gMusicData->all_music = NULL;
     delete gMusicData->all_playlists;
     gMusicData->all_playlists = NULL;
+
+    if (LCD *lcd = LCD::Get())
+    {
+        lcd->setFunctionLEDs(FUNC_MUSIC, false);
+    }
 }
 
 int mythplugin_run(void)
Index: mythplugins/mythweather/mythweather/main.cpp
===================================================================
--- mythplugins/mythweather/mythweather/main.cpp	(revision 22880)
+++ mythplugins/mythweather/mythweather/main.cpp	(working copy)
@@ -142,8 +142,10 @@
     menu->setKillable();
     if (menu->foundTheme())
     {
-        if (LCD *lcd = LCD::Get())
+        if (LCD *lcd = LCD::Get()) {
+            lcd->setFunctionLEDs(FUNC_NEWS, false);
             lcd->switchToTime();
+        }
 
         GetMythMainWindow()->GetMainStack()->AddScreen(menu);
         return 0;
Index: mythplugins/mythgallery/mythgallery/imageview.cpp
===================================================================
--- mythplugins/mythgallery/mythgallery/imageview.cpp	(revision 22880)
+++ mythplugins/mythgallery/mythgallery/imageview.cpp	(working copy)
@@ -152,9 +152,11 @@
 
     if (!item)
     {
+        lcd->setFunctionLEDs(FUNC_PHOTO, false);
         lcd->switchToTime();
         return;
     }
+    lcd->setFunctionLEDs(FUNC_PHOTO, true);
 
     QString name = item->GetName();
     QString desc = QString::number(m_pos + 1) + " / " +
