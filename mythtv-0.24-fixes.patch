diff -Naurp mythtv-0.24.orig/bindings/python/MythTV/dataheap.py mythtv-0.24.fixes/bindings/python/MythTV/dataheap.py
--- mythtv-0.24.orig/bindings/python/MythTV/dataheap.py	2010-11-02 23:15:16.000000000 -0400
+++ mythtv-0.24.fixes/bindings/python/MythTV/dataheap.py	2011-03-24 22:18:50.000000000 -0400
@@ -863,7 +863,7 @@ class Video( VideoSchema, DBDataWrite, C
         return vid
 
     def _playOnFe(self, fe):
-        return fe.send('play','filename myth://Videos@%s/%s' % 
+        return fe.send('play','file myth://Videos@%s/%s' % 
                     (self.host, self.filename))
 
 class VideoGrabber( Grabber ):
diff -Naurp mythtv-0.24.orig/bindings/python/MythTV/__init__.py mythtv-0.24.fixes/bindings/python/MythTV/__init__.py
--- mythtv-0.24.orig/bindings/python/MythTV/__init__.py	2010-09-09 01:11:01.000000000 -0400
+++ mythtv-0.24.fixes/bindings/python/MythTV/__init__.py	2011-03-24 22:18:50.000000000 -0400
@@ -53,8 +53,10 @@ from methodheap import *
 from sys import version_info
 if version_info >= (2, 6): # 2.6 or newer
     exec(import26)
-else:
+elif version_info >= (2, 5):
     exec(importall)
+else:
+    raise Exception("The MythTV Python bindings will only operate against Python 2.5 or later.")
 
 __version__ = OWN_VERSION
 static.mysqldb = MySQLdb.version_info
diff -Naurp mythtv-0.24.orig/bindings/python/MythTV/methodheap.py mythtv-0.24.fixes/bindings/python/MythTV/methodheap.py
--- mythtv-0.24.orig/bindings/python/MythTV/methodheap.py	2010-09-23 00:01:58.000000000 -0400
+++ mythtv-0.24.fixes/bindings/python/MythTV/methodheap.py	2011-03-24 22:18:50.000000000 -0400
@@ -11,7 +11,7 @@ from exceptions import *
 from logging import MythLog
 from connections import FEConnection, XMLConnection
 from utility import databaseSearch, datetime
-from database import DBCache
+from database import DBCache, DBData
 from system import SystemEvent
 from mythproto import BEEvent, FileOps, Program, FreeSpace
 from dataheap import *
@@ -20,6 +20,9 @@ from datetime import timedelta
 from weakref import proxy
 import re
 
+class CaptureCard( DBData ):
+    pass
+
 class MythBE( FileOps ):
     __doc__ = FileOps.__doc__+"""
         getPendingRecordings()    - returns a list of scheduled recordings
@@ -50,7 +53,7 @@ class MythBE( FileOps ):
                                     and dictionary of filenames with sizes
     """
 
-    locked_tuners = []
+    locked_tuners = {}
 
     def __del__(self):
         self.freeTuner()
@@ -110,51 +113,77 @@ class MythBE( FileOps ):
         Returns an ID of -2 if tuner is locked
                          -1 if no tuner could be found
         """
-        local = True
         cmd = 'LOCK_TUNER'
+        be = self
+
         if id is not None:
+            card = None
+            try:
+                # pull information from database to confirm existance
+                card = CaptureCard(id)
+            except MythError:
+                raise MythError("Capture card %s not found" % id)
+
             cmd += ' %d' % id
-            res = self.getRecorderDetails(id).hostname
-            if res != self.localname():
-                local = False
-
-        res = ''
-        if local:
-            res = self.backendCommand(cmd).split(BACKEND_SEP)
-        else:
-            myth = MythTV(res)
-            res = myth.backendCommand(cmd).split(BACKEND_SEP)
-            myth.close()
-        res[0] = int(res[0])
-        if res[0] > 0:
-            self.locked_tuners.append(res[0])
+            if card.hostname != be.hostname:
+                # connect to slave backend if needed
+                be = MythBE(card.hostname, db=self.db)
+
+        res = be.backendCommand(cmd).split(BACKEND_SEP)
+        err = int(res[0])
+
+        if err > 0:
+            # success, store tuner and return device nodes
+            self.locked_tuners[err] = be.hostname
             return tuple(res[1:])
-        return res[0]
 
+        # return failure mode
+        return err
 
     def freeTuner(self,id=None):
         """
         Frees a requested tuner ID
         If no ID given, free all tuners listed as used by this class instance
         """
-        def free(self,id):
-            res = self.getRecorderDetails(id).hostname
-            if res == self.localname():
-                self.backendCommand('FREE_TUNER %d' % id)
+        tunerlist = {}
+
+        if id is not None:
+            id = int(id)
+            if id in self.locked_tuners:
+                # tuner is known, pop from list
+                tunerlist[id] = self.locked_tuners.pop(id)
+
             else:
-                myth = MythTV(res)
-                myth.backendCommand('FREE_TUNER %d' % id)
-                myth.close()
-
-        if id is None:
-            for i in xrange(len(self.locked_tuners)):
-                free(self,self.locked_tuners.pop())
+                # tuner is not known, find hostname
+                try:
+                    card = CaptureCard(id)
+                except MythError:
+                    raise MythError("Capture card %s not found" % id)
+                tunerlist[id] = card.hostname
         else:
+            # use the stored list
+            tunerlist = self.locked_tuners
+
+        hosts = {self.hostname:self}
+
+        while True:
             try:
-                self.locked_tuners.remove(id)
-            except:
-                pass
-            free(self,id)
+                # get a tuner
+                id, host = tunerlist.popitem()
+
+                # get the backend connection
+                be = None
+                if host in hosts:
+                    be = hosts[host]
+                else:
+                    be = MythBE(host, db=self.db)
+                    hosts[host] = be
+
+                # unlock the tuner
+                be.backendCommand('FREE_TUNER %d' % id)
+            except KeyError:
+                # out of tuners
+                break
 
     def getCurrentRecording(self, recorder):
         """
@@ -625,9 +654,9 @@ class MythDB( DBCache ):
             return ('recorded.%s=%%s' % key, datetime.duck(value), 0)
 
         if key == 'olderthan':
-            return ('recorded.starttime>%s', datetime.duck(value), 0)
-        if key == 'newerthan':
             return ('recorded.starttime<%s', datetime.duck(value), 0)
+        if key == 'newerthan':
+            return ('recorded.starttime>%s', datetime.duck(value), 0)
 
 
         # recordedprogram matches
@@ -641,8 +670,9 @@ class MythDB( DBCache ):
             return ('people.name', 'recordedcredits', 4, 1)
 
         if key == 'livetv':
-            if value is None:
+            if (value is None) or (value == False):
                 return ('recorded.recgroup!=%s', 'LiveTV', 0)
+            return ()
 
         return None
 
diff -Naurp mythtv-0.24.orig/bindings/python/MythTV/mythproto.py mythtv-0.24.fixes/bindings/python/MythTV/mythproto.py
--- mythtv-0.24.orig/bindings/python/MythTV/mythproto.py	2010-10-14 11:36:31.000000000 -0400
+++ mythtv-0.24.fixes/bindings/python/MythTV/mythproto.py	2011-03-24 22:18:50.000000000 -0400
@@ -188,7 +188,7 @@ def ftopen(file, mode, forceremote=False
     db = DBCache(db)
     log = MythLog('Python File Transfer', db=db)
     reuri = re.compile(\
-        'myth://((?P<group>.*)@)?(?P<host>[a-zA-Z0-9_\.]*)(:[0-9]*)?/(?P<file>.*)')
+        'myth://((?P<group>.*)@)?(?P<host>[a-zA-Z0-9_\-\.]*)(:[0-9]*)?/(?P<file>.*)')
     reip = re.compile('(?:\d{1,3}\.){3}\d{1,3}')
 
     if mode not in ('r','w'):
diff -Naurp mythtv-0.24.orig/bindings/python/MythTV/static.py mythtv-0.24.fixes/bindings/python/MythTV/static.py
--- mythtv-0.24.orig/bindings/python/MythTV/static.py	2010-10-08 13:55:04.000000000 -0400
+++ mythtv-0.24.fixes/bindings/python/MythTV/static.py	2011-03-24 22:18:50.000000000 -0400
@@ -4,7 +4,7 @@
 Contains any static and global variables for MythTV Python Bindings
 """
 
-OWN_VERSION = (0,24,0,0)
+OWN_VERSION = (0,24,0,2)
 SCHEMA_VERSION = 1264
 MVSCHEMA_VERSION = 1038
 NVSCHEMA_VERSION = 1007
diff -Naurp mythtv-0.24.orig/bindings/python/MythTV/system.py mythtv-0.24.fixes/bindings/python/MythTV/system.py
--- mythtv-0.24.orig/bindings/python/MythTV/system.py	2010-10-08 13:55:04.000000000 -0400
+++ mythtv-0.24.fixes/bindings/python/MythTV/system.py	2011-03-24 22:18:50.000000000 -0400
@@ -36,8 +36,21 @@ class System( DBCache ):
             if path is None:
                 raise MythError('Invalid input to System()')
             self.path = path
-        if not os.access(self.path, os.F_OK):
-            raise MythFileError('Defined grabber path does not exist.')
+
+        cmd = self.path.split()[0]
+        if self.path.startswith('/'):
+            # test full given path
+            if not os.access(cmd, os.F_OK):
+                raise MythFileError('Defined executable path does not exist.')
+        else:
+            # search command from PATH
+            for folder in os.environ['PATH'].split(':'):
+                if os.access(os.path.join(folder,cmd), os.F_OK):
+                    self.path = os.path.join(folder,self.path)
+                    break
+            else:
+                raise MythFileError('Defined executable path does not exist.')
+
         self.returncode = 0
         self.stderr = ''
 
@@ -195,7 +208,12 @@ class InternetMetadata( Metadata ):
 
 class Grabber( System ):
     def _processMetadata(self, xml):
-        for item in etree.fromstring(xml).getiterator('item'):
+        try:
+            xml = etree.fromstring(xml)
+        except:
+            raise StopIteration
+
+        for item in xml.getiterator('item'):
             yield self.cls(item)
  
     def command(self, *args):
diff -Naurp mythtv-0.24.orig/bindings/python/MythTV/utility.py mythtv-0.24.fixes/bindings/python/MythTV/utility.py
--- mythtv-0.24.orig/bindings/python/MythTV/utility.py	2010-10-13 17:26:06.000000000 -0400
+++ mythtv-0.24.fixes/bindings/python/MythTV/utility.py	2011-03-24 22:18:50.000000000 -0400
@@ -180,7 +180,9 @@ class databaseSearch( object ):
                     raise TypeError(errstr % (self.__name__, key))
                 res[0] = 'NOT '+res[0]
 
-            if len(res) == 3:
+            if len(res) == 0:
+                continue
+            elif len(res) == 3:
                 # normal processing
                 where.append(res[0])
                 fields.append(res[1])
diff -Naurp mythtv-0.24.orig/configure mythtv-0.24.fixes/configure
--- mythtv-0.24.orig/configure	2010-11-08 12:40:43.000000000 -0500
+++ mythtv-0.24.fixes/configure	2011-03-24 22:18:50.000000000 -0400
@@ -742,7 +742,7 @@ check_ld(){
         test "${f}" = "${f#-l}" && flags="$flags $f" || libs="$libs $f"
     done
     check_cc $($filter_cflags $flags) || return
-    check_cmd $ld $LDFLAGS $flags -o $TMPE $TMPO $extralibs $libs
+    check_cmd $ld $LDFLAGS $flags -o $TMPE $TMPO $libs $extralibs
 }
 
 check_cppflags(){
@@ -1955,6 +1955,8 @@ enable avutil
 enable asm
 enable debug
 #enable doc
+enable ffmpeg
+enable ffplay
 enable fastdiv
 enable gpl
 enable mpegaudio_hp
@@ -3040,6 +3042,8 @@ case $target_os in
         enabled ppc && add_asflags -force_cpusubtype_ALL
         # Workaround compile errors from missing u_int/uint def
         CPPFLAGS=`echo $CPPFLAGS | sed 's/-D_POSIX_C_SOURCE=200112//'`
+        # Workaround compile errors from missing ru_maxrss
+        add_cppflags -D_DARWIN_C_SOURCE
         enable  appleremote
         enable  backend
         enable  darwin
@@ -4770,7 +4774,8 @@ SLIB_EXTRA_CMD=${SLIB_EXTRA_CMD}
 SLIB_INSTALL_EXTRA_CMD=${SLIB_INSTALL_EXTRA_CMD}
 SLIB_UNINSTALL_EXTRA_CMD=${SLIB_UNINSTALL_EXTRA_CMD}
 EOF
-cat >> external/FFmpeg/config.mak < $MYTH_CONFIG_MAK
+# Strip out the old dirs that we are about to put back in.
+sed -e '/^S?H?LIBDIR=.*$/d' -e '/^INCDIR=.*$/d' -e '/^BINDIR=.*$/d' -e '/^DATADIR=.*$/d' -e '/^MANDIR=.*$/d' $MYTH_CONFIG_MAK >> external/FFmpeg/config.mak
 cat >> external/FFmpeg/config.mak <<EOF
 LIBDIR=\$(INSTALL_ROOT)$libdir
 SHLIBDIR=\$(INSTALL_ROOT)$shlibdir
diff -Naurp mythtv-0.24.orig/docs/mythtv-HOWTO.sgml mythtv-0.24.fixes/docs/mythtv-HOWTO.sgml
--- mythtv-0.24.orig/docs/mythtv-HOWTO.sgml	2010-09-09 13:48:05.000000000 -0400
+++ mythtv-0.24.fixes/docs/mythtv-HOWTO.sgml	2011-03-24 22:18:50.000000000 -0400
@@ -1258,11 +1258,11 @@ like this:
 
 The <tt>lircd.conf</tt> file can have multiple remote controls defined.
 
-The second part is <tt>lircrc</tt>, which takes the name of the button which
+The second part is <tt>~/.lircrc</tt>, which takes the name of the button which
 was pressed ("ChannelUp") in the above example, and associates that to an
 action to be performed by a program using the remote control.  So in MythTV,
 ChannelUp means one thing, while in <bf>mplayer</bf> it means something
-different.  <tt>lircrc</tt> gives you the flexibility of taking the name of
+different.  <tt>~/.lircrc</tt> gives you the flexibility of taking the name of
 the button and having it perform different actions depending on which
 program you're using at the time.
 
@@ -1270,7 +1270,7 @@ program you're using at the time.
 community, and there is no standard for the common button names.  One
 <tt>lircd.conf</tt> file may contain a definition for a button called
 "ChannelUp", while another may contain a definition for "Chan+".  Your
-<tt>lircrc</tt> file must therefore be configured appropriately, or it won't
+<tt>~/.lircrc</tt> file must therefore be configured appropriately, or it won't
 work.
 
 Look for pre-made lircd.conf configuration files at <url
@@ -1309,15 +1309,23 @@ The next step is to convert those signal
 to control MythTV.  MythTV now includes native support for lirc and can
 interact directly with it.
 
+Example <tt>~/.lircrc</tt> files for configuring remote controls for MythTV are
+available in the <url
+url="http://www.mythtv.org/wiki/Category:LIRC_Configuration_Files"
+name="LIRC Configuration Files"> category of the MythTV wiki.  There are also
+many pages providing details for specific remote controls in the <url
+url="http://www.mythtv.org/wiki/Category:Remote_Controls"
+name="Remote Controls"> category of the wiki.
+
+After browsing the available configuration files,
+you may copy/paste the desired configuration information into
+<tt>~/.lircrc</tt> or download it from the wiki.
 <tscreen><verb>
-$ cd mythtv/contrib/config_files/lirc
-$ cp lircrc.example ~/.lircrc
+$ mythwikiscripts
 </verb></tscreen>
-or
-<tscreen><verb>
-$ cp lircrc.example.pinnaclestudiopctv ~/.lircrc
-</verb></tscreen>
-if you've got a Pinnacle Studio PCTV remote.
+Follow the on-screen prompts to download the configuration file.
+
+Once you've put the desired configuration into <tt>~/.lircrc</tt>, test it.
 <tscreen><verb>
 $ irw
 </verb></tscreen>
@@ -1341,12 +1349,13 @@ If <bf>irxevent</bf> isn't running, then
 control unless you're using native lirc support.
 
 <sect1>Additional information for lirc
-<p>Take a look at the lircrc.example files in the <tt>contrib/configfiles/</tt>
-directory.  In my case, (Pinnacle Studio card) the channel up and down functions
-weren't working, due to the fact that the button names were different than
-the default <tt>lircrc.example</tt> file that came with MythTV.
+<p>Take a look at the example <tt>~/.lircrc</tt> files in the <url
+url="http://www.mythtv.org/wiki/Category:LIRC_Configuration_Files"
+name="MythTV wiki">.  In my case, (Pinnacle Studio card) the channel up and
+down functions weren't working, due to the fact that the button names were
+different from the example <tt>~/.lircrc</tt> I used to start my configuration.
 
-The <tt>lircrc.example</tt> file has this:
+The example file had this:
 <tscreen><verb>
 begin
     prog = irxevent
@@ -1384,15 +1393,16 @@ begin
 end
 </verb></tscreen>
 which took care of basic functionality.  Because the PCTV Studio remote
-has additional buttons, look at the
-<tt>contrib/config_files/lirc/lircrc.example.pinnaclestudiopctv</tt> for an example of how
+has additional buttons, look at the <url
+url="http://www.mythtv.org/wiki/Lircrc_-_Pinnacle_Studio_PCTV"
+name="lircrc - Pinnacle Studio PCTV"> page for an example of how
 to define additional buttons, and how to debug potential button name
-conflicts between the <tt>lircrc.example</tt> file and how <bf>your</bf>
+conflicts between your <tt>~/.lircrc</tt> file and how <bf>your</bf>
 remote defines the button names.
 
 By examining the button names defined in <tt>/etc/lircd.conf</tt> and using
 the <bf>irw</bf> program to make sure that your remote is working, you can
-create the appropriate mappings in <tt>.lircrc</tt> to get excellent remote
+create the appropriate mappings in <tt>~/.lircrc</tt> to get excellent remote
 functionality with MythTV.
 
 Note the <bf>repeat =</bf> parameter.  This informs the <tt>irxevent</tt>
@@ -1987,8 +1997,9 @@ $ ./channel_icons.pl --find-missing --re
 
 If you do not have XMLTV software installed and do not want to install it
 for the sake of this minor task, there is a generic
-<tt>contrib/master_iconmap.xml</tt> which you can copy and use but this may
-not be as complete as using the specific information for your service.
+<tt>contrib/icons/master_iconmap/master_iconmap.xml</tt> which you can copy
+and use but this may not be as complete as using the specific information
+for your service.
 
 <!-- FIX XXXXXXX -->
 Once you have an <tt>iconmap.xml</tt> file, add the icon information to your
@@ -2696,9 +2707,10 @@ mythbackend configuration GUI.
 
 However, there is not <bf>changechannel</bf> program per-se, because this is
 going to be dependent on what sort of external tuner you have.  Look in the
-<tt>contrib/channel_changers</tt> directory for a number of programs and
-scripts which may be used to change channels.  Once you find one which
-works, copy it to <tt>/usr/local/bin/changechannel</tt>.
+<url url="http://www.mythtv.org/wiki/Category:Channel_Change_Scripts"
+name="Channel Change Scripts"> category of the MythTV wiki for a number of
+programs and scripts which may be used to change channels.  Once you find one
+which works, copy it to <tt>/usr/local/bin/changechannel</tt>.
 
 Feel free to browse some of what sort of hardware is available at <url
 url="http://store.snapstream.com/accessories.html"
@@ -5513,7 +5525,9 @@ $ cat vidout > video.yuv
 
 <sect1>Using a different window manager
 <p>MythTV is not dependent on any particular window manager.  If you wish to
-run a lightweight window manager, the <tt>contrib/configfiles/</tt> directory has an
+run a lightweight window manager, the
+<url url="http://www.mythtv.org/wiki/Category:Window_Manager_Configuration_Files"
+name="Window Manager Configuration Files"> category of the MythTV wiki has an
 example of a <tt>.twmrc</tt> and <tt>.fvwmrc</tt> file you may use.
 
 <sect1>What capture resolution should I use?  How does video work?
@@ -5837,30 +5851,36 @@ session.screen0.focusModel:     SloppyFo
 
 <label id="mythbackend_autostart">
 <sect1>Automatically starting mythbackend at system boot time
+<p>There are several example start scripts in the
+<url url="http://www.mythtv.org/wiki/Category:Startup_Scripts"
+name="Startup Scripts"> category of the MythTV wiki.
 <sect2>Red Hat And Mandriva
-<p>Here's a method for automatically starting mythbackend submitted by Mike
-Thomson (<url url="mailto:linux@m-thomson.net" name="mailto:linux@m-thomson.net">) and Stu Tomlinson (<url
-url="mailto:stu@nosnilmot.com" name="mailto:stu@nosnilmot.com">).
-
-Copy the files from the MythTV <tt>contrib</tt> directory or from Mike's web
-site (<url url="http://m-thomson.net/mythtv/"
-name="http://m-thomson.net/mythtv/">) as follows:
+<p>Here's a method for automatically starting mythbackend on Fedora.
+
+Copy the files from the
+<url url="http://www.mythtv.org/wiki/Fedora_init.d_mythbackend"
+name="Fedora init.d mythbackend"> page of the MythTV wiki as follows:
 
-<tt>etc.rc.d.init.mythbackend</tt> should be made executable and copied to
-<tt>/etc/rc.d/init.d/</tt>:
 <tscreen><verb>
-$ cd contrib
+$ mythwikiscripts
+</verb></tscreen>
+and follow the on-screen prompts to download <tt>Fedora - mythbackend
+init</tt>, choosing to save the files to temporary files
+<tt>/tmp/sysconfig.mythbackend</tt> and <tt>/tmp/init.mythbackend</tt>.
+
+<tt>/tmp/init.mythbackend</tt> should be made executable and copied to
+<tt>/etc/rc.d/init.d/</tt>
+<tscreen><verb>
 $ su
-# chmod a+x etc.rc.d.init.d.mythbackend
-# cp etc.rc.d.init.d.mythbackend /etc/rc.d/init.d/mythbackend
+# chmod a+x /tmp/init.mythbackend
+# cp /tmp/init.mythbackend /etc/rc.d/init.d/mythbackend
 </verb></tscreen>
 
-<tt>etc.sysconfig.mythbackend</tt> should be copied to
+<tt>/tmp/sysconfig.mythbackend</tt> should be copied to
 <tt>/etc/sysconfig/</tt>:
 <tscreen><verb>
-$ cd contrib
 $ su
-# cp etc.sysconfig.mythbackend /etc/sysconfig/mythbackend
+# cp /tmp/sysconfig.mythbackend /etc/sysconfig/mythbackend
 </verb></tscreen>
 
 Edit <tt>/etc/sysconfig/mythbackend</tt> if you want to change the defaults
@@ -5969,12 +5989,19 @@ following:
 /var/log/mythtv/*               root.mythtv             664
 </verb></tscreen>
 
-A copy of the above has been included in the contrib/ directory.  You may
-add it by typing:
+A copy of the above has been included in the
+<url url="http://www.mythtv.org/wiki/Mandriva_Security_Package_Configuration"
+name="Mandriva Security Package Configuration"> page on the MythTV wiki.
+You may add it by typing:
+<tscreen><verb>
+$ mythwikiscripts
+</verb></tscreen>
+and follow the on-screen prompts to download <tt>msec Configuration File</tt>
+to a temporary file <tt>/tmp/msec.perm.local</tt>.
+
 <tscreen><verb>
-$ cd contrib
 $ su
-# cat etc.security.msec.perm.local >> /etc/security/msec/perm.local
+# cat /tmp/msec.perm.local >> /etc/security/msec/perm.local
 # exit
 </verb></tscreen>
 
@@ -6441,8 +6468,12 @@ direct serial connection is more reliabl
 that have a Low Speed Data port have it enabled; you may need to convince
 your service provider to turn it on.  Stating that you have a Tivo may help;
 the Tivo has a direct-connect capability.
-<item>Use a firewire connection.  There is a <tt>6200ch.c</tt> in the MythTV
-contrib directory which may work for you.
+<item>Use a firewire connection.  There are firewire channel change scripts and
+firewire priming scripts in the
+<url url="http://www.mythtv.org/wiki/Category:Channel_Change_Scripts"
+name="Channel_Change_Scripts"> and
+<url url="http://www.mythtv.org/wiki/Category:Firewire_Priming_Scripts"
+name="Firewire Priming Scripts"> categories of the MythTV wiki.
 </enum>
 <sect1>Configuring one machine to flag all commercials
 <p>Commercial flagging can be CPU intensive.  By default, the backend that
diff -Naurp mythtv-0.24.orig/external/FFmpeg/libavcodec/dvbsubdec.c mythtv-0.24.fixes/external/FFmpeg/libavcodec/dvbsubdec.c
--- mythtv-0.24.orig/external/FFmpeg/libavcodec/dvbsubdec.c	2010-09-02 22:21:18.000000000 -0400
+++ mythtv-0.24.fixes/external/FFmpeg/libavcodec/dvbsubdec.c	2011-03-24 22:18:50.000000000 -0400
@@ -1481,6 +1481,7 @@ static int dvbsub_decode(AVCodecContext 
                 break;
             case DVBSUB_DISPLAYDEFINITION_SEGMENT:
                 dvbsub_parse_display_definition_segment(avctx, p, segment_length);
+                break;
             case DVBSUB_DISPLAY_SEGMENT:
                 *data_size = dvbsub_display_end_segment(avctx, p, segment_length, sub);
                 break;
diff -Naurp mythtv-0.24.orig/external/FFmpeg/libavformat/mpegts.c mythtv-0.24.fixes/external/FFmpeg/libavformat/mpegts.c
--- mythtv-0.24.orig/external/FFmpeg/libavformat/mpegts.c	2010-10-16 17:30:31.000000000 -0400
+++ mythtv-0.24.fixes/external/FFmpeg/libavformat/mpegts.c	2011-03-24 22:18:50.000000000 -0400
@@ -638,6 +638,7 @@ static void mpegts_push_section(MpegTSFi
     if (sect->new_packet && pkt && sect->st) {
         int pktLen = section_len + 184; /* Add enough for a complete TS payload. */
         sect->new_packet = 0;
+        av_free_packet(pkt);
         if (av_new_packet(pkt, pktLen) == 0) {
             memcpy(pkt->data, section, section_len);
             memset(pkt->data+section_len, 0xff, pktLen-section_len);
diff -Naurp mythtv-0.24.orig/external/FFmpeg/libavformat/rmdec.c mythtv-0.24.fixes/external/FFmpeg/libavformat/rmdec.c
--- mythtv-0.24.orig/external/FFmpeg/libavformat/rmdec.c	2010-08-23 12:54:20.000000000 -0400
+++ mythtv-0.24.fixes/external/FFmpeg/libavformat/rmdec.c	2011-03-24 22:18:50.000000000 -0400
@@ -294,18 +294,17 @@ ff_rm_read_mdpr_codecdata (AVFormatConte
             goto fail1;
         st->codec->width = get_be16(pb);
         st->codec->height = get_be16(pb);
-        st->codec->time_base.num= 1;
+        st->codec->time_base.num= 1 << 16;
         fps= get_be16(pb);
         st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
         get_be32(pb);
-        fps2= get_be16(pb);
-        get_be16(pb);
+        fps2= get_be32(pb);
 
         if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (url_ftell(pb) - codec_pos))) < 0)
             return ret;
 
 //        av_log(s, AV_LOG_DEBUG, "fps= %d fps2= %d\n", fps, fps2);
-        st->codec->time_base.den = fps * st->codec->time_base.num;
+        st->codec->time_base.den = fps2;
         //XXX: do we really need that?
         switch(st->codec->extradata[4]>>4){
         case 1: st->codec->codec_id = CODEC_ID_RV10; break;
diff -Naurp mythtv-0.24.orig/external/FFmpeg/Makefile mythtv-0.24.fixes/external/FFmpeg/Makefile
--- mythtv-0.24.orig/external/FFmpeg/Makefile	2010-08-23 12:54:20.000000000 -0400
+++ mythtv-0.24.fixes/external/FFmpeg/Makefile	2011-03-24 22:18:50.000000000 -0400
@@ -16,6 +16,7 @@ MANPAGES    = $(addprefix doc/, $(addsuf
 HTMLPAGES   = $(addprefix doc/, $(addsuffix -doc.html, $(PROGS-yes)))
 TOOLS       = $(addprefix tools/, $(addsuffix $(EXESUF), cws2fws pktdumper probetest qt-faststart trasher))
 HOSTPROGS   = $(addprefix tests/, audiogen videogen rotozoom tiny_psnr base64)
+MYTHPROGS   = $(addprefix myth, ${PROGS})
 
 BASENAMES   = ffmpeg ffplay ffprobe ffserver
 ALLPROGS    = $(addsuffix   $(EXESUF), $(BASENAMES))
@@ -46,7 +47,8 @@ FF_DEP_LIBS  := $(DEP_LIBS)
 ALL_TARGETS-$(CONFIG_DOC)       += documentation
 
 ifdef PROGS
-INSTALL_TARGETS-yes             += install-progs install-data
+INSTALL_TARGETS-yes             += install-mythprogs
+#INSTALL_TARGETS-yes             += install-progs install-data
 INSTALL_TARGETS-$(CONFIG_DOC)   += install-man
 endif
 INSTALL_PROGS_TARGETS-$(CONFIG_SHARED) = install-libs
@@ -57,6 +59,9 @@ $(PROGS): %$(EXESUF): %_g$(EXESUF)
 	$(CP) $< $@
 	$(STRIP) $@
 
+${MYTHPROGS}: myth%: %
+	$(CP) $< $@
+
 config.h: .config
 .config: $(wildcard $(FFLIBS:%=$(SRC_DIR)/lib%/all*.c))
 	@-tput bold 2>/dev/null
@@ -137,6 +142,10 @@ install-progs: $(PROGS) $(INSTALL_PROGS_
 	$(Q)mkdir -p "$(BINDIR)"
 	$(INSTALL) -c -m 755 $(PROGS) "$(BINDIR)"
 
+install-mythprogs: $(MYTHPROGS) $(INSTALL_PROGS_TARGETS-yes)
+	$(Q)mkdir -p "$(BINDIR)"
+	$(INSTALL) -c -m 755 $(MYTHPROGS) "$(BINDIR)"
+
 install-data: $(DATA_FILES)
 	$(Q)mkdir -p "$(DATADIR)"
 	$(INSTALL) -m 644 $(DATA_FILES) "$(DATADIR)"
diff -Naurp mythtv-0.24.orig/filters/quickdnr/quickdnr.pro mythtv-0.24.fixes/filters/quickdnr/quickdnr.pro
--- mythtv-0.24.orig/filters/quickdnr/quickdnr.pro	2009-08-08 18:54:22.000000000 -0400
+++ mythtv-0.24.fixes/filters/quickdnr/quickdnr.pro	2011-03-24 22:18:50.000000000 -0400
@@ -3,4 +3,4 @@ include ( ../filter-avcodec.pro )
 
 # Input
 SOURCES += filter_quickdnr.c
-QMAKE_CXXFLAGS += -fno-strict-aliasing
+QMAKE_CFLAGS += -fno-strict-aliasing
diff -Naurp mythtv-0.24.orig/i18n/mythfrontend_en_gb.ts mythtv-0.24.fixes/i18n/mythfrontend_en_gb.ts
--- mythtv-0.24.orig/i18n/mythfrontend_en_gb.ts	2010-10-01 02:44:59.000000000 -0400
+++ mythtv-0.24.fixes/i18n/mythfrontend_en_gb.ts	2011-03-24 22:18:50.000000000 -0400
@@ -8523,7 +8523,7 @@ Do you wish to continue watching?</trans
     <message>
         <location filename="../programs/mythfrontend/globalsettings.cpp" line="364"/>
         <source>7.1</source>
-        <translation>0% {7.1?}</translation>
+        <translation>7.1</translation>
     </message>
     <message>
         <location filename="../programs/mythfrontend/globalsettings.cpp" line="380"/>
diff -Naurp mythtv-0.24.orig/i18n/mythfrontend_fi.ts mythtv-0.24.fixes/i18n/mythfrontend_fi.ts
--- mythtv-0.24.orig/i18n/mythfrontend_fi.ts	2010-10-14 18:02:56.000000000 -0400
+++ mythtv-0.24.fixes/i18n/mythfrontend_fi.ts	2011-03-24 22:18:50.000000000 -0400
@@ -200,7 +200,7 @@
     </message>
     <message>
         <source>Delete ALL channels?</source>
-        <translation>Poista kaikki kanvat?</translation>
+        <translation>Poista kaikki kanavat?</translation>
     </message>
     <message>
         <source>Delete all unassigned channels?</source>
@@ -212,7 +212,7 @@
     </message>
     <message>
         <source>Icon Import Options</source>
-        <translation>Kanavalogojen tuonnin asetukstet</translation>
+        <translation>Kanavalogojen tuonnin asetukset</translation>
     </message>
     <message>
         <source>Download all icons...</source>
@@ -8855,7 +8855,7 @@ Useimmat DVB-S transponderit l채hett채v
     </message>
     <message>
         <source>(Delete all capture cards on %1)</source>
-        <translation>(Poista 1%:n kaikki TV-kortit)</translation>
+        <translation>(Poista kaikki TV-kortit palvelimelta %1)</translation>
     </message>
     <message>
         <source>This is updated on every successful channel change.</source>
@@ -9244,7 +9244,7 @@ Useimmat DVB-S transponderit l채hett채v
     </message>
     <message>
         <source>Recording Groups</source>
-        <translation>Nauoitusryhm채t</translation>
+        <translation>Tallennusryhm채t</translation>
     </message>
     <message>
         <source>Recording Type Priority Settings</source>
@@ -9357,7 +9357,7 @@ Useimmat DVB-S transponderit l채hett채v
     </message>
     <message>
         <source>This is the format to use to display the date. See http://doc.trolltech.com/3.3/qdate.html#toString for a list of valid format specifiers.</source>
-        <translation>T채m채 on muoto, jolla aika n채ytet채채n. Katso http://doc.trolltech.com/3.3/qdate.html#toString m채hd채ksesi listan mahdollisista muotovaihtoehdoista.</translation>
+        <translation>T채m채 on muoto, jolla aika n채ytet채채n. Katso http://doc.trolltech.com/3.3/qdate.html#toString n채hd채ksesi listan mahdollisista muotovaihtoehdoista.</translation>
     </message>
     <message>
         <source>Command to Set Wakeup Time</source>
@@ -9410,7 +9410,7 @@ Useimmat DVB-S transponderit l채hett채v
     </message>
     <message>
         <source>No grabber</source>
-        <translation>E itarttujaa</translation>
+        <translation>Ei kaappaajaa</translation>
     </message>
     <message>
         <source>Loading...</source>
@@ -10014,7 +10014,7 @@ K채yt채 Eject-nappia aseman alareunassa.
     </message>
     <message>
         <source>Audio Capabilities</source>
-        <translation>Audio ominaisuudet</translation>
+        <translation type="obsolete">Audio ominaisuudet</translation>
     </message>
     <message>
         <source> is invalid or not useable.</source>
@@ -10026,23 +10026,19 @@ K채yt채 Eject-nappia aseman alareunassa.
     </message>
     <message>
         <source>No digital passthrough</source>
-        <translation>Ei digitaalista l채pivienti채</translation>
-    </message>
-    <message>
-        <source>LPCM</source>
-        <translation></translation>
+        <translation type="obsolete">Ei digitaalista l채pivienti채</translation>
     </message>
     <message>
         <source>Enable if your amplifier or TV supports multi-channel LPCM. If unchecked Dolby Digital support is required for multi-channel audio</source>
-        <translation>Valitse jos vahvistimesi tai TV tukee monikanavaista LPCM :채채. Jos et valitse, monikanava채채nelle vaaditaan Dolby Digital tuki</translation>
+        <translation type="obsolete">Valitse jos vahvistimesi tai TV tukee monikanavaista LPCM :채채. Jos et valitse, monikanava채채nelle vaaditaan Dolby Digital tuki</translation>
     </message>
     <message>
         <source>Analog or LPCM</source>
-        <translation>Analooginen tai LPCM</translation>
+        <translation type="obsolete">Analooginen tai LPCM</translation>
     </message>
     <message>
         <source>Enable if analog output or if your amplifier or TV supports multi-channel LPCM. If unchecked with digital output, Dolby Digital support is required for multi-channel audio</source>
-        <translation>Valitse jos analooginen ulostulo, tai vahvistimesi tai TV tukee monikanavaista LPCM :채채. Jos et valitse ja k채yt철ss채 on digitaalinen ulostulo, monikanava채채nelle vaaditaan Dolby Digital tuki</translation>
+        <translation type="obsolete">Valitse jos analooginen ulostulo, tai vahvistimesi tai TV tukee monikanavaista LPCM :채채. Jos et valitse ja k채yt철ss채 on digitaalinen ulostulo, monikanava채채nelle vaaditaan Dolby Digital tuki</translation>
     </message>
     <message>
         <source>7.1</source>
@@ -10069,6 +10065,14 @@ K채yt채 Eject-nappia aseman alareunassa.
         <translation>Aseta tila채채neksi muunnoksen laatu.</translation>
     </message>
     <message>
+        <source>Stereo PCM Only</source>
+        <translation>Vain stereo PCM</translation>
+    </message>
+    <message>
+        <source>Enable if your amplifier or sound decoder only supports 2 channels PCM (typically an old HDMI 1.0 device). Multi-channels audio will be re-encoded to AC3 when required</source>
+        <translation>Valitse jos vahvistimesi tai muu 채채nilaitteesi tukee vain 2 kanavaista PCM:채채 (yleens채 vanha HDMI 1.0 laite). Monikanava채채net muunnetaan AC3:ksi tarpeen mukaan.</translation>
+    </message>
+    <message>
         <source>Advanced audio configuration</source>
         <translation>횆채nen S채채t철jen Lis채asetukset</translation>
     </message>
@@ -11353,6 +11357,10 @@ ei voi olla tyhj채.</translation>
         <translation>Etsi k채ytett채viss채 olevia audiolaitteita. Laite skannataan ja ker채t채채n tiedot sen ominaisuuksista.</translation>
     </message>
     <message>
+        <source>Digital Audio Capabilities</source>
+        <translation>Digitaalisen audion ominaisuudet</translation>
+    </message>
+    <message>
         <source>Enable if your amplifier or sound decoder supports AC3/Dolby Digital. You must use a digital connection. Uncheck if using an analog connection.</source>
         <translation>Ota k채ytt철철n jos vahvistimesi tukee AC3/Dolby Digital -채채nt채. T채ll철in on k채ytett채v채 digitaalista ulostuloa. Ota pois k채yt철st채 jos k채yt채t analogisia kaapeleita.</translation>
     </message>
@@ -13391,11 +13399,11 @@ Valitse nykyinen tallennus</translation>
     </message>
     <message>
         <source>Open Live TV PIP</source>
-        <translation>K채ynnist채  Kuva kuvassa -toiminto Katso televisiossa -tilassa</translation>
+        <translation>K채ynnist채 Kuva kuvassa -toiminto Katso televisiota -tilassa</translation>
     </message>
     <message>
         <source>Open Live TV PBP</source>
-        <translation>K채ynnist채  Kuvsta kuvaan -toiminto Katso televisiossa -tilassa</translation>
+        <translation>K채ynnist채 Kuvasta kuvaan -toiminto Katso televisiota -tilassa</translation>
     </message>
     <message>
         <source>Open Recording PIP</source>
diff -Naurp mythtv-0.24.orig/i18n/mythfrontend_pt.ts mythtv-0.24.fixes/i18n/mythfrontend_pt.ts
--- mythtv-0.24.orig/i18n/mythfrontend_pt.ts	2010-09-26 18:53:05.000000000 -0400
+++ mythtv-0.24.fixes/i18n/mythfrontend_pt.ts	2011-03-24 22:18:50.000000000 -0400
@@ -13071,7 +13071,7 @@ You may have to use the eject button und
     <message>
         <location filename="../programs/mythfrontend/globalsettings.cpp" line="364"/>
         <source>7.1</source>
-        <translation>2h {7.1?}</translation>
+        <translation>7.1</translation>
     </message>
     <message>
         <location filename="../programs/mythfrontend/globalsettings.cpp" line="380"/>
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutputalsa.cpp mythtv-0.24.fixes/libs/libmyth/audiooutputalsa.cpp
--- mythtv-0.24.orig/libs/libmyth/audiooutputalsa.cpp	2010-10-27 21:00:25.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutputalsa.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -33,11 +33,11 @@ using namespace std;
 AudioOutputALSA::AudioOutputALSA(const AudioSettings &settings) :
     AudioOutputBase(settings),
     pcm_handle(NULL),
-    numbadioctls(0),
     pbufsize(-1),
     m_card(-1),
     m_device(-1),
-    m_subdevice(-1)
+    m_subdevice(-1),
+    m_autopassthrough(false)
 {
     m_mixer.handle = NULL;
     m_mixer.elem = NULL;
@@ -45,16 +45,48 @@ AudioOutputALSA::AudioOutputALSA(const A
     // Set everything up
     if (passthru_device == "auto")
     {
+        m_autopassthrough = true;
         passthru_device = main_device;
-        if (!passthru_device.contains(":"))
-            passthru_device += ":AES0=0x6,AES1=0x82,AES2=0x0,AES3=0x2";
+
+        /* to set the non-audio bit, use AES0=6 */
+        int len = passthru_device.length();
+        int args = passthru_device.indexOf(":");
+
+        if (args < 0)
+        {
+            /* no existing parameters: add it behind device name */
+            passthru_device += ":AES0=6";
+        }
         else
         {
-            passthru_device = passthru_device.insert(
-                passthru_device.indexOf(":") + 1,
-                "AES0=0x6,AES1=0x82,AES2=0x0,AES3=0x2,");
+            do
+                ++args;
+            while (args < passthru_device.length() &&
+                   passthru_device[args].isSpace());
+            if (args == passthru_device.length())
+            {
+                /* ":" but no parameters */
+                passthru_device += "AES0=6";
+            }
+            else if (passthru_device[args] != '{')
+            {
+                /* a simple list of parameters: add it at the end of the list */
+                passthru_device += ",AES0=6";
+            }
+            else
+            {
+                /* parameters in config syntax: add it inside the { } block */
+                do
+                    --len;
+                while (len > 0 && passthru_device[len].isSpace());
+                if (passthru_device[len] == '}')
+                    passthru_device = passthru_device.insert(len, " AES0=6");
+            }
         }
     }
+    else if (passthru_device.toLower() == "default")
+        passthru_device = main_device;
+
     InitSettings(settings);
     if (settings.init)
         Reconfigure(settings);
@@ -62,11 +94,40 @@ AudioOutputALSA::AudioOutputALSA(const A
 
 AudioOutputALSA::~AudioOutputALSA()
 {
-    if (pbufsize > 0)
-        SetPreallocBufferSize(pbufsize);
     KillAudio();
 }
 
+int AudioOutputALSA::TryOpenDevice(int open_mode, int try_ac3)
+{
+    QString real_device;
+    QByteArray dev_ba;
+    int err = -1;
+
+    if (try_ac3)
+    {
+        dev_ba = passthru_device.toAscii();
+        err = snd_pcm_open(&pcm_handle, dev_ba.constData(),
+                           SND_PCM_STREAM_PLAYBACK, open_mode);
+        m_lastdevice = passthru_device;
+        if (!m_autopassthrough)
+            return err;
+        if (err < 0)
+        {
+            VBAUDIO(QString("Auto setting passthrough failed (%1), defaulting "
+                            "to main device").arg(snd_strerror(err)));
+        }
+    }
+    if (!try_ac3 || err < 0)
+    {
+        // passthru open failed, retry default device
+        dev_ba = main_device.toAscii();
+        err = snd_pcm_open(&pcm_handle, dev_ba.constData(),
+                           SND_PCM_STREAM_PLAYBACK, open_mode);
+        m_lastdevice = main_device;
+    }
+    return err;
+}
+
 int AudioOutputALSA::GetPCMInfo(int &card, int &device, int &subdevice)
 {
     // Check for saved values
@@ -114,19 +175,25 @@ bool AudioOutputALSA::SetPreallocBufferS
     int card, device, subdevice;
     bool ret = true;
 
-    VBAUDIO(QString("Setting preallocated buffer size to %1").arg(size));
+    VBERROR(QString("Setting hardware audio buffer size to %1").arg(size));
 
     if (GetPCMInfo(card, device, subdevice) < 0)
         return false;
 
+    // We can not increase the size of the audio buffer while device is opened
+    // so make sure it is closed
+    if (pcm_handle != NULL)
+        CloseDevice();
+
     QFile pfile(QString("/proc/asound/card%1/pcm%2p/sub%3/prealloc")
                 .arg(card).arg(device).arg(subdevice));
 
     if (!pfile.open(QIODevice::ReadWrite))
     {
-        VBERROR(QString("Error opening %1: %2. "
-                        "Try to increase it with: echo %3 | sudo tee %1")
-                .arg(pfile.fileName()).arg(pfile.errorString()).arg(size));
+        VBERROR(QString("Error opening %1: %2. ")
+                .arg(pfile.fileName()).arg(pfile.errorString()));
+        VBERROR(QString("Try to manually increase audio buffer with: echo %1 "
+                        "| sudo tee %2").arg(size).arg(pfile.fileName()));
         return false;
     }
 
@@ -143,7 +210,7 @@ bool AudioOutputALSA::SetPreallocBufferS
     return ret;
 }
 
-bool AudioOutputALSA::IncPreallocBufferSize(int buffer_time)
+bool AudioOutputALSA::IncPreallocBufferSize(int requested, int buffer_time)
 {
     int card, device, subdevice;
     bool ret = true;
@@ -172,19 +239,26 @@ bool AudioOutputALSA::IncPreallocBufferS
 
     int cur  = pfile.readAll().trimmed().toInt();
     int max  = mfile.readAll().trimmed().toInt();
-    int size = cur * (50000 / buffer_time + 1);
 
-    VBAUDIO(QString("Prealloc buffer cur: %1 max: %3").arg(cur).arg(max));
+    int size = ((int)(cur * (float)requested / (float)buffer_time)
+                / 64 + 1) * 64;
+
+    VBAUDIO(QString("Hardware audio buffer cur: %1 need: %2 max allowed: %3")
+            .arg(cur).arg(size).arg(max));
 
-    if (size > max)
+    if (cur == max)
+    {
+        // It's already the maximum it can be, no point trying further
+        pfile.close();
+        mfile.close();
+        return false;
+    }
+    if (size > max || !size)
     {
         size = max;
         ret = false;
     }
 
-    if (!size)
-        ret = false;
-
     pfile.close();
     mfile.close();
 
@@ -204,8 +278,6 @@ AudioOutputSettings* AudioOutputALSA::Ge
     int rate;
     int err;
 
-    QString real_device = (passthru || enc) ? passthru_device : main_device;
-
     AudioOutputSettings *settings = new AudioOutputSettings();
 
     if (pcm_handle)
@@ -213,11 +285,10 @@ AudioOutputSettings* AudioOutputALSA::Ge
         snd_pcm_close(pcm_handle);
         pcm_handle = NULL;
     }
-    QByteArray dev_ba = real_device.toAscii();
-    if((err = snd_pcm_open(&pcm_handle, dev_ba.constData(),
-                           SND_PCM_STREAM_PLAYBACK, OPEN_FLAGS)) < 0)
+
+    if((err = TryOpenDevice(OPEN_FLAGS, passthru || enc)) < 0)
     {
-        AERROR(QString("snd_pcm_open(\"%1\")").arg(real_device));
+        AERROR(QString("snd_pcm_open(\"%1\")").arg(m_lastdevice));
         delete settings;
         return NULL;
     }
@@ -227,11 +298,9 @@ AudioOutputSettings* AudioOutputALSA::Ge
     if ((err = snd_pcm_hw_params_any(pcm_handle, params)) < 0)
     {
         snd_pcm_close(pcm_handle);
-        if((err = snd_pcm_open(&pcm_handle, dev_ba.constData(),
-                               SND_PCM_STREAM_PLAYBACK, OPEN_FLAGS&FILTER_FLAGS
-                               )) < 0)
+        if((err = TryOpenDevice(OPEN_FLAGS&FILTER_FLAGS, passthru || enc)) < 0)
         {
-            AERROR(QString("snd_pcm_open(\"%1\")").arg(real_device));
+            AERROR(QString("snd_pcm_open(\"%1\")").arg(m_lastdevice));
             delete settings;
             return NULL;
         }
@@ -277,6 +346,9 @@ AudioOutputSettings* AudioOutputALSA::Ge
     QMap<QString, QString> *alsadevs = GetALSADevices("pcm");
     while(1)
     {
+        QString real_device = (((passthru || enc) && !m_autopassthrough) ?
+                               passthru_device : main_device);
+
         QString desc = alsadevs->value(real_device);
 
         settings->setPassthrough(1);   // yes passthrough
@@ -314,30 +386,13 @@ bool AudioOutputALSA::OpenDevice()
     snd_pcm_format_t format;
     uint buffer_time, period_time;
     int err;
-    QString real_device;
 
     if (pcm_handle != NULL)
         CloseDevice();
 
-    numbadioctls = 0;
-
-    if (passthru || enc)
-    {
-        real_device = passthru_device;        
-    }
-    else
-    {
-        real_device = main_device;
-    }
-
-    VERBOSE(VB_GENERAL, QString("Opening ALSA audio device '%1'.")
-                        .arg(real_device));
-
-    QByteArray dev_ba = real_device.toAscii();
-    if ((err = snd_pcm_open(&pcm_handle, dev_ba.constData(),
-                            SND_PCM_STREAM_PLAYBACK, OPEN_FLAGS&FILTER_FLAGS)) < 0)
+    if ((err = TryOpenDevice(0, passthru || enc)) < 0)    
     {
-        AERROR(QString("snd_pcm_open(%1)").arg(real_device));
+        AERROR(QString("snd_pcm_open(\"%1\")").arg(m_lastdevice));
         if (pcm_handle)
             CloseDevice();
         return false;
@@ -355,8 +410,8 @@ bool AudioOutputALSA::OpenDevice()
             return false;
     }
 
-    period_time = 50000;  // aim for an interrupt every 50ms
-    buffer_time = period_time << 2; // buffer 200ms worth of samples
+    buffer_time = 500000; // buffer 0.5s worth of samples
+    period_time = 16;     // aim for an interrupt every (1/16th of buffer_time)
 
     err = SetParameters(pcm_handle, format, channels, samplerate,
                         buffer_time, period_time);
@@ -370,8 +425,8 @@ bool AudioOutputALSA::OpenDevice()
     {
         // We need to increase preallocated buffer size in the driver
         // Set it and try again
-        if(!IncPreallocBufferSize(err))
-            VBERROR("Unable to sufficiently increase preallocated buffer size"
+        if(!IncPreallocBufferSize(buffer_time, err))
+            VBERROR("Unable to sufficiently increase ALSA hardware buffer size"
                     " - underruns are likely");
         return OpenDevice();
     }
@@ -526,15 +581,22 @@ int AudioOutputALSA::GetBufferedOnSoundc
     return delay * output_bytes_per_frame;
 }
 
+/*
+ * Set the various ALSA audio parameters.
+ * Returns:
+ * < 0 : an error occurred
+ * 0   : Succeeded
+ * > 0 : Buffer timelength returned by ALSA which is less than what we asked for
+ */ 
 int AudioOutputALSA::SetParameters(snd_pcm_t *handle, snd_pcm_format_t format,
                                    uint channels, uint rate, uint buffer_time,
                                    uint period_time)
 {
-    int err, dir;
-    snd_pcm_hw_params_t *params;
-    snd_pcm_sw_params_t *swparams;
-    snd_pcm_uframes_t buffer_size;
-    snd_pcm_uframes_t period_size;
+    int err;
+    snd_pcm_hw_params_t  *params;
+    snd_pcm_sw_params_t  *swparams;
+    snd_pcm_uframes_t     period_size, period_size_min, period_size_max;
+    snd_pcm_uframes_t     buffer_size, buffer_size_min, buffer_size_max;
 
     VBAUDIO(QString("SetParameters(format=%1, channels=%2, rate=%3, "
                     "buffer_time=%4, period_time=%5)")
@@ -544,7 +606,7 @@ int AudioOutputALSA::SetParameters(snd_p
     if (handle == NULL)
     {
         Error("SetParameters() called with handle == NULL!");
-        return 0;
+        return -1;
     }
 
     snd_pcm_hw_params_alloca(&params);
@@ -603,22 +665,39 @@ int AudioOutputALSA::SetParameters(snd_p
     }
 
     /* set the buffer time */
+    err = snd_pcm_hw_params_get_buffer_size_min(params, &buffer_size_min);
+    err = snd_pcm_hw_params_get_buffer_size_max(params, &buffer_size_max);
+    err = snd_pcm_hw_params_get_period_size_min(params, &period_size_min, NULL);
+    err = snd_pcm_hw_params_get_period_size_max(params, &period_size_max, NULL);
+    VBAUDIO(QString("Buffer size range from %1 to %2")
+            .arg(buffer_size_min)
+            .arg(buffer_size_max));
+    VBAUDIO(QString("Period size range from %1 to %2")
+            .arg(period_size_min)
+            .arg(period_size_max));
+
+    /* set the buffer time */
+    uint original_buffer_time = buffer_time;
     err = snd_pcm_hw_params_set_buffer_time_near(handle, params,
-                                                 &buffer_time, &dir);
+                                                 &buffer_time, NULL);
     CHECKERR(QString("Unable to set buffer time %1").arg(buffer_time));
 
-    // See if we need to increase the prealloc'd buffer size
-    // If buffer_time is too small we could underrun
-    if (buffer_time < 50000 && pbufsize < 0)
+    /* See if we need to increase the prealloc'd buffer size
+      If buffer_time is too small we could underrun - make 10% difference ok */
+    if ((buffer_time * 1.10f < (float)original_buffer_time) && pbufsize < 0)
+    {
+        VBAUDIO(QString("Requested %1us got %2 buffer time")
+                .arg(original_buffer_time).arg(buffer_time));
         return buffer_time;
+    }
 
     VBAUDIO(QString("Buffer time = %1 us").arg(buffer_time));
 
     /* set the period time */
-    err = snd_pcm_hw_params_set_period_time_near(handle, params,
-                                                 &period_time, &dir);
+    err = snd_pcm_hw_params_set_periods_near(handle, params,
+                                             &period_time, NULL);
     CHECKERR(QString("Unable to set period time %1").arg(period_time));
-    VBAUDIO(QString("Period time = %1 us").arg(period_time));
+    VBAUDIO(QString("Period time = %1 periods").arg(period_time));
 
     /* write the parameters to device */
     err = snd_pcm_hw_params(handle, params);
@@ -638,7 +717,7 @@ int AudioOutputALSA::SetParameters(snd_p
     CHECKERR("Unable to get current swparams");
 
     /* start the transfer after period_size */
-    err = snd_pcm_sw_params_set_start_threshold(handle, swparams, buffer_size);
+    err = snd_pcm_sw_params_set_start_threshold(handle, swparams, period_size);
     CHECKERR("Unable to set start threshold");
 
     /* allow the transfer when at least period_size samples can be processed */
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutputalsa.h mythtv-0.24.fixes/libs/libmyth/audiooutputalsa.h
--- mythtv-0.24.orig/libs/libmyth/audiooutputalsa.h	2010-09-14 12:38:21.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutputalsa.h	2011-03-24 22:18:50.000000000 -0400
@@ -31,9 +31,10 @@ class AudioOutputALSA : public AudioOutp
     AudioOutputSettings* GetOutputSettings(void);
 
   private:
+    int TryOpenDevice(int open_mode, int try_ac3);
     int GetPCMInfo(int &card, int &device, int &subdevice);
     bool SetPreallocBufferSize(int size);
-    bool IncPreallocBufferSize(int buffer_time);
+    bool IncPreallocBufferSize(int requested, int buffer_time);
     inline int SetParameters(snd_pcm_t *handle, snd_pcm_format_t format,
                              uint channels, uint rate, uint buffer_time,
                              uint period_time);
@@ -42,12 +43,14 @@ class AudioOutputALSA : public AudioOutp
 
   private:
     snd_pcm_t   *pcm_handle;
-    int          numbadioctls;
     int          pbufsize;
     int          m_card, m_device, m_subdevice;
     QMutex       killAudioLock;
     snd_pcm_sframes_t (*pcm_write_func)(snd_pcm_t*, const void*,
                                         snd_pcm_uframes_t);
+    bool         m_autopassthrough;
+    QString      m_lastdevice;
+
     struct {
         QString            device;
         QString            control;
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutputbase.cpp mythtv-0.24.fixes/libs/libmyth/audiooutputbase.cpp
--- mythtv-0.24.orig/libs/libmyth/audiooutputbase.cpp	2010-11-02 14:39:01.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutputbase.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -93,6 +93,7 @@ AudioOutputBase::AudioOutputBase(const A
 
     memory_corruption_test0(0xdeadbeef),
     memory_corruption_test1(0xdeadbeef),
+    src_out(NULL),              kAudioSRCOutputSize(0),
     memory_corruption_test2(0xdeadbeef),
     memory_corruption_test3(0xdeadbeef)
 {
@@ -100,7 +101,6 @@ AudioOutputBase::AudioOutputBase(const A
     // The following are not bzero() because MS Windows doesn't like it.
     memset(&src_data,          0, sizeof(SRC_DATA));
     memset(src_in,             0, sizeof(float) * kAudioSRCInputSize);
-    memset(src_out,            0, sizeof(float) * kAudioSRCOutputSize);
     memset(audiobuffer,        0, sizeof(char)  * kAudioRingBufferSize);
 
     // Default SRC quality - QUALITY_HIGH is quite expensive
@@ -134,6 +134,9 @@ AudioOutputBase::~AudioOutputBase()
     delete output_settings;
     delete output_settingsraw;
 
+    if (kAudioSRCOutputSize > 0)
+        delete[] src_out;
+
     assert(memory_corruption_test0 == 0xdeadbeef);
     assert(memory_corruption_test1 == 0xdeadbeef);
     assert(memory_corruption_test2 == 0xdeadbeef);
@@ -200,11 +203,18 @@ AudioOutputSettings* AudioOutputBase::Ge
 /**
  * Test if we can output digital audio and if sample rate is supported
  */
-bool AudioOutputBase::CanPassthrough(int samplerate) const
+bool AudioOutputBase::CanPassthrough(int samplerate, int channels) const
 {
     bool ret = false;
     ret = output_settings->IsSupportedFormat(FORMAT_S16);
     ret &= output_settings->IsSupportedRate(samplerate);
+    // Don't know any cards that support spdif clocked at < 44100
+    // Some US cable transmissions have 2ch 32k AC-3 streams
+    ret &= samplerate >= 44100;
+        // Will downmix if we can't support the amount of channels
+    ret &= channels <= max_channels;
+        // Stereo content will always be decoded so it can later be upmixed
+    ret &= channels != 2;
 
     return ret;
 }
@@ -396,21 +406,21 @@ void AudioOutputBase::Reconfigure(const 
     was_paused = true;
     internal_vol = gCoreContext->GetNumSetting("MythControlsVolume", 0);
 
-    VBAUDIO(QString("Original codec was %1, %2, %3 kHz, %4 channels")
-            .arg(ff_codec_id_string((CodecID)codec))
-            .arg(output_settings->FormatToString(format))
-            .arg(samplerate/1000).arg(source_channels));
-
     // Don't try to do anything if audio hasn't been
     // initialized yet (e.g. rubbish was provided)
     if (source_channels <= 0 || format <= 0 || samplerate <= 0)
     {
-        Error(QString("Aborting Audio Reconfigure. ") +
-              QString("Invalid audio parameters ch %1 fmt %2 @ %3Hz")
-              .arg(source_channels).arg(format).arg(samplerate));
+        SilentError(QString("Aborting Audio Reconfigure. ") +
+                    QString("Invalid audio parameters ch %1 fmt %2 @ %3Hz")
+                    .arg(source_channels).arg(format).arg(samplerate));
         return;
     }
 
+    VBAUDIO(QString("Original codec was %1, %2, %3 kHz, %4 channels")
+            .arg(ff_codec_id_string((CodecID)codec))
+            .arg(output_settings->FormatToString(format))
+            .arg(samplerate/1000).arg(source_channels));
+
     /* Encode to AC-3 if we're allowed to passthru but aren't currently
        and we have more than 2 channels but multichannel PCM is not supported
        or if the device just doesn't support the number of channels */
@@ -456,7 +466,9 @@ void AudioOutputBase::Reconfigure(const 
                 .arg(settings.samplerate/1000).arg(samplerate/1000)
                 .arg(quality_string(src_quality)));
 
-        src_ctx = src_new(2-src_quality, source_channels, &error);
+        int chans = needs_downmix ? channels : source_channels;
+
+        src_ctx = src_new(2-src_quality, chans, &error);
         if (error)
         {
             Error(QString("Error creating resampler: %1")
@@ -465,8 +477,19 @@ void AudioOutputBase::Reconfigure(const 
             return;
         }
 
-        src_data.src_ratio      = (double)samplerate / settings.samplerate;
-        src_data.data_in        = src_in;
+        src_data.src_ratio = (double)samplerate / settings.samplerate;
+        src_data.data_in   = src_in;
+        int newsize        = (int)(kAudioSRCInputSize * src_data.src_ratio + 15)
+                             & ~0xf;
+
+        if (kAudioSRCOutputSize < newsize)
+        {
+            kAudioSRCOutputSize = newsize;
+            VBAUDIO(QString("Resampler allocating %1").arg(newsize));
+            if (src_out)
+                delete[] src_out;
+            src_out = new float[kAudioSRCOutputSize];
+        }
         src_data.data_out       = src_out;
         src_data.output_frames  = kAudioSRCOutputSize;
         src_data.end_of_input = 0;
@@ -693,7 +716,7 @@ void AudioOutputBase::Reset()
 void AudioOutputBase::SetTimecode(int64_t timecode)
 {
     audbuf_timecode = audiotime = timecode;
-    frames_buffered = (int64_t)((timecode * source_samplerate) / 1000);
+    frames_buffered = (timecode * (int64_t)source_samplerate) / 1000LL;
 }
 
 /**
@@ -750,10 +773,10 @@ int AudioOutputBase::audioready()
  */
 int64_t AudioOutputBase::GetAudiotime(void)
 {
-    if (audbuf_timecode == 0)
-        return 0;
+    if (audbuf_timecode == 0LL)
+        return 0LL;
 
-    int obpf = output_bytes_per_frame;
+    int64_t obpf = (int64_t)output_bytes_per_frame;
     int64_t oldaudiotime;
 
     /* We want to calculate 'audiotime', which is the timestamp of the audio
@@ -772,8 +795,8 @@ int64_t AudioOutputBase::GetAudiotime(vo
 
     QMutexLocker lockav(&avsync_lock);
 
-    int64_t soundcard_buffer = GetBufferedOnSoundcard(); // bytes
-    int64_t main_buffer = audioready();
+    int64_t soundcard_buffer = (int64_t)GetBufferedOnSoundcard(); // bytes
+    int64_t main_buffer =(int64_t)audioready();
 
     /* audioready tells us how many bytes are in audiobuffer
        scaled appropriately if output format != internal format */
@@ -782,11 +805,11 @@ int64_t AudioOutputBase::GetAudiotime(vo
 
     /* timecode is the stretch adjusted version
        of major post-stretched buffer contents
-       processing latencies are catered for in AddSamples/SetAudiotime
+       processing latencies are catered for in AddFrames/SetAudiotime
        to eliminate race */
     audiotime = audbuf_timecode - (
-        ((main_buffer + soundcard_buffer) * eff_stretchfactor ) /
-        (effdsp * obpf));
+        ((main_buffer + soundcard_buffer) * (int64_t)eff_stretchfactor ) /
+        ((int64_t)effdsp * obpf));
 
     /* audiotime should never go backwards, but we might get a negative
        value if GetBufferedOnSoundcard() isn't updated by the driver very
@@ -812,37 +835,43 @@ int64_t AudioOutputBase::GetAudiotime(vo
 /**
  * Set the timecode of the top of the ringbuffer
  * Exclude all other processing elements as they dont vary
- * between AddSamples calls
+ * between AddFrames calls
  */
 void AudioOutputBase::SetAudiotime(int frames, int64_t timecode)
 {
-    int64_t processframes_stretched = 0;
-    int64_t processframes_unstretched = 0;
+    int64_t processframes_stretched = 0LL;
+    int64_t processframes_unstretched = 0LL;
+    int64_t old_audbuf_timecode = audbuf_timecode;
 
     if (needs_upmix && upmixer)
-        processframes_unstretched -= upmixer->frameLatency();
+        processframes_unstretched -= (int64_t)upmixer->frameLatency();
 
     if (pSoundStretch)
     {
-        processframes_unstretched -= pSoundStretch->numUnprocessedSamples();
-        processframes_stretched -= pSoundStretch->numSamples();
+        processframes_unstretched -=
+            (int64_t)pSoundStretch->numUnprocessedSamples();
+        processframes_stretched   -=
+            (int64_t)pSoundStretch->numSamples();
     }
 
     if (encoder)
+    {
         // the input buffered data is still in audio_bytes_per_sample format
-        processframes_stretched -= encoder->Buffered() / output_bytes_per_frame;
-
-    int64_t old_audbuf_timecode = audbuf_timecode;
+        processframes_stretched -=
+            (int64_t)(encoder->Buffered() / output_bytes_per_frame);
+    }
 
-    audbuf_timecode = timecode + 
-                (((frames + processframes_unstretched) * 100000) +
-                  (processframes_stretched * eff_stretchfactor )) / effdsp;
+    audbuf_timecode =
+        timecode + (
+            ((int64_t)frames + processframes_unstretched * 100000LL) +
+            (processframes_stretched * (int64_t)eff_stretchfactor)
+                    ) / (int64_t)effdsp;
 
     // check for timecode wrap and reset audiotime if detected
-    // timecode will always be monotonic asc if not seeked and reset 
+    // timecode will always be monotonic asc if not seeked and reset
     // happens if seek or pause happens
     if (audbuf_timecode < old_audbuf_timecode)
-        audiotime = 0;
+        audiotime = 0LL;
 
     VBAUDIOTS(QString("SetAudiotime atc=%1 tc=%2 f=%3 pfu=%4 pfs=%5")
               .arg(audbuf_timecode)
@@ -862,10 +891,10 @@ void AudioOutputBase::SetAudiotime(int f
  */
 int64_t AudioOutputBase::GetAudioBufferedTime(void)
 {
-    int ret = audbuf_timecode - GetAudiotime();
+    int64_t ret = audbuf_timecode - (int64_t)GetAudiotime();
     // Pulse can give us values that make this -ve
-    if (ret < 0)
-        return 0;
+    if (ret < 0LL)
+        return 0LL;
     return ret;
 }
 
@@ -972,32 +1001,38 @@ int AudioOutputBase::CopyWithUpmix(char 
     }
 
     // Upmix to 6ch via FreeSurround
-
     // Calculate frame size of input
     off =  processing ? 4 : output_settings->SampleSize(format);
     off *= source_channels;
 
+    len = 0;
     int i = 0;
     while (i < frames)
-        i += upmixer->putFrames(buffer + i * off, frames - i, source_channels);
+    {
+        int nFrames;
 
-    int nFrames = upmixer->numFrames();
-    if (!nFrames)
-        return 0;
+        i += upmixer->putFrames(buffer + i * off,
+                                frames - i, source_channels);
 
-    len = CheckFreeSpace(nFrames);
+        nFrames = upmixer->numFrames();
 
-    int bdFrames = bdiff / bpf;
-    if (bdFrames < nFrames)
-    {
-        upmixer->receiveFrames((float *)(WPOS), bdFrames);
-        nFrames -= bdFrames;
-        org_waud = 0;
-    }
-    if (nFrames > 0)
-        upmixer->receiveFrames((float *)(WPOS), nFrames);
+        if (!nFrames)
+            continue;
+
+        len += CheckFreeSpace(nFrames);
+
+        int bdFrames = (kAudioRingBufferSize - org_waud) / bpf;
+        if (bdFrames < nFrames)
+        {
+            upmixer->receiveFrames((float *)(WPOS), bdFrames);
+            nFrames -= bdFrames;
+            org_waud = 0;
+        }
+        if (nFrames > 0)
+            upmixer->receiveFrames((float *)(WPOS), nFrames);
 
-    org_waud += nFrames * bpf;
+        org_waud += nFrames * bpf;
+    }
     return len;
 }
 
@@ -1006,11 +1041,13 @@ int AudioOutputBase::CopyWithUpmix(char 
  *
  * Returns false if there's not enough space right now
  */
-bool AudioOutputBase::AddFrames(void *buffer, int in_frames, int64_t timecode)
+bool AudioOutputBase::AddFrames(void *in_buffer, int in_frames,
+                                int64_t timecode)
 {
     int org_waud = waud,               afree = audiofree();
     int frames   = in_frames;
-    int bpf      = bytes_per_frame,    len   = frames * source_bytes_per_frame;
+    void *buffer = in_buffer;
+    int bpf      = bytes_per_frame,    len = frames * source_bytes_per_frame;
     int used     = kAudioRingBufferSize - afree;
     bool music   = false;
     int bdiff;
@@ -1035,17 +1072,19 @@ bool AudioOutputBase::AddFrames(void *bu
     if (timecode < 0)
     {
         // Send original samples to mythmusic visualisation
-        timecode = (int64_t)(frames_buffered) * 1000 / source_samplerate;
-        frames_buffered += frames;
-        dispatchVisual((uchar *)buffer, len, timecode, source_channels,
+        timecode = (frames_buffered * 1000LL) / (int64_t)source_samplerate;
+        frames_buffered += (int64_t)frames;
+        dispatchVisual((uchar *)in_buffer, len, timecode, source_channels,
                        output_settings->FormatToBits(format));
         music = true;
     }
 
+    // Calculate amount of free space required in ringbuffer
     if (processing)
     {
-        // Convert to floats
-        len = AudioOutputUtil::toFloat(format, src_in, buffer, len);
+        // Final float conversion space requirement
+        len = sizeof(*src_in_buf) /
+            AudioOutputSettings::SampleSize(format) * len;
 
         // Account for changes in number of channels
         if (needs_upmix || needs_downmix)
@@ -1067,124 +1106,176 @@ bool AudioOutputBase::AddFrames(void *bu
 
     if (len > afree)
     {
-            VBAUDIOTS("Buffer is full, AddFrames returning false");
-            return false; // would overflow
+        VBAUDIOTS("Buffer is full, AddFrames returning false");
+        return false; // would overflow
     }
 
-    // Perform downmix if necessary
-    if (needs_downmix)
-        if(AudioOutputDownmix::DownmixFrames(source_channels, channels,
-                                             src_in, src_in, frames) < 0)
-            VBERROR("Error occurred while downmixing");
+    int frames_remaining = in_frames;
+    int frames_final = 0;
+    int maxframes = (kAudioSRCInputSize / source_channels) & ~0xf;
+    int offset = 0;
 
-    // Resample if necessary
-    if (need_resampler && src_ctx)
+    while(frames_remaining > 0)
     {
-        src_data.input_frames = frames;
-        int error = src_process(src_ctx, &src_data);
+        buffer = (char *)in_buffer + offset;
+        frames = frames_remaining;
 
-        if (error)
-            VBERROR(QString("Error occurred while resampling audio: %1")
-                    .arg(src_strerror(error)));
+        len = frames * source_bytes_per_frame;
 
-        buffer = src_out;
-        in_frames = frames = src_data.output_frames_gen;
-    }
-    else if (processing)
-        buffer = src_in;
+        if (processing)
+        {
+            if (frames > maxframes)
+            {
+                frames = maxframes;
+                len = frames * source_bytes_per_frame;
+                offset += len;
+            }
+            // Convert to floats
+            len = AudioOutputUtil::toFloat(format, src_in, buffer, len);
+        }
+        frames_remaining -= frames;
 
-    /* we want the timecode of the last sample added but we are given the
-       timecode of the first - add the time in ms that the frames added
-       represent */
+        // Perform downmix if necessary
+        if (needs_downmix)
+            if(AudioOutputDownmix::DownmixFrames(source_channels, channels,
+                                                 src_in, src_in, frames) < 0)
+                VBERROR("Error occurred while downmixing");
 
-    // Copy samples into audiobuffer, with upmix if necessary
-    if ((len = CopyWithUpmix((char *)buffer, frames, org_waud)) <= 0)
-    {
-        SetAudiotime(in_frames, timecode);
-        return true;
-    }
+        // Resample if necessary
+        if (need_resampler && src_ctx)
+        {
+            src_data.input_frames = frames;
+            int error = src_process(src_ctx, &src_data);
 
-    frames = len / bpf;
+            if (error)
+                VBERROR(QString("Error occurred while resampling audio: %1")
+                        .arg(src_strerror(error)));
 
-    bdiff = kAudioRingBufferSize - waud;
+            buffer = src_out;
+            frames = src_data.output_frames_gen;
+        }
+        else if (processing)
+            buffer = src_in;
 
-    if (pSoundStretch)
-    {
-        // does not change the timecode, only the number of samples
-        org_waud     = waud;
-        int bdFrames = bdiff / bpf;
+        /* we want the timecode of the last sample added but we are given the
+           timecode of the first - add the time in ms that the frames added
+           represent */
 
-        if (bdiff < len)
+        // Copy samples into audiobuffer, with upmix if necessary
+        if ((len = CopyWithUpmix((char *)buffer, frames, org_waud)) <= 0)
         {
-            pSoundStretch->putSamples((STST *)(WPOS), bdFrames);
-            pSoundStretch->putSamples((STST *)ABUF, (len - bdiff) / bpf);
+            continue;
         }
-        else
-            pSoundStretch->putSamples((STST *)(WPOS), frames);
 
-        int nFrames = pSoundStretch->numSamples();
-        if (nFrames > frames)
-            CheckFreeSpace(nFrames);
+        frames = len / bpf;
+        frames_final += frames;
 
-        len = nFrames * bpf;
+        bdiff = kAudioRingBufferSize - waud;
 
-        if (nFrames > bdFrames)
+        if (pSoundStretch)
         {
-            nFrames -= pSoundStretch->receiveSamples((STST *)(WPOS), bdFrames);
-            org_waud = 0;
-        }
-        if (nFrames > 0)
-            nFrames = pSoundStretch->receiveSamples((STST *)(WPOS), nFrames);
+            // does not change the timecode, only the number of samples
+            org_waud     = waud;
+            int bdFrames = bdiff / bpf;
 
-        org_waud += nFrames * bpf;
-    }
+            if (bdiff < len)
+            {
+                pSoundStretch->putSamples((STST *)(WPOS), bdFrames);
+                pSoundStretch->putSamples((STST *)ABUF, (len - bdiff) / bpf);
+            }
+            else
+                pSoundStretch->putSamples((STST *)(WPOS), frames);
 
-    if (internal_vol && SWVolume())
-    {
-        org_waud    = waud;
-        int num     = len;
+            int nFrames = pSoundStretch->numSamples();
+            if (nFrames > frames)
+                CheckFreeSpace(nFrames);
 
-        if (bdiff <= num)
-        {
-            AudioOutputUtil::AdjustVolume(WPOS, bdiff, volume,
-                                          music, needs_upmix && upmixer);
-            num -= bdiff;
-            org_waud = 0;
-        }
-        if (num > 0)
-            AudioOutputUtil::AdjustVolume(WPOS, num, volume,
-                                          music, needs_upmix && upmixer);
-        org_waud += num;
-    }
+            len = nFrames * bpf;
 
-    if (encoder)
-    {
-        org_waud   = waud;
-        int to_get = 0;
+            if (nFrames > bdFrames)
+            {
+                nFrames -= pSoundStretch->receiveSamples((STST *)(WPOS),
+                                                         bdFrames);
+                org_waud = 0;
+            }
+            if (nFrames > 0)
+                nFrames = pSoundStretch->receiveSamples((STST *)(WPOS),
+                                                        nFrames);
 
-        if (bdiff < len)
-        {
-            encoder->Encode(WPOS, bdiff, processing);
-            to_get = encoder->Encode(ABUF, len - bdiff, processing);
+            org_waud += nFrames * bpf;
         }
-        else
-            to_get = encoder->Encode(WPOS, len, processing);
 
-        if (bdiff <= to_get)
+        if (internal_vol && SWVolume())
         {
-            encoder->GetFrames(WPOS, bdiff);
-            to_get -= bdiff;
-            org_waud = 0;
+            org_waud    = waud;
+            int num     = len;
+
+            if (bdiff <= num)
+            {
+                AudioOutputUtil::AdjustVolume(WPOS, bdiff, volume,
+                                              music, needs_upmix && upmixer);
+                num -= bdiff;
+                org_waud = 0;
+            }
+            if (num > 0)
+                AudioOutputUtil::AdjustVolume(WPOS, num, volume,
+                                              music, needs_upmix && upmixer);
+            org_waud += num;
+        }
+
+        if (encoder)
+        {
+            org_waud            = waud;
+            int org_waud2       = waud;
+            int remaining       = len;
+            int to_get          = 0;
+            // The AC3 encoder can only work on 128kB of data at a time
+            int maxlength       =
+                ((ENCODER_INBUFSIZE / encoder->FrameSize() - 1) *
+                 encoder->FrameSize()) & ~0xf;
+
+            do
+            {
+                len = remaining;
+                if (len > maxlength)
+                {
+                    len = maxlength;
+                }
+                remaining -= len;
+
+                bdiff = kAudioRingBufferSize - org_waud;
+                if (bdiff < len)
+                {
+                    encoder->Encode(WPOS, bdiff, processing);
+                    to_get = encoder->Encode(ABUF, len - bdiff, processing);
+                    org_waud = len - bdiff;
+                }
+                else
+                {
+                    to_get = encoder->Encode(WPOS, len, processing);
+                    org_waud += len;
+                }
+
+                bdiff = kAudioRingBufferSize - org_waud2;
+                if (bdiff <= to_get)
+                {
+                    encoder->GetFrames(audiobuffer + org_waud2, bdiff);
+                    to_get -= bdiff ;
+                    org_waud2 = 0;
+                }
+                if (to_get > 0)
+                    encoder->GetFrames(audiobuffer + org_waud2, to_get);
+
+                org_waud2 += to_get;
+            }
+            while (remaining > 0);
+            org_waud = org_waud2;
         }
-        if (to_get > 0)
-            encoder->GetFrames(WPOS, to_get);
 
-        org_waud += to_get;
+        waud = org_waud;
     }
 
-    waud = org_waud;
-
-    SetAudiotime(in_frames, timecode);
+    SetAudiotime(frames_final, timecode);
 
     return true;
 }
@@ -1235,8 +1326,8 @@ void AudioOutputBase::OutputAudioLoop(vo
 
     // to reduce startup latency, write silence in 8ms chunks
     int zero_fragment_size = (int)(0.008*samplerate/channels);
-    // make sure its a multiple of bytes_per_frame
-    zero_fragment_size *= bytes_per_frame;
+    // make sure its a multiple of output_bytes_per_frame
+    zero_fragment_size *= output_bytes_per_frame;
     if (zero_fragment_size > fragment_size)
         zero_fragment_size = fragment_size;
 
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutputbase.h mythtv-0.24.fixes/libs/libmyth/audiooutputbase.h
--- mythtv-0.24.orig/libs/libmyth/audiooutputbase.h	2010-09-12 11:19:20.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutputbase.h	2011-03-24 22:18:50.000000000 -0400
@@ -62,7 +62,7 @@ class AudioOutputBase : public AudioOutp
     virtual void SetStretchFactor(float factor);
     virtual float GetStretchFactor(void) const;
 
-    virtual bool CanPassthrough(int samplerate) const;
+    virtual bool CanPassthrough(int samplerate, int channels) const;
     virtual bool ToggleUpmix(void);
 
     virtual void Reset(void);
@@ -95,8 +95,8 @@ class AudioOutputBase : public AudioOutp
     virtual void bufferOutputData(bool y){ buffer_output_data_for_use = y; }
     virtual int readOutputData(unsigned char *read_buffer, int max_length);
 
-    static const uint kAudioSRCInputSize  = 16384<<1;
-    static const uint kAudioSRCOutputSize = 16384<<3;
+    static const uint kAudioSRCInputSize = 32768;
+
     /// Audio Buffer Size -- should be divisible by 32,24,16,12,10,8,6,4,2..
     static const uint kAudioRingBufferSize   = 3072000;
 
@@ -224,7 +224,8 @@ class AudioOutputBase : public AudioOutp
     uint memory_corruption_test0;
     float src_in_buf[kAudioSRCInputSize + 16];
     uint memory_corruption_test1;
-    float src_out[kAudioSRCOutputSize];
+    float *src_out;
+    int kAudioSRCOutputSize;
     uint memory_corruption_test2;
     /** main audio buffer */
     uchar audiobuffer[kAudioRingBufferSize];
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutputca.cpp mythtv-0.24.fixes/libs/libmyth/audiooutputca.cpp
--- mythtv-0.24.orig/libs/libmyth/audiooutputca.cpp	2010-09-12 14:10:20.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutputca.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -14,7 +14,7 @@
  * fails and passthru was set.
  *
  * = REVISION
- * $Id: audiooutputca.cpp 26260 2010-09-12 18:10:20Z nigel $
+ * $Id$
  *
  * = AUTHORS
  * Jeremiah Morris, Andrew Kimpton, Nigel Pearson
@@ -283,7 +283,7 @@ bool AudioOutputCA::OpenDevice()
 {
     bool deviceOpened = false;
 
-    if (passthru)
+    if (passthru || enc)
     {
         if (!d->FindAC3Stream())
         {
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutput.cpp mythtv-0.24.fixes/libs/libmyth/audiooutput.cpp
--- mythtv-0.24.orig/libs/libmyth/audiooutput.cpp	2010-10-08 00:47:34.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutput.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -103,10 +103,38 @@ AudioOutput *AudioOutput::OpenAudio(Audi
     }
 
 #ifdef USING_PULSE
-    if (willsuspendpa &&
-        !main_device.contains("pulse", Qt::CaseInsensitive))
+    if (willsuspendpa)
     {
-        pulsestatus = PulseHandler::Suspend(PulseHandler::kPulseSuspend);
+        bool ispulse = false;
+#ifdef USE_ALSA
+        // Check if using ALSA, that the device doesn't contain the word
+        // "pulse" in its hint
+        if (main_device.startsWith("ALSA:"))
+        {
+            QString device_name = main_device;
+
+            device_name.remove(0, 5);
+            QMap<QString, QString> *alsadevs =
+                AudioOutputALSA::GetALSADevices("pcm");
+            if (!alsadevs->empty() && alsadevs->contains(device_name))
+            {
+                if (alsadevs->value(device_name).contains("pulse",
+                                                          Qt::CaseInsensitive))
+                {
+                    ispulse = true;
+                }
+            }
+            delete alsadevs;
+        }
+#endif
+        if (main_device.contains("pulse", Qt::CaseInsensitive))
+        {
+            ispulse = true;
+        }
+        if (!ispulse)
+        {
+            pulsestatus = PulseHandler::Suspend(PulseHandler::kPulseSuspend);
+        }
     }
 #endif
 
@@ -192,6 +220,12 @@ void AudioOutput::Error(const QString &m
     VERBOSE(VB_IMPORTANT, "AudioOutput Error: " + lastError);
 }
 
+void AudioOutput::SilentError(const QString &msg)
+{
+    lastError = msg;
+    lastError.detach();
+}
+
 void AudioOutput::Warn(const QString &msg)
 {
     lastWarn = msg;
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutputdigitalencoder.h mythtv-0.24.fixes/libs/libmyth/audiooutputdigitalencoder.h
--- mythtv-0.24.orig/libs/libmyth/audiooutputdigitalencoder.h	2010-05-24 23:17:44.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutputdigitalencoder.h	2011-03-24 22:18:50.000000000 -0400
@@ -7,6 +7,7 @@ extern "C" {
 
 #define INBUFSIZE 131072
 #define OUTBUFSIZE 98304
+#define ENCODER_INBUFSIZE INBUFSIZE
 
 class AudioOutputDigitalEncoder
 {
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutputdx.cpp mythtv-0.24.fixes/libs/libmyth/audiooutputdx.cpp
--- mythtv-0.24.orig/libs/libmyth/audiooutputdx.cpp	2010-09-14 12:38:21.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutputdx.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -108,7 +108,7 @@ AudioOutputDX::AudioOutputDX(const Audio
 {
     timeBeginPeriod(1);
     InitSettings(settings);
-    if (passthru_device == "auto")
+    if (passthru_device == "auto" || passthru_device.toLower() == "default")
         passthru_device = main_device;
     if (settings.init)
         Reconfigure(settings);
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutput.h mythtv-0.24.fixes/libs/libmyth/audiooutput.h
--- mythtv-0.24.orig/libs/libmyth/audiooutput.h	2010-10-08 00:47:34.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutput.h	2011-03-24 22:18:50.000000000 -0400
@@ -65,7 +65,7 @@ class MPUBLIC AudioOutput : public Volum
         { return new AudioOutputSettings; }
     virtual AudioOutputSettings* GetOutputSettingsUsers(void)
         { return new AudioOutputSettings; }
-    virtual bool CanPassthrough(int samplerate) const = 0;
+    virtual bool CanPassthrough(int samplerate, int channels) const = 0;
 
     // dsprate is in 100 * samples/second
     virtual void SetEffDsp(int dsprate) = 0;
@@ -105,6 +105,7 @@ class MPUBLIC AudioOutput : public Volum
 
   protected:
     void Error(const QString &msg);
+    void SilentError(const QString &msg);
     void Warn(const QString &msg);
     void ClearError(void);
     void ClearWarning(void);
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutputpulse.cpp mythtv-0.24.fixes/libs/libmyth/audiooutputpulse.cpp
--- mythtv-0.24.orig/libs/libmyth/audiooutputpulse.cpp	2010-11-02 14:39:01.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutputpulse.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -45,6 +45,11 @@ AudioOutputPulseAudio::AudioOutputPulseA
 AudioOutputPulseAudio::~AudioOutputPulseAudio()
 {
     KillAudio();
+    if (pcontext)
+    {
+        pa_context_unref(pcontext);
+        pcontext = NULL;
+    }
 }
 
 AudioOutputSettings* AudioOutputPulseAudio::GetOutputSettings()
@@ -106,6 +111,7 @@ AudioOutputSettings* AudioOutputPulseAud
     }
 
     pa_context_disconnect(pcontext);
+    pa_context_unref(pcontext);
     pcontext = NULL;
     pa_threaded_mainloop_stop(mainloop);
     mainloop = NULL;
@@ -210,6 +216,7 @@ void AudioOutputPulseAudio::CloseDevice(
     {
         pa_context_drain(pcontext, NULL, NULL);
         pa_context_disconnect(pcontext);
+        pa_context_unref(pcontext);
         pcontext = NULL;
     }
 
@@ -518,7 +525,7 @@ bool AudioOutputPulseAudio::ConnectPlayb
         | PA_STREAM_NO_REMIX_CHANNELS;
 
     pa_stream_connect_playback(pstream, NULL, &buffer_settings,
-                               (pa_stream_flags_t)flags, &volume_control, NULL);
+                               (pa_stream_flags_t)flags, NULL, NULL);
 
     pa_context_state_t cstate;
     pa_stream_state_t sstate;
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutputsettings.cpp mythtv-0.24.fixes/libs/libmyth/audiooutputsettings.cpp
--- mythtv-0.24.orig/libs/libmyth/audiooutputsettings.cpp	2010-09-12 10:06:59.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutputsettings.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -239,7 +239,7 @@ void AudioOutputSettings::SetBestSupport
     vector<int>::reverse_iterator it;
 
     for (it = m_channels.rbegin();
-         *it >= channels && it < m_channels.rend();
+         it != m_channels.rend() && *it >= channels;
          it++)
         m_channels.pop_back();
     m_channels.push_back(channels);
@@ -299,13 +299,15 @@ AudioOutputSettings* AudioOutputSettings
 
     int cur_channels = gCoreContext->GetNumSetting("MaxChannels", 2);
     int max_channels = aosettings->BestSupportedChannels();
-    bool bAC3  = aosettings->m_AC3 &&
+    bool bAdv = gCoreContext->GetNumSetting("AdvancedAudioSettings", false);
+    bool bForceDigital = bAdv &&
+        gCoreContext->GetNumSetting("PassThruDeviceOverride", false);
+    bool bAC3  = (aosettings->m_AC3 || bForceDigital) &&
         gCoreContext->GetNumSetting("AC3PassThru", false);
-    bool bDTS  = aosettings->m_DTS &&
+    bool bDTS  = (aosettings->m_DTS || bForceDigital) && 
         gCoreContext->GetNumSetting("DTSPassThru", false);
     bool bLPCM = aosettings->m_LPCM &&
-        (aosettings->m_passthrough == -1 ||
-         gCoreContext->GetNumSetting("MultiChannelPCM", false));
+        !(bAdv && gCoreContext->GetNumSetting("StereoPCM", false));
 
     if (max_channels > 2 && !bLPCM)
         max_channels = 2;
@@ -316,8 +318,6 @@ AudioOutputSettings* AudioOutputSettings
         cur_channels = max_channels;
 
     aosettings->SetBestSupportedChannels(cur_channels);
-    if (cur_channels <= 2)
-        bDTS = bAC3 = false;
     aosettings->m_AC3 = bAC3;
     aosettings->m_DTS = bDTS;
     aosettings->m_LPCM = bLPCM;
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutpututil.cpp mythtv-0.24.fixes/libs/libmyth/audiooutpututil.cpp
--- mythtv-0.24.orig/libs/libmyth/audiooutpututil.cpp	2010-08-23 12:54:20.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutpututil.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -120,9 +120,8 @@ static int toFloat8(float *out, uchar *i
 }
 
 /*
- All fromFloat variants require 16 byte aligned output buffers on x86
- The SSE code processes 16 bytes at a time and leaves any remainder for the C
- - there is no remainder in practice */
+  The SSE code processes 16 bytes at a time and leaves any remainder for the C
+  - there is no remainder in practice */
 
 static int fromFloat8(uchar *out, float *in, int len)
 {
@@ -130,7 +129,7 @@ static int fromFloat8(uchar *out, float 
     float f = (1<<7) - 1;
 
 #if ARCH_X86
-    if (sse_check() && len >= 16)
+    if (sse_check() && len >= 16 && ((unsigned long)out & 0xf) == 0)
     {
         int loops = len >> 4;
         i = loops << 4;
@@ -235,7 +234,7 @@ static int fromFloat16(short *out, float
     float f = (1<<15) - 1;
 
 #if ARCH_X86
-    if (sse_check() && len >= 16)
+    if (sse_check() && len >= 16 && ((unsigned long)out & 0xf) == 0)
     {
         int loops = len >> 4;
         i = loops << 4;
@@ -342,7 +341,7 @@ static int fromFloat32(AudioFormat forma
         shift = 0;
 
 #if ARCH_X86
-    if (sse_check() && len >= 16)
+    if (sse_check() && len >= 16 && ((unsigned long)out & 0xf) == 0)
     {
         float o = 1, mo = -1;
         int loops = len >> 4;
@@ -407,7 +406,7 @@ static int fromFloatFLT(float *out, floa
     int i = 0;
 
 #if ARCH_X86
-    if (sse_check() && len >= 16)
+    if (sse_check() && len >= 16 && ((unsigned long)in & 0xf) == 0)
     {
         int loops = len >> 4;
         float o = 1, mo = -1;
@@ -452,6 +451,19 @@ static int fromFloatFLT(float *out, floa
 }
 
 /**
+ * Returns true if platform has an FPU.
+ * for the time being, this test is limited to testing if SSE2 is supported
+ */
+bool AudioOutputUtil::has_hardware_fpu()
+{
+#if ARCH_X86
+    return sse_check();
+#else
+    return false;
+#endif
+}
+
+/**
  * Convert integer samples to floats
  *
  * Consumes 'bytes' bytes from in and returns the numer of bytes written to out
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiooutpututil.h mythtv-0.24.fixes/libs/libmyth/audiooutpututil.h
--- mythtv-0.24.orig/libs/libmyth/audiooutpututil.h	2010-05-24 23:17:44.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiooutpututil.h	2011-03-24 22:18:50.000000000 -0400
@@ -5,9 +5,10 @@ using namespace std;
 #include "mythverbose.h"
 #include "audiooutputsettings.h"
 
-class AudioOutputUtil
+class MPUBLIC AudioOutputUtil
 {
  public:
+    static bool has_hardware_fpu();
     static int  toFloat(AudioFormat format, void *out, void *in, int bytes);
     static int  fromFloat(AudioFormat format, void *out, void *in, int bytes);
     static void MonoToStereo(void *dst, void *src, int samples);
diff -Naurp mythtv-0.24.orig/libs/libmyth/audiosettings.cpp mythtv-0.24.fixes/libs/libmyth/audiosettings.cpp
--- mythtv-0.24.orig/libs/libmyth/audiosettings.cpp	2010-09-14 12:38:21.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/audiosettings.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -103,14 +103,14 @@ AudioSettings::AudioSettings(
 
 void AudioSettings::FixPassThrough(void)
 {
-    if (passthru_device.isEmpty() || passthru_device.toLower() == "default")
+    if (passthru_device.isEmpty())
         passthru_device = "auto";
 }
 
 void AudioSettings::TrimDeviceType(void)
 {
     main_device.remove(0, 5);
-    if (passthru_device != "auto")
+    if (passthru_device != "auto" && passthru_device.toLower() != "default")
         passthru_device.remove(0, 5);
 }
 
diff -Naurp mythtv-0.24.orig/libs/libmyth/mediamonitor-darwin.cpp mythtv-0.24.fixes/libs/libmyth/mediamonitor-darwin.cpp
--- mythtv-0.24.orig/libs/libmyth/mediamonitor-darwin.cpp	2010-06-17 23:47:21.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/mediamonitor-darwin.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -1,7 +1,7 @@
 /**
  * \file     mediamonitor-darwin.cpp
  * \brief    MythMediaMonitor for Darwin/Mac OS X.
- * \version  $Id: mediamonitor-darwin.cpp 25131 2010-06-18 03:47:21Z nigel $
+ * \version  $Id$
  * \author   Andrew Kimpton, Nigel Pearson
  */
 
diff -Naurp mythtv-0.24.orig/libs/libmyth/mythuifilebrowser.cpp mythtv-0.24.fixes/libs/libmyth/mythuifilebrowser.cpp
--- mythtv-0.24.orig/libs/libmyth/mythuifilebrowser.cpp	2010-09-12 14:26:11.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmyth/mythuifilebrowser.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -499,10 +499,14 @@ void MythUIFileBrowser::updateRemoteFile
         item->SetText(QString("0"), "filesize");
         item->SetText(m_parentDir, "fullpath");
         item->DisplayState(type, "nodetype");
-        m_backButton->SetEnabled(true);
+        if (m_backButton)
+            m_backButton->SetEnabled(true);
     }
     else
-        m_backButton->SetEnabled(false);
+    {
+        if (m_backButton)
+            m_backButton->SetEnabled(false);
+    }
 
     QStringList::const_iterator it = slist.begin();
     while (it != slist.end())
@@ -667,7 +671,9 @@ void MythUIFileBrowser::updateLocalFileL
         }
     }
 
-    m_backButton->SetEnabled(showBackButton);
+    if (m_backButton)
+        m_backButton->SetEnabled(showBackButton);
+
     m_locationEdit->SetText(m_subDirectory);
 }
 
diff -Naurp mythtv-0.24.orig/libs/libmythdb/.gitignore mythtv-0.24.fixes/libs/libmythdb/.gitignore
--- mythtv-0.24.orig/libs/libmythdb/.gitignore	1969-12-31 19:00:00.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythdb/.gitignore	2011-03-24 22:18:50.000000000 -0400
@@ -0,0 +1,2 @@
+mythconfig.mak
+mythconfig.h
diff -Naurp mythtv-0.24.orig/libs/libmythdb/mythcorecontext.cpp mythtv-0.24.fixes/libs/libmythdb/mythcorecontext.cpp
--- mythtv-0.24.orig/libs/libmythdb/mythcorecontext.cpp	2010-10-22 21:52:35.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythdb/mythcorecontext.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -613,9 +613,8 @@ QString MythCoreContext::GetMasterHostNa
     {
         QStringList strlist("QUERY_HOSTNAME");
 
-        SendReceiveStringList(strlist);
-
-        d->m_masterHostname = strlist[0];
+        if (SendReceiveStringList(strlist))
+            d->m_masterHostname = strlist[0];
     }
 
     QString ret = d->m_masterHostname;
diff -Naurp mythtv-0.24.orig/libs/libmythdb/mythdownloadmanager.cpp mythtv-0.24.fixes/libs/libmythdb/mythdownloadmanager.cpp
--- mythtv-0.24.orig/libs/libmythdb/mythdownloadmanager.cpp	2010-08-11 22:38:05.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythdb/mythdownloadmanager.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -7,6 +7,7 @@
 #include <QThreadPool>
 
 // libmythdb
+#include "stdlib.h"
 #include "compat.h"
 #include "mythcorecontext.h"
 #include "mythcoreutil.h"
@@ -54,7 +55,7 @@ class MythDownloadInfo
     {
         m_url.detach();
         m_outFile.detach();
-    }       
+    }
 
     QString          m_url;
     QUrl             m_redirectedTo;
@@ -110,6 +111,18 @@ class RemoteFileDownloadThread : public 
     MythDownloadInfo    *m_dlInfo;
 };
 
+/** \fn ShutdownMythDownloadManager(void)
+ *  \brief Deletes the running MythDownloadManager at program exit.
+ */
+static void ShutdownMythDownloadManager(void)
+{
+    if (downloadManager)
+    {
+        delete downloadManager;
+        downloadManager = NULL;
+    }
+}
+
 /** \fn GetMythDownloadManger(void)
  *  \brief Gets the pointer to the MythDownloadManager singleton.
  *  \return Pointer to the MythDownloadManager instance
@@ -128,6 +141,8 @@ MythDownloadManager *GetMythDownloadMana
 
         while (!downloadManager->isRunning())
             usleep(10000);
+
+        atexit(ShutdownMythDownloadManager);
     }
 
     return downloadManager;
@@ -536,7 +551,7 @@ void MythDownloadManager::downloadQNetwo
     static const char dateFormat[] = "ddd, dd MMM yyyy hh:mm:ss 'GMT'";
     QUrl qurl(dlInfo->m_url);
     QNetworkRequest request;
-    
+
     if (dlInfo->m_request)
     {
         request = *dlInfo->m_request;
@@ -593,7 +608,7 @@ void MythDownloadManager::downloadQNetwo
     connect(dlInfo->m_reply, SIGNAL(error(QNetworkReply::NetworkError)), this,
             SLOT(downloadError(QNetworkReply::NetworkError)));
     connect(dlInfo->m_reply, SIGNAL(downloadProgress(qint64, qint64)),
-            this, SLOT(downloadProgress(qint64, qint64))); 
+            this, SLOT(downloadProgress(qint64, qint64)));
 }
 
 /** \fn MythDownloadManager::downloadNow(MythDownloadInfo *dlInfo,
@@ -613,10 +628,16 @@ bool MythDownloadManager::downloadNow(My
     m_infoLock->unlock();
     m_queueWaitCond.wakeAll();
 
-    // sleep for 200ms at a time for up to 20 seconds waiting for the download
+    // timeout myth:// RemoteFile transfers 20 seconds from now
+    // timeout non-myth:// QNetworkAccessManager transfers 10 seconds after
+    //    their last progress update
+    QDateTime startedAt = QDateTime::currentDateTime();
     m_infoLock->lock();
     while ((!dlInfo->m_done) &&
-           (dlInfo->m_lastStat.secsTo(QDateTime::currentDateTime()) < 20))
+           (((!dlInfo->m_url.startsWith("myth://")) &&
+             (dlInfo->m_lastStat.secsTo(QDateTime::currentDateTime()) < 10)) ||
+            ((dlInfo->m_url.startsWith("myth://")) &&
+             (startedAt.secsTo(QDateTime::currentDateTime()) < 20))))
     {
         m_infoLock->unlock();
         m_queueWaitLock.lock();
@@ -624,17 +645,24 @@ bool MythDownloadManager::downloadNow(My
         m_queueWaitLock.unlock();
         m_infoLock->lock();
     }
-    m_infoLock->unlock();
 
     bool success =
         dlInfo->m_done && (dlInfo->m_errorCode == QNetworkReply::NoError);
 
-    if (deleteInfo)
+    if (!dlInfo->m_done)
+    {
+        dlInfo->m_syncMode = false; // Let downloadFinished() cleanup for us
+        if (dlInfo->m_reply)
+            dlInfo->m_reply->abort();
+    }
+    else if (deleteInfo)
         delete dlInfo;
 
+    m_infoLock->unlock();
+
     return success;
 }
-    
+
 /** \fn MythDownloadManager::removeListener(QObject *caller)
  *  \brief Disconnects the specify caller from any existing
  *         MythDownloadInfo instances.
@@ -771,6 +799,11 @@ void MythDownloadManager::downloadFinish
 
         m_downloadReplies[dlInfo->m_reply] = dlInfo;
 
+        connect(dlInfo->m_reply, SIGNAL(error(QNetworkReply::NetworkError)), this,
+                SLOT(downloadError(QNetworkReply::NetworkError)));
+        connect(dlInfo->m_reply, SIGNAL(downloadProgress(qint64, qint64)),
+                this, SLOT(downloadProgress(qint64, qint64)));
+
         m_downloadReplies.remove(reply);
         reply->deleteLater();
     }
@@ -838,7 +871,7 @@ void MythDownloadManager::downloadFinish
             {
                 VERBOSE(VB_FILE+VB_EXTRA, QString("downloadFinished(%1): "
                         "COMPLETE: %2, sending event to caller")
-                        .arg(dlInfo->m_url));
+                        .arg((long long)dlInfo).arg(dlInfo->m_url));
 
                 QStringList args;
                 args << dlInfo->m_url;
diff -Naurp mythtv-0.24.orig/libs/libmythdb/mythsystem.cpp mythtv-0.24.fixes/libs/libmythdb/mythsystem.cpp
--- mythtv-0.24.orig/libs/libmythdb/mythsystem.cpp	2010-11-02 14:40:37.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythdb/mythsystem.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -44,7 +44,7 @@
 
 #ifndef USING_MINGW
 typedef struct {
-    QMutex  mutex;
+    QSemaphore ready;
     uint    result;
     time_t  timeout;
     bool    background;
@@ -107,7 +107,7 @@ void MythSystemReaper::run(void)
             kill(pid, SIGTERM);
             usleep(500);
             kill(pid, SIGKILL);
-            pidData->mutex.unlock();
+            pidData->ready.release(1);
         }
         count = m_pidMap.size();
         m_mapLock.unlock();
@@ -167,8 +167,8 @@ void MythSystemReaper::run(void)
 
         if( pidData->background )
             delete pidData;
-        else
-            pidData->mutex.unlock();
+        else 
+            pidData->ready.release(1);
     }
 }
 
@@ -178,6 +178,8 @@ uint MythSystemReaper::waitPid( pid_t pi
     PidData_t  *pidData = new PidData_t;
     uint        result;
 
+    pidData->ready.release(1);  // Initialize 
+
     if( timeout > 0 )
         pidData->timeout = time(NULL) + timeout;
     else
@@ -185,14 +187,14 @@ uint MythSystemReaper::waitPid( pid_t pi
 
     pidData->background = background;
 
-    pidData->mutex.lock();
+    pidData->ready.acquire(1);
     m_mapLock.lock();
     m_pidMap.insert( pid, pidData );
     m_mapLock.unlock();
 
     if( !background ) {
         /* Now we wait for the thread to see the SIGCHLD */
-        while( !pidData->mutex.tryLock(100) )
+        while( !pidData->ready.tryAcquire(1,100) )
             if (processEvents)
                 qApp->processEvents();
 
diff -Naurp mythtv-0.24.orig/libs/libmythdb/mythversion.h mythtv-0.24.fixes/libs/libmythdb/mythversion.h
--- mythtv-0.24.orig/libs/libmythdb/mythversion.h	2010-10-28 20:20:24.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythdb/mythversion.h	2011-03-24 22:18:50.000000000 -0400
@@ -11,7 +11,7 @@
 /// Update this whenever the plug-in API changes.
 /// Including changes in the libmythdb, libmyth, libmythtv, libmythav* and
 /// libmythui class methods used by plug-ins.
-#define MYTH_BINARY_VERSION "0.24.20101028-1"
+#define MYTH_BINARY_VERSION "0.24.20101129-1"
 
 /** \brief Increment this whenever the MythTV network protocol changes.
  *
diff -Naurp mythtv-0.24.orig/libs/libmythdb/storagegroup.cpp mythtv-0.24.fixes/libs/libmythdb/storagegroup.cpp
--- mythtv-0.24.orig/libs/libmythdb/storagegroup.cpp	2010-07-30 18:09:02.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythdb/storagegroup.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -356,7 +356,8 @@ QString StorageGroup::GetRelativePathnam
         return result;
     }
 
-    query.prepare("SELECT DISTINCT dirname FROM storagegroup;");
+    query.prepare("SELECT DISTINCT dirname FROM storagegroup "
+                      "ORDER BY dirname DESC;");
     if (query.exec())
     {
         QString dirname;
diff -Naurp mythtv-0.24.orig/libs/libmythfreemheg/Engine.cpp mythtv-0.24.fixes/libs/libmythfreemheg/Engine.cpp
--- mythtv-0.24.orig/libs/libmythfreemheg/Engine.cpp	2009-11-16 11:18:35.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythfreemheg/Engine.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -708,8 +708,13 @@ void MHEngine::CheckContentRequests()
         if (m_Context->CheckCarouselObject(pContent->m_FileName) &&
             m_Context->GetCarouselData(pContent->m_FileName, text))
         {
-            pContent->m_pRequester->ContentArrived((const unsigned char *)text.data(),
-                                                   text.size(), this);
+            // If the content is not recognized catch the exception and continue
+            try {
+                pContent->m_pRequester->ContentArrived((const unsigned char *)text.data(),
+                                                       text.size(), this);
+            }
+            catch (char const *) {
+            }
             // Remove from the list.
             delete pContent;
             it = m_ExternContentTable.erase(it);
diff -Naurp mythtv-0.24.orig/libs/libmythfreesurround/freesurround.cpp mythtv-0.24.fixes/libs/libmythfreesurround/freesurround.cpp
--- mythtv-0.24.orig/libs/libmythfreesurround/freesurround.cpp	2010-09-12 11:19:20.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythfreesurround/freesurround.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -37,7 +37,7 @@ using namespace std;
 #include <QDateTime>
 
 // our default internal block size, in floats
-static const unsigned default_block_size = 8192;
+static const unsigned default_block_size = SURROUND_BUFSIZE;
 // Gain of center and lfe channels in passive mode (sqrt 0.5)
 static const float center_level = 0.707107; 
 
@@ -289,7 +289,7 @@ uint FreeSurround::putFrames(void* buffe
     }
 
     VERBOSE(VB_AUDIO+VB_TIMESTAMP+VB_EXTRA,
-            QString("FreeSurround::putFrames %1 #ch %2 used %4 generated %5")
+            QString("FreeSurround::putFrames %1 #ch %2 used %3 generated %4")
             .arg(numFrames).arg(numChannels).arg(i).arg(out_count));
 
     return i;
diff -Naurp mythtv-0.24.orig/libs/libmythfreesurround/freesurround.h mythtv-0.24.fixes/libs/libmythfreesurround/freesurround.h
--- mythtv-0.24.orig/libs/libmythfreesurround/freesurround.h	2010-05-24 23:17:44.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythfreesurround/freesurround.h	2011-03-24 22:18:50.000000000 -0400
@@ -21,6 +21,8 @@ Foundation, Inc., 51 Franklin Street, Fi
 
 #include "compat.h"  // instead of sys/types.h, for MinGW compatibility
 
+#define SURROUND_BUFSIZE 8192
+
 class FreeSurround
 {
 public:
diff -Naurp mythtv-0.24.orig/libs/libmythmetadata/videometadata.cpp mythtv-0.24.fixes/libs/libmythmetadata/videometadata.cpp
--- mythtv-0.24.orig/libs/libmythmetadata/videometadata.cpp	2010-09-27 07:42:14.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythmetadata/videometadata.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -909,7 +909,7 @@ int VideoMetadata::UpdateHashedDBRecord(
 {
     MSqlQuery query(MSqlQuery::InitCon());
 
-    query.prepare("SELECT intid FROM videometadata WHERE "
+    query.prepare("SELECT intid,filename FROM videometadata WHERE "
                   "hash = :HASH");
     query.bindValue(":HASH", hash);
 
@@ -923,6 +923,7 @@ int VideoMetadata::UpdateHashedDBRecord(
         return -1;
 
     int intid = query.value(0).toInt();
+    QString oldfilename = query.value(1).toString();
 
     query.prepare("UPDATE videometadata SET filename = :FILENAME, "
                   "host = :HOST WHERE intid = :INTID");
@@ -932,7 +933,18 @@ int VideoMetadata::UpdateHashedDBRecord(
 
     if (!query.exec() || !query.isActive())
     {
-        MythDB::DBError("Video hashed metadata update", query);
+        MythDB::DBError("Video hashed metadata update (videometadata)", query);
+        return -1;
+    }
+
+    query.prepare("UPDATE filemarkup SET filename = :FILENAME "
+                  "WHERE filename = :OLDFILENAME");
+    query.bindValue(":FILENAME", file_name);
+    query.bindValue(":OLDFILENAME", oldfilename);
+
+    if (!query.exec() || !query.isActive())
+    {
+        MythDB::DBError("Video hashed metadata update (filemarkup)", query);
         return -1;
     }
 
diff -Naurp mythtv-0.24.orig/libs/libmythsoundtouch/cpu_detect.h mythtv-0.24.fixes/libs/libmythsoundtouch/cpu_detect.h
--- mythtv-0.24.orig/libs/libmythsoundtouch/cpu_detect.h	2010-08-07 14:02:06.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythsoundtouch/cpu_detect.h	2011-03-24 22:18:50.000000000 -0400
@@ -51,10 +51,10 @@
 #define MM_SSE    0x0008 /* SSE functions */
 #define MM_SSE2   0x0010 /* PIV SSE2 functions */
 #define MM_3DNOWEXT  0x0020 /* AMD 3DNowExt */
-#define MM_SSE3   0x0010 /* SSE3 functions */
-#define MM_SSSE3  0x0010 /* SSSE3 functions */
-#define MM_SSE4   0x0010 /* SSE4.1 functions */
-#define MM_SSE42  0x0010 /* SSE4.2 functions */
+#define MM_SSE3   0x0040 /* SSE3 functions */
+#define MM_SSSE3  0x0080 /* SSSE3 functions */
+#define MM_SSE4   0x0100 /* SSE4.1 functions */
+#define MM_SSE42  0x0200 /* SSE4.2 functions */
 
 /// Checks which instruction set extensions are supported by the CPU.
 ///
diff -Naurp mythtv-0.24.orig/libs/libmythtv/audioplayer.cpp mythtv-0.24.fixes/libs/libmythtv/audioplayer.cpp
--- mythtv-0.24.orig/libs/libmythtv/audioplayer.cpp	2010-09-12 13:59:22.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/audioplayer.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -5,8 +5,8 @@
 #define LOC QString("AudioPlayer: ")
 
 AudioPlayer::AudioPlayer(MythPlayer *parent, bool muted)
-  : m_parent(parent),    m_audioOutput(NULL),   m_channels(2),
-    m_orig_channels(2),  m_codec(0),            m_format(FORMAT_NONE),
+  : m_parent(parent),    m_audioOutput(NULL),   m_channels(-1),
+    m_orig_channels(-1), m_codec(0),            m_format(FORMAT_NONE),
     m_samplerate(44100), m_stretchfactor(1.0f), m_passthru(false),
     m_lock(QMutex::Recursive), m_muted_on_creation(muted), 
     m_main_device(QString::null), m_passthru_device(QString::null),
@@ -44,18 +44,24 @@ QString AudioPlayer::ReinitAudio(void)
     QMutexLocker lock(&m_lock);
     QString errMsg = QString::null;
 
+    bool firstinit = (m_format == FORMAT_NONE &&
+                      m_channels < 0 &&
+                      m_samplerate == 44100);
+
     if ((m_format == FORMAT_NONE) ||
         (m_channels <= 0) ||
         (m_samplerate <= 0))
     {
-        VERBOSE(VB_IMPORTANT, LOC +
-                QString("Disabling Audio, params(%1,%2,%3)")
-                .arg(m_format).arg(m_channels).arg(m_samplerate));
-
+        if (!firstinit)
+        {
+            VERBOSE(VB_IMPORTANT, LOC +
+                    QString("Disabling Audio, params(%1,%2,%3)")
+                    .arg(m_format).arg(m_channels).arg(m_samplerate));
+        }
         no_audio_in = no_audio_out = true;
     }
-
-    no_audio_in = false;
+    else
+        no_audio_in = false;
 
     if (no_audio_out && want_audio)
     {
@@ -76,8 +82,11 @@ QString AudioPlayer::ReinitAudio(void)
 
         if (!errMsg.isEmpty())
         {
-            VERBOSE(VB_IMPORTANT, LOC + "Disabling Audio" +
-                    QString(", reason is: %1").arg(errMsg));
+            if (!firstinit)
+            {
+                VERBOSE(VB_IMPORTANT, LOC + "Disabling Audio" +
+                        QString(", reason is: %1").arg(errMsg));
+            }
             no_audio_out = true;
         }
         else if (no_audio_out)
@@ -312,21 +321,22 @@ uint AudioPlayer::GetMaxChannels(void)
     return ret;
 }
 
-bool AudioPlayer::CanPassthrough(int samplerate)
+bool AudioPlayer::CanPassthrough(int samplerate, int channels)
 {
     bool ret = false;
     if (m_audioOutput)
-        ret = m_audioOutput->CanPassthrough(samplerate);
+        ret = m_audioOutput->CanPassthrough(samplerate, channels);
     return ret;
 }
 
 void AudioPlayer::AddAudioData(char *buffer, int len, int64_t timecode)
 {
-    if (m_parent->PrepareAudioSample(timecode) && m_audioOutput &&
-        !no_audio_out)
+    if (!m_audioOutput)
+        return;
+    if (m_parent->PrepareAudioSample(timecode) && !no_audio_out)
         m_audioOutput->Drain();
     int samplesize = m_channels * AudioOutputSettings::SampleSize(m_format);
-    if ((samplesize <= 0) || !m_audioOutput)
+    if (samplesize <= 0)
         return;
     int frames = len / samplesize;
     if (!m_audioOutput->AddFrames(buffer, frames, timecode))
@@ -342,3 +352,14 @@ bool AudioPlayer::GetBufferStatus(uint &
     m_audioOutput->GetBufferStatus(fill, total);
     return true;
 }
+
+bool AudioPlayer::IsBufferAlmostFull(void)
+{
+    uint ofill = 0, ototal = 0, othresh = 0;
+    if (GetBufferStatus(ofill, ototal))
+    {
+        othresh =  ((ototal>>1) + (ototal>>2));
+        return ofill > othresh;
+    }
+    return false;
+}
diff -Naurp mythtv-0.24.orig/libs/libmythtv/audioplayer.h mythtv-0.24.fixes/libs/libmythtv/audioplayer.h
--- mythtv-0.24.orig/libs/libmythtv/audioplayer.h	2010-09-12 13:59:22.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/audioplayer.h	2011-03-24 22:18:50.000000000 -0400
@@ -39,7 +39,7 @@ class MPUBLIC AudioPlayer
     float GetStretchFactor(void) { return m_stretchfactor;   }
     void  SetStretchFactor(float factor);
     bool  ToggleUpmix(void);
-    bool  CanPassthrough(int samplerate);
+    bool  CanPassthrough(int samplerate, int channels);
     bool  CanAC3(void);
     bool  CanDTS(void);
     uint  GetMaxChannels(void);
@@ -53,6 +53,7 @@ class MPUBLIC AudioPlayer
 
     void AddAudioData(char *buffer, int len, int64_t timecode);
     bool GetBufferStatus(uint &fill, uint &total);
+    bool IsBufferAlmostFull(void);
 
   private:
     MythPlayer  *m_parent;
diff -Naurp mythtv-0.24.orig/libs/libmythtv/avformatdecoder.cpp mythtv-0.24.fixes/libs/libmythtv/avformatdecoder.cpp
--- mythtv-0.24.orig/libs/libmythtv/avformatdecoder.cpp	2010-11-05 23:29:25.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/avformatdecoder.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -15,6 +15,7 @@ using namespace std;
 #include "avformatdecoder.h"
 #include "privatedecoder.h"
 #include "audiooutput.h"
+#include "audiooutpututil.h"
 #include "RingBuffer.h"
 #include "mythplayer.h"
 #include "remoteencoder.h"
@@ -27,6 +28,7 @@ using namespace std;
 #include "dvbdescriptors.h"
 #include "cc608decoder.h"
 #include "cc708decoder.h"
+#include "teletextdecoder.h"
 #include "subtitlereader.h"
 #include "interactivetv.h"
 #include "DVDRingBuffer.h"
@@ -73,8 +75,6 @@ extern void ff_read_frame_flush(AVFormat
 
 #define MAX_AC3_FRAME_SIZE 6144
 
-static const bool force_reordered_opaque = false;
-
 static const float eps = 1E-5;
 
 static const int max_video_queue_size = 180;
@@ -267,6 +267,7 @@ AvFormatDecoder::AvFormatDecoder(MythPla
       last_dts_for_fault_detection(0),
       pts_detected(false),
       reordered_pts_detected(false),
+      pts_selected(true),
       using_null_videoout(use_null_videoout),
       video_codec_id(kCodec_NONE),
       no_hardware_decoders(no_hardware_decode),
@@ -276,7 +277,8 @@ AvFormatDecoder::AvFormatDecoder(MythPla
       // Closed Caption & Teletext decoders
       ccd608(new CC608Decoder(parent->GetCC608Reader())),
       ccd708(new CC708Decoder(parent->GetCC708Reader())),
-      ttd(new TeletextDecoder(parent)), subReader(parent->GetSubReader()),
+      ttd(new TeletextDecoder(parent->GetTeletextReader())),
+      subReader(parent->GetSubReader()),
       // Interactive TV
       itv(NULL),
       // Audio
@@ -403,6 +405,8 @@ static int64_t lsb3full(int64_t lsb, int
 
 int64_t AvFormatDecoder::NormalizeVideoTimecode(int64_t timecode)
 {
+    int64_t start_pts = 0, pts;
+
     AVStream *st = NULL;
     for (uint i = 0; i < ic->nb_streams; i++)
     {
@@ -416,19 +420,39 @@ int64_t AvFormatDecoder::NormalizeVideoT
     if (!st)
         return false;
 
-   // convert timecode and start_time to AV_TIME_BASE units
-   int64_t start_ts = av_rescale(ic->start_time,
-                                 st->time_base.den,
-                                 AV_TIME_BASE * (int64_t)st->time_base.num);
-
-   int64_t ts = av_rescale(timecode / 1000.0 * AV_TIME_BASE,
-                           st->time_base.den,
-                           AV_TIME_BASE * (int64_t)st->time_base.num);
+    if (ic->start_time != AV_NOPTS_VALUE)
+        start_pts = av_rescale(ic->start_time,
+                               st->time_base.den,
+                               AV_TIME_BASE * (int64_t)st->time_base.num);
 
-   // adjust for start time and wrap
-   ts = lsb3full(ts, start_ts, st->pts_wrap_bits);
+    pts = av_rescale(timecode / 1000.0,
+                     st->time_base.den,
+                     st->time_base.num);
 
-   return (int64_t)(av_q2d(st->time_base) * ts * 1000);
+    // adjust for start time and wrap
+    pts = lsb3full(pts, start_pts, st->pts_wrap_bits);
+
+    return (int64_t)(av_q2d(st->time_base) * pts * 1000);
+}
+
+int64_t AvFormatDecoder::NormalizeVideoTimecode(AVStream *st,
+                                                int64_t timecode)
+{
+    int64_t start_pts = 0, pts;
+
+    if (ic->start_time != AV_NOPTS_VALUE)
+        start_pts = av_rescale(ic->start_time,
+                               st->time_base.den,
+                               AV_TIME_BASE * (int64_t)st->time_base.num);
+
+    pts = av_rescale(timecode / 1000.0,
+                     st->time_base.den,
+                     st->time_base.num);
+
+    // adjust for start time and wrap
+    pts = lsb3full(pts, start_pts, st->pts_wrap_bits);
+
+    return (int64_t)(av_q2d(st->time_base) * pts * 1000);
 }
 
 int AvFormatDecoder::GetNumChapters()
@@ -656,6 +680,7 @@ void AvFormatDecoder::SeekReset(long lon
         last_pts_for_fault_detection = 0;
         last_dts_for_fault_detection = 0;
         pts_detected = false;
+        reordered_pts_detected = false;
 
         ff_read_frame_flush(ic);
 
@@ -718,6 +743,18 @@ void AvFormatDecoder::SeekReset(long lon
     }
 }
 
+void AvFormatDecoder::SetEof(bool eof)
+{
+    if (!eof && ic && ic->pb)
+    {
+        VERBOSE(VB_IMPORTANT, LOC +
+            QString("Resetting byte context eof (livetv %1 was eof %2)")
+            .arg(livetv).arg(ic->pb->eof_reached));
+        ic->pb->eof_reached = 0;
+    }
+    DecoderBase::SetEof(eof);
+}
+
 void AvFormatDecoder::Reset(bool reset_video_data, bool seek_reset)
 {
     VERBOSE(VB_PLAYBACK, LOC + QString("Reset(%1, %2)")
@@ -921,8 +958,13 @@ int AvFormatDecoder::OpenFile(RingBuffer
 
     fmt->flags &= ~AVFMT_NOFILE;
 
-    if (!ringBuffer->isDVD() && !livetv)
+    if (!ringBuffer->isDVD() && !ringBuffer->isBD() && !livetv)
+    {
         av_estimate_timings(ic, 0);
+        // generate timings based on the video stream to avoid bogus ffmpeg
+        // values for duration and bitrate
+        av_update_stream_timings_video(ic);
+    }
 
     // Scan for the initial A/V streams
     ret = ScanStreams(novideo);
@@ -957,12 +999,18 @@ int AvFormatDecoder::OpenFile(RingBuffer
         }
     }
 
+    // If watching pre-recorded television or video use ffmpeg duration
+    int64_t dur = ic->duration / (int64_t)AV_TIME_BASE;
+    if (dur > 0 && !livetv && !watchingrecording)
+    {
+        m_parent->SetDuration((int)dur);
+    }
+
     // If we don't have a position map, set up ffmpeg for seeking
     if (!recordingHasPositionMap && !livetv)
     {
         VERBOSE(VB_PLAYBACK, LOC +
                 "Recording has no position -- using libavformat seeking.");
-        int64_t dur = ic->duration / (int64_t)AV_TIME_BASE;
 
         if (dur > 0)
         {
@@ -1582,7 +1630,7 @@ void AvFormatDecoder::ScanTeletextCaptio
                     VERBOSE(VB_PLAYBACK, LOC + QString(
                                 "Teletext stream #%1 (%2) is in the %3 language"
                                 " on page %4 %5.")
-                            .arg(k).arg((type == 1) ? "Caption" : "Menu")
+                            .arg(k).arg((type == 2) ? "Caption" : "Menu")
                             .arg(iso639_key_toName(language))
                             .arg(magazine).arg(pagenum));
                 }
@@ -1796,8 +1844,7 @@ int AvFormatDecoder::ScanStreams(bool no
                         if (dec.left(4) == "xvmc")
                             dvd_xvmc_enabled = true;
 
-                        if (ringBuffer->InDVDMenuOrStillFrame() &&
-                            dvd_xvmc_enabled)
+                        if (ringBuffer->IsDVD())
                         {
                             force_xv = true;
                             enc->pix_fmt = PIX_FMT_YUV420P;
@@ -2771,6 +2818,7 @@ void AvFormatDecoder::MpegPreProcessPkt(
                 last_pts_for_fault_detection = 0;
                 last_dts_for_fault_detection = 0;
                 pts_detected = false;
+                reordered_pts_detected = false;
 
                 // fps debugging info
                 float avFPS = normalized_fps(stream, context);
@@ -2877,6 +2925,7 @@ bool AvFormatDecoder::H264PreProcessPkt(
             last_pts_for_fault_detection = 0;
             last_dts_for_fault_detection = 0;
             pts_detected = false;
+            reordered_pts_detected = false;
 
             // fps debugging info
             float avFPS = normalized_fps(stream, context);
@@ -2946,7 +2995,7 @@ bool AvFormatDecoder::PreProcessVideoPac
 bool AvFormatDecoder::ProcessVideoPacket(AVStream *curstream, AVPacket *pkt)
 {
     int ret = 0, gotpicture = 0;
-    long long pts = 0;
+    int64_t pts = 0;
     AVCodecContext *context = curstream->codec;
     AVFrame mpa_pic;
     avcodec_get_frame_defaults(&mpa_pic);
@@ -2958,9 +3007,7 @@ bool AvFormatDecoder::ProcessVideoPacket
     avcodeclock->lock();
     if (private_dec)
     {
-        if (QString(ic->iformat->name).contains("avi"))
-            pkt->pts = pkt->dts;
-        if (!pts_detected)
+        if (QString(ic->iformat->name).contains("avi") || !pts_detected)
             pkt->pts = pkt->dts;
         // TODO disallow private decoders for dvd playback
         // N.B. we do not reparse the frame as it breaks playback for
@@ -3069,34 +3116,35 @@ bool AvFormatDecoder::ProcessVideoPacket
     if (ringBuffer->isDVD())
     {
         if (pkt->dts != (int64_t)AV_NOPTS_VALUE)
-            pts = (long long)pkt->dts;
+            pts = pkt->dts;
+        pts_selected = false;
     }
     else if (private_dec && private_dec->NeedsReorderedPTS() &&
              mpa_pic.reordered_opaque != (int64_t)AV_NOPTS_VALUE)
     {
-        pts = (long long)mpa_pic.reordered_opaque;
+        pts = mpa_pic.reordered_opaque;
+        pts_selected = true;
     }
-    else if ((force_reordered_opaque || faulty_pts <= faulty_dts ||
-             pkt->dts == (int64_t)AV_NOPTS_VALUE) &&
-             mpa_pic.reordered_opaque != (int64_t)AV_NOPTS_VALUE)
+    else if (faulty_pts <= faulty_dts && reordered_pts_detected)
     {
-        pts = (long long)mpa_pic.reordered_opaque;
+        if (mpa_pic.reordered_opaque != (int64_t)AV_NOPTS_VALUE)
+            pts = mpa_pic.reordered_opaque;
+        pts_selected = true;
     }
-    else if ((faulty_dts < faulty_pts || !reordered_pts_detected) &&
-             pkt->dts != (int64_t)AV_NOPTS_VALUE)
+    else if (pkt->dts != (int64_t)AV_NOPTS_VALUE)
     {
-        pts = (long long)pkt->dts;
+        pts = pkt->dts;
+        pts_selected = false;
     }
-    pts = (long long)(av_q2d(curstream->time_base) * pts * 1000);
-
-    long long temppts = pts;
+    long long vpts = (long long)(av_q2d(curstream->time_base) * pts * 1000);
 
+    long long temppts = vpts;
     // Validate the video pts against the last pts. If it's
     // a little bit smaller, equal or missing, compute
     // it from the last. Otherwise assume a wraparound.
     if (!ringBuffer->isDVD() &&
         temppts <= lastvpts &&
-        (temppts + 10000 > lastvpts || temppts <= 0))
+        (temppts + (1000 / fps) > lastvpts || temppts <= 0))
     {
         temppts = lastvpts;
         temppts += (long long)(1000 / fps);
@@ -3105,8 +3153,11 @@ bool AvFormatDecoder::ProcessVideoPacket
     }
 
     VERBOSE(VB_PLAYBACK+VB_TIMESTAMP, LOC +
-            QString("video timecode %1 %2 %3 %4 %5").arg(mpa_pic.reordered_opaque).arg(pkt->pts).arg(pkt->dts)
-            .arg(temppts).arg(lastvpts));
+            QString("video timecode %1 %2 %3 %4 %5 %6 (%7 active)%8")
+                    .arg(mpa_pic.reordered_opaque).arg(pkt->pts).arg(pkt->dts)
+                    .arg(vpts).arg(temppts).arg(lastvpts)
+                    .arg((pts_selected) ? "reordered" : "dts")
+                    .arg((vpts != temppts) ? " fixup" : ""));
 
 /* XXX: Broken.
     if (mpa_pic.qscale_table != NULL && mpa_pic.qstride > 0 &&
@@ -3130,10 +3181,11 @@ bool AvFormatDecoder::ProcessVideoPacket
 */
 
     picframe->interlaced_frame = mpa_pic.interlaced_frame;
-    picframe->top_field_first = mpa_pic.top_field_first;
-    picframe->repeat_pict = mpa_pic.repeat_pict;
+    picframe->top_field_first  = mpa_pic.top_field_first;
+    picframe->repeat_pict      = mpa_pic.repeat_pict;
+    picframe->disp_timecode    = NormalizeVideoTimecode(curstream, temppts);
+    picframe->frameNumber      = framesPlayed;
 
-    picframe->frameNumber = framesPlayed;
     m_parent->ReleaseNextVideoFrame(picframe, temppts);
     if (private_dec && mpa_pic.data[3])
         context->release_buffer(context, &mpa_pic);
@@ -3221,7 +3273,7 @@ bool AvFormatDecoder::ProcessVideoFrame(
     // it from the last. Otherwise assume a wraparound.
     if (!ringBuffer->isDVD() &&
         temppts <= lastvpts &&
-        (temppts + 10000 > lastvpts || temppts <= 0))
+        (temppts + (1000 / fps) > lastvpts || temppts <= 0))
     {
         temppts = lastvpts;
         temppts += (long long)(1000 / fps);
@@ -3230,8 +3282,9 @@ bool AvFormatDecoder::ProcessVideoFrame(
     }
 
     VERBOSE(VB_PLAYBACK+VB_TIMESTAMP, LOC +
-            QString("ProcessVideoFrame timecode %1 %2 %3")
-            .arg(mpa_pic->reordered_opaque).arg(temppts).arg(lastvpts));
+            QString("ProcessVideoFrame timecode %1 %2 %3%4")
+            .arg(mpa_pic->reordered_opaque).arg(pts).arg(temppts).arg(lastvpts)
+            .arg((pts != temppts) ? " fixup" : ""));
 
     picframe->interlaced_frame = mpa_pic->interlaced_frame;
     picframe->top_field_first = mpa_pic->top_field_first;
@@ -3593,11 +3646,6 @@ int AvFormatDecoder::GetTeletextDecoderT
     return ttd->GetDecoderType();
 }
 
-void AvFormatDecoder::SetTeletextDecoderViewer(TeletextViewer *view)
-{
-    ttd->SetViewer(view);
-}
-
 QString AvFormatDecoder::GetXDS(const QString &key) const
 {
     return ccd608->GetXDS(key);
@@ -3930,13 +3978,6 @@ bool AvFormatDecoder::ProcessAudioPacket
     int audSubIdx = selectedTrack[kTrackTypeAudio].av_substream_index;
     avcodeclock->unlock();
 
-    uint ofill = 0, ototal = 0, othresh = 0, total_decoded_audio = 0;
-    if (m_audio->GetBufferStatus(ofill, ototal))
-    {
-        othresh =  ((ototal>>1) + (ototal>>2));
-        allowedquit = (!(decodetype & kDecodeAudio)) && (ofill > othresh);
-    }
-
     if (pkt->dts != (int64_t)AV_NOPTS_VALUE)
         pts = (long long)(av_q2d(curstream->time_base) * pkt->dts * 1000);
 
@@ -4084,7 +4125,7 @@ bool AvFormatDecoder::ProcessAudioPacket
         // calc for next frame
         lastapts += (long long)
             ((double)(data_size * 1000) /
-             (ctx->sample_rate * ctx->channels *
+             (ctx->sample_rate * (audioOut.do_passthru ?  2 : ctx->channels) *
               av_get_bits_per_sample_format(ctx->sample_fmt)>>3));
 
         VERBOSE(VB_PLAYBACK+VB_TIMESTAMP,
@@ -4097,29 +4138,9 @@ bool AvFormatDecoder::ProcessAudioPacket
 
         m_audio->AddAudioData((char *)audioSamples, data_size, temppts);
 
-        total_decoded_audio += data_size;
-
-        allowedquit |= ringBuffer->InDVDMenuOrStillFrame();
-        // Audio can expand by a factor of 6 in audiooutputbase's audiobuffer
-        allowedquit |= !(decodetype & kDecodeVideo) &&
-                       ((ofill + total_decoded_audio * 6) > othresh);
-
-        // top off audio buffers initially in audio only mode
-        if (!allowedquit && !(decodetype & kDecodeVideo))
-        {
-            uint fill, total;
-            if (m_audio->GetBufferStatus(fill, total))
-            {
-                total /= 6; // Possible expansion in aobase (upmix, float conv)
-                allowedquit = fill == 0 || fill > total>>1           ||
-                              total - fill < (uint)(data_size)       ||
-                              ofill + total_decoded_audio > total>>2 ||
-                              total - fill < (uint)(data_size<<1);
-            }
-            else
-                VERBOSE(VB_IMPORTANT, LOC_ERR + "GetFrame() : Failed to top off "
-                                                "buffers in audio only mode");
-        }
+        allowedquit |=
+            ringBuffer->InDVDMenuOrStillFrame() ||
+            m_audio->IsBufferAlmostFull();
 
         tmp_pkt.data += ret;
         tmp_pkt.size -= ret;
@@ -4158,12 +4179,7 @@ bool AvFormatDecoder::GetFrame(DecodeTyp
         skipaudio = false;
     }
 
-    uint ofill = 0, ototal = 0, othresh = 0;
-    if (m_audio->GetBufferStatus(ofill, ototal))
-    {
-        othresh =  ((ototal>>1) + (ototal>>2));
-        allowedquit = ofill > othresh;
-    }
+    allowedquit = m_audio->IsBufferAlmostFull();
 
     if (private_dec && private_dec->HasBufferedFrames() &&
        (selectedTrack[kTrackTypeVideo].av_stream_index > -1))
@@ -4262,8 +4278,7 @@ bool AvFormatDecoder::GetFrame(DecodeTyp
                 if (retval == -EAGAIN)
                     continue;
 
-                ateof = true;
-                m_parent->SetEof();
+                SetEof(true);
                 delete pkt;
                 return false;
             }
@@ -4584,6 +4599,10 @@ void AvFormatDecoder::SetDisablePassThro
 
 inline bool AvFormatDecoder::DecoderWillDownmix(const AVCodecContext *ctx)
 {
+        // Until ffmpeg properly implements dialnorm
+        // use Myth internal downmixer if machines has FPU/SSE
+    if (AudioOutputUtil::has_hardware_fpu())
+        return false;
     switch (ctx->codec_id)
     {
         case CODEC_ID_AC3:
@@ -4603,14 +4622,9 @@ bool AvFormatDecoder::DoPassThrough(cons
         passthru = m_audio->CanAC3();
     else if (ctx->codec_id == CODEC_ID_DTS)
         passthru = m_audio->CanDTS();
-    passthru &= m_audio->CanPassthrough(ctx->sample_rate);
-        // Will downmix if we can't support the amount of channels
-    passthru &= ctx->channels >= (int)m_audio->GetMaxChannels();
+    passthru &= m_audio->CanPassthrough(ctx->sample_rate, ctx->channels);
     passthru &= !internal_vol;
     passthru &= !transcoding && !disable_passthru;
-    // Don't know any cards that support spdif clocked at < 44100
-    // Some US cable transmissions have 2ch 32k AC-3 streams
-    passthru &= ctx->sample_rate >= 44100;
 
     return passthru;
 }
@@ -4986,4 +5000,59 @@ static int dts_decode_header(uint8_t *in
     return fsize;
 }
 
+void AvFormatDecoder::av_update_stream_timings_video(AVFormatContext *ic)
+{
+    int64_t start_time, start_time1, end_time, end_time1;
+    int64_t duration, duration1;
+    AVStream *st = NULL;
+
+    start_time = INT64_MAX;
+    end_time = INT64_MIN;
+
+    for (uint i = 0; i < ic->nb_streams; i++)
+    {
+        AVStream *st1 = ic->streams[i];
+        if (st1 && st1->codec->codec_type == CODEC_TYPE_VIDEO)
+        {
+            st = st1;
+            break;
+        }
+    }
+    if (!st)
+        return;
+
+   duration = INT64_MIN;
+   if (st->start_time != (int64_t)AV_NOPTS_VALUE && st->time_base.den) {
+       start_time1= av_rescale_q(st->start_time, st->time_base, AV_TIME_BASE_Q);
+       if (start_time1 < start_time)
+           start_time = start_time1;
+       if (st->duration != (int64_t)AV_NOPTS_VALUE) {
+           end_time1 = start_time1
+                     + av_rescale_q(st->duration, st->time_base, AV_TIME_BASE_Q);
+           if (end_time1 > end_time)
+               end_time = end_time1;
+       }
+   }
+   if (st->duration != (int64_t)AV_NOPTS_VALUE) {
+       duration1 = av_rescale_q(st->duration, st->time_base, AV_TIME_BASE_Q);
+       if (duration1 > duration)
+           duration = duration1;
+   }
+    if (start_time != INT64_MAX) {
+        ic->start_time = start_time;
+        if (end_time != INT64_MIN) {
+            if (end_time - start_time > duration)
+                duration = end_time - start_time;
+        }
+    }
+    if (duration != INT64_MIN) {
+        ic->duration = duration;
+        if (ic->file_size > 0) {
+            /* compute the bitrate */
+            ic->bit_rate = (double)ic->file_size * 8.0 * AV_TIME_BASE /
+                (double)ic->duration;
+        }
+    }
+}
+
 /* vim: set expandtab tabstop=4 shiftwidth=4: */
diff -Naurp mythtv-0.24.orig/libs/libmythtv/avformatdecoder.h mythtv-0.24.fixes/libs/libmythtv/avformatdecoder.h
--- mythtv-0.24.orig/libs/libmythtv/avformatdecoder.h	2010-10-12 23:42:54.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/avformatdecoder.h	2011-03-24 22:18:50.000000000 -0400
@@ -95,9 +95,11 @@ class AvFormatDecoder : public DecoderBa
                     AVSpecialDecode av_special_decode = kAVSpecialDecode_None);
    ~AvFormatDecoder();
 
+    virtual void SetEof(bool eof);
+
     void CloseCodecs();
     void CloseContext();
-    void Reset(void);
+    virtual void Reset(void);
     void Reset(bool reset_video_data = true, bool seek_reset = true);
 
     /// Perform an av_probe_input_format on the passed data to see if we
@@ -155,9 +157,9 @@ class AvFormatDecoder : public DecoderBa
     virtual bool DoFastForward(long long desiredFrame, bool doflush = true);
 
     virtual int64_t NormalizeVideoTimecode(int64_t timecode);
+    virtual int64_t NormalizeVideoTimecode(AVStream *st, int64_t timecode);
 
     virtual int  GetTeletextDecoderType(void) const;
-    virtual void SetTeletextDecoderViewer(TeletextViewer*);
 
     virtual QString GetXDS(const QString&) const;
 
@@ -233,6 +235,7 @@ class AvFormatDecoder : public DecoderBa
     bool GenerateDummyVideoFrame(void);
     bool HasVideo(const AVFormatContext *ic);
     float normalized_fps(AVStream *stream, AVCodecContext *enc);
+    void av_update_stream_timings_video(AVFormatContext *ic);
 
   private:
     PrivateDecoder *private_dec;
@@ -283,6 +286,7 @@ class AvFormatDecoder : public DecoderBa
     int64_t last_dts_for_fault_detection;
     bool pts_detected;
     bool reordered_pts_detected;
+    bool pts_selected;
 
     bool using_null_videoout;
     MythCodecID video_codec_id;
diff -Naurp mythtv-0.24.orig/libs/libmythtv/bswap.h mythtv-0.24.fixes/libs/libmythtv/bswap.h
--- mythtv-0.24.orig/libs/libmythtv/bswap.h	1969-12-31 19:00:00.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythtv/bswap.h	2011-03-24 22:18:50.000000000 -0400
@@ -0,0 +1,29 @@
+#ifndef MYTHTV_BSWAP_H
+#define MYTHTV_BSWAP_H
+
+#include <stdint.h> /* uint32_t */
+
+#ifdef __linux__
+#  include <byteswap.h> /* bswap_16|32|64 */
+#elif defined __APPLE__
+#  include <libkern/OSByteOrder.h> 
+#  define bswap_16(x) OSSwapInt16(x)
+#  define bswap_32(x) OSSwapInt32(x)
+#  define bswap_64(x) OSSwapInt64(x)
+#else
+#  error Byte swapping functions not defined for this platform
+#endif
+
+static __inline__ double bswap_dbl(double x)
+{
+    union {
+        uint32_t l[2];
+        double   d;
+    } w, r;
+    w.d = x;
+    r.l[0] = bswap_32(w.l[1]);
+    r.l[1] = bswap_32(w.l[0]);
+    return r.d;
+}
+
+#endif /* ndef MYTHTV_BSWAP_H */
diff -Naurp mythtv-0.24.orig/libs/libmythtv/cc608reader.cpp mythtv-0.24.fixes/libs/libmythtv/cc608reader.cpp
--- mythtv-0.24.orig/libs/libmythtv/cc608reader.cpp	2010-08-31 10:31:38.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/cc608reader.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -41,7 +41,6 @@ CC608Buffer* CC608Reader::GetOutputText(
     if (!m_enabled || !m_parent)
         return NULL;
 
-    changed = m_changed;
     VideoFrame *last = NULL;
     if (m_parent->getVideoOutput())
         last = m_parent->getVideoOutput()->GetLastShownFrame();
diff -Naurp mythtv-0.24.orig/libs/libmythtv/decoderbase.cpp mythtv-0.24.fixes/libs/libmythtv/decoderbase.cpp
--- mythtv-0.24.orig/libs/libmythtv/decoderbase.cpp	2010-10-14 09:04:37.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/decoderbase.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -77,7 +77,7 @@ void DecoderBase::Reset(void)
     dontSyncPositionMap = false;
 
     waitingForChange = false;
-    ateof = false;
+    SetEof(false);
 }
 
 void DecoderBase::SeekReset(long long, uint, bool, bool)
diff -Naurp mythtv-0.24.orig/libs/libmythtv/decoderbase.h mythtv-0.24.fixes/libs/libmythtv/decoderbase.h
--- mythtv-0.24.orig/libs/libmythtv/decoderbase.h	2010-10-07 02:27:49.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/decoderbase.h	2011-03-24 22:18:50.000000000 -0400
@@ -94,6 +94,9 @@ class DecoderBase
                          char testbuf[kDecoderProbeBufferSize],
                          int testbufsize = kDecoderProbeBufferSize) = 0;
 
+    virtual void SetEof(bool eof)  { ateof = eof;  }
+    bool         GetEof(void)      { return ateof; }
+
     void setExactSeeks(bool exact) { exactseeks = exact; }
     bool getExactSeeks(void) const { return exactseeks;  }
     void setLiveTVMode(bool live)  { livetv = live;      }
@@ -188,7 +191,6 @@ class DecoderBase
     inline int   NextTrack(uint type);
 
     virtual int  GetTeletextDecoderType(void) const { return -1; }
-    virtual void SetTeletextDecoderViewer(TeletextViewer*) {;}
 
     virtual QString GetXDS(const QString&) const { return QString::null; }
 
diff -Naurp mythtv-0.24.orig/libs/libmythtv/dtvrecorder.cpp mythtv-0.24.fixes/libs/libmythtv/dtvrecorder.cpp
--- mythtv-0.24.orig/libs/libmythtv/dtvrecorder.cpp	2010-10-17 13:35:21.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/dtvrecorder.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -11,6 +11,7 @@
 #include "mpegstreamdata.h"
 #include "dtvrecorder.h"
 #include "tv_rec.h"
+#include "mythverbose.h"
 
 extern "C" {
 extern const uint8_t *ff_find_start_code(const uint8_t *p, const uint8_t *end, uint32_t *state);
@@ -329,7 +330,7 @@ bool DTVRecorder::FindMPEG2Keyframes(con
     if (hasKeyFrame)
     {
         _last_keyframe_seen = _frames_seen_count;
-        HandleKeyframe();
+        HandleKeyframe(_frames_written_count, TSPacket::SIZE);
     }
 
     if (hasFrame)
@@ -388,7 +389,7 @@ bool DTVRecorder::FindAudioKeyframes(con
         if (1 == (_frames_seen_count & 0x7))
         {
             _last_keyframe_seen = _frames_seen_count;
-            HandleKeyframe();
+            HandleKeyframe(_frames_written_count);
             hasKeyFrame = true;
         }
 
@@ -416,7 +417,7 @@ bool DTVRecorder::FindOtherKeyframes(con
     _frames_written_count++;
     _last_keyframe_seen = _frames_seen_count;
 
-    HandleKeyframe();
+    HandleKeyframe(_frames_written_count);
 
     _has_written_other_keyframe = true;
 
@@ -451,12 +452,14 @@ void DTVRecorder::SetNextRecording(const
  *  \brief This save the current frame to the position maps
  *         and handles ringbuffer switching.
  */
-void DTVRecorder::HandleKeyframe(uint64_t extra)
+void DTVRecorder::HandleKeyframe(uint64_t frameNum, int64_t extra)
 {
     if (!ringBuffer)
         return;
 
+#if 0
     unsigned long long frameNum = _frames_written_count;
+#endif
 
     _first_keyframe = (_first_keyframe < 0) ? frameNum : _first_keyframe;
 
@@ -466,7 +469,7 @@ void DTVRecorder::HandleKeyframe(uint64_
     {
         long long startpos = ringBuffer->GetWritePosition();
         // FIXME: handle keyframes with start code spanning over two ts packets
-        startpos += _payload_buffer.size() + extra;
+        startpos += _payload_buffer.size() - extra;
 
         // Don't put negative offsets into the database, they get munged into
         // MAX_INT64 - offset, which is an exceedingly large number, and
@@ -773,19 +776,19 @@ void DTVRecorder::FindPSKeyFrames(const 
             hasKeyFrame &= (_last_seq_seen + maxKFD) < _frames_seen_count;
         }
 
-        if (hasKeyFrame)
-        {
-            _last_keyframe_seen = _frames_seen_count;
-            HandleKeyframe(bufptr - bufstart);
-        }
-
         if (hasFrame)
         {
             _frames_seen_count++;
-            if (!_wait_for_keyframe_option || _first_keyframe>=0)
+            if (!_wait_for_keyframe_option || _first_keyframe >= 0)
                 _frames_written_count++;
         }
 
+        if (hasKeyFrame)
+        {
+            _last_keyframe_seen = _frames_seen_count;
+            HandleKeyframe(_frames_written_count, bufptr - bufstart);
+        }
+
         if ((aspectRatio > 0) && (aspectRatio != m_videoAspect))
         {
             m_videoAspect = aspectRatio;
@@ -846,6 +849,9 @@ void DTVRecorder::FindPSKeyFrames(const 
     uint64_t rem = (bufend - bufstart);
     _payload_buffer.resize(idx + rem);
     memcpy(&_payload_buffer[idx], bufstart, rem);
+#if 0
+VERBOSE(VB_GENERAL, QString("idx: %1, rem: %2").arg(idx).arg(rem) );
+#endif
 }
 
 /* vim: set expandtab tabstop=4 shiftwidth=4: */
diff -Naurp mythtv-0.24.orig/libs/libmythtv/dtvrecorder.h mythtv-0.24.fixes/libs/libmythtv/dtvrecorder.h
--- mythtv-0.24.orig/libs/libmythtv/dtvrecorder.h	2010-04-05 07:18:03.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/dtvrecorder.h	2011-03-24 22:18:50.000000000 -0400
@@ -51,7 +51,7 @@ class DTVRecorder: public RecorderBase
     void FinishRecording(void);
     void ResetForNewFile(void);
 
-    void HandleKeyframe(uint64_t extra = 0);
+    void HandleKeyframe(uint64_t frameNum, int64_t extra = 0);
 
     void BufferedWrite(const TSPacket &tspacket);
 
diff -Naurp mythtv-0.24.orig/libs/libmythtv/eithelper.cpp mythtv-0.24.fixes/libs/libmythtv/eithelper.cpp
--- mythtv-0.24.orig/libs/libmythtv/eithelper.cpp	2010-09-24 18:30:51.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/eithelper.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -304,13 +304,13 @@ static inline void parse_dvb_component_d
 void EITHelper::AddEIT(const DVBEventInformationTable *eit)
 {
     uint descCompression = (eit->TableID() > 0x80) ? 2 : 1;
-    uint fix = fixup[eit->OriginalNetworkID() << 16];
-    fix |= fixup[(((uint64_t)eit->TSID()) << 32) |
-                 (eit->OriginalNetworkID() << 16)];
-    fix |= fixup[(eit->OriginalNetworkID() << 16) | eit->ServiceID()];
-    fix |= fixup[(((uint64_t)eit->TSID()) << 32) |
+    uint fix = fixup.value(eit->OriginalNetworkID() << 16);
+    fix |= fixup.value((((uint64_t)eit->TSID()) << 32) |
+                 (eit->OriginalNetworkID() << 16));
+    fix |= fixup.value((eit->OriginalNetworkID() << 16) | eit->ServiceID());
+    fix |= fixup.value((((uint64_t)eit->TSID()) << 32) |
                  (uint64_t)(eit->OriginalNetworkID() << 16) |
-                  (uint64_t)eit->ServiceID()];
+                  (uint64_t)eit->ServiceID());
     fix |= EITFixUp::kFixGenericDVB;
 
     uint chanid = GetChanID(eit->ServiceID(), eit->OriginalNetworkID(),
@@ -493,7 +493,7 @@ void EITHelper::AddEIT(const DVBEventInf
 void EITHelper::AddEIT(const PremiereContentInformationTable *cit)
 {
     // set fixup for Premiere
-    uint fix = fixup[133 << 16];
+    uint fix = fixup.value(133 << 16);
     fix |= EITFixUp::kFixGenericDVB;
 
     QString title         = QString("");
@@ -656,7 +656,7 @@ void EITHelper::CompleteEvent(uint atsc_
     subtitle.detach();
     db_events.enqueue(new DBEventEIT(chanid, title, subtitle,
                                      starttime, endtime,
-                                     fixup[atsc_key], subtitle_type,
+                                     fixup.value(atsc_key), subtitle_type,
                                      audio_properties, video_properties));
 }
 
diff -Naurp mythtv-0.24.orig/libs/libmythtv/fourcc.h mythtv-0.24.fixes/libs/libmythtv/fourcc.h
--- mythtv-0.24.orig/libs/libmythtv/fourcc.h	2010-08-29 01:57:54.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/fourcc.h	2011-03-24 22:18:50.000000000 -0400
@@ -10,7 +10,7 @@
  *
  * Time to define them in one file.
  * 
- * $Id: fourcc.h 25936 2010-08-29 05:57:54Z markk $
+ * $Id$
  *****************************************************************************/
 
 #ifdef __cplusplus
diff -Naurp mythtv-0.24.orig/libs/libmythtv/frame.h mythtv-0.24.fixes/libs/libmythtv/frame.h
--- mythtv-0.24.orig/libs/libmythtv/frame.h	2010-09-03 10:11:12.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/frame.h	2011-03-24 22:18:50.000000000 -0400
@@ -2,6 +2,7 @@
 #define _FRAME_H 
 
 #include <string.h>
+#include <stdint.h>
 #include "fourcc.h"
 
 #ifdef __cplusplus
@@ -40,6 +41,7 @@ typedef struct VideoFrame_
 
     long long frameNumber;
     long long timecode;
+    int64_t   disp_timecode;
 
     unsigned char *priv[4]; // random empty storage
 
diff -Naurp mythtv-0.24.orig/libs/libmythtv/frequencies.c mythtv-0.24.fixes/libs/libmythtv/frequencies.c
--- mythtv-0.24.orig/libs/libmythtv/frequencies.c	2009-04-10 20:04:30.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/frequencies.c	2011-03-24 22:18:50.000000000 -0400
@@ -79,21 +79,6 @@ static struct CHANLIST ntsc_bcast[] = {
     { "67",	789250 },
     { "68",	795250 },
     { "69",	801250 },
- 
-    { "70",	807250 },
-    { "71",	813250 },
-    { "72",	819250 },
-    { "73",	825250 },
-    { "74",	831250 },
-    { "75",	837250 },
-    { "76",	843250 },
-    { "77",	849250 },
-    { "78",	855250 },
-    { "79",	861250 },
-    { "80",	867250 },
-    { "81",	873250 },
-    { "82",	879250 },
-    { "83",	885250 },
 };
 
 /* US cable */
diff -Naurp mythtv-0.24.orig/libs/libmythtv/frequencytables.cpp mythtv-0.24.fixes/libs/libmythtv/frequencytables.cpp
--- mythtv-0.24.orig/libs/libmythtv/frequencytables.cpp	2010-06-29 11:30:19.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/frequencytables.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -513,10 +513,6 @@ static void init_freq_tables(freq_table_
     fmap["atsc_vsb8_us3"] = new FrequencyTable(
         "ATSC Channel %1", 14, 473000000, 803000000, 6000000,
         DTVModulation::kModulation8VSB);
-    // UHF 70-83
-    fmap["atsc_vsb8_us4"] = new FrequencyTable(
-        "ATSC Channel %1", 70, 809000000, 887000000, 6000000,
-        DTVModulation::kModulation8VSB);
 #endif // !DEBUG_DVB_OFFSETS
 
     QString modStr[] = { "vsb8",  "qam256",   "qam128",   "qam64",   };
diff -Naurp mythtv-0.24.orig/libs/libmythtv/libmythtv.pro mythtv-0.24.fixes/libs/libmythtv/libmythtv.pro
--- mythtv-0.24.orig/libs/libmythtv/libmythtv.pro	2010-09-17 10:49:19.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/libmythtv.pro	2011-03-24 22:18:50.000000000 -0400
@@ -87,7 +87,12 @@ QMAKE_LFLAGS_SHLIB += $${FREETYPE_LIBS}
 
 macx {
     # Mac OS X Frameworks
-    FWKS = AGL ApplicationServices Carbon Cocoa CoreFoundation CoreVideo OpenGL QuickTime IOKit
+    FWKS = AGL ApplicationServices Carbon Cocoa CoreFoundation OpenGL QuickTime IOKit
+    using_quartz_video {
+        FWKS += QuartzCore
+    } else {
+        FWKS += CoreVideo
+    }
 
     using_firewire:using_backend: FWKS += IOKit
 
@@ -197,8 +202,8 @@ HEADERS += datadirect.h
 SOURCES += datadirect.cpp
 
 # Teletext stuff
-HEADERS += teletextdecoder.h        vbilut.h
-SOURCES += teletextdecoder.cpp      vbilut.cpp
+HEADERS += teletextdecoder.h        teletextreader.h   vbilut.h
+SOURCES += teletextdecoder.cpp      teletextreader.cpp vbilut.cpp
 
 # MPEG parsing stuff
 HEADERS += mpeg/tspacket.h          mpeg/pespacket.h
@@ -344,8 +349,6 @@ using_frontend {
         DEFINES += USING_OPENGL
         HEADERS += util-opengl.h
         SOURCES += util-opengl.cpp
-        HEADERS += mythrender_opengl.h
-        SOURCES += mythrender_opengl.cpp
         QT += opengl
     }
     using_opengl_vsync:DEFINES += USING_OPENGL_VSYNC
diff -Naurp mythtv-0.24.orig/libs/libmythtv/minilzo.cpp mythtv-0.24.fixes/libs/libmythtv/minilzo.cpp
--- mythtv-0.24.orig/libs/libmythtv/minilzo.cpp	2009-08-17 06:26:07.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/minilzo.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -2230,7 +2230,7 @@ const char __lzo_copyright[] =
     "$Copyright: LZO (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Markus Franz Xaver Johannes Oberhumer\n"
     "<markus@oberhumer.com>\n"
     "http://www.oberhumer.com $\n\n"
-    "$Id: minilzo.cpp 21332 2009-08-17 10:26:07Z janne $\n"
+    "$Id$\n"
     "$Built: " __DATE__ " " __TIME__ " $\n"
     "$Info: " LZO_INFO_STRING " $\n";
 #endif
diff -Naurp mythtv-0.24.orig/libs/libmythtv/mpeg/H264Parser.cpp mythtv-0.24.fixes/libs/libmythtv/mpeg/H264Parser.cpp
--- mythtv-0.24.orig/libs/libmythtv/mpeg/H264Parser.cpp	2010-10-29 05:17:38.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/mpeg/H264Parser.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -1,5 +1,6 @@
 // MythTV headers
 #include "H264Parser.h"
+#include <iostream>
 
 extern "C" {
 // from libavcodec
@@ -92,9 +93,13 @@ static const float eps = 1E-5;
 
 H264Parser::H264Parser(void)
 {
+    rbsp_buffer_size = 188 * 2;
+    rbsp_buffer = new uint8_t[rbsp_buffer_size];
+    if (rbsp_buffer == 0)
+        rbsp_buffer_size = 0;
+
     Reset();
     I_is_keyframe = true;
-    memset(&gb, 0, sizeof(gb));
 }
 
 void H264Parser::Reset(void)
@@ -144,9 +149,47 @@ void H264Parser::Reset(void)
 
     AU_offset = frame_start_offset = keyframe_start_offset = 0;
     on_frame = on_key_frame = false;
+
+    resetRBSP();
 }
 
 
+QString H264Parser::NAL_type_str(uint8_t type)
+{
+    switch (type)
+    {
+      case UNKNOWN:
+        return "UNKNOWN";
+      case SLICE:
+        return "SLICE";
+      case SLICE_DPA:
+        return "SLICE_DPA";
+      case SLICE_DPB:
+        return "SLICE_DPB";
+      case SLICE_DPC:
+        return "SLICE_DPC";
+      case SLICE_IDR:
+        return "SLICE_IDR";
+      case SEI:
+        return "SEI";
+      case SPS:
+        return "SPS";
+      case PPS:
+        return "PPS";
+      case AU_DELIMITER:
+        return "AU_DELIMITER";
+      case END_SEQUENCE:
+        return "END_SEQUENCE";
+      case END_STREAM:
+        return "END_STREAM";
+      case FILLER_DATA:
+        return "FILLER_DATA";
+      case SPS_EXT:
+        return "SPS_EXT";
+    }
+    return "OTHER";
+}
+
 bool H264Parser::new_AU(void)
 {
     /*
@@ -183,28 +226,28 @@ bool H264Parser::new_AU(void)
       one or more of the following ways.
 
       - frame_num differs in value. The value of frame_num used to
-      test this condition is the value of frame_num that appears in
-      the syntax of the slice header, regardless of whether that value
-      is inferred to have been equal to 0 for subsequent use in the
-      decoding process due to the presence of
-      memory_management_control_operation equal to 5.
+        test this condition is the value of frame_num that appears in
+        the syntax of the slice header, regardless of whether that value
+        is inferred to have been equal to 0 for subsequent use in the
+        decoding process due to the presence of
+        memory_management_control_operation equal to 5.
           Note: If the current picture is an IDR picture FrameNum and
           PrevRefFrameNum are set equal to 0.
       - pic_parameter_set_id differs in value.
       - field_pic_flag differs in value.
       - bottom_field_flag is present in both and differs in value.
-      - nal_ref_idc differs in value with one of the nal_ref_idc values
-      being equal to 0.
+      - nal_ref_idc differs in value with one of the nal_ref_idc
+        values being equal to 0.
       - pic_order_cnt_type is equal to 0 for both and either
-      pic_order_cnt_lsb differs in value, or delta_pic_order_cnt_bottom
-      differs in value.
+        pic_order_cnt_lsb differs in value, or delta_pic_order_cnt_bottom
+        differs in value.
       - pic_order_cnt_type is equal to 1 for both and either
-      delta_pic_order_cnt[0] differs in value, or
-      delta_pic_order_cnt[1] differs in value.
+        delta_pic_order_cnt[0] differs in value, or
+        delta_pic_order_cnt[1] differs in value.
       - nal_unit_type differs in value with one of the nal_unit_type values
-      being equal to 5.
+        being equal to 5.
       - nal_unit_type is equal to 5 for both and idr_pic_id differs in
-      value.
+        value.
 
       NOTE  Some of the VCL NAL units in redundant coded pictures or some
       non-VCL NAL units (e.g. an access unit delimiter NAL unit) may also
@@ -230,6 +273,9 @@ bool H264Parser::new_AU(void)
         else if ((bottom_field_flag != -1 && prev_bottom_field_flag != -1) &&
                  bottom_field_flag != prev_bottom_field_flag)
             result = true;
+        else if ((nal_ref_idc == 0 || prev_nal_ref_idc == 0) &&
+                 nal_ref_idc != prev_nal_ref_idc)
+            result = true;
         else if ((pic_order_cnt_type == 0 && prev_pic_order_cnt_type == 0) &&
                  (pic_order_cnt_lsb != prev_pic_order_cnt_lsb ||
                   delta_pic_order_cnt_bottom !=
@@ -253,6 +299,7 @@ bool H264Parser::new_AU(void)
     prev_pic_parameter_set_id = pic_parameter_set_id;
     prev_field_pic_flag = field_pic_flag;
     prev_bottom_field_flag = bottom_field_flag;
+    prev_nal_ref_idc = nal_ref_idc;
     prev_pic_order_cnt_lsb = pic_order_cnt_lsb;
     prev_delta_pic_order_cnt_bottom = delta_pic_order_cnt_bottom;
     prev_delta_pic_order_cnt[0] = delta_pic_order_cnt[0];
@@ -263,22 +310,144 @@ bool H264Parser::new_AU(void)
     return result;
 }
 
+void H264Parser::resetRBSP(void)
+{
+    rbsp_index = 0;
+    consecutive_zeros = 0;
+    have_unfinished_NAL = false;
+}
+
+bool H264Parser::fillRBSP(const uint8_t *byteP, uint32_t byte_count,
+                          bool found_start_code)
+{
+    /*
+      bitstream buffer, must be FF_INPUT_BUFFER_PADDING_SIZE
+      bytes larger then the actual data
+    */
+    uint32_t required_size = rbsp_index + byte_count +
+                             FF_INPUT_BUFFER_PADDING_SIZE;
+    if (rbsp_buffer_size < required_size)
+    {
+        // Round up to packet size
+        required_size = ((required_size / 188) + 1) * 188;
+
+        /* Need a bigger buffer */
+        uint8_t *new_buffer = new uint8_t[required_size];
+
+        if (new_buffer == NULL)
+        {
+            /* Allocation failed. Discard the new bytes */
+            std::cerr << "H264Parser::fillRBSP: "
+                      << "FAILED to allocate RBSP buffer!\n";
+            return false;
+        }
+
+        /* Copy across bytes from old buffer */
+        memcpy(new_buffer, rbsp_buffer, rbsp_index);
+        delete [] rbsp_buffer;
+        rbsp_buffer = new_buffer;
+        rbsp_buffer_size = required_size;
+    }
+
+    /* Fill rbsp while we have data */
+    while (byte_count)
+    {
+        /* Copy the byte into the rbsp, unless it
+         * is the 0x03 in a 0x000003 */
+        if (consecutive_zeros < 2 || *byteP != 0x03)
+            rbsp_buffer[rbsp_index++] = *byteP;
+
+        if (*byteP == 0)
+            ++consecutive_zeros;
+        else
+            consecutive_zeros = 0;
+
+        ++byteP;
+        --byte_count;
+    }
+
+    /* If we've found the next start code then that, plus the first byte of
+     * the next NAL, plus the preceding zero bytes will all be in the rbsp
+     * buffer. Move rbsp_index++ back to the end of the actual rbsp data. We
+     * need to know the correct size of the rbsp to decode some NALs. */
+    if (found_start_code)
+    {
+        if (rbsp_index >= 4)
+        {
+            rbsp_index -= 4;
+            while (rbsp_index > 0 && rbsp_buffer[rbsp_index-1] == 0)
+                --rbsp_index;
+        }
+        else
+        {
+            /* This should never happen. */
+            std::cerr << "H264Parser::fillRBSP: "
+                      << "Found start code, rbsp_index is "
+                      << rbsp_index << " but it should be >4\n";
+        }
+    }
+
+    /* Stick some 0xff on the end for get_bits to run into */
+    memset(&rbsp_buffer[rbsp_index], 0xff, FF_INPUT_BUFFER_PADDING_SIZE);
+    return true;
+}
+
 uint32_t H264Parser::addBytes(const uint8_t  *bytes,
                               const uint32_t  byte_count,
                               const uint64_t  stream_offset)
 {
-    const uint8_t *byteP = bytes;
-    const uint8_t *endP = bytes + byte_count;
-    uint8_t        first_byte;
+    const uint8_t *startP = bytes;
+    const uint8_t *endP;
+    bool           found_start_code;
 
-    state_changed = is_keyframe = false;
+    state_changed = false;
+    on_frame      = false;
+    on_key_frame  = false;
 
-    while (byteP < endP)
+    while (startP < bytes + byte_count && !on_frame)
     {
-        byteP = ff_find_start_code(byteP, endP, &sync_accumulator);
+        endP = ff_find_start_code(startP,
+                                  bytes + byte_count, &sync_accumulator);
+
+        found_start_code = ((sync_accumulator & 0xffffff00) == 0x00000100);
+
+        /* Between startP and endP we potentially have some more
+         * bytes of a NAL that we've been parsing (plus some bytes of
+         * start code) */
+        if (have_unfinished_NAL)
+        {
+            if (!fillRBSP(startP, endP - startP, found_start_code))
+            {
+                resetRBSP();
+                return endP - bytes;
+            }
+            processRBSP(found_start_code); /* Call may set have_uinfinished_NAL
+                                            * to false */
+        }
 
-        if ((sync_accumulator & 0xffffff00) == 0x00000100)
+        /* Dealt with everything up to endP */
+        startP = endP;
+
+        if (found_start_code)
         {
+            if (have_unfinished_NAL)
+            {
+                /* We've found a new start code, without completely
+                 * parsing the previous NAL. Either there's a
+                 * problem with the stream or with this parser.
+                 */
+                std::cerr << "H264Parser::addBytes: Found new start code, "
+                          << "but previous NAL is incomplete!\n";
+            }
+
+            /* Prepare for accepting the new NAL */
+            resetRBSP();
+
+            /* If we find the start of an AU somewhere from here
+             * to the next start code, the offset to associate with
+             * it is the one passed in to this call, not any of the
+             * subsequent calls. */
+            pkt_offset = stream_offset; // + (startP - bytes);
 /*
   nal_unit_type specifies the type of RBSP data structure contained in
   the NAL unit as specified in Table 7-1. VCL NAL units
@@ -299,92 +468,104 @@ uint32_t H264Parser::addBytes(const uint
   10 End of sequence end_of_seq_rbsp( )
   11 End of stream end_of_stream_rbsp( )
 */
-            first_byte = *(byteP - 1);
-            nal_unit_type = first_byte & 0x1f;
-            nal_ref_idc = (first_byte >> 5) & 0x3;
+            nal_unit_type = sync_accumulator & 0x1f;
+            nal_ref_idc = (sync_accumulator >> 5) & 0x3;
 
             if (nal_unit_type == SPS || nal_unit_type == PPS ||
                 nal_unit_type == SEI || NALisSlice(nal_unit_type))
             {
-                /*
-                  bitstream buffer, must be FF_INPUT_BUFFER_PADDING_SIZE
-                  bytes larger then the actual read bits
-                */
-                if (byteP + 1 + FF_INPUT_BUFFER_PADDING_SIZE < endP)
-                {
-                    init_get_bits(&gb, byteP, 8 * (endP - byteP));
-
-                    if (nal_unit_type == SEI)
-                    {
-                        decode_SEI(&gb);
-                        set_AU_pending(stream_offset);
-                    }
-                    else if (nal_unit_type == SPS)
-                    {
-                        decode_SPS(&gb);
-                        set_AU_pending(stream_offset);
-                    }
-                    else if (nal_unit_type == PPS)
-                    {
-                        decode_PPS(&gb);
-                        set_AU_pending(stream_offset);
-                    }
-                    else
-                    {
-                        decode_Header(&gb);
-                        if (new_AU())
-                            set_AU_pending(stream_offset);
-                    }
-
-                    byteP += (get_bits_count(&gb) / 8);
-                }
+                /* This is a NAL we need to parse. We may have the body
+                 * of it in the part of the stream past to us this call,
+                 * or we may get the rest in subsequent calls to addBytes.
+                 * Either way, we set have_unfinished_NAL, so that we
+                 * start filling the rbsp buffer */
+                have_unfinished_NAL = true;
             }
-            else if (!AU_pending)
-            {
-                if (nal_unit_type == AU_DELIMITER ||
+            else if (nal_unit_type == AU_DELIMITER ||
                     (nal_unit_type > SPS_EXT &&
                      nal_unit_type < AUXILIARY_SLICE))
-                {
-                    AU_pending = true;
-                    AU_offset = stream_offset;
-                }
-                else if ((nal_ref_idc == 0 || prev_nal_ref_idc == 0) &&
-                         nal_ref_idc != prev_nal_ref_idc)
-                {
-                    AU_pending = true;
-                    AU_offset = stream_offset;
-                }
+            {
+                set_AU_pending();
             }
+        }
+    }
+
+    return startP - bytes;
+}
 
-            if (AU_pending && NALisSlice(nal_unit_type))
-            {
-                /* Once we know the slice type of a new AU, we can
-                 * determine if it is a keyframe or just a frame */
 
-                AU_pending = false;
-                state_changed = true;
+void H264Parser::processRBSP(bool rbsp_complete)
+{
+    GetBitContext gb;
 
-                on_frame = true;
-                frame_start_offset = AU_offset;
+    init_get_bits(&gb, rbsp_buffer, 8 * rbsp_index);
 
-                if (is_keyframe)
-                {
-                    on_key_frame = true;
-                    keyframe_start_offset = AU_offset;
-                }
-                else
-                    on_key_frame = false;
-            }
-            else
-                on_frame = on_key_frame = false;
+    if (nal_unit_type == SEI)
+    {
+        /* SEI cannot be parsed without knowing its size. If
+         * we haven't got the whole rbsp, return and wait for
+         * the rest */
+        if (!rbsp_complete)
+            return;
 
-            prev_nal_ref_idc = nal_ref_idc;
+        set_AU_pending();
 
-            return byteP - bytes;
-        }
+        decode_SEI(&gb);
+    }
+    else if (nal_unit_type == SPS)
+    {
+        /* Best wait until we have the whole thing */
+        if (!rbsp_complete)
+            return;
+
+        set_AU_pending();
+
+        decode_SPS(&gb);
+    }
+    else if (nal_unit_type == PPS)
+    {
+        /* Best wait until we have the whole thing */
+        if (!rbsp_complete)
+            return;
+
+        set_AU_pending();
+
+        decode_PPS(&gb);
     }
+    else
+    {
+        /* Need only parse the header. So return only
+         * if we have insufficient bytes */
+        if (!rbsp_complete && rbsp_index < MAX_SLICE_HEADER_SIZE)
+            return;
 
-    return byteP - bytes;
+        decode_Header(&gb);
+
+        if (new_AU())
+            set_AU_pending();
+    }
+
+    /* If we got this far, we managed to parse a sufficient
+     * prefix of the current NAL. We can go onto the next. */
+    have_unfinished_NAL = false;
+
+    if (AU_pending && NALisSlice(nal_unit_type))
+    {
+        /* Once we know the slice type of a new AU, we can
+         * determine if it is a keyframe or just a frame */
+
+        AU_pending = false;
+        state_changed = true;
+
+        on_frame = true;
+        frame_start_offset = AU_offset;
+
+        if (is_keyframe || au_contains_keyframe_message)
+        {
+            on_key_frame = true;
+            keyframe_start_offset = AU_offset;
+        }
+    }
 }
 
 /*
@@ -394,9 +575,11 @@ bool H264Parser::decode_Header(GetBitCon
 {
     uint first_mb_in_slice;
 
+    is_keyframe = false;
+
     if (log2_max_frame_num == 0 || pic_order_present_flag == -1)
     {
-        // SPS or PPS has not been parsed yet
+        /* SPS or PPS has not been parsed yet */
         return false;
     }
 
@@ -600,7 +783,14 @@ void H264Parser::decode_SPS(GetBitContex
         {
             for (int idx = 0; idx < ((chroma_format_idc != 3) ? 8 : 12); ++idx)
             {
-                get_bits1(gb);  // scaling_list
+                if (get_bits1(gb)) // Scaling list presnent
+                {
+                    int sl_n = ((idx < 6) ? 16 : 64);
+                    for(int sl_i = 0; sl_i < sl_n; sl_i++)
+                    {
+                        get_se_golomb(gb);
+                    }
+                }
             }
         }
     }
@@ -838,30 +1028,34 @@ void H264Parser::decode_SEI(GetBitContex
 
     int type = 0, size = 0;
 
-    do {
-        type += show_bits(gb, 8);
-    } while (get_bits(gb, 8) == 255);
-
-    do {
-        size += show_bits(gb, 8);
-    } while (get_bits(gb, 8) == 255);
-
-    switch (type)
+    /* A message requires at least 2 bytes, and then
+     * there's the stop bit plus alignment, so there
+     * can be no message in less than 24 bits */
+    while (get_bits_left(gb) >= 24)
     {
-        case SEI_TYPE_RECOVERY_POINT:
-            recovery_frame_cnt = get_ue_golomb(gb);
-            exact_match_flag = get_bits1(gb);
-            broken_link_flag = get_bits1(gb);
-            changing_group_slice_idc = get_bits(gb, 2);
-            is_keyframe |= (recovery_frame_cnt >= 0);
-            return;
+        do {
+            type += show_bits(gb, 8);
+        } while (get_bits(gb, 8) == 255);
+
+        do {
+            size += show_bits(gb, 8);
+        } while (get_bits(gb, 8) == 255);
 
-        default:
-            skip_bits(gb, size * 8);
-            break;
+        switch (type)
+        {
+            case SEI_TYPE_RECOVERY_POINT:
+                recovery_frame_cnt = get_ue_golomb(gb);
+                exact_match_flag = get_bits1(gb);
+                broken_link_flag = get_bits1(gb);
+                changing_group_slice_idc = get_bits(gb, 2);
+                au_contains_keyframe_message = (recovery_frame_cnt == 0);
+                return;
+
+            default:
+                skip_bits(gb, size * 8);
+                break;
+        }
     }
-
-    align_get_bits(gb);
 }
 
 void H264Parser::vui_parameters(GetBitContext * gb)
@@ -1015,7 +1209,7 @@ void H264Parser::vui_parameters(GetBitCo
 
 uint H264Parser::frameRate(void) const
 {
-    uint64_t	num;
+    uint64_t    num;
     uint64_t    fps;
 
     num   = 500 * (uint64_t)timeScale; /* 1000 * 0.5 */
diff -Naurp mythtv-0.24.orig/libs/libmythtv/mpeg/H264Parser.h mythtv-0.24.fixes/libs/libmythtv/mpeg/H264Parser.h
--- mythtv-0.24.orig/libs/libmythtv/mpeg/H264Parser.h	2010-10-29 05:17:38.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/mpeg/H264Parser.h	2011-03-24 22:18:50.000000000 -0400
@@ -23,6 +23,7 @@
 #ifndef H264PARSER_H
 #define H264PARSER_H
 
+#include <QString>
 #include <stdint.h>
 #include "mythconfig.h"
 #include "compat.h" // for uint on Darwin, MinGW
@@ -48,6 +49,10 @@ extern "C" {
 class H264Parser {
   public:
 
+    enum {
+        MAX_SLICE_HEADER_SIZE = 256
+    };
+
     // ITU-T Rec. H.264 table 7-1
     enum NAL_unit_type {
         UNKNOWN         = 0,
@@ -101,13 +106,15 @@ class H264Parser {
     };
 
     H264Parser(void);
-    ~H264Parser(void) {;}
+    ~H264Parser(void) {delete [] rbsp_buffer;}
 
     uint32_t addBytes(const uint8_t  *bytes,
                       const uint32_t  byte_count,
                       const uint64_t  stream_offset);
     void Reset(void);
 
+    QString NAL_type_str(uint8_t type);
+
     bool stateChanged(void) const { return state_changed; }
 
     uint8_t lastNALtype(void) const { return nal_unit_type; }
@@ -158,16 +165,21 @@ class H264Parser {
   private:
     enum constants {EXTENDED_SAR = 255};
 
-    inline void set_AU_pending(const uint64_t & stream_offset)
+    inline void set_AU_pending(void)
         {
             if (!AU_pending)
             {
                 AU_pending = true;
-                AU_offset = stream_offset;
+                AU_offset = pkt_offset;
+                au_contains_keyframe_message = false;
             }
         }
 
     bool new_AU(void);
+    void resetRBSP(void);
+    bool fillRBSP(const uint8_t *byteP, uint32_t byte_count,
+                  bool found_start_code);
+    void processRBSP(bool rbsp_complete);
     bool decode_Header(GetBitContext *gb);
     void decode_SPS(GetBitContext *gb);
     void decode_PPS(GetBitContext * gb);
@@ -177,11 +189,16 @@ class H264Parser {
     bool       AU_pending;
     bool       state_changed;
     bool       seen_sps;
+    bool       au_contains_keyframe_message;
     bool       is_keyframe;
     bool       I_is_keyframe;
 
     uint32_t   sync_accumulator;
-    GetBitContext gb;
+    uint8_t   *rbsp_buffer;
+    uint32_t   rbsp_buffer_size;
+    uint32_t   rbsp_index;
+    uint32_t   consecutive_zeros;
+    bool       have_unfinished_NAL;
 
     int        prev_frame_num, frame_num;
     uint       slice_type;
@@ -218,7 +235,7 @@ class H264Parser {
     uint32_t   unitsInTick, timeScale;
     bool       fixedRate;
 
-    uint64_t   AU_offset, frame_start_offset, keyframe_start_offset;
+    uint64_t   pkt_offset, AU_offset, frame_start_offset, keyframe_start_offset;
     bool       on_frame, on_key_frame;
 };
 
diff -Naurp mythtv-0.24.orig/libs/libmythtv/mythcommflagplayer.cpp mythtv-0.24.fixes/libs/libmythtv/mythcommflagplayer.cpp
--- mythtv-0.24.orig/libs/libmythtv/mythcommflagplayer.cpp	2010-11-06 00:07:05.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/mythcommflagplayer.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -108,7 +108,7 @@ bool MythCommFlagPlayer::RebuildSeekTabl
         fflush( stdout );
     }
 
-    while (!eof)
+    while (!GetEof())
     {
         if (inuse_timer.elapsed() > 2534)
         {
diff -Naurp mythtv-0.24.orig/libs/libmythtv/mythdvdplayer.cpp mythtv-0.24.fixes/libs/libmythtv/mythdvdplayer.cpp
--- mythtv-0.24.orig/libs/libmythtv/mythdvdplayer.cpp	2010-10-21 00:15:31.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/mythdvdplayer.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -66,9 +66,13 @@ bool MythDVDPlayer::PrebufferEnoughFrame
 
 bool MythDVDPlayer::DecoderGetFrameFFREW(void)
 {
-    if (decoder)
-        decoder->UpdateDVDFramesPlayed();
     return MythPlayer::DecoderGetFrameFFREW();
+    if (decoder_change_lock.tryLock(1))
+    {
+        if (decoder)
+            decoder->UpdateDVDFramesPlayed();
+        decoder_change_lock.unlock();
+    }
 }
 
 bool MythDVDPlayer::DecoderGetFrameREW(void)
@@ -218,10 +222,12 @@ void MythDVDPlayer::DisplayLastFrame(voi
 
     DisplayDVDButton();
 
+    osdLock.lock();
     videofiltersLock.lock();
     videoOutput->ProcessFrame(NULL, osd, videoFilters, pip_players,
                               kScan_Progressive);
     videofiltersLock.unlock();
+    osdLock.unlock();
 
     AVSync(NULL, true);
 }
@@ -258,6 +264,7 @@ void MythDVDPlayer::EventStart(void)
         QString name;
         QString serialid;
         if (player_ctx->playingInfo->GetTitle().isEmpty() &&
+            player_ctx->buffer->DVD() &&
             player_ctx->buffer->DVD()->GetNameAndSerialNum(name, serialid))
         {
             player_ctx->playingInfo->SetTitle(name);
@@ -495,8 +502,10 @@ void MythDVDPlayer::DisplayDVDButton(voi
     if (!numbuttons || !dvdSubtitle || (buttonversion == 0))
     {
         SetCaptionsEnabled(false, false);
+        osdLock.lock();
         if (osd)
             osd->ClearSubtitles();
+        osdLock.unlock();
         m_buttonVersion = 0;
         player_ctx->buffer->DVD()->ReleaseMenuButton();
         return;
@@ -504,7 +513,10 @@ void MythDVDPlayer::DisplayDVDButton(voi
 
     m_buttonVersion = buttonversion;
     QRect buttonPos = player_ctx->buffer->DVD()->GetButtonCoords();
-    osd->DisplayDVDButton(dvdSubtitle, buttonPos);
+    osdLock.lock();
+    if (osd)
+        osd->DisplayDVDButton(dvdSubtitle, buttonPos);
+    osdLock.unlock();
     textDisplayMode = kDisplayDVDButton;
     player_ctx->buffer->DVD()->ReleaseMenuButton();
 }
diff -Naurp mythtv-0.24.orig/libs/libmythtv/mythplayer.cpp mythtv-0.24.fixes/libs/libmythtv/mythplayer.cpp
--- mythtv-0.24.orig/libs/libmythtv/mythplayer.cpp	2010-11-07 23:38:30.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythtv/mythplayer.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -89,43 +89,6 @@ static unsigned dbg_ident(const MythPlay
 #define LOC_ERR  QString("Player(%1), Error: ").arg(dbg_ident(this),0,36)
 #define LOC_DEC  QString("Player(%1): ").arg(dbg_ident(m_mp),0,36)
 
-QEvent::Type PlayerTimer::kPlayerEventType =
-    (QEvent::Type) QEvent::registerEventType();
-
-PlayerTimer::PlayerTimer(MythPlayer *player) : m_mp(player), m_queue_size(0)
-{
-    if (!m_mp)
-        VERBOSE(VB_IMPORTANT, QString("PlayerTimer has no parent."));
-    PostNextEvent();
-}
-
-void PlayerTimer::PostNextEvent(void)
-{
-    QEvent *event = new QEvent(kPlayerEventType);
-    qApp->postEvent(this, event);
-    m_queue_size++;
-}
-
-bool PlayerTimer::event(QEvent *e)
-{
-    if (e->type() == kPlayerEventType)
-    {
-        // TODO this may fail if events are lost and the queue size is wrong
-        m_queue_size--;
-        uint max_queue = m_mp->GetFFRewSkip() == 1 ? 3 : 1;
-        while (m_queue_size < max_queue)
-            PostNextEvent();
-
-        if (m_mp && !m_mp->IsErrored())
-        {
-            m_mp->EventLoop();
-            m_mp->VideoLoop();
-        }
-        return true;
-    }
-    return false;
-}
-
 void DecoderThread::run(void)
 {
     if (!m_mp)
@@ -162,7 +125,6 @@ MythPlayer::MythPlayer(bool muted)
     : decoder(NULL),                decoder_change_lock(QMutex::Recursive),
       videoOutput(NULL),            player_ctx(NULL),
       decoderThread(NULL),          playerThread(NULL),
-      playerTimer(NULL),
       no_hardware_decoders(false),
       // Window stuff
       parentWidget(NULL), embedid(0),
@@ -173,8 +135,6 @@ MythPlayer::MythPlayer(bool muted)
       needNewPauseFrame(false),
       bufferPaused(false),  videoPaused(false),
       allpaused(false),     playing(false),
-
-      eof(false),
       m_double_framerate(false),    m_double_process(false),
       m_can_double(false),          m_deint_possible(true),
       livetv(false),
@@ -191,6 +151,7 @@ MythPlayer::MythPlayer(bool muted)
       // Playback misc.
       videobuf_retries(0),          framesPlayed(0),
       totalFrames(0),               totalLength(0),
+      totalDuration(0),
       rewindtime(0),
       // Input Video Attributes
       video_disp_dim(0,0), video_dim(0,0),
@@ -209,7 +170,6 @@ MythPlayer::MythPlayer(bool muted)
       ttPageNum(0x888),
       // Support for captions, teletext, etc. decoded by libav
       textDesired(false), enableCaptions(false), disableCaptions(false),
-      initTeletext(false),
       // CC608/708
       db_prefer708(true), cc608(this), cc708(this),
       // MHEG/MHI Interactive TV visible in OSD
@@ -240,6 +200,7 @@ MythPlayer::MythPlayer(bool muted)
       avsync_adjustment(0),         avsync_avg(0),
       refreshrate(0),
       lastsync(false),              repeat_delay(0),
+      disp_timecode(0),
       // Time Code stuff
       prevtc(0),                    prevrp(0),
       savedAudioTimecodeOffset(0),
@@ -288,12 +249,6 @@ MythPlayer::~MythPlayer(void)
         decoderThread = NULL;
     }
 
-    if (playerTimer)
-    {
-        delete playerTimer;
-        playerTimer = NULL;
-    }
-
     if (interactiveTV)
     {
         delete interactiveTV;
@@ -339,8 +294,6 @@ MythPlayer::~MythPlayer(void)
 
 void MythPlayer::SetWatchingRecording(bool mode)
 {
-    QMutexLocker locker(&decoder_change_lock);
-
     watchingrecording = mode;
     if (decoder)
         decoder->setWatchingRecording(mode);
@@ -388,7 +341,6 @@ bool MythPlayer::Pause(void)
     PauseBuffer();
     allpaused = decoderPaused && videoPaused && bufferPaused;
     {
-        QMutexLocker locker(&decoder_change_lock);
         if (using_null_videoout && decoder)
             decoder->UpdateFramesPlayed();
         else if (videoOutput && !using_null_videoout)
@@ -543,15 +495,13 @@ bool MythPlayer::InitVideo(void)
                 decoder->GetVideoCodecPrivate(),
                 pipState,
                 video_disp_dim, video_aspect,
-                widget->winId(), display_rect, (video_frame_rate * play_speed),
+                widget->winId(), display_rect, video_frame_rate,
                 0 /*embedid*/);
         }
 
         if (videoOutput)
         {
             videoOutput->SetVideoScalingAllowed(true);
-            // We need to tell it this for automatic deinterlacer settings
-            videoOutput->SetVideoFrameRate(video_frame_rate * play_speed);
             CheckExtraAudioDecode();
         }
     }
@@ -615,7 +565,6 @@ void MythPlayer::ReinitOSD(void)
                 uint old = textDisplayMode;
                 ToggleCaptions(old);
                 osd->Reinit(visible, aspect);
-                SetupTeletextViewer();
                 EnableCaptions(old, false);
             }
         }
@@ -649,6 +598,8 @@ void MythPlayer::ReinitVideo(void)
         QMutexLocker locker1(&osdLock);
         QMutexLocker locker2(&vidExitLock);
         QMutexLocker locker3(&videofiltersLock);
+
+        videoOutput->SetVideoFrameRate(video_frame_rate);
         float aspect = (forced_video_aspect > 0) ? forced_video_aspect :
                                                video_aspect;
         if (!videoOutput->InputChanged(video_disp_dim, aspect,
@@ -662,8 +613,6 @@ void MythPlayer::ReinitVideo(void)
             return;
         }
 
-        // We need to tell it this for automatic deinterlacer settings
-        videoOutput->SetVideoFrameRate(video_frame_rate * play_speed);
         if (osd)
             osd->SetPainter(videoOutput->GetOSDPainter());
         ReinitOSD();
@@ -897,6 +846,11 @@ void MythPlayer::SetFileLength(int total
     totalFrames = frames;
 }
 
+void MythPlayer::SetDuration(int duration)
+{
+    totalDuration = duration;
+}
+
 void MythPlayer::OpenDummy(void)
 {
     isDummy = true;
@@ -1008,10 +962,7 @@ int MythPlayer::OpenFile(uint retries, b
     decoder->setWatchingRecording(watchingrecording);
     decoder->setTranscoding(transcoding);
     CheckExtraAudioDecode();
-    //noVideoTracks = !decoder->GetTrackCount(kTrackTypeVideo);
-
-
-    eof = false;
+    noVideoTracks = !decoder->GetTrackCount(kTrackTypeVideo);
 
     // Set 'no_video_decode' to true for audio only decodeing
     bool no_video_decode = false;
@@ -1037,7 +988,10 @@ int MythPlayer::OpenFile(uint retries, b
         deleteMap.TrackerReset(0, totalFrames);
     }
 
+    // Determine the initial bookmark and update it for the cutlist
     bookmarkseek = GetBookmark();
+    deleteMap.TrackerReset(bookmarkseek, totalFrames);
+    deleteMap.TrackerWantsToJump(bookmarkseek, totalFrames, bookmarkseek);
 
     if (player_ctx->playingInfo->QueryAutoExpire() == kLiveTVAutoExpire)
         gCoreContext->SaveSetting("DefaultChanid",
@@ -1236,22 +1190,21 @@ void MythPlayer::WindowResized(const QSi
 
 void MythPlayer::EnableTeletext(int page)
 {
+    QMutexLocker locker(&osdLock);
     if (!osd)
         return;
 
-    osdLock.lock();
     osd->EnableTeletext(true, page);
     prevTextDisplayMode = textDisplayMode;
     textDisplayMode = kDisplayTeletextMenu;
-    osdLock.unlock();
 }
 
 void MythPlayer::DisableTeletext(void)
 {
+    QMutexLocker locker(&osdLock);
     if (!osd)
         return;
 
-    osdLock.lock();
     osd->EnableTeletext(false, 0);
     textDisplayMode = kDisplayNone;
 
@@ -1259,17 +1212,15 @@ void MythPlayer::DisableTeletext(void)
        re-enabled them. */
     if (prevTextDisplayMode & kDisplayAllCaptions)
         EnableCaptions(prevTextDisplayMode, false);
-    osdLock.unlock();
 }
 
 void MythPlayer::ResetTeletext(void)
 {
+    QMutexLocker locker(&osdLock);
     if (!osd)
         return;
 
-    osdLock.lock();
     osd->TeletextReset();
-    osdLock.unlock();
 }
 
 /** \fn MythPlayer::SetTeletextPage(uint)
@@ -1296,7 +1247,7 @@ bool MythPlayer::HandleTeletextAction(co
     osdLock.lock();
     if (action == "MENU" || action == "TOGGLETT" || action == "ESCAPE")
         DisableTeletext();
-    else
+    else if (osd)
         handled = osd->TeletextAction(action);
     osdLock.unlock();
 
@@ -1305,28 +1256,28 @@ bool MythPlayer::HandleTeletextAction(co
 
 void MythPlayer::ResetCaptions(void)
 {
-    if (osd && ((textDisplayMode & kDisplayAVSubtitle)      ||
-                (textDisplayMode & kDisplayTextSubtitle)    ||
-                (textDisplayMode & kDisplayRawTextSubtitle) ||
-                (textDisplayMode & kDisplayDVDButton)       ||
-                (textDisplayMode & kDisplayCC608)           ||
-                (textDisplayMode & kDisplayCC708)))
+    QMutexLocker locker(&osdLock);
+    if (!osd)
+        return;
+
+    if (((textDisplayMode & kDisplayAVSubtitle)      ||
+         (textDisplayMode & kDisplayTextSubtitle)    ||
+         (textDisplayMode & kDisplayRawTextSubtitle) ||
+         (textDisplayMode & kDisplayDVDButton)       ||
+         (textDisplayMode & kDisplayCC608)           ||
+         (textDisplayMode & kDisplayCC708)))
     {
-        osdLock.lock();
         osd->ClearSubtitles();
-        osdLock.unlock();
     }
 }
 
-// caller has decoder_changed_lock
 void MythPlayer::DisableCaptions(uint mode, bool osd_msg)
 {
     textDisplayMode &= ~mode;
     ResetCaptions();
-    if (!osd)
-        return;
 
     QMutexLocker locker(&osdLock);
+
     QString msg = "";
     if (kDisplayNUVTeletextCaptions & mode)
         msg += QObject::tr("TXT CAP");
@@ -1344,12 +1295,14 @@ void MythPlayer::DisableCaptions(uint mo
     {
         int type = toTrackType(mode);
         msg += decoder->GetTrackDesc(type, GetTrack(type));
-        osd->EnableSubtitles(preserve);
+        if (osd)
+            osd->EnableSubtitles(preserve);
     }
     if (kDisplayTextSubtitle & mode)
     {
         msg += QObject::tr("Text subtitles");
-        osd->EnableSubtitles(preserve);
+        if (osd)
+            osd->EnableSubtitles(preserve);
     }
     if (!msg.isEmpty() && osd_msg)
     {
@@ -1358,7 +1311,6 @@ void MythPlayer::DisableCaptions(uint mo
     }
 }
 
-// caller has decoder_changed_lock
 void MythPlayer::EnableCaptions(uint mode, bool osd_msg)
 {
     QMutexLocker locker(&osdLock);
@@ -1420,26 +1372,6 @@ bool MythPlayer::ToggleCaptions(uint typ
     return textDisplayMode;
 }
 
-void MythPlayer::SetupTeletextViewer(void)
-{
-    if (QThread::currentThread() != playerThread)
-    {
-        initTeletext = true;
-        return;
-    }
-
-    if (osd)
-    {
-        QMutexLocker locker(&osdLock);
-        TeletextViewer* ttview =  (TeletextViewer*)osd->InitTeletext();
-        if (ttview && decoder)
-        {
-            initTeletext = false;
-            decoder->SetTeletextDecoderViewer(ttview);
-        }
-    }
-}
-
 void MythPlayer::SetCaptionsEnabled(bool enable, bool osd_msg)
 {
     QMutexLocker locker(&osdLock);
@@ -1474,7 +1406,6 @@ void MythPlayer::SetCaptionsEnabled(bool
 
 QStringList MythPlayer::GetTracks(uint type)
 {
-    QMutexLocker locker(&decoder_change_lock);
     if (decoder)
         return decoder->GetTracks(type);
     return QStringList();
@@ -1483,7 +1414,6 @@ QStringList MythPlayer::GetTracks(uint t
 int MythPlayer::SetTrack(uint type, int trackNo)
 {
     int ret = -1;
-    QMutexLocker locker(&decoder_change_lock);
     if (!decoder)
         return ret;
 
@@ -1539,7 +1469,6 @@ void MythPlayer::EnableSubtitles(bool en
 
 int MythPlayer::GetTrack(uint type)
 {
-    QMutexLocker locker(&decoder_change_lock);
     if (decoder)
         return decoder->GetTrack(type);
     return -1;
@@ -1547,23 +1476,21 @@ int MythPlayer::GetTrack(uint type)
 
 int MythPlayer::ChangeTrack(uint type, int dir)
 {
-    QMutexLocker locker(&decoder_change_lock);
-    if (decoder)
+    if (!decoder)
+        return -1;
+
+    int retval = decoder->ChangeTrack(type, dir);
+    if (retval >= 0)
     {
-        int retval = decoder->ChangeTrack(type, dir);
-        if (retval >= 0)
-        {
-            SetOSDMessage(decoder->GetTrackDesc(type, GetTrack(type)),
-                          kOSDTimeout_Med);
-            return retval;
-        }
+        SetOSDMessage(decoder->GetTrackDesc(type, GetTrack(type)),
+                      kOSDTimeout_Med);
+        return retval;
     }
     return -1;
 }
 
 void MythPlayer::ChangeCaptionTrack(int dir)
 {
-    QMutexLocker locker(&decoder_change_lock);
     if (!decoder || (dir < 0))
         return;
 
@@ -1674,8 +1601,9 @@ void MythPlayer::AVSync(VideoFrame *buff
 
     if (buffer)
     {
-        repeat_pict = buffer->repeat_pict;
-        timecode    = buffer->timecode;
+        repeat_pict   = buffer->repeat_pict;
+        timecode      = buffer->timecode;
+        disp_timecode = buffer->disp_timecode;
     }
 
     float diverge = 0.0f;
@@ -1944,6 +1872,14 @@ bool MythPlayer::PrebufferEnoughFrames(b
             VERBOSE(VB_IMPORTANT, LOC +
                 QString("Waited 100ms for video buffers %1")
                 .arg(videoOutput->GetFrameStatus()));
+            if (audio.IsBufferAlmostFull())
+            {
+                // We are likely to enter this condition
+                // if the audio buffer was too full during GetFrame in AVFD
+                VERBOSE(VB_AUDIO, LOC +
+                    QString("Resetting audio buffer"));
+                audio.Reset();
+            }
         }
         if ((waited_for > 500) && !videoOutput->EnoughFreeFrames())
         {
@@ -2003,11 +1939,11 @@ void MythPlayer::PreProcessNormalFrame(v
 {
 #ifdef USING_MHEG
     // handle Interactive TV
-    if (GetInteractiveTV() && osd)
+    if (GetInteractiveTV())
     {
         osdLock.lock();
         itvLock.lock();
-        if (videoOutput->GetOSDPainter())
+        if (osd && videoOutput->GetOSDPainter())
         {
             InteractiveScreen *window =
                 (InteractiveScreen*)osd->GetWindow(OSD_WIN_INTERACT);
@@ -2036,7 +1972,6 @@ void MythPlayer::VideoStart(void)
         videoOutput->GetOSDBounds(total, visible, aspect, scaling, 1.0f);
         osd->Init(visible, aspect);
         videoOutput->InitOSD(osd);
-        SetupTeletextViewer();
         osd->EnableSubtitles(kDisplayNone);
 
 #ifdef USING_MHEG
@@ -2124,7 +2059,7 @@ void MythPlayer::VideoStart(void)
 
 bool MythPlayer::VideoLoop(void)
 {
-    if (videoPaused || isDummy || noVideoTracks)
+    if (videoPaused || isDummy /*|| noVideoTracks*/)
     {
         usleep(frame_interval);
         DisplayPauseFrame();
@@ -2158,7 +2093,7 @@ bool MythPlayer::FastForward(float secon
     if (!videoOutput)
         return false;
 
-    if (fftime >= 0)
+    if (fftime <= 0)
         fftime = (long long)(seconds * video_frame_rate);
     return fftime > CalcMaxFFTime(fftime, false);
 }
@@ -2168,7 +2103,7 @@ bool MythPlayer::Rewind(float seconds)
     if (!videoOutput)
         return false;
 
-    if (rewindtime >= 0)
+    if (rewindtime <= 0)
         rewindtime = (long long)(seconds * video_frame_rate);
     return (uint64_t)rewindtime >= framesPlayed;
 }
@@ -2232,6 +2167,7 @@ void MythPlayer::SwitchToProgram(void)
         discontinuity, newtype, newid);
     if (!pginfo)
         return;
+    newtype = true; // force reloading of context and stream properties
 
     bool newIsDummy = player_ctx->tvchain->GetCardType(newid) == "DUMMY";
 
@@ -2243,13 +2179,13 @@ void MythPlayer::SwitchToProgram(void)
     {
         OpenDummy();
         ResetPlaying();
-        eof = false;
+        SetEof(false);
         delete pginfo;
         return;
     }
 
     player_ctx->buffer->OpenFile(
-        pginfo->GetPlaybackURL(), RingBuffer::kDefaultOpenTimeout);
+        pginfo->GetPlaybackURL(), RingBuffer::kLiveTVOpenTimeout);
 
     if (!player_ctx->buffer->IsOpen())
     {
@@ -2257,26 +2193,27 @@ void MythPlayer::SwitchToProgram(void)
                 QString("(card type: %1).")
                 .arg(player_ctx->tvchain->GetCardType(newid)));
         VERBOSE(VB_IMPORTANT, QString("\n") + player_ctx->tvchain->toString());
-        eof = true;
+        SetEof(true);
         SetErrored(QObject::tr("Error opening switch program buffer"));
         delete pginfo;
         return;
     }
 
-    if (eof)
+    if (GetEof())
     {
         discontinuity = true;
         ResetCaptions();
     }
 
     VERBOSE(VB_PLAYBACK, LOC + QString("SwitchToProgram(void) "
-            "discont: %1 newtype: %2 newid: %3 eof: %4")
-            .arg(discontinuity).arg(newtype).arg(newid).arg(eof));
+            "discont: %1 newtype: %2 newid: %3 decoderEof: %4")
+            .arg(discontinuity).arg(newtype).arg(newid).arg(GetEof()));
 
     if (discontinuity || newtype)
     {
         player_ctx->tvchain->SetProgram(*pginfo);
-        decoder->SetProgramInfo(*pginfo);
+        if (decoder)
+            decoder->SetProgramInfo(*pginfo);
 
         player_ctx->buffer->Reset(true);
         if (newtype)
@@ -2301,10 +2238,12 @@ void MythPlayer::SwitchToProgram(void)
     if (IsErrored())
     {
         VERBOSE(VB_IMPORTANT, LOC_ERR + "SwitchToProgram failed.");
-        eof = true;
+        SetEof(true);
         return;
     }
 
+    SetEof(false);
+
     // the bitrate is reset by player_ctx->buffer->OpenFile()...
     if (decoder)
         player_ctx->buffer->UpdateRawBitrate(decoder->GetRawBitrate());
@@ -2316,7 +2255,6 @@ void MythPlayer::SwitchToProgram(void)
         forcePositionMapSync = true;
     }
 
-    eof = false;
     Play();
     VERBOSE(VB_PLAYBACK, LOC + "SwitchToProgram - end");
 }
@@ -2331,10 +2269,9 @@ void MythPlayer::FileChangedCallback(voi
         player_ctx->buffer->Reset(false, true);
     else
         player_ctx->buffer->Reset(false, true, true);
+    SetEof(false);
     Play();
 
-    eof = false;
-
     player_ctx->SetPlayerChangingBuffers(false);
 
     player_ctx->LockPlayingInfo(__FILE__, __LINE__);
@@ -2357,6 +2294,7 @@ void MythPlayer::JumpToProgram(void)
         discontinuity, newtype, newid);
     if (!pginfo)
         return;
+    newtype = true; // force reloading of context and stream properties
 
     bool newIsDummy = player_ctx->tvchain->GetCardType(newid) == "DUMMY";
     SetPlayingInfo(*pginfo);
@@ -2371,7 +2309,7 @@ void MythPlayer::JumpToProgram(void)
     {
         OpenDummy();
         ResetPlaying();
-        eof = false;
+        SetEof(false);
         delete pginfo;
         return;
     }
@@ -2379,7 +2317,7 @@ void MythPlayer::JumpToProgram(void)
     SendMythSystemPlayEvent("PLAY_CHANGED", pginfo);
 
     player_ctx->buffer->OpenFile(
-        pginfo->GetPlaybackURL(), RingBuffer::kDefaultOpenTimeout);
+        pginfo->GetPlaybackURL(), RingBuffer::kLiveTVOpenTimeout);
 
     if (!player_ctx->buffer->IsOpen())
     {
@@ -2387,8 +2325,7 @@ void MythPlayer::JumpToProgram(void)
                 QString("(card type: %1).")
                 .arg(player_ctx->tvchain->GetCardType(newid)));
         VERBOSE(VB_IMPORTANT, QString("\n") + player_ctx->tvchain->toString());
-
-        eof = true;
+        SetEof(true);
         SetErrored(QObject::tr("Error opening jump program file buffer"));
         delete pginfo;
         return;
@@ -2412,6 +2349,8 @@ void MythPlayer::JumpToProgram(void)
         return;
     }
 
+    SetEof(false);
+
     // the bitrate is reset by player_ctx->buffer->OpenFile()...
     player_ctx->buffer->UpdateRawBitrate(decoder->GetRawBitrate());
     player_ctx->buffer->IgnoreLiveEOF(false);
@@ -2432,7 +2371,6 @@ void MythPlayer::JumpToProgram(void)
     if (nextpos > 10)
         DoFastForward(nextpos, true, false);
 
-    eof = false;
     player_ctx->SetPlayerChangingBuffers(false);
     VERBOSE(VB_PLAYBACK, LOC + "JumpToProgram - end");
 }
@@ -2465,9 +2403,6 @@ bool MythPlayer::StartPlaying(void)
         InitialSeek();
     VideoStart();
 
-    if (playerTimer)
-        delete playerTimer;
-    playerTimer = new PlayerTimer(this);
     playerThread->setPriority(QThread::TimeCriticalPriority);
     return !IsErrored();
 }
@@ -2493,12 +2428,6 @@ void MythPlayer::StopPlaying()
     VERBOSE(VB_PLAYBACK, LOC + QString("StopPlaying - begin"));
     playerThread->setPriority(QThread::NormalPriority);
 
-    if (playerTimer)
-    {
-        delete playerTimer;
-        playerTimer = NULL;
-    }
-
     DecoderEnd();
     VideoEnd();
     AudioEnd();
@@ -2529,10 +2458,6 @@ void MythPlayer::EventLoop(void)
     if (disableCaptions)
         SetCaptionsEnabled(false, false);
 
-    // (re)initialise the teletext viewer
-    if (initTeletext)
-        SetupTeletextViewer();
-
     // refresh the position map for an in-progress recording while editing
     if (hasFullPositionMap && watchingrecording && player_ctx->recorder &&
         player_ctx->recorder->IsValidRecorder() && deleteMap.IsEditing())
@@ -2568,7 +2493,7 @@ void MythPlayer::EventLoop(void)
         player_ctx->tvchain->JumpToNext(true, 1);
         JumpToProgram();
     }
-    else if ((!allpaused || eof) && player_ctx->tvchain &&
+    else if ((!allpaused || GetEof()) && player_ctx->tvchain &&
              (decoder && !decoder->GetWaitForChange()))
     {
         // Switch to the next program in livetv
@@ -2591,7 +2516,7 @@ void MythPlayer::EventLoop(void)
 
     // Disable rewind if we are too close to the beginning of the buffer
     if (CalcRWTime(-ffrew_skip) > 0 &&
-       (!noVideoTracks && (framesPlayed <= keyframedist)))
+       (/*!noVideoTracks && */(framesPlayed <= keyframedist)))
     {
         VERBOSE(VB_PLAYBACK, LOC + "Near start, stopping rewind.");
         float stretch = (ffrew_skip > 0) ? 1.0f : audio.GetStretchFactor();
@@ -2619,7 +2544,7 @@ void MythPlayer::EventLoop(void)
     }
 
     // Handle end of file
-    if (eof)
+    if (GetEof())
     {
         if (player_ctx->tvchain)
         {
@@ -2652,7 +2577,7 @@ void MythPlayer::EventLoop(void)
         if (fftime > 0)
         {
             DoFastForward(fftime);
-            if (eof)
+            if (GetEof())
                return;
         }
     }
@@ -2714,7 +2639,7 @@ void MythPlayer::EventLoop(void)
                   && !player_ctx->IsPIP() &&
                   player_ctx->GetState() == kState_WatchingPreRecorded))
             {
-                eof = true;
+                SetEof(true);
             }
         }
         else
@@ -2742,7 +2667,7 @@ bool MythPlayer::PauseDecoder(void)
 
     int tries = 0;
     pauseDecoder = true;
-    while (decoderThread && !killdecoder && !eof && (tries++ < 100) &&
+    while (decoderThread && !killdecoder && (tries++ < 100) &&
           !decoderThreadPause.wait(&decoderPauseLock, 100))
     {
         VERBOSE(VB_IMPORTANT, LOC_WARN + "Waited 100ms for decoder to pause");
@@ -2817,6 +2742,34 @@ void MythPlayer::DecoderPauseCheck(void)
         UnpauseDecoder();
 }
 
+//// FIXME - move the eof ownership back into MythPlayer
+bool MythPlayer::GetEof(void)
+{
+    if (QThread::currentThread() == (QThread*)playerThread)
+        return decoder ? decoder->GetEof() : true;
+
+    decoder_change_lock.lock();
+    bool eof = decoder ? decoder->GetEof() : true;
+    decoder_change_lock.unlock();
+    return eof;
+}
+
+void MythPlayer::SetEof(bool eof)
+{
+    if (QThread::currentThread() == (QThread*)playerThread)
+    {
+        if (decoder)
+            decoder->SetEof(eof);
+        return;
+    }
+
+    decoder_change_lock.lock();
+    if (decoder)
+        decoder->SetEof(eof);
+    decoder_change_lock.unlock();
+}
+//// FIXME end
+
 void MythPlayer::DecoderLoop(bool pause)
 {
     if (pause)
@@ -2824,29 +2777,45 @@ void MythPlayer::DecoderLoop(bool pause)
 
     while (!killdecoder && !IsErrored())
     {
-        //noVideoTracks = decoder &&
-        //            !decoder->GetTrackCount(kTrackTypeVideo);
-
         DecoderPauseCheck();
 
+        if (!decoder_change_lock.tryLock(1))
+            continue;
+        if (decoder)
+            noVideoTracks = !decoder->GetTrackCount(kTrackTypeVideo);
+        decoder_change_lock.unlock();
+
         if (forcePositionMapSync)
         {
-            forcePositionMapSync = false;
-            decoder->SyncPositionMap();
+            if (!decoder_change_lock.tryLock(1))
+                continue;
+            if (decoder)
+            {
+                forcePositionMapSync = false;
+                decoder->SyncPositionMap();
+            }
+            decoder_change_lock.unlock();
         }
 
         if (decoderSeek >= 0)
         {
-            decoderSeekLock.lock();
-            if (((uint64_t)decoderSeek < framesPlayed) && decoder)
-                decoder->DoRewind(decoderSeek);
-            else if (decoder)
-                decoder->DoFastForward(decoderSeek);
-            decoderSeek = -1;
-            decoderSeekLock.unlock();
+            if (!decoder_change_lock.tryLock(1))
+                continue;
+            if (decoder)
+            {
+                decoderSeekLock.lock();
+                if (((uint64_t)decoderSeek < framesPlayed) && decoder)
+                    decoder->DoRewind(decoderSeek);
+                else if (decoder)
+                    decoder->DoFastForward(decoderSeek);
+                decoderSeek = -1;
+                decoderSeekLock.unlock();
+            }
+            decoder_change_lock.unlock();
         }
 
-        bool obey_eof = eof && !(eof && player_ctx->tvchain && !allpaused);
+        bool obey_eof = GetEof() &&
+                        !(GetEof() && player_ctx->tvchain && !allpaused);
         if (isDummy || ((decoderPaused || ffrew_skip == 0 || obey_eof) &&
             !decodeOneFrame))
         {
@@ -2856,8 +2825,8 @@ void MythPlayer::DecoderLoop(bool pause)
 
         DecodeType dt = (audio.HasAudioOut() && normal_speed) ?
             kDecodeAV : kDecodeVideo;
-        if (noVideoTracks && audio.HasAudioOut())
-            dt = kDecodeAudio;
+        //if (noVideoTracks && audio.HasAudioOut())
+        //    dt = kDecodeAudio;
         DecoderGetFrame(dt);
         decodeOneFrame = false;
     }
@@ -2912,10 +2881,10 @@ bool MythPlayer::DecoderGetFrame(DecodeT
     {
         int tries = 0;
         while (!videoOutput->EnoughFreeFrames() && (tries++ < 10))
-            usleep(10000);
+            usleep(1000);
         if (!videoOutput->EnoughFreeFrames())
         {
-            if (++videobuf_retries >= 200)
+            if (++videobuf_retries >= 2000)
             {
                 VERBOSE(VB_IMPORTANT, LOC +
                         "Timed out waiting for free video buffers.");
@@ -2926,17 +2895,19 @@ bool MythPlayer::DecoderGetFrame(DecodeT
         videobuf_retries = 0;
     }
 
-    if (killdecoder)
+    if (!decoder_change_lock.tryLock(5))
         return false;
-    if (!decoder)
+    if (killdecoder || !decoder || IsErrored())
     {
-        VERBOSE(VB_IMPORTANT, LOC + "DecoderGetFrame() called with NULL decoder.");
+        decoder_change_lock.unlock();
         return false;
     }
-    else if (ffrew_skip == 1 || decodeOneFrame)
+
+    if (ffrew_skip == 1 || decodeOneFrame)
         ret = decoder->GetFrame(decodetype);
     else if (ffrew_skip != 0)
         ret = DecoderGetFrameFFREW();
+    decoder_change_lock.unlock();
     return ret;
 }
 
@@ -3183,9 +3154,10 @@ void MythPlayer::ChangeSpeed(void)
     if (skip_changed && videoOutput)
     {
         videoOutput->SetPrebuffering(ffrew_skip == 1);
-        decoder->setExactSeeks(exactseeks && ffrew_skip == 1);
+        if (decoder)
+            decoder->setExactSeeks(exactseeks && ffrew_skip == 1);
         if (play_speed != 0.0f && !(last_speed == 0.0f && ffrew_skip == 1))
-            DoJumpToFrame(framesPlayed);
+            DoJumpToFrame(framesPlayed + fftime - rewindtime);
     }
 
     VERBOSE(VB_PLAYBACK, LOC + "Play speed: " +
@@ -3196,7 +3168,7 @@ void MythPlayer::ChangeSpeed(void)
     if (videoOutput && videosync)
     {
         // We need to tell it this for automatic deinterlacer settings
-        videoOutput->SetVideoFrameRate(video_frame_rate * play_speed);
+        videoOutput->SetVideoFrameRate(video_frame_rate);
 
         // If using bob deinterlace, turn on or off if we
         // changed to or from synchronous playback speed.
@@ -3427,8 +3399,11 @@ void MythPlayer::WaitForSeek(uint64_t fr
                            (allpaused && !deleteMap.IsEditing()) ? true: after;
     decoder->setExactSeeks(before);
 
+    bool islivetvcur = (livetv && player_ctx->tvchain &&
+                        !player_ctx->tvchain->HasNext());
+
     uint64_t max = totalFrames;
-    if ((livetv || (watchingrecording && player_ctx->recorder &&
+    if ((islivetvcur || (watchingrecording && player_ctx->recorder &&
                    player_ctx->recorder->IsValidRecorder())))
     {
         max = (uint64_t)player_ctx->recorder->GetFramesWritten();
@@ -3457,10 +3432,11 @@ void MythPlayer::WaitForSeek(uint64_t fr
             need_clear = true;
         }
     }
-    if (need_clear && osd)
+    if (need_clear)
     {
         osdLock.lock();
-        osd->HideWindow("osd_message");
+        if (osd)
+            osd->HideWindow("osd_message");
         osdLock.unlock();
     }
     decoder->setExactSeeks(after);
@@ -3523,14 +3499,18 @@ bool MythPlayer::EnableEdit(void)
         return false;
     }
 
-    if (!osd || deleteMap.IsFileEditing(player_ctx))
+    if (deleteMap.IsFileEditing(player_ctx))
+        return false;
+
+    QMutexLocker locker(&osdLock);
+    if (!osd)
         return false;
 
-    osdLock.lock();
     speedBeforeEdit = play_speed;
     pausedBeforeEdit = Pause();
     deleteMap.SetEditing(true);
     osd->DialogQuit();
+    ResetCaptions();
     osd->HideAll();
     deleteMap.UpdateSeekAmount(0, video_frame_rate);
     deleteMap.UpdateOSD(framesPlayed, totalFrames, video_frame_rate,
@@ -3541,13 +3521,16 @@ bool MythPlayer::EnableEdit(void)
         player_ctx->playingInfo->SaveEditing(true);
     player_ctx->UnlockPlayingInfo(__FILE__, __LINE__);
     editUpdateTimer.start();
-    osdLock.unlock();
+
     return deleteMap.IsEditing();
 }
 
 void MythPlayer::DisableEdit(bool save)
 {
-    osdLock.lock();
+    QMutexLocker locker(&osdLock);
+    if (!osd)
+        return;
+
     deleteMap.SetEditing(false, osd);
     if (save)
         deleteMap.SaveMap(totalFrames, player_ctx);
@@ -3563,7 +3546,6 @@ void MythPlayer::DisableEdit(bool save)
         Play(speedBeforeEdit);
     else
         SetOSDStatus(QObject::tr("Paused"), kOSDTimeout_None);
-    osdLock.unlock();
 }
 
 bool MythPlayer::HandleProgramEditorActions(QStringList &actions,
@@ -3681,8 +3663,11 @@ bool MythPlayer::HandleProgramEditorActi
     if (handled && refresh)
     {
         osdLock.lock();
-        deleteMap.UpdateOSD(framesPlayed, totalFrames, video_frame_rate,
-                            player_ctx, osd);
+        if (osd)
+        {
+            deleteMap.UpdateOSD(framesPlayed, totalFrames, video_frame_rate,
+                                player_ctx, osd);
+        }
         osdLock.unlock();
     }
 
@@ -4171,7 +4156,7 @@ bool MythPlayer::TranscodeGetNextFrame(
     if (!decoder->GetFrame(kDecodeAV))
         return false;
 
-    if (eof)
+    if (GetEof())
         return false;
 
     if (honorCutList && !deleteMap.IsEmpty())
@@ -4196,7 +4181,7 @@ bool MythPlayer::TranscodeGetNextFrame(
             did_ff = 1;
         }
     }
-    if (eof)
+    if (GetEof())
       return false;
     is_key = decoder->isLastFrameKey();
     return true;
@@ -4267,6 +4252,9 @@ int MythPlayer::GetSecondsBehind(void) c
 
 void MythPlayer::calcSliderPos(osdInfo &info, bool paddedFields)
 {
+    if (!decoder)
+        return;
+
     bool islive = false;
     int chapter = GetCurrentChapter() + 1;
     int title = GetCurrentTitle() + 1;
@@ -4276,7 +4264,10 @@ void MythPlayer::calcSliderPos(osdInfo &
     info.values.insert("progbefore", 0);
     info.values.insert("progafter",  0);
 
-    int playbackLen = totalLength;
+    int playbackLen = totalDuration;
+
+    if (totalDuration == 0 || noVideoTracks || decoder->GetCodecDecoderName() == "nuppel")
+        playbackLen = totalLength;
 
     if (livetv && player_ctx->tvchain)
     {
@@ -4294,7 +4285,10 @@ void MythPlayer::calcSliderPos(osdInfo &
         islive = true;
     }
 
-    float secsplayed = ((float)framesPlayed / video_frame_rate);
+    float secsplayed = (noVideoTracks || decoder->GetCodecDecoderName() == "nuppel") ? 
+        (float)(framesPlayed / video_frame_rate) :
+        (float)(disp_timecode / 1000.f);
+
     calcSliderPosPriv(info, paddedFields, playbackLen, secsplayed, islive);
 }
 
@@ -4430,11 +4424,12 @@ int64_t MythPlayer::GetChapter(int chapt
 InteractiveTV *MythPlayer::GetInteractiveTV(void)
 {
 #ifdef USING_MHEG
-    if (!interactiveTV && osd && itvEnabled)
+    if (!interactiveTV && itvEnabled)
     {
         QMutexLocker locker1(&osdLock);
         QMutexLocker locker2(&itvLock);
-        interactiveTV = new InteractiveTV(this);
+        if (osd)
+            interactiveTV = new InteractiveTV(this);
     }
 #endif // USING_MHEG
     return interactiveTV;
@@ -4503,15 +4498,21 @@ bool MythPlayer::SetVideoByComponentTag(
  */
 void MythPlayer::SetDecoder(DecoderBase *dec)
 {
-    QMutexLocker locker(&decoder_change_lock);
+    PauseDecoder();
 
-    if (!decoder)
-        decoder = dec;
-    else
     {
-        DecoderBase *d = decoder;
-        decoder = dec;
-        delete d;
+        while (!decoder_change_lock.tryLock(10))
+            VERBOSE(VB_IMPORTANT, LOC + QString("Waited 10ms for decoder lock"));
+
+        if (!decoder)
+            decoder = dec;
+        else
+        {
+            DecoderBase *d = decoder;
+            decoder = dec;
+            delete d;
+        }
+        decoder_change_lock.unlock();
     }
 }
 
@@ -4569,28 +4570,26 @@ QString MythPlayer::GetError(void) const
 
 void MythPlayer::SetOSDMessage(const QString &msg, OSDTimeout timeout)
 {
+    QMutexLocker locker(&osdLock);
     if (!osd)
         return;
 
-    osdLock.lock();
     QHash<QString,QString> info;
     info.insert("message_text", msg);
     osd->SetText("osd_message", info, timeout);
-    osdLock.unlock();
 }
 
 void MythPlayer::SetOSDStatus(const QString &title, OSDTimeout timeout)
 {
+    QMutexLocker locker(&osdLock);
     if (!osd)
         return;
 
-    osdLock.lock();
     osdInfo info;
     calcSliderPos(info);
     info.text.insert("title", title);
     osd->SetText("osd_status", info.text, timeout);
     osd->SetValues("osd_status", info.values, timeout);
-    osdLock.unlock();
 }
 
 static unsigned dbg_ident(const MythPlayer *player)
diff -Naurp mythtv-0.24.orig/libs/libmythtv/mythplayer.h mythtv-0.24.fixes/libs/libmythtv/mythplayer.h
--- mythtv-0.24.orig/libs/libmythtv/mythplayer.h	2010-11-07 23:38:30.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythtv/mythplayer.h	2011-03-24 22:18:50.000000000 -0400
@@ -15,7 +15,7 @@
 #include "osd.h"
 #include "jitterometer.h"
 #include "videooutbase.h"
-#include "teletextdecoder.h"
+#include "teletextreader.h"
 #include "subtitlereader.h"
 #include "tv_play.h"
 #include "yuv2rgb.h"
@@ -80,20 +80,6 @@ enum
     kDisplayTeletextMenu        = 0x100,
 };
 
-class PlayerTimer : public QObject
-{
-    Q_OBJECT
-  public:
-    PlayerTimer(MythPlayer *mp);
-    void PostNextEvent(void);
-    virtual bool event(QEvent *e);
-    static enum QEvent::Type kPlayerEventType;
-
-  private:
-    MythPlayer *m_mp;
-    uint32_t    m_queue_size;
-};
-
 class DecoderThread : public QThread
 {
     Q_OBJECT
@@ -138,7 +124,7 @@ class MPUBLIC MythPlayer
     void SetLength(int len)                   { totalLength = len; }
     void SetFramesPlayed(uint64_t played)     { framesPlayed = played; }
     void SetVideoFilters(const QString &override);
-    void SetEof(void)                         { eof = true; }
+    void SetEof(bool eof);
     void SetPIPActive(bool is_active)         { pip_active = is_active; }
     void SetPIPVisible(bool is_visible)       { pip_visible = is_visible; }
 
@@ -150,6 +136,7 @@ class MPUBLIC MythPlayer
                         float a = 1.33333, FrameScanType scan = kScan_Ignore,
                         bool video_codec_changed = false);
     void SetFileLength(int total, int frames);
+    void SetDuration(int duration);
     void SetForcedAspectRatio(int mpeg2_aspect_value, int letterbox_permission);
     void SetVideoResize(const QRect &videoRect);
 
@@ -188,7 +175,7 @@ class MPUBLIC MythPlayer
     // Bool Gets
     bool    GetRawAudioState(void) const;
     bool    GetLimitKeyRepeat(void) const     { return limitKeyRepeat; }
-    bool    GetEof(void) const                { return eof; }
+    bool    GetEof(void);
     bool    IsErrored(void) const;
     bool    IsPlaying(uint wait_ms = 0, bool wait_for = true) const;
     bool    AtNormalSpeed(void) const         { return next_normal_speed; }
@@ -253,11 +240,11 @@ class MPUBLIC MythPlayer
     virtual bool PrepareAudioSample(int64_t &timecode);
 
     // Public Closed caption and teletext stuff
-    void SetupTeletextViewer(void);
     uint GetCaptionMode(void) const    { return textDisplayMode; }
     CC708Reader* GetCC708Reader(void)  { return &cc708; }
     CC608Reader* GetCC608Reader(void)  { return &cc608; }
     SubtitleReader* GetSubReader(void) { return &subReader; }
+    TeletextReader* GetTeletextReader(void) { return &ttxReader; }
 
     // Public Audio/Subtitle/EIA-608/EIA-708 stream selection - thread safe
     void TracksChanged(uint trackType);
@@ -297,8 +284,9 @@ class MPUBLIC MythPlayer
                        QMap<long long, long long> &posMap);
 
     // OSD locking for TV class
-    void LockOSD(void)   { osdLock.lock();   }
-    void UnlockOSD(void) { osdLock.unlock(); }
+    bool TryLockOSD(void) { return osdLock.tryLock(50); }
+    void LockOSD(void)    { osdLock.lock();   }
+    void UnlockOSD(void)  { osdLock.unlock(); }
 
   protected:
     // Initialization
@@ -531,7 +519,6 @@ class MPUBLIC MythPlayer
     PlayerContext *player_ctx;
     DecoderThread *decoderThread;
     QThread       *playerThread;
-    PlayerTimer   *playerTimer;
     bool           no_hardware_decoders;
 
     // Window stuff
@@ -562,7 +549,6 @@ class MPUBLIC MythPlayer
     mutable QWaitCondition playingWaitCond;
     mutable QMutex vidExitLock;
     mutable QMutex playingLock;
-    bool     eof;             ///< At end of file/ringbuffer
     bool     m_double_framerate;///< Output fps is double Video (input) rate
     bool     m_double_process;///< Output filter must processed at double rate
     bool     m_can_double;    ///< VideoOutput capable of doubling frame rate
@@ -581,7 +567,7 @@ class MPUBLIC MythPlayer
     int jumpchapter;
 
     // Bookmark stuff
-    long long bookmarkseek;
+    uint64_t bookmarkseek;
 
     // Seek
     /// If fftime>0, number of frames to seek forward.
@@ -597,6 +583,7 @@ class MPUBLIC MythPlayer
     uint64_t  framesPlayed;
     uint64_t  totalFrames;
     long long totalLength;
+    int64_t   totalDuration;
     long long rewindtime;
 
     // -- end state stuff --
@@ -634,12 +621,12 @@ class MPUBLIC MythPlayer
 
     // Support for captions, teletext, etc. decoded by libav
     SubtitleReader subReader;
+    TeletextReader ttxReader;
     /// This allows us to enable captions/subtitles later if the streams
     /// are not immediately available when the video starts playing.
     bool      textDesired;
     bool      enableCaptions;
     bool      disableCaptions;
-    bool      initTeletext;
 
     // CC608/708
     bool db_prefer708;
@@ -706,6 +693,7 @@ class MPUBLIC MythPlayer
     bool       lastsync;
     bool       decode_extra_audio;
     int        repeat_delay;
+    int64_t    disp_timecode;
 
     // Time Code stuff
     int        prevtc;        ///< 32 bit timecode if last VideoFrame shown
diff -Naurp mythtv-0.24.orig/libs/libmythtv/nuppeldecoder.cpp mythtv-0.24.fixes/libs/libmythtv/nuppeldecoder.cpp
--- mythtv-0.24.orig/libs/libmythtv/nuppeldecoder.cpp	2010-11-08 12:39:23.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythtv/nuppeldecoder.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -1056,8 +1056,7 @@ bool NuppelDecoder::GetFrame(DecodeType 
 
         if (!ReadFrameheader(&frameheader))
         {
-            ateof = true;
-            GetPlayer()->SetEof();
+            SetEof(true);
             return false;
         }
 
@@ -1065,8 +1064,7 @@ bool NuppelDecoder::GetFrame(DecodeType 
         if (!ringBuffer->LiveMode() &&
             ((frameheader.frametype == 'Q') || (frameheader.frametype == 'K')))
         {
-            ateof = true;
-            GetPlayer()->SetEof();
+            SetEof(true);
             return false;
         }
 
@@ -1083,8 +1081,7 @@ bool NuppelDecoder::GetFrame(DecodeType 
 
             if (!ReadFrameheader(&frameheader))
             {
-                ateof = true;
-                GetPlayer()->SetEof();
+                SetEof(true);
                 return false;
             }
             seeklen = 1;
@@ -1098,8 +1095,7 @@ bool NuppelDecoder::GetFrame(DecodeType 
             if (ringBuffer->Read(dummy, sizetoskip) != sizetoskip)
             {
                 delete [] dummy;
-                ateof = true;
-                GetPlayer()->SetEof();
+                SetEof(true);
                 return false;
             }
 
@@ -1157,15 +1153,13 @@ bool NuppelDecoder::GetFrame(DecodeType 
                 VERBOSE(VB_IMPORTANT, QString("Broken packet: %1 %2")
                         .arg(frameheader.frametype)
                         .arg(frameheader.packetlength));
-                ateof = true;
-                GetPlayer()->SetEof();
+                SetEof(true);
                 return false;
             }
             if (ringBuffer->Read(strm, frameheader.packetlength) !=
                 frameheader.packetlength)
             {
-                ateof = true;
-                GetPlayer()->SetEof();
+                SetEof(true);
                 return false;
             }
         }
diff -Naurp mythtv-0.24.orig/libs/libmythtv/playercontext.cpp mythtv-0.24.fixes/libs/libmythtv/playercontext.cpp
--- mythtv-0.24.orig/libs/libmythtv/playercontext.cpp	2010-10-28 23:06:06.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/playercontext.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -468,8 +468,6 @@ bool PlayerContext::CreatePlayer(TV *tv,
         if (audio->HasAudioOut())
         {
             QString errMsg = audio->ReinitAudio();
-            if (!errMsg.isEmpty())
-                VERBOSE(VB_IMPORTANT, LOC_ERR + errMsg);
         }
     }
     else if (pipState == kPBPRight)
diff -Naurp mythtv-0.24.orig/libs/libmythtv/privatedecoder_vda.cpp mythtv-0.24.fixes/libs/libmythtv/privatedecoder_vda.cpp
--- mythtv-0.24.orig/libs/libmythtv/privatedecoder_vda.cpp	2010-09-30 21:26:38.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/privatedecoder_vda.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -9,6 +9,10 @@
 #include "myth_imgconvert.h"
 #include "util-osx-cocoa.h"
 #include "privatedecoder_vda.h"
+#ifdef USING_QUARTZ_VIDEO
+#undef CodecType
+#import  "QuickTime/ImageCompression.h"
+#endif
 
 extern "C" {
 #include "libavformat/avformat.h"
@@ -191,7 +195,11 @@ bool PrivateDecoderVDA::Init(const QStri
         CFDictionaryCreateMutable(kCFAllocatorDefault, 1,
                                   &kCFTypeDictionaryKeyCallBacks,
                                   &kCFTypeDictionaryValueCallBacks);
+#ifdef USING_QUARTZ_VIDEO
+    OSType cvPixelFormatType = k422YpCbCr8PixelFormat;
+#else
     OSType cvPixelFormatType = kCVPixelFormatType_422YpCbCr8;
+#endif
     CFNumberRef pixelFormat  = CFNumberCreate(kCFAllocatorDefault,
                                               kCFNumberSInt32Type,
                                               &cvPixelFormatType);
diff -Naurp mythtv-0.24.orig/libs/libmythtv/privatedecoder_vda.h mythtv-0.24.fixes/libs/libmythtv/privatedecoder_vda.h
--- mythtv-0.24.orig/libs/libmythtv/privatedecoder_vda.h	2010-09-30 21:26:38.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/privatedecoder_vda.h	2011-03-24 22:18:50.000000000 -0400
@@ -6,7 +6,11 @@
 #include <QList>
 
 #import  "CoreFoundation/CoreFoundation.h"
+#ifdef USING_QUARTZ_VIDEO
+#import  "QuartzCore/CoreVideo.h"
+#else
 #import  "CoreVideo/CoreVideo.h"
+#endif
 #include "privatedecoder_vda_defs.h"
 #include "privatedecoder.h"
 
diff -Naurp mythtv-0.24.orig/libs/libmythtv/recordinginfo.cpp mythtv-0.24.fixes/libs/libmythtv/recordinginfo.cpp
--- mythtv-0.24.orig/libs/libmythtv/recordinginfo.cpp	2010-09-12 17:43:56.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/recordinginfo.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -1125,6 +1125,7 @@ void RecordingInfo::AddHistory(bool resc
     oldrecstatus = GetRecordingStatus();
     if (dup)
         SetReactivated(false);
+    uint erecid = parentid ? parentid : recordid;
 
     MSqlQuery result(MSqlQuery::InitCon());
 
@@ -1145,7 +1146,7 @@ void RecordingInfo::AddHistory(bool resc
     result.bindValue(":SERIESID", seriesid);
     result.bindValue(":PROGRAMID", programid);
     result.bindValue(":FINDID", findid);
-    result.bindValue(":RECORDID", recordid);
+    result.bindValue(":RECORDID", erecid);
     result.bindValue(":STATION", chansign);
     result.bindValue(":RECTYPE", rectype);
     result.bindValue(":RECSTATUS", rs);
@@ -1159,7 +1160,7 @@ void RecordingInfo::AddHistory(bool resc
     {
         result.prepare("REPLACE INTO oldfind (recordid, findid) "
                        "VALUES(:RECORDID,:FINDID);");
-        result.bindValue(":RECORDID", recordid);
+        result.bindValue(":RECORDID", erecid);
         result.bindValue(":FINDID", findid);
 
         if (!result.exec())
@@ -1177,6 +1178,8 @@ void RecordingInfo::AddHistory(bool resc
  */
 void RecordingInfo::DeleteHistory(void)
 {
+    uint erecid = parentid ? parentid : recordid;
+
     MSqlQuery result(MSqlQuery::InitCon());
 
     result.prepare("DELETE FROM oldrecorded WHERE title = :TITLE AND "
@@ -1192,7 +1195,7 @@ void RecordingInfo::DeleteHistory(void)
     {
         result.prepare("DELETE FROM oldfind WHERE "
                        "recordid = :RECORDID AND findid = :FINDID");
-        result.bindValue(":RECORDID", recordid);
+        result.bindValue(":RECORDID", erecid);
         result.bindValue(":FINDID", findid);
 
         if (!result.exec())
@@ -1214,6 +1217,8 @@ void RecordingInfo::DeleteHistory(void)
  */
 void RecordingInfo::ForgetHistory(void)
 {
+    uint erecid = parentid ? parentid : recordid;
+
     MSqlQuery result(MSqlQuery::InitCon());
 
     result.prepare("UPDATE recorded SET duplicate = 0 "
@@ -1254,7 +1259,7 @@ void RecordingInfo::ForgetHistory(void)
     {
         result.prepare("DELETE FROM oldfind WHERE "
                        "recordid = :RECORDID AND findid = :FINDID");
-        result.bindValue(":RECORDID", recordid);
+        result.bindValue(":RECORDID", erecid);
         result.bindValue(":FINDID", findid);
 
         if (!result.exec())
diff -Naurp mythtv-0.24.orig/libs/libmythtv/recordingprofile.cpp mythtv-0.24.fixes/libs/libmythtv/recordingprofile.cpp
--- mythtv-0.24.orig/libs/libmythtv/recordingprofile.cpp	2010-09-11 09:53:10.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/recordingprofile.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -1166,6 +1166,7 @@ class RecordingProfilePopup
     }
 };
 
+// id and name will be deleted by ConfigurationGroup's destructor
 RecordingProfile::RecordingProfile(QString profName)
     : id(new ID()),        name(new Name(*this)),
       imageSize(NULL),     videoSettings(NULL),
@@ -1216,13 +1217,6 @@ RecordingProfile::RecordingProfile(QStri
     addChild(profile);
 };
 
-RecordingProfile::~RecordingProfile()
-{
-    id->deleteLater();
-    delete name;
-    name = NULL;
-}
-
 void RecordingProfile::ResizeTranscode(bool resize)
 {
     MythWizard *wizard = (MythWizard *)dialog;
diff -Naurp mythtv-0.24.orig/libs/libmythtv/recordingprofile.h mythtv-0.24.fixes/libs/libmythtv/recordingprofile.h
--- mythtv-0.24.orig/libs/libmythtv/recordingprofile.h	2010-09-18 22:17:00.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/recordingprofile.h	2011-03-24 22:18:50.000000000 -0400
@@ -85,7 +85,6 @@ class MPUBLIC RecordingProfile : public 
   public:
     // initializers
     RecordingProfile(QString profName = QString());
-    ~RecordingProfile();
     virtual void loadByID(int id);
     virtual bool loadByType(const QString &name, const QString &cardtype);
     virtual bool loadByGroup(const QString &name, const QString &group);
diff -Naurp mythtv-0.24.orig/libs/libmythtv/RingBuffer.cpp mythtv-0.24.fixes/libs/libmythtv/RingBuffer.cpp
--- mythtv-0.24.orig/libs/libmythtv/RingBuffer.cpp	2010-10-06 23:06:23.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/RingBuffer.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -1405,6 +1405,14 @@ bool RingBuffer::WaitForAvail(int count)
     int avail = ReadBufAvail();
     count = (ateof && avail < count) ? avail : count;
 
+    if (livetvchain && setswitchtonext && avail < count)
+    {
+        VERBOSE(VB_IMPORTANT, LOC + "Checking to see if there's a "
+                              "new livetv program to switch to..");
+        livetvchain->ReloadAll();
+        return false;
+    }
+
     MythTimer t;
     t.start();
     while ((avail < count) && !stopreads &&
@@ -1414,7 +1422,7 @@ bool RingBuffer::WaitForAvail(int count)
         generalWait.wait(&rwlock, 250);
         avail = ReadBufAvail();
 
-        if ((ateof || setswitchtonext) && avail < count)
+        if (ateof && avail < count)
             count = avail;
 
         if (avail < count)
@@ -1433,28 +1441,13 @@ bool RingBuffer::WaitForAvail(int count)
                         " seconds for data \n\t\t\tto become available..." +
                         QString(" %2 < %3")
                         .arg(avail).arg(count));
-                if (livetvchain)
-                {
-                    VERBOSE(VB_IMPORTANT, "Checking to see if there's a "
-                                          "new livetv program to switch to..");
-                    livetvchain->ReloadAll();
-                }
             }
 
-            bool quit = livetvchain && (livetvchain->NeedsToSwitch() ||
-                                        livetvchain->NeedsToJump() ||
-                                        setswitchtonext);
-
-            if (elapsed > 16000 || quit)
-            {
-                if (!quit)
-                    VERBOSE(VB_IMPORTANT, LOC_ERR + "Waited " +
-                            QString("%1").arg(elapsed/1000) +
-                            " seconds for data, aborting.");
-                else
-                    VERBOSE(VB_IMPORTANT, LOC + "Timing out wait due to "
-                            "impending livetv switch.");
-
+            if (elapsed > 16000)
+            {
+                VERBOSE(VB_IMPORTANT, LOC_ERR + "Waited " +
+                        QString("%1").arg(elapsed/1000) +
+                        " seconds for data, aborting.");
                 return false;
             }
         }
@@ -1887,7 +1880,7 @@ long long RingBuffer::Seek(long long pos
     }
 #endif
 
-#if 1
+#if 0
     // This optimizes the seek end-250000, read, seek 0, read portion 
     // of the pattern ffmpeg performs at the start of playback to
     // determine the pts.
@@ -1986,8 +1979,6 @@ long long RingBuffer::Seek(long long pos
                 readsallowed = false;
             }
 
-            rbwlock.unlock();
-            rbrlock.unlock();
             poslock.unlock();
 
             generalWait.wakeAll();
diff -Naurp mythtv-0.24.orig/libs/libmythtv/subtitlescreen.cpp mythtv-0.24.fixes/libs/libmythtv/subtitlescreen.cpp
--- mythtv-0.24.orig/libs/libmythtv/subtitlescreen.cpp	2010-11-07 23:39:58.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythtv/subtitlescreen.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -314,7 +314,6 @@ void SubtitleScreen::DisplayTextSubtitle
             int height = (m_safeArea.height() * m_textFontZoom) / 1800;
             gTextSubFont->GetFace()->setPixelSize(height);
             gTextSubFont->SetColor(Qt::white);
-            gTextSubFont->SetOutline(true, Qt::black, 2, 255);
         }
     }
     else
@@ -362,6 +361,12 @@ void SubtitleScreen::DisplayTextSubtitle
 
     DeleteAllChildren();
     SetRedraw();
+    if (playPos == 0)
+    {
+        subs->Unlock();
+        return;
+    }
+
     QStringList rawsubs = subs->GetSubtitles(playPos);
     if (rawsubs.empty())
     {
@@ -394,7 +399,6 @@ void SubtitleScreen::DisplayRawTextSubti
             int height = (m_safeArea.height() * m_textFontZoom) / 1800;
             gTextSubFont->GetFace()->setPixelSize(height);
             gTextSubFont->SetColor(Qt::white);
-            gTextSubFont->SetOutline(true, Qt::black, 2, 255);
         }
     }
     else
@@ -602,7 +606,7 @@ void SubtitleScreen::DisplayCC608Subtitl
 
         if (cc && (cc->text != QString::null))
         {
-            int width  = font.width(cc->text) + pad_width * 2;
+            int width  = font.width(cc->text) + pad_width;
             int x = teletextmode ? cc->y : (cc->x + 3);
             int y = teletextmode ? cc->x : cc->y;
             x = (int)(((float)x / (float)xscale) * (float)m_safeArea.width());
@@ -614,7 +618,8 @@ void SubtitleScreen::DisplayCC608Subtitl
                 MythUIShape *shape = new MythUIShape(this,
                     QString("cc608bg%1%2%3").arg(cc->x).arg(cc->y).arg(width));
                 shape->SetFillBrush(bgfill);
-                shape->SetArea(MythRect(rect));
+                QRect bgrect(x - pad_width, y, width + pad_width, height);
+                shape->SetArea(MythRect(bgrect));
             }
 
             gTextSubFont->SetColor(clr[max(min(0, cc->color), 7)]);
@@ -622,7 +627,7 @@ void SubtitleScreen::DisplayCC608Subtitl
                    cc->text, *gTextSubFont, rect, rect, (MythUIType*)this,
                    QString("cc608txt%1%2%3").arg(cc->x).arg(cc->y).arg(width));
             if (text)
-                text->SetJustification(Qt::AlignCenter);
+                text->SetJustification(Qt::AlignLeft);
             m_refreshArea = true;
             VERBOSE(VB_VBI, QString("x %1 y %2 String: '%3'")
                                 .arg(cc->x).arg(cc->y).arg(cc->text));
@@ -915,8 +920,11 @@ bool SubtitleScreen::InitialiseFont(int 
     QString font = gCoreContext->GetSetting("OSDSubFont", "FreeSans");
     if (initialised)
     {
-        if (gTextSubFont->face().family() == font)
-            return gTextSubFont;
+        if (gTextSubFont->face().family() == font &&
+            gTextSubFont->face().stretch() == fontStretch)
+        {
+            return true;
+        }
         delete gTextSubFont;
     }
 
@@ -927,6 +935,7 @@ bool SubtitleScreen::InitialiseFont(int 
         newfont.setStretch(fontStretch);
         font.detach();
         mythfont->SetFace(newfont);
+        mythfont->SetOutline(true, Qt::black, 2, 255);
         gTextSubFont = mythfont;
     }
     else
@@ -942,13 +951,14 @@ bool SubtitleScreen::Initialise708Fonts(
 {
     static bool initialised = false;
     if (initialised)
+    {
+        foreach(MythFontProperties* font, gCC708Fonts)
+            font->face().setStretch(fontStretch);
         return true;
-
-    initialised = true;
+    }
 
     VERBOSE(VB_IMPORTANT, "Initialise708Fonts()");
 
-    // TODO remove extra fonts from settings page
     QStringList fonts;
     fonts.append("Droid Sans Mono"); // default
     fonts.append("FreeMono");        // mono serif
@@ -973,8 +983,9 @@ bool SubtitleScreen::Initialise708Fonts(
             count++;
         }
     }
+    initialised = count > 0;
     VERBOSE(VB_PLAYBACK, LOC + QString("Loaded %1 CEA-708 fonts").arg(count));
-    return true;
+    return initialised;
 }
 
 MythFontProperties* SubtitleScreen::Get708Font(CC708CharacterAttribute attr)
diff -Naurp mythtv-0.24.orig/libs/libmythtv/teletextdecoder.cpp mythtv-0.24.fixes/libs/libmythtv/teletextdecoder.cpp
--- mythtv-0.24.orig/libs/libmythtv/teletextdecoder.cpp	2010-11-07 23:31:54.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythtv/teletextdecoder.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -31,14 +31,10 @@ using namespace std;
 
 #include "osd.h"
 #include "teletextdecoder.h"
+#include "teletextreader.h"
 #include "vbilut.h"
-#include "mythplayer.h"
 #include "mythverbose.h"
 
-/******************************************************************/
-//Decoder section
-//
-
 /** \fn TeletextDecoder::Decode(const unsigned char*, int)
  *  \brief Decodes teletext data
  *
@@ -50,24 +46,8 @@ void TeletextDecoder::Decode(const unsig
     int err = 0, latin1 = -1, zahl1, pagenum, subpagenum, lang, flags;
     uint magazine, packet, header;
 
-    if (!m_player)
-        return;
-
-    m_player->LockOSD();
-
-    if (!m_teletextviewer && m_player)
-    {
-        m_player->UnlockOSD();
-        m_player->SetupTeletextViewer();
+    if (!m_teletext_reader)
         return;
-    }
-
-    if (!m_teletextviewer)
-    {
-        VERBOSE(VB_VBI, "TeletextDecoder: No Teletext Viewer defined!");
-        m_player->UnlockOSD();
-        return;
-    }
 
     m_decodertype = vbimode;
 
@@ -77,10 +57,7 @@ void TeletextDecoder::Decode(const unsig
             header = hamm16(buf, &err);
 
             if (err & 0xf000)
-            {
-                m_player->UnlockOSD();
                 return; // error in data header
-            }
 
             magazine = header & 7;
             packet = (header >> 3) & 0x1f;
@@ -113,16 +90,12 @@ void TeletextDecoder::Decode(const unsig
                 packet += 16;
 
             if (err == 1)
-            {
-                m_player->UnlockOSD();
                 return;  // error in data header
-            }
 
             buf += 2;
             break;
 
         default:
-            m_player->UnlockOSD();
             return; // error in vbimode
     }
 
@@ -138,10 +111,7 @@ void TeletextDecoder::Decode(const unsig
                     b3 = hamm16(buf+4, &err);// subpage number + flags
                     b4 = hamm16(buf+6, &err);// language code + more flags
                     if (err & 0xf000)
-                    {
-                        m_player->UnlockOSD();
                         return;
-                    }
 
                     break;
 
@@ -152,22 +122,14 @@ void TeletextDecoder::Decode(const unsig
                     b3 = hamm84(buf+5, &err)*16+hamm84(buf+4, &err);
                     b4 = hamm84(buf+7, &err)*16+hamm84(buf+6, &err);
                     if (err == 1)
-                    {
-                        m_player->UnlockOSD();
                         return;
-                    }
 
                     break;
 
                 default:
-                    m_player->UnlockOSD();
                     return; // error in vbimode
             }
 
-            //VERBOSE(VB_VBI, QString("Page Header found: "
-            //                        "Magazine %1, Page Number %2")
-            //        .arg(magazine).arg(b1));
-
             subpagenum= (b2 + b3 * 256) & 0x3f7f;
             pagenum = (magazine?:8)*256 + b1;
 
@@ -175,15 +137,14 @@ void TeletextDecoder::Decode(const unsig
             flags = b4 & 0x1F;
             flags |= b3 & 0xC0;
             flags |= (b2 & 0x80) >> 2;
-            m_teletextviewer->AddPageHeader(pagenum, subpagenum, buf,
-                                            vbimode, lang, flags);
+            m_teletext_reader->AddPageHeader(pagenum, subpagenum, buf,
+                                             vbimode, lang, flags);
 
             break;
 
         default: // Page Data
-            m_teletextviewer->AddTeletextData((magazine?:8), packet,
-                                              buf, vbimode);
+            m_teletext_reader->AddTeletextData((magazine?:8), packet,
+                                               buf, vbimode);
             break;
     }
-    m_player->UnlockOSD();
 }
diff -Naurp mythtv-0.24.orig/libs/libmythtv/teletextdecoder.h mythtv-0.24.fixes/libs/libmythtv/teletextdecoder.h
--- mythtv-0.24.orig/libs/libmythtv/teletextdecoder.h	2010-08-16 01:10:18.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/teletextdecoder.h	2011-03-24 22:18:50.000000000 -0400
@@ -3,52 +3,20 @@
 
 #include <stdint.h>
 
-class TeletextViewer
-{
-  public:
-    TeletextViewer() { }
-    virtual ~TeletextViewer() { }
-
-    virtual void KeyPress(uint key) { (void) key; }
-    virtual void SetPage(int page, int subpage) { (void) page; (void) subpage; }
-    virtual void SetDisplaying(bool displaying) { (void) displaying; }
-
-    virtual void Reset(void) = 0;
-    virtual void AddPageHeader(int page,           int subpage,
-                               const uint8_t *buf, int vbimode,
-                               int lang,           int flags) = 0;
-    virtual void AddTeletextData(int magazine, int row,
-                                 const uint8_t* buf, int vbimode) = 0;
-};
-
-class MythPlayer;
+class TeletextReader;
 
 class TeletextDecoder
 {
   public:
-    TeletextDecoder(MythPlayer *player)
-      : m_player(player), m_teletextviewer(NULL), m_decodertype(-1) {}
+    TeletextDecoder(TeletextReader *reader)
+      : m_teletext_reader(reader), m_decodertype(-1) {}
     virtual ~TeletextDecoder() {}
 
-    /// Sets the TeletextViewer which will get the text from this decoder.
-    void SetViewer(TeletextViewer *viewer)
-        { m_teletextviewer = viewer; }
-
-    /**
-     *  \brief Returns the actual decoder type (DVB,IVTV,DVB_SUBTITLE...)
-     *
-     *   This is used for the decision in NuppelVideoPlayer
-     *   to this TeletextDecoder or the caption only decoder.
-     */
-    int GetDecoderType(void) const
-        { return m_decodertype; }
-
+    int  GetDecoderType(void) const { return m_decodertype; }
     void Decode(const unsigned char *buf, int vbimode);
 
   private:
-
-    MythPlayer     *m_player;
-    TeletextViewer *m_teletextviewer;
+    TeletextReader *m_teletext_reader;
     int             m_decodertype;
 };
 
diff -Naurp mythtv-0.24.orig/libs/libmythtv/teletextreader.cpp mythtv-0.24.fixes/libs/libmythtv/teletextreader.cpp
--- mythtv-0.24.orig/libs/libmythtv/teletextreader.cpp	1969-12-31 19:00:00.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythtv/teletextreader.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -0,0 +1,609 @@
+#include "teletextreader.h"
+
+#include <string.h>
+#include "vbilut.h"
+
+#define MAGAZINE(page) (page / 256)
+
+TeletextReader::TeletextReader()
+  : m_curpage(0x100),           m_cursubpage(-1),
+    m_curpage_showheader(true), m_curpage_issubtitle(false),
+    m_transparent(false),       m_revealHidden(false),
+    m_header_changed(false),    m_page_changed(false),
+    m_fetchpage(0),             m_fetchsubpage(0)
+{
+    memset(m_pageinput, 0, sizeof(m_pageinput));
+    memset(m_header,    0, sizeof(m_header));
+    for (int i = 0; i < 256; i++)
+    {
+        m_bitswap[i] = 0;
+        for (int bit = 0; bit < 8; bit++)
+            if (i & (1 << bit))
+                m_bitswap[i] |= (1 << (7-bit));
+    }
+    Reset();
+}
+
+TeletextReader::~TeletextReader()
+{
+}
+
+void TeletextReader::KeyPress(unsigned int key)
+{
+    int newPage        = m_curpage;
+    int newSubPage     = m_cursubpage;
+    bool numeric_input = false;
+
+    TeletextSubPage *curpage = FindSubPage(m_curpage, m_cursubpage);
+    TeletextPage *page;
+
+    switch (key)
+    {
+        case TTKey::k0 ... TTKey::k9:
+            numeric_input = true;
+            m_curpage_showheader = true;
+            if (m_pageinput[0] == ' ')
+                m_pageinput[0] = '0' + static_cast<int> (key);
+            else if (m_pageinput[1] == ' ')
+                m_pageinput[1] = '0' + static_cast<int> (key);
+            else if (m_pageinput[2] == ' ')
+            {
+                m_pageinput[2] = '0' + static_cast<int> (key);
+                newPage = ((m_pageinput[0] - '0') * 256) +
+                    ((m_pageinput[1] - '0') * 16) +
+                    (m_pageinput[2] - '0');
+                newSubPage = -1;
+            }
+            else
+            {
+                m_pageinput[0] = '0' + static_cast<int> (key);
+                m_pageinput[1] = ' ';
+                m_pageinput[2] = ' ';
+            }
+
+            PageUpdated(m_curpage, m_cursubpage);
+            break;
+
+        case TTKey::kNextPage:
+        {
+            TeletextPage *ttpage = FindPage(m_curpage, 1);
+            if (ttpage)
+                newPage = ttpage->pagenum;
+            newSubPage = -1;
+            m_curpage_showheader = true;
+            break;
+        }
+
+        case TTKey::kPrevPage:
+        {
+            TeletextPage *ttpage = FindPage(m_curpage, -1);
+            if (ttpage)
+                newPage = ttpage->pagenum;
+            newSubPage = -1;
+            m_curpage_showheader = true;
+            break;
+        }
+
+        case TTKey::kNextSubPage:
+        {
+            TeletextSubPage *ttpage = FindSubPage(m_curpage, m_cursubpage, 1);
+            if (ttpage)
+                newSubPage = ttpage->subpagenum;
+            m_curpage_showheader = true;
+            break;
+        }
+
+        case TTKey::kPrevSubPage:
+        {
+            TeletextSubPage *ttpage = FindSubPage(m_curpage, m_cursubpage, -1);
+            if (ttpage)
+                newSubPage = ttpage->subpagenum;
+            m_curpage_showheader = true;
+            break;
+        }
+
+        case TTKey::kHold:
+            break;
+
+        case TTKey::kTransparent:
+            m_transparent = !m_transparent;
+            PageUpdated(m_curpage, m_cursubpage);
+            break;
+
+        case TTKey::kRevealHidden:
+            m_revealHidden = !m_revealHidden;
+            PageUpdated(m_curpage, m_cursubpage);
+            break;
+
+        case TTKey::kFlofRed:
+        {
+            if (!curpage)
+                return;
+
+            if ((page = FindPage(curpage->floflink[0])) != NULL)
+            {
+                newPage = page->pagenum;
+                newSubPage = -1;
+                m_curpage_showheader = true;
+            }
+            break;
+        }
+
+        case TTKey::kFlofGreen:
+        {
+            if (!curpage)
+                return;
+
+            if ((page = FindPage(curpage->floflink[1])) != NULL)
+            {
+                newPage = page->pagenum;
+                newSubPage = -1;
+                m_curpage_showheader = true;
+            }
+            break;
+        }
+
+        case TTKey::kFlofYellow:
+        {
+            if (!curpage)
+                return;
+
+            if ((page = FindPage(curpage->floflink[2])) != NULL)
+            {
+                newPage = page->pagenum;
+                newSubPage = -1;
+                m_curpage_showheader = true;
+            }
+            break;
+        }
+
+        case TTKey::kFlofBlue:
+        {
+            if (!curpage)
+                return;
+
+            if ((page = FindPage(curpage->floflink[3])) != NULL)
+            {
+                newPage = page->pagenum;
+                newSubPage = -1;
+                m_curpage_showheader = true;
+            }
+            break;
+        }
+
+        case TTKey::kFlofWhite:
+        {
+            if (!curpage)
+                return;
+
+            if ((page = FindPage(curpage->floflink[4])) != NULL)
+            {
+                newPage = page->pagenum;
+                newSubPage = -1;
+                m_curpage_showheader = true;
+            }
+            break;
+        }
+    }
+
+    if (newPage < 0x100)
+        newPage = 0x100;
+    if (newPage > 0x899)
+        newPage = 0x899;
+
+    if (!numeric_input)
+    {
+        m_pageinput[0] = (newPage / 256) + '0';
+        m_pageinput[1] = ((newPage % 256) / 16) + '0';
+        m_pageinput[2] = (newPage % 16) + '0';
+    }
+
+    if (newPage != m_curpage || newSubPage != m_cursubpage)
+    {
+        m_curpage = newPage;
+        m_cursubpage = newSubPage;
+        m_revealHidden = false;
+        PageUpdated(m_curpage, m_cursubpage);
+    }
+}
+
+QString TeletextReader::GetPage(void)
+{
+    QString str = "";
+    int mag = MAGAZINE(m_curpage);
+    if (mag > 8 || mag < 1)
+        return str;
+
+    int count = 1, selected = 0;
+    const TeletextPage *page = FindPage(m_curpage);
+    if (page)
+    {
+        m_magazines[mag - 1].lock.lock();
+        int_to_subpage_t::const_iterator subpageIter;
+        subpageIter = page->subpages.begin();
+        while (subpageIter != page->subpages.end())
+        {
+            const TeletextSubPage *subpage = &subpageIter->second;
+
+            if (subpage->subpagenum == m_cursubpage)
+            {
+                selected = count;
+                str += "*";
+            }
+            else
+                str += " ";
+
+            str += QString().sprintf("%02X", subpage->subpagenum);
+
+            ++subpageIter;
+            ++count;
+        }
+        m_magazines[mag - 1].lock.unlock();
+    }
+
+    if (str.isEmpty())
+        return str;
+
+    // if there are less than 9 subpages fill the empty slots with spaces
+    if (count < 10)
+    {
+        QString spaces;
+        spaces.fill(' ', 27 - str.length());
+        str = "  <" + str + spaces + " > ";
+    }
+    else
+    {
+        // try to centralize the selected sub page in the list
+        int startPos = selected - 5;
+        if (startPos < 0)
+            startPos = 0;
+        if (startPos + 9 >= count)
+            startPos = count - 10;
+
+        str = "  <" + str.mid(startPos * 3, 27) + " > ";
+    }
+    return str;
+}
+
+void TeletextReader::SetPage(int page, int subpage)
+{
+    if (page < 0x100 || page > 0x899)
+        return;
+
+    m_pageinput[0] = (page / 256) + '0';
+    m_pageinput[1] = ((page % 256) / 16) + '0';
+    m_pageinput[2] = (page % 16) + '0';
+
+    m_curpage = page;
+    m_cursubpage = subpage;
+    PageUpdated(m_curpage, m_cursubpage);
+}
+
+void TeletextReader::Reset(void)
+{
+    for (uint mag = 0; mag < 8; mag++)
+    {
+        QMutexLocker lock(&m_magazines[mag].lock);
+
+        // clear all sub pages in page
+        int_to_page_t::iterator iter;
+        iter = m_magazines[mag].pages.begin();
+        while (iter != m_magazines[mag].pages.end())
+        {
+            TeletextPage *page = &iter->second;
+            page->subpages.clear();
+            ++iter;
+        }
+
+        // clear pages
+        m_magazines[mag].pages.clear();
+        m_magazines[mag].current_page = 0;
+        m_magazines[mag].current_subpage = 0;
+        m_magazines[mag].loadingpage.active = false;
+    }
+    memset(m_header, ' ', 40);
+
+    m_curpage    = 0x100;
+    m_cursubpage = -1;
+    m_curpage_showheader = true;
+
+    m_pageinput[0] = '1';
+    m_pageinput[1] = '0';
+    m_pageinput[2] = '0';
+}
+
+void TeletextReader::AddPageHeader(int page, int subpage, const uint8_t *buf,
+                                   int vbimode, int lang, int flags)
+{
+    int magazine = MAGAZINE(page);
+    if (magazine < 1 || magazine > 8)
+        return;
+    int lastPage = m_magazines[magazine - 1].current_page;
+    int lastSubPage = m_magazines[magazine - 1].current_subpage;
+
+    // update the last fetched page if the magazine is the same
+    // and the page no. is different
+
+    if ((page != lastPage || subpage != lastSubPage) &&
+        m_magazines[magazine - 1].loadingpage.active)
+    {
+        TeletextSubPage *ttpage = FindSubPage(lastPage, lastSubPage);
+        if (!ttpage)
+        {
+            ttpage = &(m_magazines[magazine - 1]
+                       .pages[lastPage].subpages[lastSubPage]);
+            m_magazines[magazine - 1].pages[lastPage].pagenum = lastPage;
+            ttpage->subpagenum = lastSubPage;
+        }
+
+        memcpy(ttpage, &m_magazines[magazine - 1].loadingpage,
+               sizeof(TeletextSubPage));
+
+        m_magazines[magazine - 1].loadingpage.active = false;
+
+        PageUpdated(lastPage, lastSubPage);
+    }
+
+    m_fetchpage = page;
+    m_fetchsubpage = subpage;
+
+    TeletextSubPage *ttpage = &m_magazines[magazine - 1].loadingpage;
+
+    m_magazines[magazine - 1].current_page = page;
+    m_magazines[magazine - 1].current_subpage = subpage;
+
+    memset(ttpage->data, ' ', sizeof(ttpage->data));
+
+    ttpage->active = true;
+    ttpage->subpagenum = subpage;
+
+    for (uint i = 0; i < 6; i++)
+        ttpage->floflink[i] = 0;
+
+    ttpage->lang = lang;
+    ttpage->flags = flags;
+    ttpage->flof = 0;
+
+    ttpage->subtitle = (vbimode == VBI_DVB_SUBTITLE);
+
+    memset(ttpage->data[0], ' ', 8 * sizeof(uint8_t));
+
+    if (vbimode == VBI_DVB || vbimode == VBI_DVB_SUBTITLE)
+    {
+        for (uint j = 8; j < 40; j++)
+            ttpage->data[0][j] = m_bitswap[buf[j]];
+    }
+    else
+    {
+        memcpy(ttpage->data[0]+0, buf, 40);
+    }
+
+    if ( !(ttpage->flags & TP_INTERRUPTED_SEQ))
+    {
+        memcpy(m_header, ttpage->data[0], 40);
+        HeaderUpdated(ttpage->data[0],ttpage->lang);
+    }
+}
+
+void TeletextReader::AddTeletextData(int magazine, int row,
+                                     const uint8_t* buf, int vbimode)
+{
+    int b1, b2, b3, err = 0;
+
+    if (magazine < 1 || magazine > 8)
+        return;
+
+    int currentpage = m_magazines[magazine - 1].current_page;
+    if (!currentpage)
+        return;
+
+    TeletextSubPage *ttpage = &m_magazines[magazine - 1].loadingpage;
+
+    switch (row)
+    {
+        case 1 ... 24: // Page Data
+            if (vbimode == VBI_DVB || vbimode == VBI_DVB_SUBTITLE)
+            {
+                for (uint j = 0; j < 40; j++)
+                    ttpage->data[row][j] = m_bitswap[buf[j]];
+            }
+            else
+            {
+                memcpy(ttpage->data[row], buf, 40);
+            }
+            break;
+        case 26:
+            /* XXX TODO: Level 1.5, 2.5, 3.5
+            *      Character location & override
+            * Level 2.5, 3.5
+            *      Modifying display attributes
+            * All levels
+            *      VCR Programming
+            * See 12.3
+            */
+            break;
+        case 27: // FLOF data (FastText)
+            switch (vbimode)
+            {
+                case VBI_IVTV:
+                    b1 = hamm8(buf, &err);
+                    b2 = hamm8(buf + 37, &err);
+                    if (err & 0xF000)
+                        return;
+                     break;
+                case VBI_DVB:
+                case VBI_DVB_SUBTITLE:
+                    b1 = hamm84(buf, &err);
+                    b2 = hamm84(buf + 37, &err);
+                    if (err == 1)
+                        return;
+                    break;
+                default:
+                    return;
+            }
+            if (b1 != 0 || not(b2 & 8))
+                return;
+
+            for (int i = 0; i < 6; ++i)
+            {
+                err = 0;
+                switch (vbimode)
+                {
+                    case VBI_IVTV:
+                        b1 = hamm16(buf+1+6*i, &err);
+                        b2 = hamm16(buf+3+6*i, &err);
+                        b3 = hamm16(buf+5+6*i, &err);
+                        if (err & 0xF000)
+                            return;
+                        break;
+                    case VBI_DVB:
+                    case VBI_DVB_SUBTITLE:
+                        b1 = hamm84(buf+2+6*i, &err) * 16 +
+                        hamm84(buf+1+6*i, &err);
+                        b2 = hamm84(buf+4+6*i, &err) * 16 +
+                        hamm84(buf+3+6*i, &err);
+                        b3 = hamm84(buf+6+6*i, &err) * 16 +
+                        hamm84(buf+5+6*i, &err);
+                        if (err == 1)
+                            return;
+                        break;
+                    default:
+                        return;
+                }
+
+                int x = (b2 >> 7) | ((b3 >> 5) & 0x06);
+                ttpage->floflink[i] = ((magazine ^ x) ?: 8) * 256 + b1;
+                ttpage->flof = 1;
+            }
+            break;
+
+        case 31: // private streams
+            break;
+
+        default: /// other packet codes...
+            break;
+    }
+}
+
+void TeletextReader::PageUpdated(int page, int subpage)
+{
+    if (page != m_curpage)
+        return;
+    if (subpage != m_cursubpage && m_cursubpage != -1)
+        return;
+    m_page_changed = true;
+}
+
+void TeletextReader::HeaderUpdated(uint8_t * page, int lang)
+{
+    (void)lang;
+
+    if (page == NULL)
+        return;
+
+    if (m_curpage_showheader == false)
+        return;
+
+    m_header_changed = true;
+}
+
+const TeletextPage *TeletextReader::FindPageInternal(
+    int page, int direction) const
+{
+    int mag = MAGAZINE(page);
+
+    if (mag > 8 || mag < 1)
+        return NULL;
+
+    QMutexLocker lock(&m_magazines[mag - 1].lock);
+
+    int_to_page_t::const_iterator pageIter;
+    pageIter = m_magazines[mag - 1].pages.find(page);
+    if (pageIter == m_magazines[mag - 1].pages.end())
+        return NULL;
+
+    const TeletextPage *res = &pageIter->second;
+    if (direction == -1)
+    {
+        --pageIter;
+        if (pageIter == m_magazines[mag - 1].pages.end())
+        {
+            int_to_page_t::const_reverse_iterator iter;
+            iter = m_magazines[mag - 1].pages.rbegin();
+            res = &iter->second;
+        }
+        else
+            res = &pageIter->second;
+    }
+
+    if (direction == 1)
+    {
+        ++pageIter;
+        if (pageIter == m_magazines[mag - 1].pages.end())
+        {
+            pageIter = m_magazines[mag - 1].pages.begin();
+            res = &pageIter->second;
+        }
+        else
+            res = &pageIter->second;
+    }
+
+    return res;
+}
+
+const TeletextSubPage *TeletextReader::FindSubPageInternal(
+                                int page, int subpage, int direction) const
+{
+    int mag = MAGAZINE(page);
+
+    if (mag > 8 || mag < 1)
+        return NULL;
+
+    QMutexLocker lock(&m_magazines[mag - 1].lock);
+
+    int_to_page_t::const_iterator pageIter;
+    pageIter = m_magazines[mag - 1].pages.find(page);
+    if (pageIter == m_magazines[mag - 1].pages.end())
+        return NULL;
+
+    const TeletextPage *ttpage = &(pageIter->second);
+    int_to_subpage_t::const_iterator subpageIter =
+        ttpage->subpages.begin();
+
+    // try to find the subpage given, or first if subpage == -1
+    if (subpage != -1)
+        subpageIter = ttpage->subpages.find(subpage);
+
+    if (subpageIter == ttpage->subpages.end())
+        return NULL;
+
+    if (subpage == -1)
+        return &(subpageIter->second);
+
+    const TeletextSubPage *res = &(subpageIter->second);
+    if (direction == -1)
+    {
+        --subpageIter;
+        if (subpageIter == ttpage->subpages.end())
+        {
+            int_to_subpage_t::const_reverse_iterator iter =
+                ttpage->subpages.rbegin();
+            res = &(iter->second);
+        }
+        else
+        {
+            res = &(subpageIter->second);
+        }
+    }
+
+    if (direction == 1)
+    {
+        ++subpageIter;
+        if (subpageIter == ttpage->subpages.end())
+            subpageIter = ttpage->subpages.begin();
+
+        res = &(subpageIter->second);
+    }
+
+    return res;
+}
diff -Naurp mythtv-0.24.orig/libs/libmythtv/teletextreader.h mythtv-0.24.fixes/libs/libmythtv/teletextreader.h
--- mythtv-0.24.orig/libs/libmythtv/teletextreader.h	1969-12-31 19:00:00.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythtv/teletextreader.h	2011-03-24 22:18:50.000000000 -0400
@@ -0,0 +1,162 @@
+#ifndef TELETEXTREADER_H
+#define TELETEXTREADER_H
+
+#include <stdint.h>
+#include <map>
+
+#include <QString>
+#include <QMutex>
+
+using namespace std;
+
+typedef enum
+{
+    kTTColorBlack       = 0,
+    kTTColorRed         = 1,
+    kTTColorGreen       = 2,
+    kTTColorYellow      = 3,
+    kTTColorBlue        = 4,
+    kTTColorMagenta     = 5,
+    kTTColorCyan        = 6,
+    kTTColorWhite       = 7,
+    kTTColorTransparent = 8,
+} TTColor;
+
+class TTKey
+{
+  public:
+    static const uint k0            = 0;
+    static const uint k1            = 1;
+    static const uint k2            = 2;
+    static const uint k3            = 3;
+    static const uint k4            = 4;
+    static const uint k5            = 5;
+    static const uint k6            = 6;
+    static const uint k7            = 7;
+    static const uint k8            = 8;
+    static const uint k9            = 9;
+    static const uint kNextPage     = 10;
+    static const uint kPrevPage     = 11;
+    static const uint kNextSubPage  = 12;
+    static const uint kPrevSubPage  = 13;
+    static const uint kHold         = 14;
+    static const uint kTransparent  = 15;
+    static const uint kFlofRed      = 16;
+    static const uint kFlofGreen    = 17;
+    static const uint kFlofYellow   = 18;
+    static const uint kFlofBlue     = 19;
+    static const uint kFlofWhite    = 20;
+    static const uint kRevealHidden = 21;
+};
+
+#define TP_SUPPRESS_HEADER  0x01
+#define TP_UPDATE_INDICATOR 0x02
+#define TP_INTERRUPTED_SEQ  0x04
+#define TP_INHIBIT_DISPLAY  0x08
+#define TP_MAGAZINE_SERIAL  0x10
+#define TP_ERASE_PAGE       0x20
+#define TP_NEWSFLASH        0x40
+#define TP_SUBTITLE         0x80
+
+class TeletextSubPage
+{
+  public:
+    int pagenum;              ///< the wanted page
+    int subpagenum;           ///< the wanted subpage
+    int lang;                 ///< language code
+    int flags;                ///< misc flags
+    uint8_t data[25][40];     ///< page data
+    int flof;                 ///< page has FastText links
+    int floflink[6];          ///< FastText links (FLOF)
+    bool subtitle;            ///< page is subtitle page
+    bool active;              ///< data has arrived since page last cleared
+};
+
+typedef map<int, TeletextSubPage> int_to_subpage_t;
+
+class TeletextPage
+{
+  public:
+    int               pagenum;
+    int               current_subpage;
+    int_to_subpage_t  subpages;
+};
+typedef map<int, TeletextPage> int_to_page_t;
+
+class TeletextMagazine
+{
+  public:
+    mutable QMutex    lock;
+    int               current_page;
+    int               current_subpage;
+    TeletextSubPage   loadingpage;
+    int_to_page_t     pages;
+};
+
+class TeletextReader
+{
+  public:
+    TeletextReader();
+   ~TeletextReader();
+
+    // OSD/Player methods
+    void Reset(void);
+    void KeyPress(uint key);
+    QString GetPage(void);
+    void SetPage(int page, int subpage);
+    void SetSubPage(int subpage)        { m_cursubpage = subpage;      }
+    bool PageChanged(void)              { return m_page_changed;       }
+    void SetPageChanged(bool changed)   { m_page_changed = changed;    }
+    void SetShowHeader(bool show)       { m_curpage_showheader = show; }
+    void SetHeaderChanged(bool changed) { m_header_changed = changed;  }
+    bool IsSubtitle(void)               { return m_curpage_issubtitle; }
+    void SetIsSubtitle(bool sub)        { m_curpage_issubtitle = sub;  }
+    bool IsTransparent(void)            { return m_transparent;        }
+    bool RevealHidden(void)             { return m_revealHidden;       }
+    int  GetPageInput(uint num)         { return m_pageinput[num];     }
+    TeletextSubPage* FindSubPage(void)
+        { return FindSubPage(m_curpage, m_cursubpage); }
+    uint8_t* GetHeader(void)            { return m_header;             }
+
+    // Decoder methods
+    void AddPageHeader(int page, int subpage, const uint8_t *buf,
+                       int vbimode, int lang, int flags);
+    void AddTeletextData(int magazine, int row,
+                         const uint8_t* buf, int vbimode);
+
+
+  private:
+    void NewsFlash(void) {};
+    void PageUpdated(int page, int subpage);
+    void HeaderUpdated(uint8_t *page, int lang);
+
+    const TeletextSubPage *FindSubPage(int page, int subpage, int dir=0) const
+        { return FindSubPageInternal(page, subpage, dir); }
+    TeletextSubPage       *FindSubPage(int page, int subpage, int dir = 0)
+        { return (TeletextSubPage*) FindSubPageInternal(page, subpage, dir); }
+
+    const TeletextPage    *FindPage(int page, int dir = 0) const
+        { return (TeletextPage*) FindPageInternal(page, dir); }
+    TeletextPage          *FindPage(int page, int dir = 0)
+        { return (TeletextPage*) FindPageInternal(page, dir); }
+
+    const TeletextSubPage *FindSubPageInternal(int,int,int) const;
+    const TeletextPage    *FindPageInternal(int,int) const;
+
+    mutable int      m_curpage;
+    mutable int      m_cursubpage;
+    mutable bool     m_curpage_showheader;
+    mutable bool     m_curpage_issubtitle;
+    int              m_pageinput[3];
+    bool             m_transparent;
+    bool             m_revealHidden;
+    uint8_t          m_header[40];
+    mutable bool     m_header_changed;
+    mutable bool     m_page_changed;
+    TeletextMagazine m_magazines[8];
+    unsigned char    m_bitswap[256];
+    int              m_fetchpage;
+    int              m_fetchsubpage;
+};
+
+#endif // TELETEXTREADER_H
diff -Naurp mythtv-0.24.orig/libs/libmythtv/teletextscreen.cpp mythtv-0.24.fixes/libs/libmythtv/teletextscreen.cpp
--- mythtv-0.24.orig/libs/libmythtv/teletextscreen.cpp	2010-10-19 04:51:15.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/teletextscreen.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -11,8 +11,7 @@
 #include "mythpainter.h"
 #include "teletextscreen.h"
 
-#define LOC QString("Teletext: ")
-#define MAGAZINE(page) (page / 256)
+#define LOC QString("TeletextScreen: ")
 
 const QColor TeletextScreen::kColorBlack      = QColor(  0,  0,  0,255);
 const QColor TeletextScreen::kColorRed        = QColor(255,  0,  0,255);
@@ -42,27 +41,13 @@ static char cvt_char(char ch, int lang)
 TeletextScreen::TeletextScreen(MythPlayer *player, const char * name,
                                int fontStretch) :
     MythScreenType((MythScreenType*)NULL, name),
-    m_player(player),           m_safeArea(QRect()),
-    m_colSize(10),              m_rowSize(10),
-    m_fetchpage(0),             m_fetchsubpage(0),
+    m_player(player),           m_teletextReader(NULL),
+    m_safeArea(QRect()),
+    m_colWidth(10),             m_rowHeight(10),
     m_bgColor(QColor(kColorBlack)),
-    m_curpage(0x100),           m_cursubpage(-1),
-    m_curpage_showheader(true), m_curpage_issubtitle(false),
-    m_transparent(false),       m_revealHidden(false),
-    m_displaying(false),        m_header_changed(false),
-    m_page_changed(false),      m_fontStretch(fontStretch)
-{
-    memset(m_pageinput, 0, sizeof(m_pageinput));
-    memset(m_header,    0, sizeof(m_header));
-    for (int i = 0; i < 256; i++)
-    {
-        m_bitswap[i] = 0;
-        for (int bit = 0; bit < 8; bit++)
-            if (i & (1 << bit))
-                m_bitswap[i] |= (1 << (7-bit));
-    }
-
-    Reset();
+    m_displaying(false),        m_fontStretch(fontStretch),
+    m_fontHeight(10)
+{
 }
 
 TeletextScreen::~TeletextScreen()
@@ -72,7 +57,9 @@ TeletextScreen::~TeletextScreen()
 
 bool TeletextScreen::Create(void)
 {
-    return m_player;
+    if (m_player)
+        m_teletextReader = m_player->GetTeletextReader();
+    return m_player && m_teletextReader;
 }
 
 void TeletextScreen::CleanUp(void)
@@ -81,15 +68,16 @@ void TeletextScreen::CleanUp(void)
     for (int i = 0; i < m_rowImages.size(); i++)
         delete m_rowImages.value(i);
     m_rowImages.clear();
+    SetRedraw();
 }
 
 QImage* TeletextScreen::GetRowImage(int row, QRect &rect)
 {
     int y   = row & ~1;
-    rect.translate(0, -(y * m_rowSize));
+    rect.translate(0, -(y * m_rowHeight));
     if (!m_rowImages.contains(y))
     {
-        QImage* img = new QImage(m_safeArea.width(), m_rowSize * 2,
+        QImage* img = new QImage(m_safeArea.width(), m_rowHeight * 2,
                                  QImage::Format_ARGB32);
         if (img)
         {
@@ -126,8 +114,8 @@ void TeletextScreen::OptimiseDisplayedAr
         if (uiimage)
         {
             uiimage->SetImage(image);
-            uiimage->SetArea(MythRect(0, row * m_rowSize,
-                                      m_safeArea.width(), m_rowSize * 2));
+            uiimage->SetArea(MythRect(0, row * m_rowHeight,
+                                      m_safeArea.width(), m_rowHeight * 2));
         }
     }
 
@@ -159,44 +147,64 @@ void TeletextScreen::OptimiseDisplayedAr
 
 void TeletextScreen::Pulse(void)
 {
-    if (!InitialiseFont(m_fontStretch) || !m_displaying)
+    if (!InitialiseFont() || !m_displaying)
         return;
 
     if (m_player && m_player->getVideoOutput())
     {
+        static const float kTextPadding = 0.96f;
         QRect oldsafe = m_safeArea;
         m_safeArea = m_player->getVideoOutput()->GetSafeRect();
+        m_colWidth = (int)((float)m_safeArea.width() / (float)kTeletextColumns);
+        m_rowHeight = (int)((float)m_safeArea.height() / (float)kTeletextRows);
+
         if (oldsafe != m_safeArea)
-            m_page_changed = true;
-        m_colSize = (int)((float)m_safeArea.width() / (float)kTeletextColumns);
-        m_rowSize = (int)((float)m_safeArea.height() / (float)kTeletextRows);
-        gTTFont->GetFace()->setPixelSize(m_safeArea.height() /
-                                        (kTeletextRows * 1.2));
+        {
+            m_teletextReader->SetPageChanged(true);
+
+            int max_width  = (int)((float)m_colWidth * kTextPadding);
+            m_fontHeight = (int)((float)m_rowHeight * kTextPadding);
+            if (max_width > (m_colWidth - 2))
+                max_width = m_colWidth -2;
+            if (m_fontHeight > (m_rowHeight - 2))
+                m_fontHeight = m_rowHeight - 2;
+            gTTFont->GetFace()->setPixelSize(m_fontHeight);
+
+            m_fontStretch = 200;
+            bool ok = false;
+            while (!ok && m_fontStretch > 50)
+            {
+                gTTFont->GetFace()->setStretch(m_fontStretch);
+                QFontMetrics font(*(gTTFont->GetFace()));
+                if (font.averageCharWidth() <= max_width || m_fontStretch < 50)
+                    ok = true;
+                else
+                    m_fontStretch -= 10;
+            }
+        }
     }
     else
     {
         return;
     }
 
-    if (!m_page_changed)
+    if (!m_teletextReader->PageChanged())
         return;
 
-    QMutexLocker locker(&m_lock);
-
     CleanUp();
 
-    const TeletextSubPage *ttpage = FindSubPage(m_curpage, m_cursubpage);
+    const TeletextSubPage *ttpage = m_teletextReader->FindSubPage();
 
     if (!ttpage)
     {
         // no page selected so show the header and a list of available pages
         DrawHeader(NULL, 0);
-        m_page_changed = false;
+        m_teletextReader->SetPageChanged(false);
         OptimiseDisplayedArea();
         return;
     }
 
-    m_cursubpage = ttpage->subpagenum;
+    m_teletextReader->SetSubPage(ttpage->subpagenum);
 
     int a = 0;
     if ((ttpage->subtitle) ||
@@ -204,223 +212,34 @@ void TeletextScreen::Pulse(void)
     {
         a = 1; // when showing subtitles we don't want to see the teletext
                // header line, so we skip that line...
-        m_curpage_showheader = false;
-        m_curpage_issubtitle = true;
+        m_teletextReader->SetShowHeader(false);
+        m_teletextReader->SetIsSubtitle(true);
     }
     else
     {
-        m_curpage_issubtitle = false;
-        m_curpage_showheader = true;
-        DrawHeader(m_header, ttpage->lang);
-
-        m_header_changed = false;
+        m_teletextReader->SetShowHeader(true);
+        m_teletextReader->SetIsSubtitle(false);
+        DrawHeader(m_teletextReader->GetHeader(), ttpage->lang);
+        m_teletextReader->SetHeaderChanged(false);
     }
 
     for (int y = kTeletextRows - a; y >= 2; y--)
         DrawLine(ttpage->data[y-1], y, ttpage->lang);
 
-    m_page_changed = false;
+    m_teletextReader->SetPageChanged(false);
     OptimiseDisplayedArea();
 }
 
 void TeletextScreen::KeyPress(uint key)
 {
-    if (!m_displaying)
-        return;
-
-    QMutexLocker locker(&m_lock);
-
-    int newPage = m_curpage;
-    int newSubPage = m_cursubpage;
-    bool numeric_input = false;
-
-    TeletextSubPage *curpage = FindSubPage(m_curpage, m_cursubpage);
-    TeletextPage *page;
-
-    switch (key)
-    {
-        case TTKey::k0 ... TTKey::k9:
-            numeric_input = true;
-            m_curpage_showheader = true;
-            if (m_pageinput[0] == ' ')
-                m_pageinput[0] = '0' + static_cast<int> (key);
-            else if (m_pageinput[1] == ' ')
-                m_pageinput[1] = '0' + static_cast<int> (key);
-            else if (m_pageinput[2] == ' ')
-            {
-                m_pageinput[2] = '0' + static_cast<int> (key);
-                newPage = ((m_pageinput[0] - '0') * 256) +
-                    ((m_pageinput[1] - '0') * 16) +
-                    (m_pageinput[2] - '0');
-                newSubPage = -1;
-            }
-            else
-            {
-                m_pageinput[0] = '0' + static_cast<int> (key);
-                m_pageinput[1] = ' ';
-                m_pageinput[2] = ' ';
-            }
-
-            PageUpdated(m_curpage, m_cursubpage);
-            break;
-
-        case TTKey::kNextPage:
-        {
-            TeletextPage *ttpage = FindPage(m_curpage, 1);
-            if (ttpage)
-                newPage = ttpage->pagenum;
-            newSubPage = -1;
-            m_curpage_showheader = true;
-            break;
-        }
-
-        case TTKey::kPrevPage:
-        {
-            TeletextPage *ttpage = FindPage(m_curpage, -1);
-            if (ttpage)
-                newPage = ttpage->pagenum;
-            newSubPage = -1;
-            m_curpage_showheader = true;
-            break;
-        }
-
-        case TTKey::kNextSubPage:
-        {
-            TeletextSubPage *ttpage = FindSubPage(m_curpage, m_cursubpage, 1);
-            if (ttpage)
-                newSubPage = ttpage->subpagenum;
-            m_curpage_showheader = true;
-            break;
-        }
-
-        case TTKey::kPrevSubPage:
-        {
-            TeletextSubPage *ttpage = FindSubPage(m_curpage, m_cursubpage, -1);
-            if (ttpage)
-                newSubPage = ttpage->subpagenum;
-            m_curpage_showheader = true;
-            break;
-        }
-
-        case TTKey::kHold:
-            break;
-
-        case TTKey::kTransparent:
-            m_transparent = !m_transparent;
-            PageUpdated(m_curpage, m_cursubpage);
-            break;
-
-        case TTKey::kRevealHidden:
-            m_revealHidden = !m_revealHidden;
-            PageUpdated(m_curpage, m_cursubpage);
-            break;
-
-        case TTKey::kFlofRed:
-        {
-            if (!curpage)
-                return;
-
-            if ((page = FindPage(curpage->floflink[0])) != NULL)
-            {
-                newPage = page->pagenum;
-                newSubPage = -1;
-                m_curpage_showheader = true;
-            }
-            break;
-        }
-
-        case TTKey::kFlofGreen:
-        {
-            if (!curpage)
-                return;
-
-            if ((page = FindPage(curpage->floflink[1])) != NULL)
-            {
-                newPage = page->pagenum;
-                newSubPage = -1;
-                m_curpage_showheader = true;
-            }
-            break;
-        }
-
-        case TTKey::kFlofYellow:
-        {
-            if (!curpage)
-                return;
-
-            if ((page = FindPage(curpage->floflink[2])) != NULL)
-            {
-                newPage = page->pagenum;
-                newSubPage = -1;
-                m_curpage_showheader = true;
-            }
-            break;
-        }
-
-        case TTKey::kFlofBlue:
-        {
-            if (!curpage)
-                return;
-
-            if ((page = FindPage(curpage->floflink[3])) != NULL)
-            {
-                newPage = page->pagenum;
-                newSubPage = -1;
-                m_curpage_showheader = true;
-            }
-            break;
-        }
-
-        case TTKey::kFlofWhite:
-        {
-            if (!curpage)
-                return;
-
-            if ((page = FindPage(curpage->floflink[4])) != NULL)
-            {
-                newPage = page->pagenum;
-                newSubPage = -1;
-                m_curpage_showheader = true;
-            }
-            break;
-        }
-    }
-
-    if (newPage < 0x100)
-        newPage = 0x100;
-    if (newPage > 0x899)
-        newPage = 0x899;
-
-    if (!numeric_input)
-    {
-        m_pageinput[0] = (newPage / 256) + '0';
-        m_pageinput[1] = ((newPage % 256) / 16) + '0';
-        m_pageinput[2] = (newPage % 16) + '0';
-    }
-
-    if (newPage != m_curpage || newSubPage != m_cursubpage)
-    {
-        m_curpage = newPage;
-        m_cursubpage = newSubPage;
-        m_revealHidden = false;
-        PageUpdated(m_curpage, m_cursubpage);
-    }
+    if (m_teletextReader)
+        m_teletextReader->KeyPress(key);
 }
 
 void TeletextScreen::SetPage(int page, int subpage)
 {
-    QMutexLocker locker(&m_lock);
-
-    if (page < 0x100 || page > 0x899)
-        return;
-
-    m_pageinput[0] = (page / 256) + '0';
-    m_pageinput[1] = ((page % 256) / 16) + '0';
-    m_pageinput[2] = (page % 16) + '0';
-
-    m_curpage = page;
-    m_cursubpage = subpage;
-    PageUpdated(m_curpage, m_cursubpage);
+    if (m_teletextReader)
+        m_teletextReader->SetPage(page, subpage);
 }
 
 void TeletextScreen::SetDisplaying(bool display)
@@ -432,218 +251,8 @@ void TeletextScreen::SetDisplaying(bool 
 
 void TeletextScreen::Reset(void)
 {
-    QMutexLocker locker(&m_lock);
-
-    for (uint mag = 0; mag < 8; mag++)
-    {
-        QMutexLocker lock(&m_magazines[mag].lock);
-
-        // clear all sub pages in page
-        int_to_page_t::iterator iter;
-        iter = m_magazines[mag].pages.begin();
-        while (iter != m_magazines[mag].pages.end())
-        {
-            TeletextPage *page = &iter->second;
-            page->subpages.clear();
-            ++iter;
-        }
-
-        // clear pages
-        m_magazines[mag].pages.clear();
-        m_magazines[mag].current_page = 0;
-        m_magazines[mag].current_subpage = 0;
-        m_magazines[mag].loadingpage.active = false;
-    }
-    memset(m_header, ' ', 40);
-
-    m_curpage    = 0x100;
-    m_cursubpage = -1;
-    m_curpage_showheader = true;
-
-    m_pageinput[0] = '1';
-    m_pageinput[1] = '0';
-    m_pageinput[2] = '0';
-}
-
-void TeletextScreen::AddPageHeader(int page, int subpage,
-                                    const uint8_t * buf,
-                                    int vbimode, int lang, int flags)
-{
-    QMutexLocker locker(&m_lock);
-
-    int magazine = MAGAZINE(page);
-    if (magazine < 1 || magazine > 8)
-        return;
-    int lastPage = m_magazines[magazine - 1].current_page;
-    int lastSubPage = m_magazines[magazine - 1].current_subpage;
-
-    // update the last fetched page if the magazine is the same
-    // and the page no. is different
-
-    if ((page != lastPage || subpage != lastSubPage) &&
-        m_magazines[magazine - 1].loadingpage.active)
-    {
-        TeletextSubPage *ttpage = FindSubPage(lastPage, lastSubPage);
-        if (!ttpage)
-        {
-            ttpage = &(m_magazines[magazine - 1]
-                       .pages[lastPage].subpages[lastSubPage]);
-            m_magazines[magazine - 1].pages[lastPage].pagenum = lastPage;
-            ttpage->subpagenum = lastSubPage;
-        }
-
-        memcpy(ttpage, &m_magazines[magazine - 1].loadingpage,
-               sizeof(TeletextSubPage));
-
-        m_magazines[magazine - 1].loadingpage.active = false;
-
-        PageUpdated(lastPage, lastSubPage);
-    }
-
-    m_fetchpage = page;
-    m_fetchsubpage = subpage;
-
-    TeletextSubPage *ttpage = &m_magazines[magazine - 1].loadingpage;
-
-    m_magazines[magazine - 1].current_page = page;
-    m_magazines[magazine - 1].current_subpage = subpage;
-
-    memset(ttpage->data, ' ', sizeof(ttpage->data));
-
-    ttpage->active = true;
-    ttpage->subpagenum = subpage;
-
-    for (uint i = 0; i < 6; i++)
-        ttpage->floflink[i] = 0;
-
-    ttpage->lang = lang;
-    ttpage->flags = flags;
-    ttpage->flof = 0;
-
-    ttpage->subtitle = (vbimode == VBI_DVB_SUBTITLE);
-
-    memset(ttpage->data[0], ' ', 8 * sizeof(uint8_t));
-
-    if (vbimode == VBI_DVB || vbimode == VBI_DVB_SUBTITLE)
-    {
-        for (uint j = 8; j < 40; j++)
-            ttpage->data[0][j] = m_bitswap[buf[j]];
-    }
-    else
-    {
-        memcpy(ttpage->data[0]+0, buf, 40);
-    }
-
-    if ( !(ttpage->flags & TP_INTERRUPTED_SEQ))
-    {
-        memcpy(m_header, ttpage->data[0], 40);
-        HeaderUpdated(ttpage->data[0],ttpage->lang);
-    }
-}
-
-/**
- *  \brief Adds Teletext Data from TeletextDecoder
- */
-void TeletextScreen::AddTeletextData(int magazine, int row,
-                                      const uint8_t * buf, int vbimode)
-{
-    QMutexLocker locker(&m_lock);
-
-    int b1, b2, b3, err = 0;
-
-    if (magazine < 1 || magazine > 8)
-        return;
-
-    int currentpage = m_magazines[magazine - 1].current_page;
-    if (!currentpage)
-        return;
-
-    TeletextSubPage *ttpage = &m_magazines[magazine - 1].loadingpage;
-
-    switch (row)
-    {
-        case 1 ... 24: // Page Data
-            if (vbimode == VBI_DVB || vbimode == VBI_DVB_SUBTITLE)
-            {
-                for (uint j = 0; j < 40; j++)
-                    ttpage->data[row][j] = m_bitswap[buf[j]];
-            }
-            else
-            {
-                memcpy(ttpage->data[row], buf, 40);
-            }
-            break;
-        case 26:
-            /* XXX TODO: Level 1.5, 2.5, 3.5
-            *      Character location & override
-            * Level 2.5, 3.5
-            *      Modifying display attributes
-            * All levels
-            *      VCR Programming
-            * See 12.3
-            */
-            break;
-        case 27: // FLOF data (FastText)
-            switch (vbimode)
-            {
-                case VBI_IVTV:
-                    b1 = hamm8(buf, &err);
-                    b2 = hamm8(buf + 37, &err);
-                    if (err & 0xF000)
-                        return;
-                     break;
-                case VBI_DVB:
-                case VBI_DVB_SUBTITLE:
-                    b1 = hamm84(buf, &err);
-                    b2 = hamm84(buf + 37, &err);
-                    if (err == 1)
-                        return;
-                    break;
-                default:
-                    return;
-            }
-            if (b1 != 0 || not(b2 & 8))
-                return;
-
-            for (int i = 0; i < 6; ++i)
-            {
-                err = 0;
-                switch (vbimode)
-                {
-                    case VBI_IVTV:
-                        b1 = hamm16(buf+1+6*i, &err);
-                        b2 = hamm16(buf+3+6*i, &err);
-                        b3 = hamm16(buf+5+6*i, &err);
-                        if (err & 0xF000)
-                            return;
-                        break;
-                    case VBI_DVB:
-                    case VBI_DVB_SUBTITLE:
-                        b1 = hamm84(buf+2+6*i, &err) * 16 +
-                        hamm84(buf+1+6*i, &err);
-                        b2 = hamm84(buf+4+6*i, &err) * 16 +
-                        hamm84(buf+3+6*i, &err);
-                        b3 = hamm84(buf+6+6*i, &err) * 16 +
-                        hamm84(buf+5+6*i, &err);
-                        if (err == 1)
-                            return;
-                        break;
-                    default:
-                        return;
-                }
-
-                int x = (b2 >> 7) | ((b3 >> 5) & 0x06);
-                ttpage->floflink[i] = ((magazine ^ x) ?: 8) * 256 + b1;
-                ttpage->flof = 1;
-            }
-            break;
-
-        case 31: // private streams
-            break;
-
-        default: /// other packet codes...
-            break;
-    }
+    if (m_teletextReader)
+        m_teletextReader->Reset();
 }
 
 void TeletextScreen::DrawHeader(const uint8_t *page, int lang)
@@ -729,7 +338,7 @@ void TeletextScreen::DrawLine(const uint
     uint newfgcolor = kTTColorWhite;
     uint newbgcolor = kTTColorBlack;
 
-    if (m_curpage_issubtitle || m_transparent)
+    if (m_teletextReader->IsSubtitle() || m_teletextReader->IsTransparent())
     {
         bgcolor    = kTTColorTransparent;
         newbgcolor = kTTColorTransparent;
@@ -859,7 +468,7 @@ void TeletextScreen::DrawLine(const uint
                 ch = ' '; // BAD_CHAR;
                 break;
             default:
-                if (conceal && !m_revealHidden)
+                if (conceal && !m_teletextReader->RevealHidden())
                     ch = ' ';
                 break;
         }
@@ -867,8 +476,7 @@ void TeletextScreen::DrawLine(const uint
         // Hide FastText/FLOF menu characters if not available
         if (flof_link_count && (flof_link_count <= 6))
         {
-            const TeletextSubPage *ttpage =
-                FindSubPage(m_curpage, m_cursubpage);
+            const TeletextSubPage *ttpage = m_teletextReader->FindSubPage();
 
             if (ttpage)
             {
@@ -884,7 +492,7 @@ void TeletextScreen::DrawLine(const uint
         SetBackgroundColor(newbgcolor);
         if ((row != 0) || (x > 7))
         {
-            if (m_transparent)
+            if (m_teletextReader->IsTransparent())
                 SetBackgroundColor(kTTColorTransparent);
 
             DrawBackground(x, row);
@@ -912,18 +520,15 @@ void TeletextScreen::DrawCharacter(int x
         return;
 
     int row = y;
-    x *= m_colSize;
-    y *= m_rowSize;
-    int height = m_rowSize * (doubleheight ? 2 : 1);
-    QRect rect(x, y, m_colSize, height);
+    x *= m_colWidth;
+    y *= m_rowHeight;
+    int height = m_rowHeight * (doubleheight ? 2 : 1);
+    QRect rect(x, y, m_colWidth, height);
 
-    int fontheight = 10;
     if (doubleheight)
     {
-        fontheight = m_safeArea.height() / (kTeletextRows * 1.2);
-        int doubleheight = fontheight * 2;
-        gTTFont->GetFace()->setPixelSize(doubleheight);
-        gTTFont->GetFace()->setStretch(50);
+        gTTFont->GetFace()->setPixelSize(m_fontHeight * 2);
+        gTTFont->GetFace()->setStretch(m_fontStretch / 2);
     }
 
     QImage* image = GetRowImage(row, rect);
@@ -939,8 +544,8 @@ void TeletextScreen::DrawCharacter(int x
     if (row & 1)
     {
         row++;
-        rect = QRect(x, y + m_rowSize, m_colSize, height);
-        rect.translate(0, -m_rowSize);
+        rect = QRect(x, y + m_rowHeight, m_colWidth, height);
+        rect.translate(0, -m_rowHeight);
         image = GetRowImage(row, rect);
         if (image)
         {
@@ -954,17 +559,17 @@ void TeletextScreen::DrawCharacter(int x
 
     if (doubleheight)
     {
-        gTTFont->GetFace()->setPixelSize(fontheight);
-        gTTFont->GetFace()->setStretch(100);
+        gTTFont->GetFace()->setPixelSize(m_fontHeight);
+        gTTFont->GetFace()->setStretch(m_fontStretch);
     }
 }
 
 void TeletextScreen::DrawBackground(int x, int y)
 {
     int row = y;
-    x *= m_colSize;
-    y *= m_rowSize;
-    DrawRect(row, QRect(x, y, m_colSize, m_rowSize));
+    x *= m_colWidth;
+    y *= m_rowHeight;
+    DrawRect(row, QRect(x, y, m_colWidth, m_rowHeight));
 }
 
 void TeletextScreen::DrawRect(int row, QRect rect)
@@ -984,11 +589,11 @@ void TeletextScreen::DrawRect(int row, Q
 void TeletextScreen::DrawMosaic(int x, int y, int code, int doubleheight)
 {
     int row = y;
-    x *= m_colSize;
-    y *= m_rowSize;
+    x *= m_colWidth;
+    y *= m_rowHeight;
 
-    int dx = (int)round(m_colSize / 2) + 1;
-    int dy = (int)round(m_rowSize / 3) + 1;
+    int dx = (int)round(m_colWidth / 2) + 1;
+    int dy = (int)round(m_rowHeight / 3) + 1;
     dy = (doubleheight) ? (2 * dy) : dy;
 
     if (code & 0x10)
@@ -1010,26 +615,19 @@ void TeletextScreen::DrawStatus(void)
     SetForegroundColor(kTTColorWhite);
     SetBackgroundColor(kTTColorBlack);
 
-    if (!m_transparent)
+    if (!m_teletextReader->IsTransparent())
         for (int i = 0; i < 40; ++i)
             DrawBackground(i, 0);
 
     DrawCharacter(1, 0, 'P', 0);
-    DrawCharacter(2, 0, m_pageinput[0], 0);
-    DrawCharacter(3, 0, m_pageinput[1], 0);
-    DrawCharacter(4, 0, m_pageinput[2], 0);
+    DrawCharacter(2, 0, m_teletextReader->GetPageInput(0), 0);
+    DrawCharacter(3, 0, m_teletextReader->GetPageInput(1), 0);
+    DrawCharacter(4, 0, m_teletextReader->GetPageInput(2), 0);
 
-    const TeletextSubPage *ttpage = FindSubPage(m_curpage, m_cursubpage);
+    const TeletextSubPage *ttpage = m_teletextReader->FindSubPage();
 
     if (!ttpage)
     {
-        SetBackgroundColor(kTTColorBlack);
-        SetForegroundColor(kTTColorWhite);
-
-        if (!m_transparent)
-            for (int i = 7; i < 40; i++)
-                DrawBackground(i, 0);
-
         QString str = QObject::tr("Page Not Available",
                                   "Requested Teletext page not available");
         for (int i = 0; (i < 30) && i < str.length(); i++)
@@ -1038,59 +636,14 @@ void TeletextScreen::DrawStatus(void)
         return;
     }
 
-    // get list of available sub pages
-    QString str = "";
-    int count = 1, selected = 0;
-    const TeletextPage *page = FindPage(m_curpage);
-    if (page)
-    {
-        int_to_subpage_t::const_iterator subpageIter;
-        subpageIter = page->subpages.begin();
-        while (subpageIter != page->subpages.end())
-        {
-            const TeletextSubPage *subpage = &subpageIter->second;
-
-            if (subpage->subpagenum == m_cursubpage)
-            {
-                selected = count;
-                str += "*";
-            }
-            else
-                str += " ";
-
-            str += QString().sprintf("%02X", subpage->subpagenum);
-
-            ++subpageIter;
-            ++count;
-        }
-    }
-
+    QString str = m_teletextReader->GetPage();
     if (str.isEmpty())
         return;
 
-    // if there are less than 9 subpages fill the empty slots with spaces
-    if (count < 10)
-    {
-        QString spaces;
-        spaces.fill(' ', 27 - str.length());
-        str = "  <" + str + spaces + " > ";
-    }
-    else
-    {
-        // try to centralize the selected sub page in the list
-        int startPos = selected - 5;
-        if (startPos < 0)
-            startPos = 0;
-        if (startPos + 9 >= count)
-            startPos = count - 10;
-
-        str = "  <" + str.mid(startPos * 3, 27) + " > ";
-    }
-
     SetForegroundColor(kTTColorWhite);
     for (int x = 0; x < 11; x++)
     {
-        if (m_transparent)
+        if (m_teletextReader->IsTransparent())
             SetBackgroundColor(kTTColorTransparent);
         else
             SetBackgroundColor(kTTColorBlack);
@@ -1112,135 +665,7 @@ void TeletextScreen::DrawStatus(void)
     }
 }
 
-void TeletextScreen::PageUpdated(int page, int subpage)
-{
-    if (!m_displaying)
-        return;
-    if (page != m_curpage)
-        return;
-    if (subpage != m_cursubpage && m_cursubpage != -1)
-        return;
-    m_page_changed = true;
-}
-
-void TeletextScreen::HeaderUpdated(uint8_t * page, int lang)
-{
-    (void)lang;
-
-    if (!m_displaying)
-        return;
-
-    if (page == NULL)
-        return;
-
-    if (m_curpage_showheader == false)
-        return;
-
-    m_header_changed = true;
-}
-
-const TeletextPage *TeletextScreen::FindPageInternal(
-    int page, int direction) const
-{
-    int mag = MAGAZINE(page);
-
-    if (mag > 8 || mag < 1)
-        return NULL;
-
-    QMutexLocker lock(&m_magazines[mag - 1].lock);
-
-    int_to_page_t::const_iterator pageIter;
-    pageIter = m_magazines[mag - 1].pages.find(page);
-    if (pageIter == m_magazines[mag - 1].pages.end())
-        return NULL;
-
-    const TeletextPage *res = &pageIter->second;
-    if (direction == -1)
-    {
-        --pageIter;
-        if (pageIter == m_magazines[mag - 1].pages.end())
-        {
-            int_to_page_t::const_reverse_iterator iter;
-            iter = m_magazines[mag - 1].pages.rbegin();
-            res = &iter->second;
-        }
-        else
-            res = &pageIter->second;
-    }
-
-    if (direction == 1)
-    {
-        ++pageIter;
-        if (pageIter == m_magazines[mag - 1].pages.end())
-        {
-            pageIter = m_magazines[mag - 1].pages.begin();
-            res = &pageIter->second;
-        }
-        else
-            res = &pageIter->second;
-    }
-
-    return res;
-}
-
-const TeletextSubPage *TeletextScreen::FindSubPageInternal(
-    int page, int subpage, int direction) const
-{
-    int mag = MAGAZINE(page);
-
-    if (mag > 8 || mag < 1)
-        return NULL;
-
-    QMutexLocker lock(&m_magazines[mag - 1].lock);
-
-    int_to_page_t::const_iterator pageIter;
-    pageIter = m_magazines[mag - 1].pages.find(page);
-    if (pageIter == m_magazines[mag - 1].pages.end())
-        return NULL;
-
-    const TeletextPage *ttpage = &(pageIter->second);
-    int_to_subpage_t::const_iterator subpageIter =
-        ttpage->subpages.begin();
-
-    // try to find the subpage given, or first if subpage == -1
-    if (subpage != -1)
-        subpageIter = ttpage->subpages.find(subpage);
-
-    if (subpageIter == ttpage->subpages.end())
-        return NULL;
-
-    if (subpage == -1)
-        return &(subpageIter->second);
-
-    const TeletextSubPage *res = &(subpageIter->second);
-    if (direction == -1)
-    {
-        --subpageIter;
-        if (subpageIter == ttpage->subpages.end())
-        {
-            int_to_subpage_t::const_reverse_iterator iter =
-                ttpage->subpages.rbegin();
-            res = &(iter->second);
-        }
-        else
-        {
-            res = &(subpageIter->second);
-        }
-    }
-
-    if (direction == 1)
-    {
-        ++subpageIter;
-        if (subpageIter == ttpage->subpages.end())
-            subpageIter = ttpage->subpages.begin();
-
-        res = &(subpageIter->second);
-    }
-
-    return res;
-}
-
-bool TeletextScreen::InitialiseFont(int fontStretch)
+bool TeletextScreen::InitialiseFont()
 {
     static bool initialised = false;
     QString font = gCoreContext->GetSetting("OSDSubFont", "FreeSans");
@@ -1256,7 +681,6 @@ bool TeletextScreen::InitialiseFont(int 
     {
         QFont newfont(font);
         font.detach();
-        newfont.setStretch(fontStretch);
         mythfont->SetFace(newfont);
         gTTFont = mythfont;
     }
diff -Naurp mythtv-0.24.orig/libs/libmythtv/teletextscreen.h mythtv-0.24.fixes/libs/libmythtv/teletextscreen.h
--- mythtv-0.24.orig/libs/libmythtv/teletextscreen.h	2010-10-19 04:51:15.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/teletextscreen.h	2011-03-24 22:18:50.000000000 -0400
@@ -4,95 +4,12 @@
 #include <QFont>
 
 #include "mythscreentype.h"
-#include "teletextdecoder.h"
+#include "teletextreader.h"
 #include "mythplayer.h"
 
-typedef enum
+class TeletextScreen: public MythScreenType
 {
-    kTTColorBlack       = 0,
-    kTTColorRed         = 1,
-    kTTColorGreen       = 2,
-    kTTColorYellow      = 3,
-    kTTColorBlue        = 4,
-    kTTColorMagenta     = 5,
-    kTTColorCyan        = 6,
-    kTTColorWhite       = 7,
-    kTTColorTransparent = 8,
-} TTColor;
-
-class TTKey
-{
-  public:
-    static const uint k0            = 0;
-    static const uint k1            = 1;
-    static const uint k2            = 2;
-    static const uint k3            = 3;
-    static const uint k4            = 4;
-    static const uint k5            = 5;
-    static const uint k6            = 6;
-    static const uint k7            = 7;
-    static const uint k8            = 8;
-    static const uint k9            = 9;
-    static const uint kNextPage     = 10;
-    static const uint kPrevPage     = 11;
-    static const uint kNextSubPage  = 12;
-    static const uint kPrevSubPage  = 13;
-    static const uint kHold         = 14;
-    static const uint kTransparent  = 15;
-    static const uint kFlofRed      = 16;
-    static const uint kFlofGreen    = 17;
-    static const uint kFlofYellow   = 18;
-    static const uint kFlofBlue     = 19;
-    static const uint kFlofWhite    = 20;
-    static const uint kRevealHidden = 21;
-};
-
-#define TP_SUPPRESS_HEADER  0x01
-#define TP_UPDATE_INDICATOR 0x02
-#define TP_INTERRUPTED_SEQ  0x04
-#define TP_INHIBIT_DISPLAY  0x08
-#define TP_MAGAZINE_SERIAL  0x10
-#define TP_ERASE_PAGE       0x20
-#define TP_NEWSFLASH        0x40
-#define TP_SUBTITLE         0x80
-
-class TeletextSubPage
-{
-  public:
-    int pagenum;              ///< the wanted page
-    int subpagenum;           ///< the wanted subpage
-    int lang;                 ///< language code
-    int flags;                ///< misc flags
-    uint8_t data[25][40];     ///< page data
-    int flof;                 ///< page has FastText links
-    int floflink[6];          ///< FastText links (FLOF)
-    bool subtitle;            ///< page is subtitle page
-    bool active;              ///< data has arrived since page last cleared
-};
-typedef map<int, TeletextSubPage> int_to_subpage_t;
-
-class TeletextPage
-{
-  public:
-    int               pagenum;
-    int               current_subpage;
-    int_to_subpage_t  subpages;
-};
-typedef map<int, TeletextPage> int_to_page_t;
-
-class TeletextMagazine
-{
-  public:
-    mutable QMutex    lock;
-    int               current_page;
-    int               current_subpage;
-    TeletextSubPage   loadingpage;
-    int_to_page_t     pages;
-};
-
-class TeletextScreen: public MythScreenType, public TeletextViewer
-{
-    static bool  InitialiseFont(int fontStretch = QFont::Unstretched);
+    static bool  InitialiseFont(void);
 
   public:
     TeletextScreen(MythPlayer *player, const char * name, int fontStretch);
@@ -103,14 +20,10 @@ class TeletextScreen: public MythScreenT
     virtual void Pulse(void);
 
     // TeletextViewer interface methods
-    virtual void KeyPress(uint key);
-    virtual void SetPage(int page, int subpage);
-    virtual void SetDisplaying(bool display);
-    virtual void Reset(void);
-    virtual void AddPageHeader(int page, int subpage, const uint8_t *buf,
-                               int vbimode, int lang, int flags);
-    virtual void AddTeletextData(int magazine, int row,
-                                 const uint8_t* buf, int vbimode);
+    void KeyPress(uint key);
+    void SetPage(int page, int subpage);
+    void SetDisplaying(bool display);
+    void Reset(void);
 
   private:
     void CleanUp();
@@ -127,51 +40,16 @@ class TeletextScreen: public MythScreenT
     void DrawStatus(void);
     void DrawPage(void);
 
-    void NewsFlash(void) {};
-    void PageUpdated(int page, int subpage);
-    void HeaderUpdated(uint8_t *page, int lang);
-
-    const TeletextSubPage *FindSubPage(int page, int subpage, int dir=0) const
-        { return FindSubPageInternal(page, subpage, dir); }
-    TeletextSubPage       *FindSubPage(int page, int subpage, int dir = 0)
-        { return (TeletextSubPage*) FindSubPageInternal(page, subpage, dir); }
-
-    const TeletextPage    *FindPage(int page, int dir = 0) const
-        { return (TeletextPage*) FindPageInternal(page, dir); }
-    TeletextPage          *FindPage(int page, int dir = 0)
-        { return (TeletextPage*) FindPageInternal(page, dir); }
-
-    const TeletextSubPage *FindSubPageInternal(int,int,int) const;
-    const TeletextPage    *FindPageInternal(int,int) const;
-
-    MythPlayer *m_player;
-    QRect       m_safeArea;
-    int         m_colSize;
-    int         m_rowSize;
-
-    QMutex m_lock;
-
-    int          m_fetchpage;
-    int          m_fetchsubpage;
-    QColor       m_bgColor;
-
-    // currently displayed page:
-    mutable int  m_curpage;
-    mutable int  m_cursubpage;
-    mutable bool m_curpage_showheader;
-    mutable bool m_curpage_issubtitle;
-
-    int          m_pageinput[3];
-    bool         m_transparent;
-    bool         m_revealHidden;
-    bool         m_displaying;
-    uint8_t      m_header[40];
-    mutable bool m_header_changed;
-    mutable bool m_page_changed;
-    TeletextMagazine m_magazines[8];
-    unsigned char    m_bitswap[256];
+    MythPlayer     *m_player;
+    TeletextReader *m_teletextReader;
+    QRect           m_safeArea;
+    int             m_colWidth;
+    int             m_rowHeight;
+    QColor          m_bgColor;
+    bool            m_displaying;
     QHash<int, QImage*> m_rowImages;
-    int          m_fontStretch;
+    int             m_fontStretch;
+    int             m_fontHeight;
 
   public:
     static const QColor kColorBlack;
diff -Naurp mythtv-0.24.orig/libs/libmythtv/textsubtitleparser.h mythtv-0.24.fixes/libs/libmythtv/textsubtitleparser.h
--- mythtv-0.24.orig/libs/libmythtv/textsubtitleparser.h	2010-06-05 01:20:23.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/textsubtitleparser.h	2011-03-24 22:18:50.000000000 -0400
@@ -40,7 +40,11 @@ typedef vector<text_subtitle_t> TextSubt
 class TextSubtitles
 {
   public:
-    TextSubtitles() : m_frameBasedTiming(false) {}
+    TextSubtitles() : m_frameBasedTiming(false)
+    {
+        m_lastReturnedSubtitle.start = 0;
+        m_lastReturnedSubtitle.end   = 0;
+    }
 
     virtual ~TextSubtitles() {}
 
diff -Naurp mythtv-0.24.orig/libs/libmythtv/tv_play.cpp mythtv-0.24.fixes/libs/libmythtv/tv_play.cpp
--- mythtv-0.24.orig/libs/libmythtv/tv_play.cpp	2010-11-08 19:53:54.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythtv/tv_play.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -268,7 +268,7 @@ bool TV::StartTV(ProgramInfo *tvrec, uin
         else if (RemoteGetFreeRecorderCount())
         {
             VERBOSE(VB_PLAYBACK, LOC + "tv->LiveTV() -- begin");
-            if (!tv->LiveTV(showDialogs, startInGuide))
+            if (!tv->LiveTV(showDialogs))
             {
                 tv->SetExitPlayer(true, true);
                 quitAll = true;
@@ -279,6 +279,9 @@ bool TV::StartTV(ProgramInfo *tvrec, uin
                 SendMythSystemEvent("LIVETV_STARTED");
             }
 
+            if (!quitAll && (startInGuide || tv->StartLiveTVInGuide()))
+                tv->DoEditSchedule();
+
             VERBOSE(VB_PLAYBACK, LOC + "tv->LiveTV() -- end");
         }
         else if (!ConfiguredTunerCards())
@@ -362,26 +365,32 @@ bool TV::StartTV(ProgramInfo *tvrec, uin
 
         // Process Events
         VERBOSE(VB_PLAYBACK, LOC + "StartTV -- process events begin");
-        MythTimer st; st.start();
-        bool is_started = false;
+
         while (true)
         {
             qApp->processEvents();
 
-            QMutexLocker locker(&tv->stateChangeCondLock);
-            TVState state   = tv->GetState(0);
-            bool is_err     = kState_Error == state;
-            bool is_none    = kState_None  == state;
-            is_started = is_started ||
-                (st.elapsed() > (int) TV::kEndOfPlaybackFirstCheckTimer) ||
-                (!is_none && !is_err && kState_ChangingState != state);
-            if (is_err || (is_none && is_started))
+            TVState state = tv->GetState(0);
+            if ((kState_Error == state) || (kState_None == state))
                 break;
 
-            // timeout needs to be low enough to process keyboard input
-            unsigned long timeout = 20; // milliseconds
-            tv->stateChangeCond.wait(&tv->stateChangeCondLock, timeout);
+            if (kState_ChangingState == state)
+                continue;
+
+            const PlayerContext *mctx = tv->GetPlayerReadLock(0, __FILE__, __LINE__);
+            if (mctx)
+            {
+                mctx->LockDeletePlayer(__FILE__, __LINE__);
+                if (mctx->player && !mctx->player->IsErrored())
+                {
+                    mctx->player->EventLoop();
+                    mctx->player->VideoLoop();
+                }
+            }
+            mctx->UnlockDeletePlayer(__FILE__, __LINE__);
+            tv->ReturnPlayerLock(mctx);
         }
+
         VERBOSE(VB_PLAYBACK, LOC + "StartTV -- process events end");
 
         if (tv->getJumpToProgram())
@@ -841,14 +850,6 @@ void TV::ResetKeys(void)
 }
 
 
-class TVInitRunnable : public QRunnable
-{
-  public:
-    TVInitRunnable(TV *ourTV) : tv(ourTV) {}
-    virtual void run(void) { tv->InitFromDB(); }
-    TV *tv;
-};
-
 /** \fn TV::TV(void)
  *  \sa Init(void)
  */
@@ -922,7 +923,7 @@ TV::TV(void)
       disableDrawUnusedRects(false),
       isEmbedded(false),            ignoreKeyPresses(false),
       // Timers
-      lcdTimerId(0),                keyListTimerId(0),
+      lcdTimerId(0),
       networkControlTimerId(0),     jumpMenuTimerId(0),
       pipChangeTimerId(0),          udpNotifyTimerId(0),
       switchToInputTimerId(0),      ccInputTimerId(0),
@@ -950,7 +951,7 @@ TV::TV(void)
     playerActive = 0;
     playerLock.unlock();
 
-    QThreadPool::globalInstance()->start(new TVInitRunnable(this), 99);
+    InitFromDB();
 
     VERBOSE(VB_PLAYBACK, LOC + "ctor -- end");
 }
@@ -1161,9 +1162,8 @@ bool TV::Init(bool createWindow)
         }
 
         MythMainWindow *mainWindow = GetMythMainWindow();
-        //QPalette p = mainWindow->palette();
-        //p.setColor(mainWindow->backgroundRole(), Qt::black);
-        //mainWindow->setPalette(p);
+        if (mainWindow->GetPaintWindow())
+            mainWindow->GetPaintWindow()->update();
         mainWindow->installEventFilter(this);
         qApp->processEvents();
     }
@@ -1177,15 +1177,29 @@ bool TV::Init(bool createWindow)
         }
     }
 
-    mainLoopCondLock.lock();
-    start();
-    mainLoopCond.wait(&mainLoopCondLock);
+    PlayerContext *mctx = GetPlayerReadLock(0, __FILE__, __LINE__);
+    mctx->paused = false;
+    mctx->ff_rew_state = 0;
+    mctx->ff_rew_index = kInitFFRWSpeed;
+    mctx->ff_rew_speed = 0;
+    mctx->ts_normal    = 1.0f;
+    ReturnPlayerLock(mctx);
+
+    sleep_index = 0;
+
+    SetUpdateOSDPosition(false);
+
+    const PlayerContext *ctx = GetPlayerReadLock(0, __FILE__, __LINE__);
+    ClearInputQueues(ctx, false);
+    ReturnPlayerLock(ctx);
+
+    switchToRec = NULL;
+    SetExitPlayer(false, false);
+
     errorRecoveryTimerId = StartTimer(kErrorRecoveryCheckFrequency, __LINE__);
     lcdTimerId           = StartTimer(1, __LINE__);
     speedChangeTimerId   = StartTimer(kSpeedChangeCheckFrequency, __LINE__);
 
-    mainLoopCondLock.unlock();
-
     VERBOSE(VB_PLAYBACK, LOC + "Init -- end");
     return true;
 }
@@ -1214,9 +1228,6 @@ TV::~TV(void)
         myWindow = NULL;
     }
 
-    TV::exit(0);
-    TV::wait();
-
     VERBOSE(VB_PLAYBACK, "TV::~TV() -- lock");
 
     // restore window to gui size and position
@@ -1323,9 +1334,8 @@ TVState TV::GetState(const PlayerContext
 /** \fn TV::LiveTV(bool,bool)
  *  \brief Starts LiveTV
  *  \param showDialogs if true error dialogs are shown, if false they are not
- *  \param startInGuide if true the EPG will be shown upon entering LiveTV
  */
-bool TV::LiveTV(bool showDialogs, bool startInGuide)
+bool TV::LiveTV(bool showDialogs)
 {
     requestDelete = false;
     allowRerecord = false;
@@ -1336,7 +1346,7 @@ bool TV::LiveTV(bool showDialogs, bool s
         RequestNextRecorder(actx, showDialogs))
     {
         actx->SetInitialTVState(true);
-        ScheduleStateChange(actx);
+        HandleStateChange(actx, actx);
         switchToRec = NULL;
 
         // Start Idle Timer
@@ -1347,31 +1357,6 @@ bool TV::LiveTV(bool showDialogs, bool s
                     .arg(db_idle_timeout*(1.0f/60000.0f)));
         }
 
-        if (startInGuide || db_start_in_guide)
-        {
-            MSqlQuery query(MSqlQuery::InitCon());
-            query.prepare("SELECT keylist FROM keybindings WHERE "
-                          "context = 'TV Playback' AND action = 'GUIDE' AND "
-                          "hostname = :HOSTNAME ;");
-            query.bindValue(":HOSTNAME", gCoreContext->GetHostName());
-
-            if (query.exec() && query.isActive() && query.size() > 0)
-            {
-                query.next();
-
-                QKeySequence keyseq(query.value(0).toString());
-
-                int keynum = keyseq[0];
-                keynum &= ~Qt::UNICODE_ACCEL;
-
-                QMutexLocker locker(&timerIdLock);
-                keyList.push_front(
-                    new QKeyEvent(QEvent::KeyPress, keynum, 0, 0));
-                if (!keyListTimerId)
-                    keyListTimerId = StartTimer(1, __LINE__);
-            }
-        }
-
         ReturnPlayerLock(actx);
         return true;
     }
@@ -1761,7 +1746,7 @@ int TV::Playback(const ProgramInfo &rcin
 
     mctx->SetPlayingInfo(&rcinfo);
     mctx->SetInitialTVState(false);
-    ScheduleStateChange(mctx);
+    HandleStateChange(mctx, mctx);
 
     ReturnPlayerLock(mctx);
 
@@ -1925,9 +1910,6 @@ void TV::HandleStateChange(PlayerContext
         VERBOSE(VB_IMPORTANT, LOC + "HandleStateChange() Warning, "
                 "called with no state to change to.");
         ctx->UnlockState();
-
-        QMutexLocker locker(&stateChangeCondLock);
-        stateChangeCond.wakeAll();
         return;
     }
 
@@ -1944,9 +1926,6 @@ void TV::HandleStateChange(PlayerContext
                 "Attempting to set to an error state!");
         SetErrored(ctx);
         ctx->UnlockState();
-
-        QMutexLocker locker(&stateChangeCondLock);
-        stateChangeCond.wakeAll();
         return;
     }
 
@@ -2041,13 +2020,6 @@ void TV::HandleStateChange(PlayerContext
 
         VERBOSE(VB_IMPORTANT, "We have a RingBuffer");
 
-        if (GetMythMainWindow() && !weDisabledGUI)
-        {
-            weDisabledGUI = true;
-            GetMythMainWindow()->PushDrawDisabled();
-            DrawUnusedRects();
-        }
-
         if (ctx->playingInfo && StartRecorder(ctx,-1))
         {
             // Cache starting frame rate for this recorder
@@ -2065,7 +2037,6 @@ void TV::HandleStateChange(PlayerContext
         }
         else if (!ctx->IsPIP())
         {
-            GetMythUI()->DisableScreensaver();
             if (!lastLockSeenTime.isValid() ||
                 (lastLockSeenTime < timerOffTime))
             {
@@ -2113,15 +2084,6 @@ void TV::HandleStateChange(PlayerContext
 
         if (ctx->buffer && ctx->buffer->IsOpen())
         {
-            GetMythUI()->DisableScreensaver();
-
-            if (GetMythMainWindow() && !weDisabledGUI)
-            {
-                weDisabledGUI = true;
-                GetMythMainWindow()->PushDrawDisabled();
-                DrawUnusedRects();
-            }
-
             if (desiredNextState == kState_WatchingRecording)
             {
                 ctx->LockPlayingInfo(__FILE__, __LINE__);
@@ -2273,6 +2235,8 @@ void TV::HandleStateChange(PlayerContext
              TRANSITION(kState_None, kState_WatchingRecording) ||
              TRANSITION(kState_None, kState_WatchingLiveTV))
     {
+        if (!ctx->IsPIP())
+            GetMythUI()->DisableScreensaver();
         MythMainWindow *mainWindow = GetMythMainWindow();
         mainWindow->setBaseSize(player_bounds.size());
         mainWindow->setMinimumSize(
@@ -2281,17 +2245,21 @@ void TV::HandleStateChange(PlayerContext
             (db_use_fixed_size) ? player_bounds.size() :
             QSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX));
         mainWindow->setGeometry(player_bounds);
-
-        // hide the GUI paint window
         GetMythMainWindow()->GetPaintWindow()->hide();
+        if (!weDisabledGUI)
+        {
+            weDisabledGUI = true;
+            GetMythMainWindow()->PushDrawDisabled();
+        }
+        DrawUnusedRects();
+        // we no longer need the contents of myWindow
+        if (myWindow)
+            myWindow->DeleteAllChildren();
     }
 
     VERBOSE(VB_PLAYBACK, LOC +
             QString("HandleStateChange(%1) -- end")
             .arg(find_player_index(ctx)));
-
-    QMutexLocker locker(&stateChangeCondLock);
-    stateChangeCond.wakeAll();
 }
 #undef TRANSITION
 #undef SET_NEXT
@@ -2446,44 +2414,6 @@ void TV::TeardownPlayer(PlayerContext *m
     }
 }
 
-void TV::run(void)
-{
-    PlayerContext *mctx = GetPlayerReadLock(0, __FILE__, __LINE__);
-    mctx->paused = false;
-    mctx->ff_rew_state = 0;
-    mctx->ff_rew_index = kInitFFRWSpeed;
-    mctx->ff_rew_speed = 0;
-    mctx->ts_normal    = 1.0f;
-    ReturnPlayerLock(mctx);
-
-    sleep_index = 0;
-
-    SetUpdateOSDPosition(false);
-
-    const PlayerContext *ctx = GetPlayerReadLock(0, __FILE__, __LINE__);
-    ClearInputQueues(ctx, false);
-    ReturnPlayerLock(ctx);
-
-    switchToRec = NULL;
-    SetExitPlayer(false, false);
-
-    mainLoopCondLock.lock();
-    mainLoopCond.wakeAll();
-    mainLoopCondLock.unlock();
-
-    exec();
-
-    mctx = GetPlayerWriteLock(0, __FILE__, __LINE__);
-    if (!mctx->IsErrored() && (GetState(mctx) != kState_None))
-    {
-        mctx->ForceNextStateNone();
-        HandleStateChange(mctx, mctx);
-        if (jumpToProgram)
-            TeardownPlayer(mctx, mctx);
-    }
-    ReturnPlayerLock(mctx);
-}
-
 void TV::timerEvent(QTimerEvent *te)
 {
     const int timer_id = te->timerId();
@@ -2492,7 +2422,6 @@ void TV::timerEvent(QTimerEvent *te)
     if (mctx->IsErrored())
     {
         ReturnPlayerLock(mctx);
-        QThread::exit(1);
         return;
     }
     ReturnPlayerLock(mctx);
@@ -2686,49 +2615,6 @@ void TV::timerEvent(QTimerEvent *te)
     if (handled)
         return;
 
-    // Check if it matches keyListTimerId
-    QKeyEvent *keyEvent = NULL;
-    {
-        QMutexLocker locker(&timerIdLock);
-
-        if (timer_id == keyListTimerId)
-        {
-            keyEvent = keyList.dequeue();
-            if (keyList.empty())
-            {
-                KillTimer(keyListTimerId);
-                keyListTimerId = 0;
-            }
-        }
-    }
-
-    if (keyEvent)
-    {
-        PlayerContext *actx = GetPlayerWriteLock(-1, __FILE__, __LINE__);
-        if (actx->HasPlayer())
-        {
-            ProcessKeypress(actx, keyEvent);
-
-            delete keyEvent;
-        }
-        else
-        {
-            VERBOSE(VB_IMPORTANT,
-                    "Ignoring key event for now because player is not set");
-
-            QMutexLocker locker(&timerIdLock);
-            keyList.push_front(keyEvent);
-            if (keyListTimerId)
-                KillTimer(keyListTimerId);
-            keyListTimerId = StartTimer(20, __LINE__);
-        }
-        ReturnPlayerLock(actx);
-        handled = true;
-    }
-
-    if (handled)
-        return;
-
     // Check if it matches networkControlTimerId
     QString netCmd = QString::null;
     {
@@ -3439,12 +3325,13 @@ bool TV::event(QEvent *e)
 
     if (QEvent::KeyPress == e->type())
     {
-        QKeyEvent *k = new QKeyEvent(*(QKeyEvent *)e);
-        QMutexLocker locker(&timerIdLock);
-        keyList.enqueue(k);
-        if (!keyListTimerId)
-            keyListTimerId = StartTimer(1, __LINE__);
-        return true;
+        bool handled = false;
+        PlayerContext *actx = GetPlayerWriteLock(-1, __FILE__, __LINE__);
+        if (actx->HasPlayer())
+            handled = ProcessKeypress(actx, (QKeyEvent *)e);
+        ReturnPlayerLock(actx);
+        if (handled)
+            return true;
     }
 
     switch (e->type())
@@ -3458,7 +3345,7 @@ bool TV::event(QEvent *e)
             break;
     }
 
-    return QThread::event(e);
+    return QObject::event(e);
 }
 
 bool TV::HandleTrackAction(PlayerContext *ctx, const QString &action)
@@ -3576,7 +3463,7 @@ static bool has_action(QString action, c
     return false;
 }
 
-void TV::ProcessKeypress(PlayerContext *actx, QKeyEvent *e)
+bool TV::ProcessKeypress(PlayerContext *actx, QKeyEvent *e)
 {
     bool ignoreKeys = actx->IsPlayerChangingBuffers();
 #if DEBUG_ACTIONS
@@ -3599,7 +3486,7 @@ void TV::ProcessKeypress(PlayerContext *
                   "TV Playback", e, actions);
 
         if (handled || actions.isEmpty())
-            return;
+            return true;
 
         bool esc   = has_action("ESCAPE", actions) ||
                      has_action("BACK", actions);
@@ -3607,7 +3494,7 @@ void TV::ProcessKeypress(PlayerContext *
         bool play  = has_action("PLAY",   actions);
 
         if ((!esc || browsehelper->IsBrowsing()) && !pause && !play)
-            return;
+            return false;
     }
 
     OSD *osd = GetOSDLock(actx);
@@ -3616,8 +3503,9 @@ void TV::ProcessKeypress(PlayerContext *
         osd->DialogHandleKeypress(e);
         handled = true;
     }
+    ReturnOSDLock(actx, osd);
 
-    if (editmode && osd && !handled)
+    if (editmode && !handled)
     {
         handled |= GetMythMainWindow()->TranslateKeyPress(
                    "TV Editing", e, actions);
@@ -3654,10 +3542,9 @@ void TV::ProcessKeypress(PlayerContext *
         if (handled)
             editmode = actx->player->GetEditMode();
     }
-    ReturnOSDLock(actx, osd);
 
     if (handled)
-        return;
+        return true;
 
     // If text is already queued up, be more lax on what is ok.
     // This allows hex teletext entry and minor channel entry.
@@ -3669,7 +3556,7 @@ void TV::ProcessKeypress(PlayerContext *
         if (ok || txt=="_" || txt=="-" || txt=="#" || txt==".")
         {
             AddKeyToInputQueue(actx, txt.at(0).toLatin1());
-            return;
+            return true;
         }
     }
 
@@ -3688,7 +3575,7 @@ void TV::ProcessKeypress(PlayerContext *
                 if (actx->player->HandleTeletextAction(tt_actions[i]))
                 {
                     actx->UnlockDeletePlayer(__FILE__, __LINE__);
-                    return;
+                    return true;
                 }
             }
         }
@@ -3708,7 +3595,7 @@ void TV::ProcessKeypress(PlayerContext *
                 if (actx->player->ITVHandleAction(itv_actions[i]))
                 {
                     actx->UnlockDeletePlayer(__FILE__, __LINE__);
-                    return;
+                    return true;
                 }
             }
         }
@@ -3719,7 +3606,7 @@ void TV::ProcessKeypress(PlayerContext *
               "TV Playback", e, actions);
 
     if (handled || actions.isEmpty())
-        return;
+        return true;
 
     handled = false;
 
@@ -3745,7 +3632,7 @@ void TV::ProcessKeypress(PlayerContext *
 #endif // DEBUG_ACTIONS
 
     if (handled)
-        return;
+        return true;
 
     if (!handled)
     {
@@ -3762,6 +3649,8 @@ void TV::ProcessKeypress(PlayerContext *
             }
         }
     }
+
+    return true;
 }
 
 bool TV::BrowseHandleAction(PlayerContext *ctx, const QStringList &actions)
@@ -9673,6 +9562,10 @@ void TV::OSDDialogEvent(int result, QStr
         else if (valid && desc[0] == "DELETE")
         {
         }
+        else if (valid && desc[0] == "PLAY")
+        {
+            DoPlay(actx);
+        }
         else
         {
             VERBOSE(VB_IMPORTANT, "Unrecognised dialog event.");
@@ -10146,7 +10039,6 @@ void TV::FillOSDMenuVideo(const PlayerCo
             cur_mode = " " + cur_mode;
             scan_type = kScan_Detect;
         }
-        ctx->UnlockDeletePlayer(__FILE__, __LINE__);
 
         osd->DialogAddButton(tr("Detect") + cur_mode, "SELECTSCAN_0", false,
                              scan_type == kScan_Detect);
@@ -10325,7 +10217,8 @@ void TV::FillOSDMenuNavigate(const Playe
     TVState state     = ctx->GetState();
     bool isdvd        = state == kState_WatchingDVD;
     bool islivetv     = StateIsLiveTV(state);
-    bool isrecording  = state == kState_WatchingPreRecorded;
+    bool isrecording  = state == kState_WatchingPreRecorded ||
+                        state == kState_WatchingRecording;
     bool previouschan = false;
     if (islivetv)
     {
@@ -11647,7 +11540,8 @@ void TV::ShowOSDPromptDeleteRecording(Pl
 
     ClearOSD(ctx);
 
-    if (!ctx->paused)
+    bool paused = ctx->paused;
+    if (!paused)
         DoTogglePause(ctx, false);
 
     InfoMap infoMap;
@@ -11676,6 +11570,8 @@ void TV::ShowOSDPromptDeleteRecording(Pl
                                  "DIALOG_VIDEOEXIT_JUSTDELETE_0");
             osd->DialogAddButton(tr("No, keep it, I changed my mind"),
                                  "DIALOG_VIDEOEXIT_JUSTEXIT_0", false, true);
+            if (!paused)
+                osd->DialogBack("", "DIALOG_PLAY_0_0", true);
         }
 
         QMutexLocker locker(&timerIdLock);
diff -Naurp mythtv-0.24.orig/libs/libmythtv/tv_play.h mythtv-0.24.fixes/libs/libmythtv/tv_play.h
--- mythtv-0.24.orig/libs/libmythtv/tv_play.h	2010-10-28 23:06:06.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/tv_play.h	2011-03-24 22:18:50.000000000 -0400
@@ -78,7 +78,6 @@ typedef void (*EMBEDRETURNVOIDSCHEDIT) (
 //            -> recorderPlaybackInfoLock
 //            -> timerIdLock
 //            -> mainLoopCondLock
-//            -> stateChangeCondLock
 //            -> channelGroupLock
 //
 // When holding one of these locks, you may lock any lock of  the locks to
@@ -164,9 +163,8 @@ class AskProgramInfo
     ProgramInfo *info;
 };
 
-class MPUBLIC TV : public QThread
+class MPUBLIC TV : public QObject
 {
-    friend class QTVEventThread;
     friend class PlaybackBox;
     friend class GuideGrid;
     friend class TvPlayWindow;
@@ -191,14 +189,15 @@ class MPUBLIC TV : public QThread
     bool Init(bool createWindow = true);
 
     // User input processing commands
-    void ProcessKeypress(PlayerContext*, QKeyEvent *e);
+    bool ProcessKeypress(PlayerContext*, QKeyEvent *e);
     void ProcessNetworkControlCommand(PlayerContext *, const QString &command);
     void customEvent(QEvent *e);
     bool event(QEvent *e);
     bool HandleTrackAction(PlayerContext*, const QString &action);
 
     // LiveTV commands
-    bool LiveTV(bool showDialogs = true, bool startInGuide = false);
+    bool LiveTV(bool showDialogs = true);
+    bool StartLiveTVInGuide(void) { return db_start_in_guide; }
 
     // Embedding commands for the guidegrid to use in LiveTV
     bool StartEmbedding(PlayerContext*, WId wid, const QRect&);
@@ -233,9 +232,6 @@ class MPUBLIC TV : public QThread
     // Boolean queries
     /// Returns true if we are currently in the process of switching recorders.
     bool IsSwitchingCards(void)  const { return switchToRec; }
-    /// Returns true if the TV event thread is running. Should always be true
-    /// between the end of the constructor and the beginning of the destructor.
-    bool IsRunning(void)         const { return isRunning(); }
     /// Returns true if the user told Mythtv to allow re-recording of the show
     bool getAllowRerecord(void) const { return allowRerecord;  }
     /// This is set to true if the player reaches the end of the
@@ -298,7 +294,6 @@ class MPUBLIC TV : public QThread
 
     void DoEditSchedule(int editType = kScheduleProgramGuide);
 
-    virtual void run(void);
     void TVEventThreadChecks(void);
 
     void PauseAudioUntilBuffered(PlayerContext *ctx);
@@ -731,7 +726,6 @@ class MPUBLIC TV : public QThread
     int       idleDialogTimerId; ///< Timer for idle dialog.
 
     /// Queue of unprocessed key presses.
-    MythDeque<QKeyEvent*> keyList;
     MythTimer keyRepeatTimer; ///< Timeout timer for repeat key filtering
 
     // CC/Teletex input state variables
@@ -840,7 +834,6 @@ class MPUBLIC TV : public QThread
     typedef QMap<int,const PlayerContext*> TimerContextConstMap;
     mutable QMutex       timerIdLock;
     volatile int         lcdTimerId;
-    volatile int         keyListTimerId;
     volatile int         networkControlTimerId;
     volatile int         jumpMenuTimerId;
     volatile int         pipChangeTimerId;
@@ -863,14 +856,6 @@ class MPUBLIC TV : public QThread
     TimerContextMap      signalMonitorTimerId;
     TimerContextMap      tvchainUpdateTimerId;
 
-    /// Condition to signal that the Event thread is up and running
-    QWaitCondition mainLoopCond;
-    QMutex mainLoopCondLock;
-
-    /// Condition to signal State changes
-    QWaitCondition stateChangeCond;
-    QMutex stateChangeCondLock;
-
   public:
     // Constants
     static const int kInitFFRWSpeed; ///< 1x, default to normal speed
diff -Naurp mythtv-0.24.orig/libs/libmythtv/tv_rec.cpp mythtv-0.24.fixes/libs/libmythtv/tv_rec.cpp
--- mythtv-0.24.orig/libs/libmythtv/tv_rec.cpp	2010-10-28 20:53:40.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/tv_rec.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -874,8 +874,10 @@ void TVRec::FinishedRecording(RecordingI
     VERBOSE(VB_RECORD, LOC + QString("FinishedRecording(%1) in recgroup: %2")
             .arg(curRec->GetTitle()).arg(recgrp));
 
-    if (curRec->GetRecordingStatus() != rsFailed)
+    if (curRec->GetRecordingStatus() == rsRecording)
         curRec->SetRecordingStatus(rsRecorded);
+    else if (curRec->GetRecordingStatus() != rsRecorded)
+        curRec->SetRecordingStatus(rsFailed);
     curRec->SetRecordingEndTime(mythCurrentDateTime());
 
     if (tvchain)
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videodisplayprofile.h mythtv-0.24.fixes/libs/libmythtv/videodisplayprofile.h
--- mythtv-0.24.orig/libs/libmythtv/videodisplayprofile.h	2010-04-04 12:54:32.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videodisplayprofile.h	2011-03-24 22:18:50.000000000 -0400
@@ -85,6 +85,7 @@ class MPUBLIC VideoDisplayProfile
 
     void SetInput(const QSize &size);
     void SetOutput(float framerate);
+    float GetOutput(void) { return last_rate; }
 
     void SetVideoRenderer(const QString &video_renderer);
     bool CheckVideoRendererGroup(const QString renderer);
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videooutbase.cpp mythtv-0.24.fixes/libs/libmythtv/videooutbase.cpp
--- mythtv-0.24.orig/libs/libmythtv/videooutbase.cpp	2010-10-10 13:33:19.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videooutbase.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -213,7 +213,7 @@ VideoOutput *VideoOutput::Create(
         if (vo)
         {
             vo->SetPIPState(pipState);
-            vo->video_prate = video_prate;
+            vo->SetVideoFrameRate(video_prate);
             if (vo->Init(
                     video_dim.width(), video_dim.height(), video_aspect,
                     win_id, display_rect.x(), display_rect.y(),
@@ -314,8 +314,7 @@ VideoOutput::VideoOutput() :
     db_use_picture_controls(false),
 
     // Video parameters
-    video_codec_id(kCodec_NONE),
-    db_vdisp_profile(NULL),             video_prate(0.0),
+    video_codec_id(kCodec_NONE),        db_vdisp_profile(NULL),
 
     // Picture-in-Picture stuff
     pip_desired_display_size(160,128),  pip_display_size(0,0),
@@ -463,7 +462,6 @@ bool VideoOutput::IsPreferredRenderer(QS
 
 void VideoOutput::SetVideoFrameRate(float playback_fps)
 {
-    video_prate = playback_fps;
     if (db_vdisp_profile)
         db_vdisp_profile->SetOutput(playback_fps);
 }
@@ -1582,7 +1580,8 @@ void VideoOutput::ResizeForVideo(uint wi
     if ((width == 1920 || width == 1440) && height == 1088)
         height = 1080; // ATSC 1920x1080
 
-    if (display_res && display_res->SwitchToVideo(width, height, video_prate))
+    float rate = db_vdisp_profile ? db_vdisp_profile->GetOutput() : 0.0f;
+    if (display_res && display_res->SwitchToVideo(width, height, rate))
     {
         // Switching to custom display resolution succeeded
         // Make a note of the new size
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videooutbase.h mythtv-0.24.fixes/libs/libmythtv/videooutbase.h
--- mythtv-0.24.orig/libs/libmythtv/videooutbase.h	2010-10-05 05:12:48.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videooutbase.h	2011-03-24 22:18:50.000000000 -0400
@@ -290,7 +290,6 @@ class VideoOutput
     // Video parameters
     MythCodecID          video_codec_id;
     VideoDisplayProfile *db_vdisp_profile;
-    float                video_prate;  ///< Playback frame rate of video
 
     // Picture-in-Picture
     QSize   pip_desired_display_size;
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videoout_d3d.cpp mythtv-0.24.fixes/libs/libmythtv/videoout_d3d.cpp
--- mythtv-0.24.orig/libs/libmythtv/videoout_d3d.cpp	2010-10-11 20:51:55.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videoout_d3d.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -297,7 +297,7 @@ void VideoOutputD3D::PrepareFrame(VideoF
                        (*it)->Draw();
                     }
                 }
-                if (osd && m_osd_painter)
+                if (osd && m_osd_painter && !window.IsEmbedding())
                     osd->DrawDirect(m_osd_painter, GetTotalOSDBounds().size(),
                                     true);
                 m_render->End();
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videoout_d3d.h mythtv-0.24.fixes/libs/libmythtv/videoout_d3d.h
--- mythtv-0.24.orig/libs/libmythtv/videoout_d3d.h	2010-08-04 00:46:01.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videoout_d3d.h	2011-03-24 22:18:50.000000000 -0400
@@ -43,7 +43,7 @@ class VideoOutputD3D : public VideoOutpu
                  MythPlayer  *pipplayer,
                  PIPLocation  loc);
     void RemovePIP(MythPlayer *pipplayer);
-    bool IsPIPSupported(void) const { return true; }
+    bool IsPIPSupported(void) const { return false; /*true*/}
     virtual MythPainter *GetOSDPainter(void) { return (MythPainter*)m_osd_painter; }
 
   private:
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videoout_opengl.cpp mythtv-0.24.fixes/libs/libmythtv/videoout_opengl.cpp
--- mythtv-0.24.orig/libs/libmythtv/videoout_opengl.cpp	2010-10-11 20:51:55.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videoout_opengl.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -393,7 +393,7 @@ void VideoOutputOpenGL::PrepareFrame(Vid
         }
     }
 
-    if (osd && gl_painter)
+    if (osd && gl_painter && !window.IsEmbedding())
         osd->DrawDirect(gl_painter, GetTotalOSDBounds().size(), true);
 
     gl_context->Flush(false);
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videoout_opengl.h mythtv-0.24.fixes/libs/libmythtv/videoout_opengl.h
--- mythtv-0.24.orig/libs/libmythtv/videoout_opengl.h	2010-09-03 07:55:16.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videoout_opengl.h	2011-03-24 22:18:50.000000000 -0400
@@ -46,7 +46,7 @@ class VideoOutputOpenGL : public VideoOu
     void MoveResizeWindow(QRect new_rect);
 
     virtual void RemovePIP(MythPlayer *pipplayer);
-    virtual bool IsPIPSupported(void) const   { return true; }
+    virtual bool IsPIPSupported(void) const   { return false/*true*/; }
     virtual bool hasFullScreenOSD(void) const { return true; }
     virtual bool IsSyncLocked(void) const     { return true; }
     virtual bool ApproveDeintFilter(const QString& filtername) const;
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videoout_quartz.cpp mythtv-0.24.fixes/libs/libmythtv/videoout_quartz.cpp
--- mythtv-0.24.orig/libs/libmythtv/videoout_quartz.cpp	2010-10-15 07:02:28.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videoout_quartz.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -51,9 +51,13 @@ using namespace std;
 
 #include "util-osx.h"
 
+#ifdef USING_QUARTZ_VIDEO
+#import <QuartzCore/CoreVideo.h>
+#else
 #import <CoreGraphics/CGBase.h>
 #import <CoreGraphics/CGDisplayConfiguration.h>
 #import <CoreGraphics/CGImage.h>
+#endif
 #import <Carbon/Carbon.h>
 #import <QuickTime/QuickTime.h>
 
@@ -1685,7 +1689,8 @@ void VideoOutputQuartz::ProcessFrame(Vid
     }
 
     ShowPIPs(frame, pipPlayers);
-    DisplayOSD(frame, osd);
+    if (osd && !window.IsEmbedding())
+        DisplayOSD(frame, osd);
 
     if (m_deinterlacing &&
         m_deintFilter != NULL &&
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videoout_vdpau.cpp mythtv-0.24.fixes/libs/libmythtv/videoout_vdpau.cpp
--- mythtv-0.24.orig/libs/libmythtv/videoout_vdpau.cpp	2010-10-21 00:07:38.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videoout_vdpau.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -504,7 +504,7 @@ void VideoOutputVDPAU::PrepareFrame(Vide
                               m_pip_ready ? m_pip_layer : 0, 0))
         VERBOSE(VB_PLAYBACK, LOC_ERR + QString("Prepare frame failed."));
 
-    if (osd && m_osd_painter)
+    if (osd && m_osd_painter && !window.IsEmbedding())
         osd->DrawDirect(m_osd_painter, GetTotalOSDBounds().size(), true);
 
     if (!frame)
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videoout_vdpau.h mythtv-0.24.fixes/libs/libmythtv/videoout_vdpau.h
--- mythtv-0.24.orig/libs/libmythtv/videoout_vdpau.h	2010-08-04 00:46:01.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videoout_vdpau.h	2011-03-24 22:18:50.000000000 -0400
@@ -55,7 +55,7 @@ class VideoOutputVDPAU : public VideoOut
     static MythCodecID GetBestSupportedCodec(uint width, uint height,
                                              uint stream_type,
                                              bool no_acceleration);
-    virtual bool IsPIPSupported(void) const { return true; }
+    virtual bool IsPIPSupported(void) const { return false;/*true; */}
     virtual bool IsPBPSupported(void) const { return false; }
     virtual bool NeedExtraAudioDecode(void) const
         { return codec_is_vdpau(video_codec_id); }
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videoout_xv.cpp mythtv-0.24.fixes/libs/libmythtv/videoout_xv.cpp
--- mythtv-0.24.orig/libs/libmythtv/videoout_xv.cpp	2010-10-11 20:51:55.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videoout_xv.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -1766,8 +1766,8 @@ bool VideoOutputXv::CreateBuffers(VOSTyp
             Visual *visual = DefaultVisual(d, scrn);
             XJ_non_xv_image = XCreateImage(d, visual, disp->GetDepth(),
                                            ZPixmap, /*offset*/0, /*data*/0,
-                                           display_visible_rect.width(),
-                                           display_visible_rect.height(),
+                                           display_visible_rect.width()  & ~0x1,
+                                           display_visible_rect.height() & ~0x1,
                                            /*bitmap_pad*/8, 0);
 
             if (!XJ_non_xv_image)
diff -Naurp mythtv-0.24.orig/libs/libmythtv/videoout_xv.h mythtv-0.24.fixes/libs/libmythtv/videoout_xv.h
--- mythtv-0.24.orig/libs/libmythtv/videoout_xv.h	2010-08-30 00:00:09.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythtv/videoout_xv.h	2011-03-24 22:18:50.000000000 -0400
@@ -91,10 +91,8 @@ class VideoOutputXv : public VideoOutput
     int  SetPictureAttribute(PictureAttribute attribute, int newValue);
     void InitPictureAttributes(void);
 
-    virtual bool IsPIPSupported(void) const
-        { return XVideo == VideoOutputSubType(); }
-    virtual bool IsPBPSupported(void) const
-        { return XVideo == VideoOutputSubType(); }
+    virtual bool IsPIPSupported(void) const { return false; }
+    virtual bool IsPBPSupported(void) const { return false; }
     virtual bool NeedExtraAudioDecode(void) const
         { return XVideoMC <= VideoOutputSubType(); }
     virtual bool hasHWAcceleration(void) const
diff -Naurp mythtv-0.24.orig/libs/libmythui/DisplayResOSX.cpp mythtv-0.24.fixes/libs/libmythui/DisplayResOSX.cpp
--- mythtv-0.24.orig/libs/libmythui/DisplayResOSX.cpp	2010-09-14 21:37:33.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythui/DisplayResOSX.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -1,8 +1,6 @@
 
 #include "DisplayResOSX.h"
 
-#import <CoreGraphics/CGBase.h>
-#import <CoreGraphics/CGDisplayConfiguration.h>
 #import <Carbon/Carbon.h>
 #import <IOKit/graphics/IOGraphicsLib.h> // for IODisplayCreateInfoDictionary()
 
diff -Naurp mythtv-0.24.orig/libs/libmythui/mythmainwindow.cpp mythtv-0.24.fixes/libs/libmythui/mythmainwindow.cpp
--- mythtv-0.24.orig/libs/libmythui/mythmainwindow.cpp	2010-09-22 20:48:30.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythui/mythmainwindow.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -1933,7 +1933,7 @@ void MythMainWindow::customEvent(QEvent 
             if (screen)
                 screen->gestureEvent(ge);
         }
-        VERBOSE(VB_IMPORTANT, QString("Gesture: %1")
+        VERBOSE(VB_GUI, QString("Gesture: %1")
                 .arg(QString(*ge).toLocal8Bit().constData()));
     }
     else if (ce->type() == MythEvent::kExitToMainMenuEventType &&
diff -Naurp mythtv-0.24.orig/libs/libmythui/mythrender_opengl.cpp mythtv-0.24.fixes/libs/libmythui/mythrender_opengl.cpp
--- mythtv-0.24.orig/libs/libmythui/mythrender_opengl.cpp	2010-09-22 20:48:30.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythui/mythrender_opengl.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -111,9 +111,12 @@ MythRenderOpenGL::MythRenderOpenGL(const
 
 MythRenderOpenGL::~MythRenderOpenGL()
 {
-    makeCurrent();
-    DeleteOpenGLResources();
-    doneCurrent();
+    if (isValid())
+    {
+        makeCurrent();
+        DeleteOpenGLResources();
+        doneCurrent();
+    }
     if (m_lock)
         delete m_lock;
 }
@@ -139,8 +142,10 @@ void MythRenderOpenGL::makeCurrent()
 void MythRenderOpenGL::doneCurrent()
 {
     m_lock_level--;
+#ifndef Q_OS_WIN32
     if (m_lock_level == 0)
         QGLContext::doneCurrent();
+#endif
     if (m_lock_level < 0)
         VERBOSE(VB_IMPORTANT, LOC_ERR + "Mis-matched calls to makeCurrent()");
     m_lock->unlock();
@@ -891,24 +896,27 @@ void MythRenderOpenGL::DrawBitmap(uint t
         prog = 0;
 
     double srcx1, srcx2, srcy1, srcy2;
+    QSize  size = m_textures[tex].m_size;
+    int width   = std::min(src->width(), size.width());
+    int height  = std::min(src->height(), size.height());
 
     if (tex && !IsRectTexture(m_textures[tex].m_type))
     {
-        srcx1 = src->x() / (double)m_textures[tex].m_size.width();
-        srcx2 = srcx1 + src->width() / (double)m_textures[tex].m_size.width();
-        srcy1 = src->y() / (double)m_textures[tex].m_size.height();
-        srcy2 = srcy1 + src->height() / (double)m_textures[tex].m_size.height();
+        srcx1 = src->x() / (double)size.width();
+        srcx2 = srcx1 + width / (double)size.width();
+        srcy1 = src->y() / (double)size.height();
+        srcy2 = srcy1 + height / (double)size.height();
     }
     else
     {
         srcx1 = src->x();
-        srcx2 = srcx1 + src->width();
+        srcx2 = srcx1 + width;
         srcy1 = src->y();
-        srcy2 = srcy1 + src->height();
+        srcy2 = srcy1 + height;
     }
 
-    int width = std::min(src->width(), dst->width());
-    int height = std::min(src->height(), dst->height());
+    width = std::min(width, dst->width());
+    height = std::min(height, dst->height());
 
     makeCurrent();
 
@@ -1208,8 +1216,10 @@ void MythRenderOpenGL::InitFeatures(void
     m_exts_supported = kGLFeatNone;
 
     GLint maxtexsz = 0;
+    GLint maxunits = 0;
     glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxtexsz);
-    glGetIntegerv(GL_MAX_TEXTURE_UNITS, &m_max_units);
+    glGetIntegerv(GL_MAX_TEXTURE_UNITS, &maxunits);
+    m_max_units = maxunits;
     m_max_tex_size = (maxtexsz) ? maxtexsz : 512;
 
     m_extensions = (const char*) glGetString(GL_EXTENSIONS);
diff -Naurp mythtv-0.24.orig/libs/libmythui/mythrender_opengl.h mythtv-0.24.fixes/libs/libmythui/mythrender_opengl.h
--- mythtv-0.24.orig/libs/libmythui/mythrender_opengl.h	2010-09-22 20:48:30.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythui/mythrender_opengl.h	2011-03-24 22:18:50.000000000 -0400
@@ -50,7 +50,7 @@ class MythGLTexture;
 class MythGLShaderObject;
 class MythRenderOpenGL;
 
-class OpenGLLocker
+class MPUBLIC OpenGLLocker
 {
   public:
     OpenGLLocker(MythRenderOpenGL *render);
@@ -59,7 +59,7 @@ class OpenGLLocker
     MythRenderOpenGL *m_render;
 };
 
-class MythRenderOpenGL : public QGLContext, public MythRender
+class MPUBLIC MythRenderOpenGL : public QGLContext, public MythRender
 {
   public:
     MythRenderOpenGL(const QGLFormat& format, QPaintDevice* device);
diff -Naurp mythtv-0.24.orig/libs/libmythui/mythscreentype.cpp mythtv-0.24.fixes/libs/libmythui/mythscreentype.cpp
--- mythtv-0.24.orig/libs/libmythui/mythscreentype.cpp	2010-10-28 23:09:14.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythui/mythscreentype.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -121,8 +121,8 @@ bool MythScreenType::SetFocusWidget(Myth
     m_CurrentFocusWidget = widget;
     m_CurrentFocusWidget->TakeFocus();
 
-    if (helpText)
-        helpText->SetText(m_CurrentFocusWidget->GetHelpText());
+    if (helpText && !widget->GetHelpText().isEmpty())
+        helpText->SetText(widget->GetHelpText());
 
     return true;
 }
diff -Naurp mythtv-0.24.orig/libs/libmythui/mythuibuttonlist.cpp mythtv-0.24.fixes/libs/libmythui/mythuibuttonlist.cpp
--- mythtv-0.24.orig/libs/libmythui/mythuibuttonlist.cpp	2010-09-28 19:01:35.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythui/mythuibuttonlist.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -265,7 +265,7 @@ bool MythUIButtonList::DistributeRow(int
     int  max_width, max_height;
     int  left_width, right_width;
     int  begin, end;
-    bool underflow;
+    bool underflow = false;	// keep from being uninitialized
     bool added;
     bool hsplit, vsplit;
     int  selectedIdx;
diff -Naurp mythtv-0.24.orig/libs/libmythui/mythuiimage.cpp mythtv-0.24.fixes/libs/libmythui/mythuiimage.cpp
--- mythtv-0.24.orig/libs/libmythui/mythuiimage.cpp	2010-10-28 23:09:14.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythui/mythuiimage.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -210,6 +210,12 @@ void MythUIImage::Clear(void)
         m_Images.remove(it.key());
     }
     m_Delays.clear();
+    if (m_animatedImage)
+    {
+        m_LowNum = 0;
+        m_HighNum = 0;
+        m_animatedImage = false;
+    }
 }
 
 /**
@@ -221,7 +227,12 @@ void MythUIImage::Reset(void)
     if (m_Filename != m_OrigFilename)
     {
         m_Filename = m_OrigFilename;
-        m_animatedImage = false;
+        if (m_animatedImage)
+        {
+            m_LowNum = 0;
+            m_HighNum = 0;
+            m_animatedImage = false;
+        }
         d->m_UpdateLock.unlock();
         Load();
     }
@@ -626,7 +637,8 @@ bool MythUIImage::Load(bool allowLoadInB
     int j = 0;
     for (int i = m_LowNum; i <= m_HighNum && !m_animatedImage; i++)
     {
-        if (!m_animatedImage && m_HighNum >= 1)
+        if (!m_animatedImage && m_HighNum != m_LowNum && 
+            bFilename.contains("%1"))
             filename = bFilename.arg(i);
 
         imagelabel = GenImageLabel(filename, w, h);
diff -Naurp mythtv-0.24.orig/libs/libmythui/mythuistatetype.cpp mythtv-0.24.fixes/libs/libmythui/mythuistatetype.cpp
--- mythtv-0.24.orig/libs/libmythui/mythuistatetype.cpp	2010-05-24 15:26:16.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythui/mythuistatetype.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -51,12 +51,7 @@ bool MythUIStateType::AddObject(const QS
     else
         objectArea.CalculateArea(GetMythMainWindow()->GetUIScreenRect());
 
-    if (objectArea.width() > m_Area.width() ||
-        objectArea.height() > m_Area.height())
-    {
-        m_Area.setWidth(objectArea.getWidth());
-        m_Area.setHeight(objectArea.getHeight());
-    }
+    ExpandArea(objectArea);
 
     return true;
 }
@@ -88,12 +83,7 @@ bool MythUIStateType::AddObject(StateTyp
     else
         objectArea.CalculateArea(GetMythMainWindow()->GetUIScreenRect());
 
-    if (objectArea.width() > m_Area.width() ||
-        objectArea.height() > m_Area.height())
-    {
-        m_Area.setWidth(objectArea.getWidth());
-        m_Area.setHeight(objectArea.getHeight());
-    }
+    ExpandArea(objectArea);
 
     return true;
 }
@@ -104,7 +94,7 @@ bool MythUIStateType::DisplayState(const
         return false;
 
     MythUIType *old = m_CurrentState;
-    
+
     QMap<QString, MythUIType *>::Iterator i = m_ObjectsByName.find(name.toLower());
     if (i != m_ObjectsByName.end())
         m_CurrentState = i.value();
diff -Naurp mythtv-0.24.orig/libs/libmythui/mythuitype.cpp mythtv-0.24.fixes/libs/libmythui/mythuitype.cpp
--- mythtv-0.24.orig/libs/libmythui/mythuitype.cpp	2010-10-28 23:09:14.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythui/mythuitype.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -1002,7 +1002,7 @@ void MythUIType::LoadNow(void)
  */
 bool MythUIType::ContainsPoint(const QPoint &point) const
 {
-    if (m_Area.contains(point - m_Area.topLeft()))
+    if (m_Area.contains(point))
         return true;
 
     return false;
diff -Naurp mythtv-0.24.orig/libs/libmythui/mythuiwebbrowser.cpp mythtv-0.24.fixes/libs/libmythui/mythuiwebbrowser.cpp
--- mythtv-0.24.orig/libs/libmythui/mythuiwebbrowser.cpp	2010-10-28 23:09:14.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythui/mythuiwebbrowser.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -3,7 +3,7 @@
  * \author Paul Harrison <mythtv@dsl.pipex.com>
  * \brief Provide a web browser widget.
  *
- * This requires qt4.4.0 or later to function properly.
+ * This requires qt4.5.0 or later to function properly.
  *
  */
 
@@ -458,11 +458,7 @@ void MythUIWebBrowser::SetZoom(float zoo
         return;
 
     m_zoom = zoom;
-#if QT_VERSION >= 0x040500
     m_browser->setZoomFactor(m_zoom);
-#else
-    m_browser->setTextSizeMultiplier(m_zoom);
-#endif
     UpdateBuffer();
 }
 
diff -Naurp mythtv-0.24.orig/libs/libmythui/util-osx-cocoa.mm mythtv-0.24.fixes/libs/libmythui/util-osx-cocoa.mm
--- mythtv-0.24.orig/libs/libmythui/util-osx-cocoa.mm	2010-07-29 10:01:52.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythui/util-osx-cocoa.mm	2011-03-24 22:18:50.000000000 -0400
@@ -48,5 +48,5 @@ CGDirectDisplayID GetOSXCocoaDisplay(voi
     if (!screen)
         return NULL;
     NSDictionary* desc = [screen deviceDescription];
-    return [[desc objectForKey:@"NSScreenNumber"] intValue];
+    return (CGDirectDisplayID)[[desc objectForKey:@"NSScreenNumber"] intValue];
 }
diff -Naurp mythtv-0.24.orig/libs/libmythupnp/httprequest.cpp mythtv-0.24.fixes/libs/libmythupnp/httprequest.cpp
--- mythtv-0.24.orig/libs/libmythupnp/httprequest.cpp	2010-08-23 13:58:26.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythupnp/httprequest.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -522,6 +522,8 @@ qint64 HTTPRequest::SendFile( QFile &fil
     } 
     else 
     { 
+        qint64     llSent = 0;
+
         do 
         { 
             // SSIZE_MAX should work in kernels 2.6.16 and later. 
@@ -531,12 +533,18 @@ qint64 HTTPRequest::SendFile( QFile &fil
                 getSocketHandle(), fd, &offset, 
                 (size_t) ((llBytes > INT_MAX) ? INT_MAX : llBytes)); 
   
-            llBytes  -= ( offset - llStart ); 
-            VERBOSE(VB_UPNP, QString("SendResponseFile : --- " 
-            "size = %1, offset = %2, sent = %3") 
-            .arg(llBytes).arg(offset).arg(sent)); 
+            if (sent >= 0)
+            {
+                llBytes -= sent; 
+                llSent  += sent;
+                VERBOSE(VB_UPNP, QString("SendResponseFile : --- " 
+                        "size = %1, offset = %2, sent = %3") 
+                        .arg(llBytes).arg(offset).arg(sent)); 
+            }
         } 
         while (( sent >= 0 ) && ( llBytes > 0 )); 
+
+        sent = llSent;
     } 
 
 #endif
@@ -844,8 +852,8 @@ long HTTPRequest::GetParameters( QString
 
             if ((sName.length() != 0) && (sValue.length() !=0))
             {
-                sName  = QUrl::fromPercentEncoding(sName.toLatin1());
-                sValue = QUrl::fromPercentEncoding(sValue.toLatin1());
+                sName  = QUrl::fromPercentEncoding(sName.toUtf8());
+                sValue = QUrl::fromPercentEncoding(sValue.toUtf8());
 
                 mapParams.insert( sName.trimmed(), sValue );
                 nCount++;
@@ -1085,12 +1093,12 @@ void HTTPRequest::ProcessRequestLine( co
         if (nCount > 1)
         {
             //m_sBaseUrl = tokens[1].section( '?', 0, 0).trimmed();
-            m_sBaseUrl = (QUrl::fromPercentEncoding(tokens[1].toLatin1())).section( '?', 0, 0).trimmed();
+            m_sBaseUrl = (QUrl::fromPercentEncoding(tokens[1].toUtf8())).section( '?', 0, 0).trimmed();
 
             // Process any Query String Parameters
 
             //QString sQueryStr = tokens[1].section( '?', 1, 1   );
-            QString sQueryStr = (QUrl::fromPercentEncoding(tokens[1].toLatin1())).section( '?', 1, 1 );
+            QString sQueryStr = (QUrl::fromPercentEncoding(tokens[1].toUtf8())).section( '?', 1, 1 );
 
             if (sQueryStr.length() > 0)
                 GetParameters( sQueryStr, m_mapParams );
@@ -1299,8 +1307,8 @@ bool HTTPRequest::ProcessSOAPPayload( co
                     if (!oText.isNull())
                         sValue = oText.nodeValue();
 
-                    sName  = QUrl::fromPercentEncoding(sName.toLatin1());
-                    sValue = QUrl::fromPercentEncoding(sValue.toLatin1());
+                    sName  = QUrl::fromPercentEncoding(sName.toUtf8());
+                    sValue = QUrl::fromPercentEncoding(sValue.toUtf8());
 
                     m_mapParams.insert( sName.trimmed(), sValue );
                 }
diff -Naurp mythtv-0.24.orig/libs/libmythupnp/soapclient.cpp mythtv-0.24.fixes/libs/libmythupnp/soapclient.cpp
--- mythtv-0.24.orig/libs/libmythupnp/soapclient.cpp	2009-11-17 12:41:55.000000000 -0500
+++ mythtv-0.24.fixes/libs/libmythupnp/soapclient.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -139,7 +139,7 @@ QString SOAPClient::GetNodeValue( QDomNo
         if (!oText.isNull())
             sValue = oText.nodeValue();
 
-        return QUrl::fromPercentEncoding(sValue.toLatin1());
+        return QUrl::fromPercentEncoding(sValue.toUtf8());
     }
 
     return sDefault;
@@ -261,8 +261,8 @@ bool SOAPClient::SendSOAPRequest( const 
                     if (!oText.isNull())
                         sValue = oText.nodeValue();
 
-                    list.insert(QUrl::fromPercentEncoding(sName.toLatin1()),
-                                QUrl::fromPercentEncoding(sValue.toLatin1()));
+                    list.insert(QUrl::fromPercentEncoding(sName.toUtf8()),
+                                QUrl::fromPercentEncoding(sValue.toUtf8()));
                 }
             }
         }
diff -Naurp mythtv-0.24.orig/libs/libmythupnp/threadpool.cpp mythtv-0.24.fixes/libs/libmythupnp/threadpool.cpp
--- mythtv-0.24.orig/libs/libmythupnp/threadpool.cpp	2010-11-03 16:11:10.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythupnp/threadpool.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -326,14 +326,11 @@ ThreadPool::~ThreadPool( )
     while (it != m_lstThreads.end() )
     {
         WorkerThread *pThread = *it;
-
-        if (pThread != NULL)
-            delete pThread;
-
         it = m_lstThreads.erase( it );
-    }
-
 
+        if (pThread != NULL) 
+            pThread->deleteLater();
+    }
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -367,15 +364,13 @@ WorkerThread *ThreadPool::GetWorkerThrea
         // --------------------------------------------------------------
         
         m_mList.lock();
+        if ( m_lstAvailableThreads.size() > 0)
         {
-            if ( m_lstAvailableThreads.size() > 0)
-            {
-                pThread = m_lstAvailableThreads.front();                
-                m_lstAvailableThreads.pop_front();
-            }
-        
-            nThreadCount = m_lstThreads.size();
+            pThread = m_lstAvailableThreads.front();                
+            m_lstAvailableThreads.pop_front();
         }
+        
+        nThreadCount = m_lstThreads.size();
         m_mList.unlock();
 
         if (pThread == NULL)
@@ -411,6 +406,7 @@ WorkerThread *ThreadPool::GetWorkerThrea
 WorkerThread *ThreadPool::AddWorkerThread( bool bMakeAvailable, long nTimeout )
 {
     QString sName = m_sName + "_WorkerThread"; 
+    long nThreadCount;
 
     VERBOSE( VB_UPNP, QString( "ThreadPool:AddWorkerThread - %1" ).arg( sName ));
 
@@ -428,23 +424,21 @@ WorkerThread *ThreadPool::AddWorkerThrea
             // ------------------------------------------------------
 
             m_mList.lock();
-            {
+            m_lstThreads.push_back( pThread );
+            nThreadCount = m_lstThreads.size();
 
-                m_lstThreads.push_back( pThread );
-                
-                if (bMakeAvailable)
-                {
-                    m_lstAvailableThreads.push_back( pThread );
+            VERBOSE(VB_IMPORTANT|VB_EXTRA, QString("ThreadPool:%1: thread pool size %2") .arg(m_sName) .arg(nThreadCount));
                 
-                    m_threadAvail.wakeAll();
-                }
+            if (bMakeAvailable)
+            {
+                m_lstAvailableThreads.push_back( pThread );
+                m_threadAvail.wakeAll();
             }
             m_mList.unlock();
 
         }
         else
         {
-
             // ------------------------------------------------------
             // It's taking longer than 5 seconds to initialize this thread.... 
             // give up on it.
@@ -478,16 +472,21 @@ void ThreadPool::ThreadAvailable ( Worke
 
 void ThreadPool::ThreadTerminating ( WorkerThread *pThread )
 {
+    long nThreadCount;
+
     m_mList.lock();
-    {
-        WorkerThreadList::iterator it =
-            find(m_lstAvailableThreads.begin(),
-                 m_lstAvailableThreads.end(), pThread);
-        m_lstAvailableThreads.erase(it);
+    WorkerThreadList::iterator it = find(m_lstAvailableThreads.begin(),
+                                         m_lstAvailableThreads.end(), pThread);
+    m_lstAvailableThreads.erase(it);
+
+    it = find(m_lstThreads.begin(), m_lstThreads.end(), pThread);
+    m_lstThreads.erase(it);
+
+    nThreadCount = m_lstThreads.size();
+    VERBOSE(VB_IMPORTANT|VB_EXTRA, QString("ThreadPool:%1: thread pool size %2") .arg(m_sName) .arg(nThreadCount));
+
+    pThread->deleteLater();
 
-        // Need to leave in m_lstThreads so that we can
-        // delete the ptr in destructor
-    }
     m_mList.unlock();
 }
 
diff -Naurp mythtv-0.24.orig/libs/libmythupnp/upnpcds.cpp mythtv-0.24.fixes/libs/libmythupnp/upnpcds.cpp
--- mythtv-0.24.orig/libs/libmythupnp/upnpcds.cpp	2010-08-19 14:07:33.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythupnp/upnpcds.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -994,7 +994,7 @@ UPnpCDSExtensionResults *UPnpCDSExtensio
     // ----------------------------------------------------------------------
     
     QString sKey = idPath.last().section( '=', 1, 1 );
-    sKey = QUrl::fromPercentEncoding(sKey.toLatin1());
+    sKey = QUrl::fromPercentEncoding(sKey.toUtf8());
 
     if (sKey.length() > 0)
     {
diff -Naurp mythtv-0.24.orig/libs/libmythupnp/upnpcdsobjects.cpp mythtv-0.24.fixes/libs/libmythupnp/upnpcdsobjects.cpp
--- mythtv-0.24.orig/libs/libmythupnp/upnpcdsobjects.cpp	2010-08-15 02:56:05.000000000 -0400
+++ mythtv-0.24.fixes/libs/libmythupnp/upnpcdsobjects.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -128,7 +128,7 @@ QString CDSObject::GetPropValue(const QS
     Properties::const_iterator it = m_properties.find(sName);
 
     if (it !=  m_properties.end() && *it)
-        return QUrl::fromPercentEncoding((*it)->m_sValue.toLatin1());
+        return QUrl::fromPercentEncoding((*it)->m_sValue.toUtf8());
     
     return "";
 }
diff -Naurp mythtv-0.24.orig/Makefile mythtv-0.24.fixes/Makefile
--- mythtv-0.24.orig/Makefile	2010-10-27 13:41:10.000000000 -0400
+++ mythtv-0.24.fixes/Makefile	2011-03-24 22:18:50.000000000 -0400
@@ -26,6 +26,10 @@ all: version.cpp subdirs
 config.mak:
 	$(error run configure to create $@)
 
+# Override PWD in case this is run from a makefile at a higher level with
+# make -C mythtv
+PWD := $(shell pwd)
+
 version.cpp:	libs/libmythdb/mythversion.h
 	sh version.sh $(PWD)
 
@@ -61,7 +65,7 @@ $(addsuffix _distclean,$(SUBDIRS)): $(ad
 	$(MAKE) -C $(subst _distclean,,$@) distclean
 
 $(addsuffix _install,$(SUBDIRS)): $(addsuffix /Makefile,$(SUBDIRS))
-	$(MAKE) -C $(subst _install,,$@) install
+	$(MAKE) -C $(subst _install,,$@) install INSTALL_ROOT=${INSTALL_ROOT}
 
 $(addsuffix _uninstall,$(SUBDIRS)): $(addsuffix /Makefile,$(SUBDIRS))
 	$(MAKE) -C $(subst _uninstall,,$@) uninstall
diff -Naurp mythtv-0.24.orig/programs/mythbackend/mainserver.cpp mythtv-0.24.fixes/programs/mythbackend/mainserver.cpp
--- mythtv-0.24.orig/programs/mythbackend/mainserver.cpp	2010-10-20 12:15:19.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythbackend/mainserver.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -2237,6 +2237,11 @@ void MainServer::DoHandleStopRecording(
     if (pbs)
         pbssock = pbs->getSocket();
 
+    if (recinfo.GetRecordingStatus() == rsRecording)
+        recinfo.SetRecordingStatus(rsRecorded);
+    else if (recinfo.GetRecordingStatus() != rsRecorded)
+        recinfo.SetRecordingStatus(rsFailed);
+
     if (ismaster && recinfo.GetHostname() != gCoreContext->GetHostName())
     {
         PlaybackSock *slave = GetSlaveByHostname(recinfo.GetHostname());
@@ -2248,7 +2253,6 @@ void MainServer::DoHandleStopRecording(
             if (num > 0)
             {
                 (*encoderList)[num]->StopRecording();
-                recinfo.SetRecordingStatus(rsRecorded);
                 if (m_sched)
                     m_sched->UpdateRecStatus(&recinfo);
             }
@@ -2267,7 +2271,6 @@ void MainServer::DoHandleStopRecording(
             // recording has stopped and the status should be updated.
             // Continue so that the master can try to update the endtime
             // of the file is in a shared directory.
-            recinfo.SetRecordingStatus(rsRecorded);
             if (m_sched)
                 m_sched->UpdateRecStatus(&recinfo);
         }
@@ -2295,7 +2298,6 @@ void MainServer::DoHandleStopRecording(
 
             if (ismaster)
             {
-                recinfo.SetRecordingStatus(rsRecorded);
                 if (m_sched)
                     m_sched->UpdateRecStatus(&recinfo);
             }
@@ -2378,13 +2380,21 @@ void MainServer::DoHandleDeleteRecording
     {
         recinfo.ApplyRecordRecGroupChange("Deleted");
         recinfo.SaveAutoExpire(kDeletedAutoExpire, true);
-        if (recinfo.GetRecordingStatus() == rsRecording)
+        if (recinfo.GetRecordingStatus() == rsRecording ||
+            recinfo.GetRecordingStatus() == rsTuning)
             DoHandleStopRecording(recinfo, NULL);
+        if (forgetHistory)
+            recinfo.ForgetHistory();
         QStringList outputlist( QString::number(0) );
         SendResponse(pbssock, outputlist);
         return;
     }
 
+    if (recinfo.GetRecordingStatus() == rsRecording)
+        recinfo.SetRecordingStatus(rsRecorded);
+    else if (recinfo.GetRecordingStatus() != rsRecorded)
+        recinfo.SetRecordingStatus(rsFailed);
+
     // If this recording was made by a another recorder, and that
     // recorder is available, tell it to do the deletion.
     if (ismaster && recinfo.GetHostname() != gCoreContext->GetHostName())
@@ -2398,7 +2408,6 @@ void MainServer::DoHandleDeleteRecording
             if (num > 0)
             {
                 (*encoderList)[num]->StopRecording();
-                recinfo.SetRecordingStatus(rsRecorded);
                 if (m_sched)
                     m_sched->UpdateRecStatus(&recinfo);
             }
@@ -2439,7 +2448,6 @@ void MainServer::DoHandleDeleteRecording
 
             if (ismaster)
             {
-                recinfo.SetRecordingStatus(rsRecorded);
                 if (m_sched)
                     m_sched->UpdateRecStatus(&recinfo);
             }
diff -Naurp mythtv-0.24.orig/programs/mythbackend/playbacksock.cpp mythtv-0.24.fixes/programs/mythbackend/playbacksock.cpp
--- mythtv-0.24.orig/programs/mythbackend/playbacksock.cpp	2010-09-25 11:10:23.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythbackend/playbacksock.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -242,7 +242,7 @@ QStringList PlaybackSock::GetSGFileList(
     strlist << host;
     strlist << groupname;
     strlist << directory;
-    QString::number(fileNamesOnly);
+    strlist << QString::number(fileNamesOnly);
 
     SendReceiveStringList(strlist);
 
diff -Naurp mythtv-0.24.orig/programs/mythbackend/scheduler.cpp mythtv-0.24.fixes/programs/mythbackend/scheduler.cpp
--- mythtv-0.24.orig/programs/mythbackend/scheduler.cpp	2010-10-28 20:20:24.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythbackend/scheduler.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -1820,6 +1820,8 @@ void Scheduler::RunScheduler(void)
 
                 if (firstRun)
                 {
+                    firstRun = false;
+
                     //the parameter given to the startup_cmd. "user" means a user
                     // started the BE, 'auto' means it was started automatically
                     QString startupParam = "user";
@@ -1853,9 +1855,12 @@ void Scheduler::RunScheduler(void)
                     if (!startupCommand.isEmpty())
                     {
                         startupCommand.replace("$status", startupParam);
+                        schedLock.unlock();
                         myth_system(startupCommand);
+                        schedLock.lock();
+                        if (reclist_changed)
+                            continue;
                     }
-                    firstRun = false;
                 }
 
                 PutInactiveSlavesToSleep();
@@ -2428,10 +2433,12 @@ void Scheduler::ShutdownServer(int prero
                                     "this computer :-\n\t\t\t\t\t\t") + halt_cmd);
 
         // and now shutdown myself
-        if (!myth_system(halt_cmd))
+        schedLock.unlock();
+        unsigned int res = myth_system(halt_cmd);
+        schedLock.lock();
+        if (!res)
             return;
-        else
-            VERBOSE(VB_IMPORTANT, "ServerHaltCommand failed, shutdown aborted");
+        VERBOSE(VB_IMPORTANT, "ServerHaltCommand failed, shutdown aborted");
     }
 
     // If we make it here then either the shutdown failed
diff -Naurp mythtv-0.24.orig/programs/mythfrontend/exitprompt.cpp mythtv-0.24.fixes/programs/mythfrontend/exitprompt.cpp
--- mythtv-0.24.orig/programs/mythfrontend/exitprompt.cpp	2010-08-29 18:22:36.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythfrontend/exitprompt.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -12,6 +12,7 @@
 #include "mythmainwindow.h"
 #include "mythscreenstack.h"
 #include "mythsystem.h"
+#include "mythverbose.h"
 
 void ExitPrompter::quit()
 {
@@ -62,16 +63,18 @@ static bool DBusHalt(void)
 
 void ExitPrompter::halt()
 {
-
     QString halt_cmd = gCoreContext->GetSetting("HaltCommand","");
+    int ret = -1;
+
     if (!halt_cmd.isEmpty()) /* Use user specified command if it exists */
     {
-        myth_system(halt_cmd);
-    } else if (!DBusHalt()) /* If supported, use DBus to shutdown */
-    {
-        myth_system("sudo /sbin/halt -p"); 
+        ret = myth_system(halt_cmd);
+        if (ret != 0)
+            VERBOSE(VB_IMPORTANT, "User defined HaltCommand failed, falling back to alternative methods.");
     }
 
+    if (ret != 0 && !DBusHalt()) /* If supported, use DBus to shutdown */
+        myth_system("sudo /sbin/halt -p"); 
 }
 
 static bool DBusReboot(void)
@@ -118,16 +121,18 @@ static bool DBusReboot(void)
 
 void ExitPrompter::reboot()
 {
-
     QString reboot_cmd = gCoreContext->GetSetting("RebootCommand","");
+    int ret = -1;
+
     if (!reboot_cmd.isEmpty()) /* Use user specified command if it exists */
     {
-        myth_system(reboot_cmd);
-    } else if (!DBusReboot()) /* If supported, use DBus to reboot */
-    {
-        myth_system("sudo /sbin/reboot");
+        ret = myth_system(reboot_cmd);
+        if (ret != 0)
+            VERBOSE(VB_IMPORTANT, "User defined RebootCommand failed, falling back to alternative methods.");
     }
 
+    if (ret != 0 && !DBusReboot()) /* If supported, use DBus to reboot */
+        myth_system("sudo /sbin/reboot");
 }
 
 void ExitPrompter::handleExit()
diff -Naurp mythtv-0.24.orig/programs/mythfrontend/globalsettings.cpp mythtv-0.24.fixes/programs/mythfrontend/globalsettings.cpp
--- mythtv-0.24.orig/programs/mythfrontend/globalsettings.cpp	2010-10-14 15:35:44.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythfrontend/globalsettings.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -118,7 +118,8 @@ AudioConfigSettings::AudioConfigSettings
     VerticalConfigurationGroup(false, true, false, false),
     m_OutputDevice(NULL),   m_MaxAudioChannels(NULL),
     m_AudioUpmix(NULL),     m_AudioUpmixType(NULL),
-    m_AC3PassThrough(NULL), m_DTSPassThrough(NULL),  m_MPCM(NULL)
+    m_AC3PassThrough(NULL), m_DTSPassThrough(NULL),  m_MPCM(NULL),
+    m_AdvancedAudioSettings(NULL),                   m_PassThroughOverride(NULL)
 {
     setLabel(QObject::tr("Audio System"));
     setUseLabel(false);
@@ -144,51 +145,43 @@ AudioConfigSettings::AudioConfigSettings
     devices.append(*adc);
     delete adc;
 
-    m_triggerAC3 = new TransCheckBoxSetting();
-    m_AC3PassThrough = AC3PassThrough();
-    TriggeredItem *subAC3 = new TriggeredItem(m_triggerAC3, m_AC3PassThrough);
-
-    m_triggerDTS = new TransCheckBoxSetting();
-    m_DTSPassThrough = DTSPassThrough();
-    TriggeredItem *subDTS = new TriggeredItem(m_triggerDTS, m_DTSPassThrough);
-
-    m_triggerMPCM = new TransCheckBoxSetting();
-    m_MPCM = MPCM();
-    TriggeredItem *subMPCM = new TriggeredItem(m_triggerMPCM, m_MPCM);
-
     ConfigurationGroup *maingroup = new VerticalConfigurationGroup(false,
                                                                    false);
     addChild(maingroup);
 
+    m_triggerDigital = new TransCheckBoxSetting();
+    m_AC3PassThrough = AC3PassThrough();
+    m_DTSPassThrough = DTSPassThrough();
+
     m_cgsettings = new HorizontalConfigurationGroup();
-    m_cgsettings->setLabel(QObject::tr("Audio Capabilities"));
+    m_cgsettings->setLabel(QObject::tr("Digital Audio Capabilities"));
+    m_cgsettings->addChild(m_AC3PassThrough);
+    m_cgsettings->addChild(m_DTSPassThrough);
 
-    m_cgsettings->addChild(subMPCM);
-    m_cgsettings->addChild(subAC3);
-    m_cgsettings->addChild(subDTS);
+    TriggeredItem *sub1 = new TriggeredItem(m_triggerDigital, m_cgsettings);
 
-    maingroup->addChild(m_cgsettings);
+    maingroup->addChild(sub1);
 
     maingroup->addChild((m_MaxAudioChannels = MaxAudioChannels()));
     maingroup->addChild((m_AudioUpmix = AudioUpmix()));
     maingroup->addChild((m_AudioUpmixType = AudioUpmixType()));
 
-    Setting *advancedsettings = AdvancedAudioSettings();
-    addChild(advancedsettings);
+    m_AdvancedAudioSettings = AdvancedAudioSettings();
+    addChild(m_AdvancedAudioSettings);
 
     ConfigurationGroup *group2 =
         new VerticalConfigurationGroup(false);
 
-    TriggeredItem *sub2 = new TriggeredItem(advancedsettings, group2);
+    TriggeredItem *sub2 = new TriggeredItem(m_AdvancedAudioSettings, group2);
     addChild(sub2);
 
     ConfigurationGroup *settings3 =
         new HorizontalConfigurationGroup(false, false);
 
-    Setting *passthroughoverride = PassThroughOverride();
+    m_PassThroughOverride = PassThroughOverride();
     TriggeredItem *sub3 =
-        new TriggeredItem(passthroughoverride, PassThroughOutputDevice());
-    settings3->addChild(passthroughoverride);
+        new TriggeredItem(m_PassThroughOverride, PassThroughOutputDevice());
+    settings3->addChild(m_PassThroughOverride);
     settings3->addChild(sub3);
 
     ConfigurationGroup *settings4 =
@@ -203,9 +196,18 @@ AudioConfigSettings::AudioConfigSettings
         new HorizontalConfigurationGroup(false, false);
     settings5->addChild(Audio48kOverride());
 
+    m_triggerMPCM = new TransCheckBoxSetting();
+    m_MPCM = MPCM();
+    TriggeredItem *subMPCM = new TriggeredItem(m_triggerMPCM, m_MPCM);
+
+    ConfigurationGroup *settings6 =
+        new HorizontalConfigurationGroup(false, false);
+    settings6->addChild(subMPCM);
+
     group2->addChild(settings4);
     group2->addChild(settings5);
     group2->addChild(settings3);
+    group2->addChild(settings6);
 
         // Set slots
     connect(m_MaxAudioChannels, SIGNAL(valueChanged(const QString&)),
@@ -218,6 +220,10 @@ AudioConfigSettings::AudioConfigSettings
             this, SLOT(UpdateCapabilities(const QString&)));
     connect(m_MPCM, SIGNAL(valueChanged(const QString&)),
             this, SLOT(UpdateCapabilities(const QString&)));
+    connect(m_PassThroughOverride, SIGNAL(valueChanged(const QString&)),
+            this, SLOT(UpdateCapabilities(const QString&)));
+    connect(m_AdvancedAudioSettings, SIGNAL(valueChanged(const QString&)),
+            this, SLOT(UpdateCapabilities(const QString&)));
 }
 
 void AudioConfigSettings::AudioRescan()
@@ -271,19 +277,22 @@ void AudioConfigSettings::UpdateVisibili
 
 void AudioConfigSettings::UpdateCapabilities(const QString &device)
 {
-   int max_speakers = 8;
+    int max_speakers = 8;
     bool invalid = false;
-    int passthrough = 0;
     AudioOutputSettings settings;
 
         // Test if everything is set yet
-    if (!m_OutputDevice   || !m_MaxAudioChannels ||
-        !m_AC3PassThrough || !m_DTSPassThrough   || !m_MPCM)
+    if (!m_OutputDevice   || !m_MaxAudioChannels || !m_AdvancedAudioSettings || 
+        !m_AC3PassThrough || !m_DTSPassThrough   || !m_MPCM ||
+        !m_PassThroughOverride)
         return;
 
     if (!slotlock.tryLock()) // Doing a rescan of channels
         return;
 
+    bool bForceDigital = (m_AdvancedAudioSettings->boolValue() &&
+                          m_PassThroughOverride->boolValue());
+
     QString out = m_OutputDevice->getValue();
     if (!audiodevs.contains(out))
     {
@@ -296,44 +305,24 @@ void AudioConfigSettings::UpdateCapabili
 
         max_speakers = settings.BestSupportedChannels();
 
-        bool bAC3  = settings.canAC3() && m_AC3PassThrough->boolValue();
-        bool bDTS  = settings.canDTS() && m_DTSPassThrough->boolValue();
+        bool bAC3  = (settings.canAC3() || bForceDigital) &&
+            m_AC3PassThrough->boolValue();
+        bool bDTS  = (settings.canDTS() || bForceDigital) &&
+            m_DTSPassThrough->boolValue();
         bool bLPCM = settings.canPassthrough() == -1 ||
-            (settings.canLPCM() && m_MPCM->boolValue());
+            (settings.canLPCM() &&
+             !(m_AdvancedAudioSettings->boolValue() && m_MPCM->boolValue()));
 
         if (max_speakers > 2 && !bLPCM)
             max_speakers = 2;
         if (max_speakers == 2 && (bAC3 || bDTS))
             max_speakers = 6;
-        passthrough = settings.canPassthrough();
     }
 
-    m_triggerAC3->setValue(invalid || settings.canAC3());
-    m_triggerDTS->setValue(invalid || settings.canDTS());
-
-    m_MPCM->setEnabled(invalid || (settings.canLPCM() &&
-                                   settings.canPassthrough() >= 0));
-    switch (passthrough)
-    {
-        case -1:
-            m_MPCM->setLabel(QObject::tr("No digital passthrough"));
-            break;
-        case 1:
-            m_MPCM->setLabel(QObject::tr("LPCM"));
-            m_MPCM->setHelpText(QObject::tr(
-                            "Enable if your amplifier or TV supports "
-                            "multi-channel LPCM. If unchecked Dolby Digital "
-                            "support is required for multi-channel audio"));
-            break;
-        default:
-            m_MPCM->setLabel(QObject::tr("Analog or LPCM"));
-            m_MPCM->setHelpText(QObject::tr(
-                            "Enable if analog output or if your amplifier "
-                            "or TV supports multi-channel LPCM. "
-                            "If unchecked with digital output, Dolby Digital "
-                            "support is required for multi-channel audio"));
-            break;
-    }
+    m_triggerDigital->setValue(invalid || bForceDigital ||
+                               settings.canAC3() || settings.canDTS());
+    m_triggerMPCM->setValue(invalid || (settings.canLPCM() &&
+                                        settings.canPassthrough() >= 0));
 
     int cur_speakers = m_MaxAudioChannels->getValue().toInt();
 
@@ -348,7 +337,8 @@ void AudioConfigSettings::UpdateCapabili
     m_MaxAudioChannels->resetMaxCount(3);
     for (int i = 1; i <= max_speakers; i++)
     {
-        if (invalid || settings.IsSupportedChannels(i))
+        if (invalid || settings.IsSupportedChannels(i) ||
+            (bForceDigital && i == 6))
         {
             QString txt;
 
@@ -430,8 +420,13 @@ HostCheckBox *AudioConfigSettings::DTSPa
 
 HostCheckBox *AudioConfigSettings::MPCM()
 {
-    HostCheckBox *gc = new HostCheckBox("MultiChannelPCM");
+    HostCheckBox *gc = new HostCheckBox("StereoPCM");
+    gc->setLabel(QObject::tr("Stereo PCM Only"));
     gc->setValue(false);
+    gc->setHelpText(QObject::tr("Enable if your amplifier or sound decoder "
+                    "only supports 2 channels PCM (typically an old HDMI 1.0 "
+                    "device). Multi-channels audio will be re-encoded to AC3 "
+                    "when required"));
     return gc;
 }
 
diff -Naurp mythtv-0.24.orig/programs/mythfrontend/globalsettings.h mythtv-0.24.fixes/programs/mythfrontend/globalsettings.h
--- mythtv-0.24.orig/programs/mythfrontend/globalsettings.h	2010-07-01 03:29:22.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythfrontend/globalsettings.h	2011-03-24 22:18:50.000000000 -0400
@@ -51,12 +51,13 @@ class AudioConfigSettings : public Verti
     HostComboBox         *m_MaxAudioChannels;
     HostCheckBox         *m_AudioUpmix;
     HostComboBox         *m_AudioUpmixType;
-    TransCheckBoxSetting *m_triggerAC3;
-    TransCheckBoxSetting *m_triggerDTS;
+    TransCheckBoxSetting *m_triggerDigital;
     TransCheckBoxSetting *m_triggerMPCM;
     HostCheckBox         *m_AC3PassThrough;
     HostCheckBox         *m_DTSPassThrough;
     HostCheckBox         *m_MPCM;
+    HostCheckBox         *m_AdvancedAudioSettings;
+    HostCheckBox         *m_PassThroughOverride;
     ADCMap                audiodevs;
     AudioOutput::ADCVect  devices;
     QMutex                slotlock;
diff -Naurp mythtv-0.24.orig/programs/mythfrontend/guidegrid.cpp mythtv-0.24.fixes/programs/mythfrontend/guidegrid.cpp
--- mythtv-0.24.orig/programs/mythfrontend/guidegrid.cpp	2010-10-29 05:17:38.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythfrontend/guidegrid.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -264,9 +264,6 @@ GuideGrid::GuideGrid(MythScreenStack *pa
     m_currentStartTime = m_originalStartTime.addSecs(secsoffset);
     m_startChanID  = chanid;
     m_startChanNum = channum;
-
-    if (m_player)
-        m_embedVideo = m_player->IsRunning() && m_embedVideo;
 }
 
 bool GuideGrid::Create()
@@ -2200,7 +2197,7 @@ void GuideGrid::EmbedTVWindow(void)
 
 void GuideGrid::refreshVideo(void)
 {
-    if (m_player && m_player->IsRunning() && m_usingNullVideo)
+    if (m_player && m_usingNullVideo)
     {
         GetMythMainWindow()->GetPaintWindow()->update(m_videoRect);
     }
@@ -2216,7 +2213,7 @@ void GuideGrid::aboutToHide(void)
 
 void GuideGrid::aboutToShow(void)
 {
-    if (m_player && m_player->IsRunning())
+    if (m_player)
         EmbedTVWindow();
 
     MythScreenType::aboutToShow();
diff -Naurp mythtv-0.24.orig/programs/mythfrontend/playbackbox.cpp mythtv-0.24.fixes/programs/mythfrontend/playbackbox.cpp
--- mythtv-0.24.orig/programs/mythfrontend/playbackbox.cpp	2010-10-15 06:40:36.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythfrontend/playbackbox.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -4336,12 +4336,21 @@ void PlaybackBox::showGroupFilter(void)
     {
         connect(recGroupPopup, SIGNAL(result(QString)),
                 SLOT(displayRecGroup(QString)));
+        connect(recGroupPopup, SIGNAL(Exiting()),
+                SLOT(groupSelectorClosed()));
         m_popupStack->AddScreen(recGroupPopup);
     }
     else
         delete recGroupPopup;
 }
 
+void PlaybackBox::groupSelectorClosed(void)
+{
+    if ((gCoreContext->GetNumSetting("QueryInitialFilter", 0) == 1) &&
+        ((m_titleList.size() <= 1)))
+        Close();
+}
+
 void PlaybackBox::setGroupFilter(const QString &recGroup)
 {
     QString newRecGroup = recGroup;
@@ -4582,7 +4591,7 @@ void PlaybackBox::saveRecMetadata(const 
     QString groupname = m_groupList->GetItemCurrent()->GetData().toString();
 
     if (groupname == pginfo->GetTitle().toLower() &&
-        newTitle != groupname)
+        newTitle != pginfo->GetTitle())
     {
         m_recordingList->RemoveItem(item);
     }
@@ -4596,8 +4605,6 @@ void PlaybackBox::saveRecMetadata(const 
         item->SetText(tempSubTitle, "titlesubtitle");
         item->SetText(newTitle, "title");
         item->SetText(newSubtitle, "subtitle");
-
-        UpdateUIListItem(item, true); // Why?
     }
 
     RecordingInfo ri(*pginfo);
@@ -4813,6 +4820,10 @@ void GroupSelector::AcceptItem(MythUIBut
     if (!item)
         return;
 
+    // ignore the dividers
+    if (item->GetData().toString().isEmpty())
+        return;
+
     QString group = item->GetData().toString();
     emit result(group);
     Close();
diff -Naurp mythtv-0.24.orig/programs/mythfrontend/playbackbox.h mythtv-0.24.fixes/programs/mythfrontend/playbackbox.h
--- mythtv-0.24.orig/programs/mythfrontend/playbackbox.h	2010-09-12 17:43:56.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythfrontend/playbackbox.h	2011-03-24 22:18:50.000000000 -0400
@@ -134,6 +134,7 @@ class PlaybackBox : public ScheduleCommo
 
   public slots:
     void displayRecGroup(const QString &newRecGroup = "");
+    void groupSelectorClosed(void);
 
   protected slots:
     void updateRecList(MythUIButtonListItem *);
diff -Naurp mythtv-0.24.orig/programs/mythfrontend/progfind.cpp mythtv-0.24.fixes/programs/mythfrontend/progfind.cpp
--- mythtv-0.24.orig/programs/mythfrontend/progfind.cpp	2010-10-29 05:17:38.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythfrontend/progfind.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -567,7 +567,8 @@ void ProgFinder::selectShowData(QString 
 
     MSqlBindings bindings;
     QString querystr = "WHERE program.title = :TITLE "
-                       "  AND program.endtime > :ENDTIME ";
+                       "  AND program.endtime > :ENDTIME "
+                       "  AND channel.visible = 1 ";
     bindings[":TITLE"] = progTitle;
     bindings[":ENDTIME"] = progStart.toString("yyyy-MM-ddThh:mm:50");
 
@@ -602,12 +603,14 @@ void ProgFinder::whereClauseGetSearchDat
 
     if (searchChar.contains('@'))
     {
-        where = "SELECT DISTINCT title FROM program WHERE ( "
-                   "title NOT REGEXP '^[A-Z0-9]' AND "
-                   "title NOT REGEXP '^The [A-Z0-9]' AND "
-                   "title NOT REGEXP '^A [A-Z0-9]' AND "
-                   "title NOT REGEXP '^An [A-Z0-9]' AND "
-                   "starttime > :STARTTIME ) ";
+        where = "SELECT DISTINCT title FROM program "
+                "LEFT JOIN channel ON program.chanid = channel.chanid "
+                "WHERE channel.visible = 1 AND "
+                "( title NOT REGEXP '^[A-Z0-9]' AND "
+                "  title NOT REGEXP '^The [A-Z0-9]' AND "
+                "  title NOT REGEXP '^A [A-Z0-9]' AND "
+                "  title NOT REGEXP '^An [A-Z0-9]' AND "
+                "  starttime > :STARTTIME ) ";
         if (!m_searchStr.isEmpty())
         {
             where += "AND title LIKE :SEARCH ";
@@ -625,11 +628,12 @@ void ProgFinder::whereClauseGetSearchDat
         QString three = QString("A ") + one;
         QString four = QString("An ") + one;
 
-        where = "SELECT DISTINCT title "
-                "FROM program "
-                "WHERE ( title LIKE :ONE OR title LIKE :TWO "
-                "        OR title LIKE :THREE "
-                "        OR title LIKE :FOUR ) "
+        where = "SELECT DISTINCT title FROM program "
+                "LEFT JOIN channel ON program.chanid = channel.chanid "
+                "WHERE channel.visible = 1 "
+                "AND ( title LIKE :ONE OR title LIKE :TWO "
+                "      OR title LIKE :THREE "
+                "      OR title LIKE :FOUR ) "
                 "AND starttime > :STARTTIME ";
         if (!m_searchStr.isEmpty())
             where += "AND title LIKE :SEARCH ";
@@ -782,44 +786,46 @@ void JaProgFinder::whereClauseGetSearchD
     QDateTime progStart = QDateTime::currentDateTime();
     int charNum = m_alphabetList->GetCurrentPos();
 
-    where = "SELECT DISTINCT title FROM program ";
+    where = "SELECT DISTINCT title FROM program "
+            "LEFT JOIN channel ON program.chanid = channel.chanid "
+            "WHERE channel.visible = 1 ";
 
     switch (charNum) {
     case 0:
-        where += "WHERE ( title_pronounce >= '걗' AND title_pronounce <= '걡') ";
+        where += "AND ( title_pronounce >= '걗' AND title_pronounce <= '걡') ";
         break;
     case 1:
-        where += "WHERE ( title_pronounce >= '걢' AND title_pronounce <= '걫') ";
+        where += "AND ( title_pronounce >= '걢' AND title_pronounce <= '걫') ";
         break;
     case 2:
-        where += "WHERE ( title_pronounce >= '걬' AND title_pronounce <= '걹') ";
+        where += "AND ( title_pronounce >= '걬' AND title_pronounce <= '걹') ";
         break;
     case 3:
-        where += "WHERE ( title_pronounce >= '걼' AND title_pronounce <= '겑') ";
+        where += "AND ( title_pronounce >= '걼' AND title_pronounce <= '겑') ";
         break;
     case 4:
-        where += "WHERE ( title_pronounce >= '겒' AND title_pronounce <= '겗') ";
+        where += "AND ( title_pronounce >= '겒' AND title_pronounce <= '겗') ";
         break;
     case 5:
-        where += "WHERE ( title_pronounce >= '겘' AND title_pronounce <= '겱') ";
+        where += "AND ( title_pronounce >= '겘' AND title_pronounce <= '겱') ";
         break;
     case 6:
-        where += "WHERE ( title_pronounce >= '겲' AND title_pronounce <= '굚') ";
+        where += "AND ( title_pronounce >= '겲' AND title_pronounce <= '굚') ";
         break;
     case 7:
-        where += "WHERE ( title_pronounce >= '굜' AND title_pronounce <= '굠') ";
+        where += "AND ( title_pronounce >= '굜' AND title_pronounce <= '굠') ";
         break;
     case 8:
-        where += "WHERE ( title_pronounce >= '굢' AND title_pronounce <= '굧') ";
+        where += "AND ( title_pronounce >= '굢' AND title_pronounce <= '굧') ";
         break;
     case 9:
-        where += "WHERE ( title_pronounce >= '굩' AND title_pronounce <= '굯') ";
+        where += "AND ( title_pronounce >= '굩' AND title_pronounce <= '굯') ";
         break;
     case 10:
-        where += "WHERE ( title_pronounce >= '竊' AND title_pronounce <= '節') ";
+        where += "AND ( title_pronounce >= '竊' AND title_pronounce <= '節') ";
         break;
     case 11:
-        where += "WHERE ( title_pronounce >= '竊' AND title_pronounce <= '竊') ";
+        where += "AND ( title_pronounce >= '竊' AND title_pronounce <= '竊') ";
         break;
     }
 
@@ -890,21 +896,23 @@ void HeProgFinder::whereClauseGetSearchD
     if (searchChar.isEmpty())
         searchChar = searchChars[0];
 
-    where = "SELECT DISTINCT title FROM program ";
+    where = "SELECT DISTINCT title FROM program "
+            "LEFT JOIN channel ON program.chanid = channel.chanid "
+            "WHERE channel.visible = 1 ";
 
     if (searchChar.contains('E'))
     {
-        where += "WHERE ( title REGEXP '^[A-Z]') ";
+        where += "AND ( title REGEXP '^[A-Z]') ";
     }
     else if (searchChar.contains('#'))
     {
-        where += "WHERE ( title REGEXP '^[0-9]') ";
+        where += "AND ( title REGEXP '^[0-9]') ";
     }
     else
     {
         QString one = searchChar + '%';
         bindings[":ONE"] = one;
-        where += "WHERE ( title LIKE :ONE ) ";
+        where += "AND ( title LIKE :ONE ) ";
     }
 
     where += "AND starttime > :STARTTIME ";
@@ -982,7 +990,10 @@ void RuProgFinder::whereClauseGetSearchD
 
   if (searchChar.contains('@'))
    {
-       where = "SELECT DISTINCT title FROM program WHERE ( "
+       where = "SELECT DISTINCT title FROM program "
+               "LEFT JOIN channel ON program.chanid = channel.chanid "
+               "WHERE channel.visible = 1 AND "
+               "( "
                   "title NOT REGEXP '^[A-Z0-9]' AND "
                   "title NOT REGEXP '^The [A-Z0-9]' AND "
                   "title NOT REGEXP '^A [A-Z0-9]' AND "
@@ -1006,12 +1017,13 @@ void RuProgFinder::whereClauseGetSearchD
        QString four = QString("An ") + one;
        QString five = QString("\"") + one;
 
-       where = "SELECT DISTINCT title "
-               "FROM program "
-               "WHERE ( title LIKE :ONE OR title LIKE :TWO "
-               "        OR title LIKE :THREE "
-               "        OR title LIKE :FOUR  "
-               "        OR title LIKE :FIVE )"
+       where = "SELECT DISTINCT title FROM program "
+               "LEFT JOIN channel ON program.chanid = channel.chanid "
+               "WHERE channel.visible = 1 "
+               "AND ( title LIKE :ONE OR title LIKE :TWO "
+               "      OR title LIKE :THREE "
+               "      OR title LIKE :FOUR  "
+               "      OR title LIKE :FIVE )"
                "AND starttime > :STARTTIME ";
        if (!m_searchStr.isEmpty())
            where += "AND title LIKE :SEARCH ";
diff -Naurp mythtv-0.24.orig/programs/mythfrontend/proglist.cpp mythtv-0.24.fixes/programs/mythfrontend/proglist.cpp
--- mythtv-0.24.orig/programs/mythfrontend/proglist.cpp	2010-09-07 16:02:40.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythfrontend/proglist.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -113,7 +113,7 @@ ProgLister::ProgLister(
 
     m_allowEvents(true),
     m_titleSort(false),
-    m_reverseSort(false),
+    m_reverseSort(true),
     m_useGenres(false),
 
     m_schedText(NULL),
@@ -1056,7 +1056,12 @@ void ProgLister::FillViewList(const QStr
         m_curView = m_viewList.size() - 1;
 }
 
-typedef binary_function<const ProgramInfo*, const ProgramInfo*, bool> plCompare;
+class plCompare : binary_function<const ProgramInfo*, const ProgramInfo*, bool>
+{
+    public:
+        virtual bool operator()(const ProgramInfo *a, const ProgramInfo *b)
+            = 0;
+};
 
 class plTitleSort : public plCompare
 {
@@ -1363,7 +1368,12 @@ void ProgLister::FillItemList(bool resto
     ProgramInfo        selected;
     const ProgramInfo *selectedP = (restorePosition) ? GetCurrent() : NULL;
     if (selectedP)
+    {
         selected = *selectedP;
+        selectedP = &selected;
+    }
+    int selectedOffset = 
+        m_progList->GetCurrentPos() - m_progList->GetTopItemPos();
 
     m_progList->Reset();
     m_itemList.clear();
@@ -1415,7 +1425,7 @@ void ProgLister::FillItemList(bool resto
         SortList(GetSortBy(), m_reverseSort);
 
     if (updateDisp)
-        UpdateDisplay(selected);
+        UpdateDisplay(selectedP, selectedOffset);
 }
 
 ProgLister::SortBy ProgLister::GetSortBy(void) const
@@ -1477,19 +1487,37 @@ void ProgLister::UpdateDisplay(void)
     UpdateButtonList();
 }
 
-void ProgLister::UpdateDisplay(const ProgramInfo & selected)
+void ProgLister::UpdateDisplay(const ProgramInfo *selected, int selectedOffset)
 {
     UpdateDisplay();
 
+    if (!selected)
+        return;
+
     // Restore selection
-    for (uint i = 0; i < m_itemList.size(); i++)
+    plCompare *comp;
+    if (!m_titleSort)
+        comp = new plTimeSort();
+    else if (m_type == plPreviouslyRecorded)
+        comp = new plPrevTitleSort();
+    else
+        comp = new plTitleSort();
+
+    int i;
+    for (i = m_itemList.size() - 2; i >= 0; i--)
     {
-        if (selected.IsSameProgramWeakCheck(*(m_itemList[i])))
-        {
-            m_progList->SetItemCurrent(i);
+        bool dobreak;
+        if (m_reverseSort)
+            dobreak = comp->operator()(selected, m_itemList[i]);
+        else
+            dobreak = comp->operator()(m_itemList[i], selected);
+        if (dobreak)
             break;
-        }
     }
+
+    delete comp;
+
+    m_progList->SetItemCurrent(i + 1, i + 1 - selectedOffset);
 }
 
 void ProgLister::UpdateButtonList(void)
diff -Naurp mythtv-0.24.orig/programs/mythfrontend/proglist.h mythtv-0.24.fixes/programs/mythfrontend/proglist.h
--- mythtv-0.24.orig/programs/mythfrontend/proglist.h	2010-08-01 16:11:43.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythfrontend/proglist.h	2011-03-24 22:18:50.000000000 -0400
@@ -77,7 +77,7 @@ class ProgLister : public ScheduleCommon
 
     void ClearCurrentProgramInfo(void);
     void UpdateDisplay(void);
-    void UpdateDisplay(const ProgramInfo & selected);
+    void UpdateDisplay(const ProgramInfo *selected, int selectedOffset);
     void UpdateButtonList(void);
     void UpdateKeywordInDB(const QString &text, const QString &oldValue);
 
diff -Naurp mythtv-0.24.orig/programs/mythfrontend/programrecpriority.cpp mythtv-0.24.fixes/programs/mythfrontend/programrecpriority.cpp
--- mythtv-0.24.orig/programs/mythfrontend/programrecpriority.cpp	2010-08-19 15:45:44.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythfrontend/programrecpriority.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -426,7 +426,7 @@ bool ProgramRecPriority::Create()
     m_rectypePriorityText = dynamic_cast<MythUIText *>
                                                  (GetChild("rectypepriority"));
     m_recPriorityText = dynamic_cast<MythUIText *> (GetChild("recpriority"));
-    m_recPriorityBText = dynamic_cast<MythUIText *> (GetChild("recpriorityb"));
+    m_recPriorityBText = dynamic_cast<MythUIText *> (GetChild("recpriorityB"));
     m_finalPriorityText = dynamic_cast<MythUIText *> (GetChild("finalpriority"));
     m_recGroupText = dynamic_cast<MythUIText *> (GetChild("recordinggroup"));
     m_storageGroupText = dynamic_cast<MythUIText *> (GetChild("storagegroup"));
@@ -1111,12 +1111,30 @@ void ProgramRecPriority::changeRecPriori
         {
             // No need to re-fill the entire list, just update this entry
             int progRecPriority = pgRecInfo->GetRecordingPriority();
+            int autorecpri = pgRecInfo->autoRecPriority;
             int finalRecPriority = progRecPriority +
-                                    pgRecInfo->autoRecPriority +
+                                    autorecpri +
                                     pgRecInfo->recTypeRecPriority;
 
             item->SetText(QString::number(progRecPriority), "progpriority");
             item->SetText(QString::number(finalRecPriority), "finalpriority");
+
+            if (m_recPriorityText)
+            {
+                QString msg = QString::number(progRecPriority);
+
+                if(autorecpri != 0)
+                    msg += tr(" + %1 automatic priority (%2hr)")
+                                .arg(autorecpri).arg(pgRecInfo->avg_delay);
+                m_recPriorityText->SetText(msg);
+            }
+
+            if (m_recPriorityBText)
+                m_recPriorityBText->SetText(QString::number(progRecPriority +
+                                                            autorecpri));
+
+            if (m_finalPriorityText)
+                m_finalPriorityText->SetText(QString::number(finalRecPriority));
         }
     }
 }
@@ -1572,7 +1590,7 @@ void ProgramRecPriority::updateInfo(Myth
 
         if(autorecpri != 0)
             msg += tr(" + %1 automatic priority (%2hr)")
-                        .arg(autorecpri).arg((pgRecInfo->avg_delay));
+                        .arg(autorecpri).arg(pgRecInfo->avg_delay);
         m_recPriorityText->SetText(msg);
     }
 
diff -Naurp mythtv-0.24.orig/programs/mythtranscode/mpeg2fix.cpp mythtv-0.24.fixes/programs/mythtranscode/mpeg2fix.cpp
--- mythtv-0.24.orig/programs/mythtranscode/mpeg2fix.cpp	2010-08-29 18:22:36.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythtranscode/mpeg2fix.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -836,7 +836,7 @@ void MPEG2fixup::AddSequence(MPEG2frame 
     }
 }
 
-bool MPEG2fixup::ProcessVideo(MPEG2frame *vf, mpeg2dec_t *dec)
+int MPEG2fixup::ProcessVideo(MPEG2frame *vf, mpeg2dec_t *dec)
 {
     int state = -1;
     int last_pos = 0;
diff -Naurp mythtv-0.24.orig/programs/mythtranscode/mpeg2fix.h mythtv-0.24.fixes/programs/mythtranscode/mpeg2fix.h
--- mythtv-0.24.orig/programs/mythtranscode/mpeg2fix.h	2010-08-23 12:54:20.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythtranscode/mpeg2fix.h	2011-03-24 22:18:50.000000000 -0400
@@ -172,7 +172,7 @@ class MPEG2fixup
     int AddFrame(MPEG2frame *f);
     int InitAV(const char *inputfile, const char *type, int64_t offset);
     void ScanAudio();
-    bool ProcessVideo(MPEG2frame *vf, mpeg2dec_t *dec);
+    int ProcessVideo(MPEG2frame *vf, mpeg2dec_t *dec);
     void WriteFrame(const char *filename, MPEG2frame *f);
     void WriteFrame(const char *filename, AVPacket *pkt);
     void WriteYUV(const char *filename, const mpeg2_info_t *info);
diff -Naurp mythtv-0.24.orig/programs/mythtranscode/replex/.gitignore mythtv-0.24.fixes/programs/mythtranscode/replex/.gitignore
--- mythtv-0.24.orig/programs/mythtranscode/replex/.gitignore	1969-12-31 19:00:00.000000000 -0500
+++ mythtv-0.24.fixes/programs/mythtranscode/replex/.gitignore	2011-03-24 22:18:50.000000000 -0400
@@ -0,0 +1 @@
+mythreplex
diff -Naurp mythtv-0.24.orig/programs/mythtranscode/transcode.cpp mythtv-0.24.fixes/programs/mythtranscode/transcode.cpp
--- mythtv-0.24.orig/programs/mythtranscode/transcode.cpp	2010-09-23 02:38:05.000000000 -0400
+++ mythtv-0.24.fixes/programs/mythtranscode/transcode.cpp	2011-03-24 22:18:50.000000000 -0400
@@ -59,13 +59,10 @@ class AudioReencodeBuffer : public Audio
     virtual void Reconfigure(const AudioSettings &settings)
     {
         ClearError();
-        bytes_per_frame = channels *
-                           AudioOutputSettings::SampleSize(settings.format);
 
         channels = settings.channels;
-
-        if ((uint)settings.channels > 2)
-            Error(QString("Invalid channel count %1").arg(channels));
+        bytes_per_frame = channels *
+                           AudioOutputSettings::SampleSize(settings.format);
     }
 
     // dsprate is in 100 * samples/second
@@ -115,7 +112,7 @@ class AudioReencodeBuffer : public Audio
     {
         last_audiotime = timecode;
     }
-    virtual bool CanPassthrough(int) const
+    virtual bool CanPassthrough(int, int) const
     {
         return false;
     }
diff -Naurp mythtv-0.24.orig/programs/scripts/database/mythconverg_restore.pl mythtv-0.24.fixes/programs/scripts/database/mythconverg_restore.pl
--- mythtv-0.24.orig/programs/scripts/database/mythconverg_restore.pl	2010-10-17 20:25:30.000000000 -0400
+++ mythtv-0.24.fixes/programs/scripts/database/mythconverg_restore.pl	2011-03-24 22:18:50.000000000 -0400
@@ -13,7 +13,7 @@
 
 # Script info
     $NAME           = 'MythTV Database Restore Script';
-    $VERSION        = '1.0.16';
+    $VERSION        = '1.0.17';
 
 # Some variables we'll use here
     our ($username, $homedir, $mythconfdir, $database_information_file);
@@ -1435,9 +1435,9 @@ EOF
             $query = "UPDATE $table_name SET value = REPLACE(value, ?, ?)".
                      " WHERE value LIKE ?";
             $sth_update = $dbh->prepare($query);
-            $sth_update->bind_param(1, $old_hostname);
-            $sth_update->bind_param(2, $new_hostname);
-            $sth_update->bind_param(3, '%'.$old_hostname.'%');
+            $sth_update->bind_param(1, 'SGweightPerDir:'.$old_hostname.':');
+            $sth_update->bind_param(2, 'SGweightPerDir:'.$new_hostname.':');
+            $sth_update->bind_param(3, 'SGweightPerDir:'.$old_hostname.':%');
             $result = $sth_update->execute;
             if (!defined($result))
             {
diff -Naurp mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/bbciplayer/bbciplayer_api.py mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/bbciplayer/bbciplayer_api.py
--- mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/bbciplayer/bbciplayer_api.py	2010-08-28 16:16:22.000000000 -0400
+++ mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/bbciplayer/bbciplayer_api.py	2011-03-24 22:18:50.000000000 -0400
@@ -349,16 +349,19 @@ class Videos(object):
             urlType = u'fullscreen'
 
         # Translate the search results into MNV RSS item format
-        linkFilter = etree.XPath(u".//div[@class='episode-details']/a")
-        titleFilter = etree.XPath(u".//div[@class='episode-details']/h3")
-        descFilter = etree.XPath(u".//div[@class='episode-details']//p")
-        thumbnailFilter = etree.XPath(u".//div[@class='episode-thumbnail']//img")
+        audioFilter = etree.XPath('./@class="audio"')
+        linkFilter = etree.XPath(u".//div[@class='episode-info']//a")
+        titleFilter = etree.XPath(u".//div[@class='episode-info']//a")
+        descFilter = etree.XPath(u".//div[@class='episode-info']//p[@class='episode-synopsis']")
+        thumbnailFilter = etree.XPath(u".//div[@class='episode-image']//img")
         itemDict = {}
         for result in searchResults:
             tmpLink = linkFilter(result)
             if not len(tmpLink):   # Make sure that this result actually has a video
                 continue
             bbciplayerItem = etree.XML(self.common.mnvItem)
+            # Is this an Audio or Video item (true/false)
+            audioTF = audioFilter(result)
             # Extract and massage data
             link = tmpLink[0].attrib['href']
             if urlType == 'bigscreen':
@@ -366,7 +369,7 @@ class Videos(object):
             elif urlType == 'bbcweb':
                 link = u'http://www.bbc.co.uk'+ link
             else:
-                if tmpLink[0].attrib['class'].find('cta-video') != -1:
+                if not audioTF:
                     link = link.replace(u'/iplayer/episode/', u'')
                     index = link.find(u'/')
                     link = link[:index]
@@ -388,7 +391,10 @@ class Videos(object):
             bbciplayerItem.xpath('.//media:thumbnail', namespaces=self.common.namespaces)[0].attrib['url'] = self.common.ampReplace(thumbnailFilter(result)[0].attrib['src'])
             bbciplayerItem.xpath('.//media:content', namespaces=self.common.namespaces)[0].attrib['url'] = link
             # Videos are only viewable in the UK so add a country indicator if this is a video
-            countCode = self.setCountry(result)
+            if audioTF:
+                countCode = None
+            else:
+                countCode = u'uk'
             if countCode:
                 etree.SubElement(bbciplayerItem, "{http://www.mythtv.org/wiki/MythNetvision_Grabber_Script_Format}country").text = countCode
             s_e = self.getSeasonEpisode(title)
diff -Naurp mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/common/common_api.py mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/common/common_api.py
--- mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/common/common_api.py	2010-08-28 16:16:22.000000000 -0400
+++ mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/common/common_api.py	2011-03-24 22:18:50.000000000 -0400
@@ -18,7 +18,7 @@ MythNetvision Grabber scripts that run a
 MNV grabbers.
 '''
 
-__version__="v0.2.2"
+__version__="v0.2.3"
 # 0.0.1 Initial development
 # 0.1.0 Alpha release
 # 0.1.1 Added the ability to have a mashup name independant of the mashup title
@@ -50,6 +50,7 @@ __version__="v0.2.2"
 #       when new custom HTML pages were added.
 # 0.2.1 Add the ability for a parameters to be passed to a XSLT style sheet
 # 0.2.2 Added a common XPath extention to test if a string starts or ends with a substring
+# 0.2.3 Fixed Error messages that were not unicode strings
 
 import os, struct, sys, re, datetime, time, subprocess, string
 import urllib
@@ -964,7 +965,7 @@ class getURL(Thread):
 
     def run(self):
         if self.debug:
-            print "getURL href(%s)" % (self.urlDictionary[self.urlKey]['href'], )
+            print u"getURL href(%s)" % (self.urlDictionary[self.urlKey]['href'], )
             print
 
         # Input the data from a url
@@ -985,9 +986,9 @@ class getURL(Thread):
                 try:
                    self.urlDictionary[self.urlKey]['tmp'] = self.urlDictionary[self.urlKey]['tree'].xpath(self.urlDictionary[self.urlKey]['filter'][index], namespaces=self.urlDictionary[self.urlKey]['namespaces'])
                 except AssertionError, e:
-                    sys.stderr.write("No filter results for Name(%s)\n" % self.urlKey)
-                    sys.stderr.write("No filter results for url(%s)\n" % self.urlDictionary[self.urlKey]['href'])
-                    sys.stderr.write("! Error:(%s)\n" % e)
+                    sys.stderr.write(u"No filter results for Name(%s)\n" % self.urlKey)
+                    sys.stderr.write(u"No filter results for url(%s)\n" % self.urlDictionary[self.urlKey]['href'])
+                    sys.stderr.write(u"! Error:(%s)\n" % e)
                     if len(self.urlDictionary[self.urlKey]['filter']) == index-1:
                         return
                     else:
@@ -1003,15 +1004,15 @@ self.urlDictionary[self.urlKey]['paramet
                     else:
                         self.urlDictionary[self.urlKey]['tmp'] = self.urlDictionary[self.urlKey]['xslt'][index](self.urlDictionary[self.urlKey]['tree'])
                 except Exception, e:
-                    sys.stderr.write("! XSLT Error:(%s) Key(%s)\n" % (e, self.urlKey))
+                    sys.stderr.write(u"! XSLT Error:(%s) Key(%s)\n" % (e, self.urlKey))
                     if len(self.urlDictionary[self.urlKey]['filter']) == index-1:
                         return
                     else:
                         continue
                 # Was any data found?
                 if self.urlDictionary[self.urlKey]['tmp'].getroot() == None:
-                    sys.stderr.write("No Xslt results for Name(%s)\n" % self.urlKey)
-                    sys.stderr.write("No Xslt results for url(%s)\n" % self.urlDictionary[self.urlKey]['href'])
+                    sys.stderr.write(u"No Xslt results for Name(%s)\n" % self.urlKey)
+                    sys.stderr.write(u"No Xslt results for url(%s)\n" % self.urlDictionary[self.urlKey]['href'])
                     if len(self.urlDictionary[self.urlKey]['filter']) == index-1:
                         return
                     else:
diff -Naurp mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/configs/HTML/mtv.html mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/configs/HTML/mtv.html
--- mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/configs/HTML/mtv.html	1969-12-31 19:00:00.000000000 -0500
+++ mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/configs/HTML/mtv.html	2011-03-24 22:18:50.000000000 -0400
@@ -0,0 +1,39 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
+<html>
+  <head>
+  <!-- Author: R.D. Vaughan
+       Nov 17th, 2010
+       Purpose: Implement full screen browser video display for MTV Videos
+  Example:
+  file:///usr/local/share/mythtv/mythnetvision/scripts/nv_python_libs/configs/HTML/mtv.html?title=We%20Are%20The%20One&videocode=176000
+  -->
+    <script type="text/javascript">
+      function gup( name )
+        {
+          name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
+          var regexS = "[\\?&]"+name+"=([^&#]*)";
+          var regex = new RegExp( regexS );
+          var results = regex.exec( window.location.href );
+          if( results == null )
+            return "";
+          else
+            return results[1];
+        }
+
+      var pageTitle = gup( 'title' );
+      if (pageTitle != "")
+          pageTitle = 'MTV: '+unescape(pageTitle);
+      var videocode = gup( 'videocode' );
+      var image = gup( 'image' );
+
+      var embedded = '<object style="visibility: visible;" data="http://media.mtvnservices.com/mgid:uma:video:mtv.com:VIDEOCODE" name="embeddedPlayer" id="embeddedPlayer" type="application/x-shockwave-flash" height="100%" width="100%"><param value="true" name="allowFullScreen"><param value="always" name="allowScriptAccess"><param value="transparent" name="wmode"><param value="true" name="swliveconnect"><param value="#000000" name="bgcolor"><param value="sid=MTV_Videos&amp;configParams=instance%3Dmtv%26vid%3DVIDEOCODE%26id%3D1572737&amp;autoPlay=true" name="flashvars"></object>'
+
+      document.write('<title>'+pageTitle+'</title>');
+      embedded = embedded.replace(/VIDEOCODE/g, videocode)
+      embedded = embedded.replace(/IMAGE/g, image)
+
+      document.write(embedded);
+
+    </script>
+  </head>
+</html>
diff -Naurp mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/configs/XML/bbc_config.xml mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/configs/XML/bbc_config.xml
--- mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/configs/XML/bbc_config.xml	2010-08-28 16:16:22.000000000 -0400
+++ mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/configs/XML/bbc_config.xml	2011-03-24 22:18:50.000000000 -0400
@@ -19,9 +19,8 @@
             <url>
                 <name>BBC iPlayer Search</name>
                 <href>http://www.bbc.co.uk/iplayer/search</href>
-                <filter>//div[@class='search result-wrapper']//ul</filter>
-                <filter>//div[@id='results-container']//ul</filter>
-                <pageFilter>//a/@class[starts-with(.,'last page')]/..</pageFilter>
+                <filter>//ul[@class='result-list listview episodelist']/li</filter>
+                <pageFilter>//a/@title[starts-with(.,'Next page')]/..</pageFilter>
                 <parserType>html</parserType>
             </url>
         </urls>
diff -Naurp mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/configs/XML/defaultUserPrefs/trailersMashup.xml mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/configs/XML/defaultUserPrefs/trailersMashup.xml
--- mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/configs/XML/defaultUserPrefs/trailersMashup.xml	2010-08-28 16:16:22.000000000 -0400
+++ mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/configs/XML/defaultUserPrefs/trailersMashup.xml	2011-03-24 22:18:50.000000000 -0400
@@ -46,7 +46,7 @@
   </subDirectory>
 
   <subDirectory name="Tribute.ca">
-    <sourceURL enabled="true" name="Tribute.ca"  xsltFile="tributecaHTML_item" type="html" url="http://www.tribute.ca/trailers/"/>
+    <sourceURL enabled="true" name="Tribute.ca"  xsltFile="tributecaHTML_item" type="html" url="http://www.tribute.ca/movietrailers/"/>
   </subDirectory>
 
   <subDirectory name="TrailerAddict.com">
diff -Naurp mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/configs/XSLT/tributecaHTML_item.xsl mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/configs/XSLT/tributecaHTML_item.xsl
--- mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/configs/XSLT/tributecaHTML_item.xsl	2010-07-13 12:14:21.000000000 -0400
+++ mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/configs/XSLT/tributecaHTML_item.xsl	2011-03-24 22:18:50.000000000 -0400
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
     Tribute.ca items conversion to MythNetvision item format
--->
+-->
 <xsl:stylesheet version="1.0"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
     xmlns:media="http://search.yahoo.com/mrss/"
@@ -11,7 +11,7 @@
 	xmlns:xhtml="http://www.w3.org/1999/xhtml">
 
     <xsl:output method="xml" indent="yes" version="1.0" encoding="UTF-8" omit-xml-declaration="yes"/>
-
+
     <!--
         This template calls all other templates which allows for multiple sources to be processed
         within a single Xslt file
@@ -27,11 +27,15 @@
             </xml>
         </xsl:if>
     </xsl:template>
-
-    <xsl:template name="featured">
+
+    <xsl:template name="featured">
         <xsl:element name="directory">
-            <xsl:attribute name="name"><xsl:value-of select="string('Featured movie Trailers')"/></xsl:attribute>
-            <xsl:attribute name="thumbnail"><xsl:value-of select="string('http://www.tribute.ca/images/tribute_title.gif')"/></xsl:attribute>
+            <xsl:attribute name="name">
+                <xsl:value-of select="string('Featured movie Trailers')"/>
+            </xsl:attribute>
+            <xsl:attribute name="thumbnail">
+                <xsl:value-of select="string('http://www.tribute.ca/images/tribute_title.gif')"/>
+            </xsl:attribute>
             <xsl:for-each select="//a[@class]/img[@src]/..">
                 <dataSet>
                     <directoryThumbnail>http://www.tribute.ca/images/tribute_title.gif</directoryThumbnail>
@@ -42,8 +46,8 @@
                         <xsl:otherwise>
                             <xsl:element name="item">
                                 <title><xsl:value-of select="normalize-space(string(.))"/></title>
-                                <author>Tribute.ca</author>
-                                <pubDate><xsl:value-of select="mnvXpath:pubDate('Now')"/></pubDate>
+                                <author>Tribute.ca</author>
+                                <pubDate><xsl:value-of select="mnvXpath:pubDate('Now')"/></pubDate>
                                 <description><xsl:value-of select="normalize-space(img/@alt)"/></description>
                                 <link><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), //a[@class]/img[@src]/..)"/></link>
                                 <xsl:if test="mnvXpath:tributecaIsCustomHTML(('dummy'))">
@@ -62,19 +66,20 @@
                                         <xsl:attribute name="lang">en</xsl:attribute>
                                     </xsl:element>
                                 </xsl:element>
-                            </xsl:element>
+                            </xsl:element>
                         </xsl:otherwise>
                     </xsl:choose>
                 </dataSet>
             </xsl:for-each>
-        </xsl:element>
+        </xsl:element>
     </xsl:template>
 
-    <xsl:template name="nowplaying">
+    <xsl:template name="nowplaying">
         <xsl:element name="directory">
             <xsl:attribute name="name"><xsl:value-of select="string('Movie Trailers Now Playing')"/></xsl:attribute>
             <xsl:attribute name="thumbnail"><xsl:value-of select="string('http://www.tribute.ca/images/tribute_title.gif')"/></xsl:attribute>
-            <xsl:for-each select="//h3[string(span)='Movie Trailers Now Playing']/..//a">
+            <!-- ul = 1 for 'Movie Trailers Now Playing'-->
+            <xsl:for-each select="mnvXpath:tributecaGetAnchors(//ul[@class='clump'], 1)">
                 <dataSet>
                     <directoryThumbnail>http://www.tribute.ca/images/tribute_title.gif</directoryThumbnail>
                     <xsl:choose>
@@ -84,10 +89,10 @@
                         <xsl:otherwise>
                             <xsl:element name="item">
                                 <title><xsl:value-of select="normalize-space(string(.))"/></title>
-                                <author>Tribute.ca</author>
-                                <pubDate><xsl:value-of select="mnvXpath:pubDate('Now')"/></pubDate>
+                                <author>Tribute.ca</author>
+                                <pubDate><xsl:value-of select="mnvXpath:pubDate('Now')"/></pubDate>
                                 <description><xsl:value-of select="normalize-space(./@title)"/></description>
-                                <link><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), //h3[string(span)='Movie Trailers Now Playing']/..//a)"/></link>
+                                <link><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), ../..//a)"/></link>
                                 <xsl:if test="mnvXpath:tributecaIsCustomHTML(('dummy'))">
                                     <mythtv:customhtml>true</mythtv:customhtml>
                                 </xsl:if>
@@ -96,7 +101,7 @@
                                         <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaThumbnailLink(string(.))"/></xsl:attribute>
                                     </xsl:element>
                                     <xsl:element name="media:content">
-                                        <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), //h3[string(span)='Movie Trailers Now Playing']/..//a)"/></xsl:attribute>
+                                        <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), ../..//a)"/></xsl:attribute>
                                         <xsl:attribute name="duration"></xsl:attribute>
                                         <xsl:attribute name="width"></xsl:attribute>
                                         <xsl:attribute name="height"></xsl:attribute>
@@ -104,19 +109,20 @@
                                         <xsl:attribute name="lang">en</xsl:attribute>
                                     </xsl:element>
                                 </xsl:element>
-                            </xsl:element>
+                            </xsl:element>
                         </xsl:otherwise>
                     </xsl:choose>
                 </dataSet>
             </xsl:for-each>
-        </xsl:element>
+        </xsl:element>
     </xsl:template>
 
-    <xsl:template name="comingsoon">
+    <xsl:template name="comingsoon">
         <xsl:element name="directory">
-            <xsl:attribute name="name"><xsl:value-of select="string('Coming Soon Movie Trailers')"/></xsl:attribute>
+            <xsl:attribute name="name"><xsl:value-of select="string('Coming Soon  Movie Trailers')"/></xsl:attribute>
             <xsl:attribute name="thumbnail"><xsl:value-of select="string('http://www.tribute.ca/images/tribute_title.gif')"/></xsl:attribute>
-            <xsl:for-each select="//h3[string(span)='Coming Soon Movie Trailers']/..//a">
+            <!-- ul = 3 for 'Coming Soon  Movie Trailers'-->
+            <xsl:for-each select="mnvXpath:tributecaGetAnchors(//ul[@class='clump'], 3)">
                 <dataSet>
                     <directoryThumbnail>http://www.tribute.ca/images/tribute_title.gif</directoryThumbnail>
                     <xsl:choose>
@@ -126,10 +132,10 @@
                         <xsl:otherwise>
                             <xsl:element name="item">
                                 <title><xsl:value-of select="normalize-space(string(.))"/></title>
-                                <author>Tribute.ca</author>
-                                <pubDate><xsl:value-of select="mnvXpath:pubDate('Now')"/></pubDate>
-                                <description><xsl:value-of select="concat(normalize-space(string(.)), ' coming ', normalize-space(string(../small/i)))"/></description>
-                                <link><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), //h3[string(span)='Coming Soon Movie Trailers']/..//a)"/></link>
+                                <author>Tribute.ca</author>
+                                <pubDate><xsl:value-of select="mnvXpath:pubDate('Now')"/></pubDate>
+                                <description><xsl:value-of select="concat(normalize-space(string(.)), ' coming ', normalize-space(string(../small/i)))"/></description>
+                                <link><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), ../..//a)"/></link>
                                 <xsl:if test="mnvXpath:tributecaIsCustomHTML(('dummy'))">
                                     <mythtv:customhtml>true</mythtv:customhtml>
                                 </xsl:if>
@@ -138,7 +144,7 @@
                                         <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaThumbnailLink(string(.))"/></xsl:attribute>
                                     </xsl:element>
                                     <xsl:element name="media:content">
-                                        <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), //h3[string(span)='Coming Soon Movie Trailers']/..//a)"/></xsl:attribute>
+                                        <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), ../..//a)"/></xsl:attribute>
                                         <xsl:attribute name="duration"></xsl:attribute>
                                         <xsl:attribute name="width"></xsl:attribute>
                                         <xsl:attribute name="height"></xsl:attribute>
@@ -146,19 +152,20 @@
                                         <xsl:attribute name="lang">en</xsl:attribute>
                                     </xsl:element>
                                 </xsl:element>
-                            </xsl:element>
+                            </xsl:element>
                         </xsl:otherwise>
                     </xsl:choose>
                 </dataSet>
             </xsl:for-each>
-        </xsl:element>
+        </xsl:element>
     </xsl:template>
 
-    <xsl:template name="topupcoming">
+    <xsl:template name="topupcoming">
         <xsl:element name="directory">
             <xsl:attribute name="name"><xsl:value-of select="string('Top 10 Upcoming Trailers')"/></xsl:attribute>
             <xsl:attribute name="thumbnail"><xsl:value-of select="string('http://www.tribute.ca/images/tribute_title.gif')"/></xsl:attribute>
-            <xsl:for-each select="//h3[string(span)='Top 10 Upcoming Trailers']/..//a">
+            <!-- ul = 2 for 'Top 10 Upcoming Trailers'-->
+            <xsl:for-each select="mnvXpath:tributecaGetAnchors(//ul[@class='clump'], 2)">
                 <dataSet>
                     <directoryThumbnail>http://www.tribute.ca/images/tribute_title.gif</directoryThumbnail>
                     <xsl:choose>
@@ -168,10 +175,10 @@
                         <xsl:otherwise>
                             <xsl:element name="item">
                                 <title><xsl:value-of select="normalize-space(string(.))"/></title>
-                                <author>Tribute.ca</author>
-                                <pubDate><xsl:value-of select="mnvXpath:pubDate('Now')"/></pubDate>
-                                <description><xsl:value-of select="normalize-space(./@title)"/></description>
-                                <link><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), //h3[string(span)='Top 10 Upcoming Trailers']/..//a)"/></link>
+                                <author>Tribute.ca</author>
+                                <pubDate><xsl:value-of select="mnvXpath:pubDate('Now')"/></pubDate>
+                                <description><xsl:value-of select="normalize-space(./@title)"/></description>
+                                <link><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), ../..//a)"/></link>
                                 <xsl:if test="mnvXpath:tributecaIsCustomHTML(('dummy'))">
                                     <mythtv:customhtml>true</mythtv:customhtml>
                                 </xsl:if>
@@ -180,7 +187,7 @@
                                         <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaThumbnailLink(string(.))"/></xsl:attribute>
                                     </xsl:element>
                                     <xsl:element name="media:content">
-                                        <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), //h3[string(span)='Top 10 Upcoming Trailers']/..//a)"/></xsl:attribute>
+                                        <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), ../..//a)"/></xsl:attribute>
                                         <xsl:attribute name="duration"></xsl:attribute>
                                         <xsl:attribute name="width"></xsl:attribute>
                                         <xsl:attribute name="height"></xsl:attribute>
@@ -188,19 +195,20 @@
                                         <xsl:attribute name="lang">en</xsl:attribute>
                                     </xsl:element>
                                 </xsl:element>
-                            </xsl:element>
+                            </xsl:element>
                         </xsl:otherwise>
                     </xsl:choose>
                 </dataSet>
             </xsl:for-each>
-        </xsl:element>
+        </xsl:element>
     </xsl:template>
 
-    <xsl:template name="topboxoffice">
+    <xsl:template name="topboxoffice">
         <xsl:element name="directory">
             <xsl:attribute name="name"><xsl:value-of select="string('Top Box Office Movie Trailers')"/></xsl:attribute>
             <xsl:attribute name="thumbnail"><xsl:value-of select="string('http://www.tribute.ca/images/tribute_title.gif')"/></xsl:attribute>
-            <xsl:for-each select="//h3[string(span)='Top Box Office Movie Trailers']/..//a">
+            <!-- ul = 0 for 'Top Box Office Movie Trailers'-->
+            <xsl:for-each select="mnvXpath:tributecaGetAnchors(//ul[@class='clump'], 0)">
                 <dataSet>
                     <directoryThumbnail>http://www.tribute.ca/images/tribute_title.gif</directoryThumbnail>
                     <xsl:choose>
@@ -210,10 +218,10 @@
                         <xsl:otherwise>
                             <xsl:element name="item">
                                 <title><xsl:value-of select="normalize-space(mnvXpath:tributecaTopTenTitle(string(..)))"/></title>
-                                <author>Tribute.ca</author>
-                                <pubDate><xsl:value-of select="mnvXpath:pubDate('Now')"/></pubDate>
-                                <description><xsl:value-of select="normalize-space(./@title)"/></description>
-                                <link><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), //h3[string(span)='Top Box Office Movie Trailers']/..//a)"/></link>
+                                <author>Tribute.ca</author>
+                                <pubDate><xsl:value-of select="mnvXpath:pubDate('Now')"/></pubDate>
+                                <description><xsl:value-of select="normalize-space(./@title)"/></description>
+                                <link><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), ..//a)"/></link>
                                 <xsl:if test="mnvXpath:tributecaIsCustomHTML(('dummy'))">
                                     <mythtv:customhtml>true</mythtv:customhtml>
                                 </xsl:if>
@@ -222,7 +230,7 @@
                                         <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaThumbnailLink(string(.))"/></xsl:attribute>
                                     </xsl:element>
                                     <xsl:element name="media:content">
-                                        <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), //h3[string(span)='Top Box Office Movie Trailers']/..//a)"/></xsl:attribute>
+                                        <xsl:attribute name="url"><xsl:value-of select="mnvXpath:tributecaLinkGeneration(position(), ..//a)"/></xsl:attribute>
                                         <xsl:attribute name="duration"></xsl:attribute>
                                         <xsl:attribute name="width"></xsl:attribute>
                                         <xsl:attribute name="height"></xsl:attribute>
@@ -230,12 +238,12 @@
                                         <xsl:attribute name="lang">en</xsl:attribute>
                                     </xsl:element>
                                 </xsl:element>
-                            </xsl:element>
+                            </xsl:element>
                         </xsl:otherwise>
                     </xsl:choose>
                 </dataSet>
             </xsl:for-each>
-        </xsl:element>
+        </xsl:element>
     </xsl:template>
 
 </xsl:stylesheet>
diff -Naurp mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/mtv/mtv_api.py mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/mtv/mtv_api.py
--- mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/mtv/mtv_api.py	2010-08-28 16:16:22.000000000 -0400
+++ mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/mtv/mtv_api.py	2011-03-24 22:18:50.000000000 -0400
@@ -19,7 +19,7 @@ metadata, video and image URLs from MTV.
 for this api are published at http://developer.mtvnservices.com/docs
 '''
 
-__version__="v0.2.4"
+__version__="v0.2.5"
 # 0.1.0 Initial development
 # 0.1.1 Added Tree View Processing
 # 0.1.2 Modified Reee view code and structure to be standandized across all grabbers
@@ -33,6 +33,7 @@ __version__="v0.2.4"
 #       Removed the import and use of the feedparser library
 # 0.2.3 Fixed an exception message output code error in two places
 # 0.2.4 Removed the need for python MythTV bindings and added "%SHAREDIR%" to icon directory path
+# 0.2.5 Use MTV web page as API not returning valid URLs
 
 import os, struct, sys, re, time
 from datetime import datetime, timedelta
@@ -238,6 +239,8 @@ class Videos(object):
             'genres': {'Genres': 'directories/topics/music','world_reggae': 'directories/music_genres/world_reggae', 'pop': 'directories/music_genres/pop', 'metal': 'directories/music_genres/metal', 'environmental': 'directories/music_genres/environmental', 'latin': 'directories/music_genres/latino', 'randb': 'directories/music_genres/rnb', 'rock': 'directories/music_genres/rock', 'easy_listening': 'directories/music_genres/easy_listening', 'jazz': 'directories/music_genres/jazz', 'country': 'directories/music_genres/country', 'hip_hop': 'directories/music_genres/hiphop', 'classical': 'directories/music_genres/classical', 'electronic_dance': 'directories/music_genres/electronic_dance', 'blues_folk': 'directories/music_genres/blues_folk', 'alternative': 'directories/music_genres/alternative', 'soundtracks_musicals': 'directories/music_genres/soundtracks_musicals',
             },
             }
+        # Get the absolute path to the mtv.html file
+        self.mtvHtmlPath = u'file://'+os.path.dirname( os.path.realpath( __file__ )).replace(u'/nv_python_libs/mtv', u'/nv_python_libs/configs/HTML/mtv.html?title=%s&amp;videocode=%s')
 
         # Initialize the tree view flag so that the item parsing code can be used for multiple purposes
         self.treeview = False
@@ -400,7 +403,7 @@ class Videos(object):
 
             video_details = None
             try:
-                video_details = self.videoDetails(item['id'])
+                video_details = self.videoDetails(item['id'], urllib.quote(item['title'].encode("utf-8")))
             except MtvUrlError, msg:
                 sys.stderr.write(self.error_messages['MtvUrlError'] % msg)
             except MtvVideoDetailError, msg:
@@ -442,7 +445,7 @@ class Videos(object):
         # end searchTitle()
 
 
-    def videoDetails(self, url):
+    def videoDetails(self, url, title=u''):
         '''Using the passed URL retrieve the video meta data details
         return a dictionary of video metadata details
         return
@@ -463,7 +466,10 @@ class Videos(object):
         cur_size = True
         for e in etree:
             if e.tag.endswith(u'content') and e.text == None:
-                metadata['video'] =  e.get('url')
+                index = e.get('url').rindex(u':')
+                metadata['video'] = self.mtvHtmlPath % (title,  e.get('url')[index+1:])
+                # !! This tag will need to be added at a later date
+#                metadata['customhtml'] = u'true'
                 metadata['duration'] =  e.get('duration')
             if e.tag.endswith(u'player'):
                 metadata['link'] = e.get('url')
@@ -745,7 +751,11 @@ class Videos(object):
             if not metadata.has_key('video'):
                 metadata['video'] = metadata['link']
             else:
+                index = metadata['video'].rindex(u':')
+                metadata['video'] = self.mtvHtmlPath % (urllib.quote(metadata['title'].encode("utf-8")), metadata['video'][index+1:])
                 metadata['link'] =  metadata['video']
+                # !! This tag will need to be added at a later date
+#                metadata['customhtml'] = u'true'
 
             if not dictionary_first:  # Add the dictionaries display name
                 dictionaries.append([self.massageDescription(self.feed_names[self.tree_key][self.feed]), self.setTreeViewIcon()])
diff -Naurp mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/xsltfunctions/tributeca_api.py mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/xsltfunctions/tributeca_api.py
--- mythtv-0.24.orig/programs/scripts/internetcontent/nv_python_libs/xsltfunctions/tributeca_api.py	2010-08-28 16:16:22.000000000 -0400
+++ mythtv-0.24.fixes/programs/scripts/internetcontent/nv_python_libs/xsltfunctions/tributeca_api.py	2011-03-24 22:18:50.000000000 -0400
@@ -21,8 +21,9 @@ See this link for the specifications:
 http://www.mythtv.org/wiki/MythNetvision_Grabber_Script_Format
 '''
 
-__version__="v0.1.0"
+__version__="v0.1.1"
 # 0.1.0 Initial development
+# 0.1.1 Changes to due to Web site modifications
 
 
 # Specify the class names that have XPath extention functions
@@ -91,8 +92,9 @@ class xpathFunctions(object):
     """Functions specific extending XPath
     """
     def __init__(self):
-        self.functList = ['tributecaLinkGeneration', 'tributecaThumbnailLink', 'tributecaTopTenTitle', 'tributecaIsCustomHTML', 'tributecaCheckIfDBItem', ]
+        self.functList = ['tributecaLinkGeneration', 'tributecaThumbnailLink', 'tributecaTopTenTitle', 'tributecaIsCustomHTML', 'tributecaCheckIfDBItem', 'tributecaDebug', 'tributecaGetAnchors', ]
         self.TextTail = etree.XPath("string()")
+        self.anchorList = etree.XPath(".//a", namespaces=common.namespaces)
         self.persistence = {}
     # end __init__()
 
@@ -104,12 +106,13 @@ class xpathFunctions(object):
 
     def tributecaLinkGeneration(self, context, *args):
         '''Generate a link for the Tribute.ca site. Sigificant massaging of the title is required.
-        Call example: 'mnvXpath:tributecaLinkGeneration(string(.), string(preceding-sibling::a[1]))'
+        Call example: 'mnvXpath:tributecaLinkGeneration(position(), ..//a)'
         return the url link
         '''
         downloadURL = u'http://www.tribute.ca/streamingflash/%s.flv'
         position = int(args[0])-1
         webURL = u'http://www.tribute.ca%s' % args[1][position].attrib['href'].strip()
+
         # If this is for the download then just return what was found for the "link" element
         if self.persistence.has_key('tributecaLinkGeneration'):
             if self.persistence['tributecaLinkGeneration'] != None:
@@ -151,7 +154,6 @@ class xpathFunctions(object):
             trailer2 = u'tr2'
         if currentTitle.find(': An IMAX') != -1:
             trailer2 = u'tr2'
-
         titleArray[0] = titleArray[0].replace(u'&', u'and')
         self.persistence['tributecaThumbnailLink'] = urllib.quote_plus(titleArray[0].lower().replace(u' ', u'_').replace(u"'", u'').replace(u'-', u'_').replace(u'?', u'').replace(u'.', u'').encode("utf-8"))
         titleArray[0] = urllib.quote_plus(re.sub('[%s]' % re.escape(string.punctuation), '', titleArray[0].lower().replace(u' ', u'').encode("utf-8")))
@@ -159,7 +161,6 @@ class xpathFunctions(object):
         # Verify that the FLV file url really exits. If it does not then use the Web page link.
         videocode = u'%s%s' % (titleArray[0], trailer2)
         flvURL = downloadURL % videocode
-
         resultCheckUrl = common.checkURL(flvURL)
         if not resultCheckUrl[0] or resultCheckUrl[1]['Content-Type'] != u'video/x-flv':
             if trailer2 != u'':
@@ -183,7 +184,6 @@ class xpathFunctions(object):
                             flvURL = webURL
                     else:
                         flvURL = webURL
-
         if flvURL != webURL:
             self.persistence['tributecaLinkGeneration'] = videocode
             return common.linkWebPage(u'dummycontext', 'tributeca')+videocode
@@ -252,6 +252,33 @@ class xpathFunctions(object):
         return common.checkIfDBItem('dummy', {'feedtitle': 'Movie Trailers', 'title': arg[0].replace('Trailer', u'').strip(), 'author': arg[1], 'description': arg[2]})
     # end tributecaCheckIfDBItem()
 
+    def tributecaGetAnchors(self, context, *arg):
+        ''' Routine used to get specific anchor elements.
+        Unfortunitely position dependant.
+        Call: mnvXpath:tributecaGetAnchors(//ul[@class='clump'], 3)
+        '''
+        return self.anchorList(arg[0][int(arg[1])])
+    # end tributecaGetAnchors()
+
+    def tributecaDebug(self, context, *arg):
+        ''' Routine only used for debugging. Prints out the node
+        passed as an argument. Not to be used in production.
+        Call example: mnvXpath:tributecaDebug(//a)
+        '''
+        testpath = etree.XPath(".//a", namespaces=common.namespaces)
+        print arg
+        count = 0
+        for x in arg:
+            sys.stdout.write(u'\nElement Count (%s):\n' % count)
+#            for y in testpath(x):
+#                sys.stdout.write(etree.tostring(y, encoding='UTF-8', pretty_print=True))
+            print "testpath(%s)" % testpath(x)
+            count+=1
+        print
+#        sys.stdout.write(etree.tostring(arg[0], encoding='UTF-8', pretty_print=True))
+        return u"========tributecaDebug Called========="
+    # end tributecaDebug()
+
 ######################################################################################################
 #
 # End of XPath extension functions
diff -Naurp mythtv-0.24.orig/themes/DVR/util_menu.xml mythtv-0.24.fixes/themes/DVR/util_menu.xml
--- mythtv-0.24.orig/themes/DVR/util_menu.xml	2010-08-13 15:45:54.000000000 -0400
+++ mythtv-0.24.fixes/themes/DVR/util_menu.xml	2011-03-24 22:18:50.000000000 -0400
@@ -8,6 +8,13 @@
     </button>
 
     <button>
+        <type>NET_VIDEO</type>
+        <text>Internet Video</text>
+        <action>MENU netvisionmenu.xml</action>
+        <depends>mythnetvision</depends>
+    </button>
+
+    <button>
         <type>MUSIC</type>
         <text>Music</text>
         <action>PLUGIN mythmusic</action>
diff -Naurp mythtv-0.24.orig/themes/.gitignore mythtv-0.24.fixes/themes/.gitignore
--- mythtv-0.24.orig/themes/.gitignore	1969-12-31 19:00:00.000000000 -0500
+++ mythtv-0.24.fixes/themes/.gitignore	2011-03-24 22:18:50.000000000 -0400
@@ -0,0 +1 @@
+themes
diff -Naurp mythtv-0.24.orig/themes/MythCenter/base.xml mythtv-0.24.fixes/themes/MythCenter/base.xml
--- mythtv-0.24.orig/themes/MythCenter/base.xml	2010-09-22 08:39:41.000000000 -0400
+++ mythtv-0.24.fixes/themes/MythCenter/base.xml	2011-03-24 22:18:50.000000000 -0400
@@ -766,6 +766,7 @@
         <textarea name="message" from="basetextarea">
             <area>170,20,390,125</area>
             <align>allcenter</align>
+            <multiline>yes</multiline>
         </textarea>
     </window>
 
diff -Naurp mythtv-0.24.orig/themes/MythCenter-wide/base.xml mythtv-0.24.fixes/themes/MythCenter-wide/base.xml
--- mythtv-0.24.orig/themes/MythCenter-wide/base.xml	2010-10-06 10:17:51.000000000 -0400
+++ mythtv-0.24.fixes/themes/MythCenter-wide/base.xml	2011-03-24 22:18:50.000000000 -0400
@@ -881,6 +881,7 @@
         <textarea name="message" from="basetextarea">
             <area>170,20,390,126</area>
             <align>allcenter</align>
+            <multiline>yes</multiline>
         </textarea>
     </window>
 
diff -Naurp mythtv-0.24.orig/themes/MythCenter-wide/osd.xml mythtv-0.24.fixes/themes/MythCenter-wide/osd.xml
--- mythtv-0.24.orig/themes/MythCenter-wide/osd.xml	2010-11-09 21:44:09.000000000 -0500
+++ mythtv-0.24.fixes/themes/MythCenter-wide/osd.xml	2011-03-24 22:18:50.000000000 -0400
@@ -429,6 +429,22 @@
                 <fill color="#FFFFFF" alpha="255" />
                 <alphapulse min="180" max="255" change="4" />
             </shape>
+            <shape name="cuttoright">
+                <area>0,4,3,30</area>
+                <fill color="#FF0000" alpha="255" />
+            </shape>
+            <shape name="cuttoleft">
+                <area>0,4,3,30</area>
+                <fill color="#FF0000" alpha="255" />
+            </shape>
+            <shape name="keeptoright">
+                <area>0,4,3,30</area>
+                <fill color="#00FF00" alpha="255" />
+            </shape>
+            <shape name="keeptoleft">
+                <area>0,4,3,30</area>
+                <fill color="#00FF00" alpha="255" />
+            </shape>
         </editbar>
     </window>
 
diff -Naurp mythtv-0.24.orig/themes/MythCenter-wide/schedule-ui.xml mythtv-0.24.fixes/themes/MythCenter-wide/schedule-ui.xml
--- mythtv-0.24.orig/themes/MythCenter-wide/schedule-ui.xml	2010-10-06 10:17:51.000000000 -0400
+++ mythtv-0.24.fixes/themes/MythCenter-wide/schedule-ui.xml	2011-03-24 22:18:50.000000000 -0400
@@ -145,7 +145,7 @@
         </textarea>
 
         <textarea name="subtitle" from="basetextarea">
-            <area>40,80,620,30</area>
+            <area>40,80,640,30</area>
             <align>left,vcenter</align>
             <font>basesmall</font>
         </textarea>
@@ -157,7 +157,7 @@
         </textarea>
 
         <textarea name="rectypestatus" from="basetextarea">
-            <area>680,80,550,30</area>
+            <area>710,80,530,30</area>
             <align>right,vcenter</align>
             <font>basesmallyellow</font>
         </textarea>
@@ -532,7 +532,7 @@
                         <area>240,2,220,24</area>
                     </textarea>
                     <textarea name="title" from="shortstarttimedate">
-                        <area>475,2,675,24</area>
+                        <area>480,2,675,24</area>
                     </textarea>
                     <textarea name="card" from="shortstarttimedate">
                         <area>1165,2,30,24</area>
@@ -1205,26 +1205,26 @@
         </buttonlist>
 
         <textarea name="title" from="basetextarea">
-            <area>30,454,1200,50</area>
+            <area>30,454,1220,40</area>
             <font>baselarge</font>
         </textarea>
         <textarea name="channel" from="basetextarea">
             <area>30,494,360,30</area>
         </textarea>
         <textarea name="timedate" from="basetextarea">
-            <area>410,490,520,30</area>
+            <area>410,494,520,30</area>
         </textarea>
         <textarea name="description" from="basetextarea">
-            <area>30,524,1200,150</area>
+            <area>30,524,1220,160</area>
             <multiline>yes</multiline>
             <template>%"|SUBTITLE|"\n%%YEARSTARS| %%DESCRIPTION%</template>
         </textarea>
         <textarea name="type" from="basetextarea">
-            <area>30,670,560,30</area>
+            <area>30,685,560,30</area>
             <font>basemedium_highlight</font>
         </textarea>
         <textarea name="programid" from="basetextarea">
-            <area>800,670,440,30</area>
+            <area>800,685,450,30</area>
             <align>right</align>
         </textarea>
         <textarea name="msg" from="basetextarea">
@@ -1411,22 +1411,22 @@
         </buttonlist>
 
         <textarea name="title" from="basetextarea">
-            <area>90,50,1040,46</area>
+            <area>90,50,1075,40</area>
             <font>baselarge</font>
         </textarea>
         <textarea name="timedate" from="basetextarea">
-            <area>90,290,540,28</area>
+            <area>90,290,540,30</area>
         </textarea>
         <textarea name="channel" from="basetextarea">
-            <area>780,290,380,36</area>
+            <area>780,290,385,30</area>
             <align>right</align>
         </textarea>
         <textarea name="rectypestatus" from="basetextarea">
-            <area>90,254,600,36</area>
+            <area>90,254,600,30</area>
             <font>basesmallyellow</font>
         </textarea>
         <textarea name="description" from="basetextarea">
-            <area>90,90,1040,176</area>
+            <area>90,90,1075,160</area>
             <multiline>yes</multiline>
             <template>%"|SUBTITLE|"\n%%LONGREPEAT%%(|STARS|) %%DESCRIPTION%</template>
         </textarea>
diff -Naurp mythtv-0.24.orig/themes/MythCenter-wide/zoneminder-ui.xml mythtv-0.24.fixes/themes/MythCenter-wide/zoneminder-ui.xml
--- mythtv-0.24.orig/themes/MythCenter-wide/zoneminder-ui.xml	2010-10-06 11:37:20.000000000 -0400
+++ mythtv-0.24.fixes/themes/MythCenter-wide/zoneminder-ui.xml	2011-03-24 22:18:50.000000000 -0400
@@ -652,23 +652,23 @@
 
     <window name="zmplayer">
 
-        <font name="label" from="basesmall">
+        <fontdef name="label" from="basesmall">
             <color>#ffff00</color>
             <size>16</size>
             <weight>bold</weight>
-        </font>
+        </fontdef>
 
-        <font name="data" from="basesmall">
+        <fontdef name="data" from="basesmall">
             <color>#ffffff</color>
             <size>14</size>
             <weight>bold</weight>
-        </font>
+        </fontdef>
 
-        <font name="buttons" from="basesmall">
+        <fontdef name="buttons" from="basesmall">
             <color>#ffffff</color>
             <size>12</size>
             <weight>bold</weight>
-        </font>
+        </fontdef>
 
         <textarea name="pagetitle" from="basetextarea">
             <area>30,10,570,40</area>
diff -Naurp mythtv-0.24.orig/version.sh mythtv-0.24.fixes/version.sh
--- mythtv-0.24.orig/version.sh	2010-08-29 18:22:54.000000000 -0400
+++ mythtv-0.24.fixes/version.sh	2011-03-24 22:18:50.000000000 -0400
@@ -1,12 +1,11 @@
 #!/bin/sh
 #
 # small shell script to generate version.cpp
-# it expects two parameters
+# it expects one parameter
 # first parameter is the root of the source directory
-# second parameter is the svn base folder (trunk, branches/release-0-21-fixes)
 
 if test $# -ne 1; then
-    echo "Usage: version.sh SVN_TREE_DIR"
+    echo "Usage: version.sh GIT_TREE_DIR"
     exit 1
 fi
 
@@ -18,21 +17,21 @@ else
     exit 0
 fi
 
-SVNTREEDIR=$1
-SVNREPOPATH="exported"
+GITTREEDIR=$1
+GITREPOPATH="exported"
 
-SOURCE_VERSION=$(svnversion ${SVNTREEDIR} 2>/dev/null || echo Unknown)
+cd ${GITTREEDIR}
+
+SOURCE_VERSION=$(git describe --dirty || git describe || echo Unknown)
 
 case "${SOURCE_VERSION}" in
     exported|Unknown)
-        if test -e $SVNTREEDIR/VERSION ; then
-            . $SVNTREEDIR/VERSION
+        if test -e $GITTREEDIR/VERSION ; then
+            . $GITTREEDIR/VERSION
         fi
     ;;
     *)
-    SVNREPOPATH=$(echo "$$URL: http://svn.mythtv.org/svn/tags/release-0-24/mythtv/version.sh $$" | sed -e 's,.*/svn/,,' \
-                                       -e 's,/mythtv/version\.sh.*,,' \
-                                       -e 's,/version\.sh.*,,')
+    BRANCH=$(git branch --no-color | sed -e '/^[^\*]/d' -e 's/^\* //' -e 's/(no branch)/exported/')
     ;;
 esac
 
@@ -41,7 +40,7 @@ cat > .vers.new <<EOF
 #include "mythversion.h"
 
 const MPUBLIC char *myth_source_version = "${SOURCE_VERSION}";
-const MPUBLIC char *myth_source_path = "${SVNREPOPATH}";
+const MPUBLIC char *myth_source_path = "${BRANCH}";
 const MPUBLIC char *myth_binary_version = MYTH_BINARY_VERSION;
 EOF
 
