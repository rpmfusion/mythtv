 mythtv/bindings/python/MythTV/database.py          |    2 +-
 mythtv/bindings/python/MythTV/dataheap.py          |    6 +-
 mythtv/bindings/python/MythTV/logging.py           |    6 +-
 mythtv/bindings/python/MythTV/system.py            |   11 +-
 .../bindings/python/MythTV/tmdb/XSLT/tmdbQuery.xsl |   99 --
 .../bindings/python/MythTV/tmdb/XSLT/tmdbVideo.xsl |  157 ---
 mythtv/bindings/python/MythTV/tmdb/__init__.py     |    0
 mythtv/bindings/python/MythTV/tmdb/tmdb_api.py     | 1317 --------------------
 .../bindings/python/MythTV/tmdb/tmdb_exceptions.py |   45 -
 mythtv/bindings/python/MythTV/tmdb/tmdb_ui.py      |  266 ----
 mythtv/bindings/python/setup.py                    |    4 +-
 mythtv/bindings/python/tmdb3/scripts/pytmdb3.py    |    7 +-
 mythtv/bindings/python/tmdb3/tmdb3/pager.py        |    5 +-
 mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py     |    2 +-
 mythtv/i18n/mythfrontend_de.qm                     |  Bin 630506 -> 630506 bytes
 mythtv/i18n/mythfrontend_de.ts                     |   22 +-
 mythtv/libs/libmythbase/logging.cpp                |    4 +-
 mythtv/libs/libmythbase/mythcommandlineparser.cpp  |    6 +-
 mythtv/libs/libmythmetadata/metadatadownload.cpp   |    8 +-
 mythtv/libs/libmythtv/avformatdecoder.cpp          |    2 +-
 mythtv/libs/libmythtv/decoderbase.cpp              |    5 +-
 mythtv/libs/libmythtv/eithelper.cpp                |   29 +-
 mythtv/programs/mythfrontend/commandlineparser.cpp |    2 +-
 mythtv/programs/scripts/hardwareprofile/config.py  |    5 +
 .../distros/mythtv_data/data_mythtv.py             |   16 +-
 .../programs/scripts/hardwareprofile/os_detect.py  |    5 +
 mythtv/programs/scripts/metadata/Movie/tmdb.py     |  640 ----------
 mythtv/programs/scripts/metadata/Movie/tmdb3.py    |    8 +-
 28 files changed, 114 insertions(+), 2565 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/database.py b/mythtv/bindings/python/MythTV/database.py
index 525a213..368fb9e 100644
--- a/mythtv/bindings/python/MythTV/database.py
+++ b/mythtv/bindings/python/MythTV/database.py
@@ -835,7 +835,7 @@ class DatabaseConfig( object ):
     database =  QuickProperty('_database', 'mythconverg')
 
     @QuickProperty('_profile', gethostname())
-    def profile(self, value):
+    def profile(value):
         if value == 'my-unique-identifier-goes-here':
             raise Exception
         return value
diff --git a/mythtv/bindings/python/MythTV/dataheap.py b/mythtv/bindings/python/MythTV/dataheap.py
index 4a17d6b..268d007 100644
--- a/mythtv/bindings/python/MythTV/dataheap.py
+++ b/mythtv/bindings/python/MythTV/dataheap.py
@@ -1136,7 +1136,7 @@ class VideoGrabber( Grabber ):
     def __init__(self, mode, lang='en', db=None):
         dbvalue = {'tv':'TelevisionGrabber', 'movie':'MovieGrabber'}
         path = {'tv':'metadata/Television/ttvdb.py',
-                'movie':'metadata/Movie/tmdb.py'}
+                'movie':'metadata/Movie/tmdb3.py'}
         self.mode = mode.lower()
         try:
             Grabber.__init__(self, setting=dbvalue[self.mode], db=db,
@@ -1144,6 +1144,10 @@ class VideoGrabber( Grabber ):
                         prefix=os.path.join(INSTALL_PREFIX, 'share/mythtv'))
         except KeyError:
             raise MythError('Invalid MythVideo grabber')
+
+        if self.path[-7:] == 'tmdb.py':
+            self.path = self.path[:-7] + 'tmdb3.py'
+
         self.append('-l',lang)
 
 #### MYTHNETVISION ####
diff --git a/mythtv/bindings/python/MythTV/logging.py b/mythtv/bindings/python/MythTV/logging.py
index f27387f..45ace32 100644
--- a/mythtv/bindings/python/MythTV/logging.py
+++ b/mythtv/bindings/python/MythTV/logging.py
@@ -409,11 +409,15 @@ class MythLog( LOGLEVEL, LOGMASK, LOGFACILITY ):
     def _logdatabase(self, mask, level, message, detail):
         if self.db and self._DBLOG:
             with self.db.cursor(DummyLogger()) as cursor:
+                application = argv[0]
+                if '/' in application:
+                    application = application.rsplit('/', 1)[1]
+
                 cursor.execute("""INSERT INTO logging
                                     (host, application, pid, thread,
                                      msgtime, level, message)
                                   VALUES (?, ?, ?, ?, ?, ?, ?)""",
-                    (self.db.gethostname(), argv[0].rsplit('/', 1)[1],
+                    (self.db.gethostname(), application,
                      os.getpid(), self.module, self.time(), level,
                      message + (' -- {0}'.format(detail) if detail else '')))
 
diff --git a/mythtv/bindings/python/MythTV/system.py b/mythtv/bindings/python/MythTV/system.py
index f24c8a9..44803bd 100644
--- a/mythtv/bindings/python/MythTV/system.py
+++ b/mythtv/bindings/python/MythTV/system.py
@@ -79,10 +79,17 @@ class System( DBCache ):
         self.path = None
 
         if setting is not None:
-            # pull setting from database, substitute from argument if needed
+            # pull local setting from database
             host = self.gethostname()
             self.path = self.settings[host][setting]
-            if (self.path is None) and (path is None):
+            if self.path is None:
+                # see if that setting is applied globally
+                self.path = self.settings['NULL'][setting]
+            if self.path is None:
+                # not set globally either, use supplied default
+                self.path = path
+            if self.path is None:
+                # no default supplied, just error out
                 raise MythDBError(MythError.DB_SETTING, setting, host)
 
         if self.path is None:
diff --git a/mythtv/bindings/python/MythTV/tmdb/XSLT/tmdbQuery.xsl b/mythtv/bindings/python/MythTV/tmdb/XSLT/tmdbQuery.xsl
deleted file mode 100644
index f87b72a..0000000
--- a/mythtv/bindings/python/MythTV/tmdb/XSLT/tmdbQuery.xsl
+++ /dev/null
@@ -1,99 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-    themoviedb.org query result conversion to MythTV Universal Metadata Format
-    See: http://www.mythtv.org/wiki/MythTV_Universal_Metadata_Format
--->
-<xsl:stylesheet version="1.0"
-    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
-    xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/"
-    xmlns:tmdbXpath="http://www.mythtv.org/wiki/MythTV_Universal_Metadata_Format">
-
-    <xsl:output method="xml" indent="yes" version="1.0" encoding="UTF-8" omit-xml-declaration="yes"/>
-
-    <!--
-        This template calls all other templates which allows for multiple sources to be processed
-        within a single Xslt file
-    -->
-    <xsl:template match="/">
-        <xsl:if test="not(string(opensearch:totalResults)='0')">
-            <metadata>
-                <xsl:call-template name='movieQuery'/>
-            </metadata>
-        </xsl:if>
-    </xsl:template>
-
-    <xsl:template name="movieQuery">
-        <xsl:for-each select="//movie">
-            <item>
-                <language><xsl:value-of select="normalize-space(language)"/></language>
-                <xsl:for-each select="tmdbXpath:titleElement(string(name))">
-                    <title><xsl:value-of select="normalize-space(./@title)"/></title>
-                    <xsl:if test="./@subtitle">
-                        <subtitle><xsl:value-of select="normalize-space(./@subtitle)"/></subtitle>
-                    </xsl:if>
-                </xsl:for-each>
-                <inetref><xsl:value-of select="normalize-space(id)"/></inetref>
-                <imdb><xsl:value-of select="normalize-space(substring-after(string(imdb_id), 'tt'))"/></imdb>
-                <userrating><xsl:value-of select="normalize-space(rating)"/></userrating>
-                <xsl:if test="./certification/text() != ''">
-                    <certifications>
-                        <!--
-                            This code will need to be modified when multiple country cerification
-                            information is supported. Right now it assumes ONLY ratings from the US.
-                        -->
-                        <xsl:for-each select=".//certification">
-                            <xsl:element name="certification">
-                                <xsl:attribute name="locale">us</xsl:attribute>
-                                <xsl:attribute name="name"><xsl:value-of select="normalize-space(.)"/></xsl:attribute>
-                            </xsl:element>
-                        </xsl:for-each>
-                    </certifications>
-                </xsl:if>
-                <description><xsl:value-of select="normalize-space(overview)"/></description>
-                <releasedate><xsl:value-of select="normalize-space(released)"/></releasedate>
-                <xsl:if test=".//image[@type='poster'] or .//image[@type='backdrop']">
-                    <images>
-                        <xsl:if test=".//image[@type='poster']">
-                            <xsl:element name="image">
-                                <xsl:attribute name="type">coverart</xsl:attribute>
-                                <xsl:if test=".//image[@type='poster' and @size='original']">
-                                    <xsl:attribute name="url"><xsl:value-of select="normalize-space(.//image[@type='poster' and @size='original']/@url)"/></xsl:attribute>
-                                    <xsl:if test=".//image[@type='poster' and @size='original']/@width != ''">
-                                        <xsl:attribute name="width"><xsl:value-of select="normalize-space(.//image[@type='poster' and @size='original']/@width)"/></xsl:attribute>
-                                    </xsl:if>
-                                    <xsl:if test=".//image[@type='poster' and @size='original']/@height != ''">
-                                        <xsl:attribute name="height"><xsl:value-of select="normalize-space(.//image[@type='poster' and @size='original']/@height)"/></xsl:attribute>
-                                    </xsl:if>
-                                </xsl:if>
-                                <xsl:if test=".//image[@type='poster' and @size='cover']">
-                                    <xsl:attribute name="thumb"><xsl:value-of select="normalize-space(.//image[@type='poster' and @size='cover']/@url)"/></xsl:attribute>
-                                </xsl:if>
-                                <xsl:if test="not(.//image[@type='poster' and @size='cover']) and .//image[@type='poster' and @size='thumb']">
-                                    <xsl:attribute name="thumb"><xsl:value-of select="normalize-space(.//image[@type='poster' and @size='thumb']/@url)"/></xsl:attribute>
-                                </xsl:if>
-                            </xsl:element>
-                        </xsl:if>
-                        <xsl:if test=".//image[@type='backdrop']">
-                            <xsl:element name="image">
-                                <xsl:attribute name="type">fanart</xsl:attribute>
-                                <xsl:if test=".//image[@type='backdrop' and @size='original']">
-                                    <xsl:attribute name="url"><xsl:value-of select="normalize-space(.//image[@type='backdrop' and @size='original']/@url)"/></xsl:attribute>
-                                    <xsl:if test=".//image[@type='backdrop' and @size='original']/@width != ''">
-                                        <xsl:attribute name="width"><xsl:value-of select="normalize-space(.//image[@type='backdrop' and @size='original']/@width)"/></xsl:attribute>
-                                    </xsl:if>
-                                    <xsl:if test=".//image[@type='backdrop' and @size='original']/@height != ''">
-                                        <xsl:attribute name="height"><xsl:value-of select="normalize-space(.//image[@type='backdrop' and @size='original']/@height)"/></xsl:attribute>
-                                    </xsl:if>
-                                </xsl:if>
-                                <xsl:if test=".//image[@type='backdrop' and @size='thumb']">
-                                    <xsl:attribute name="thumb"><xsl:value-of select="normalize-space(.//image[@type='backdrop' and @size='thumb']/@url)"/></xsl:attribute>
-                                </xsl:if>
-                            </xsl:element>
-                        </xsl:if>
-                    </images>
-                </xsl:if>
-                <lastupdated><xsl:value-of select="tmdbXpath:lastUpdated(string(last_modified_at), '%Y-%m-%d %H:%M:%S')"/></lastupdated>
-            </item>
-        </xsl:for-each>
-    </xsl:template>
-</xsl:stylesheet>
diff --git a/mythtv/bindings/python/MythTV/tmdb/XSLT/tmdbVideo.xsl b/mythtv/bindings/python/MythTV/tmdb/XSLT/tmdbVideo.xsl
deleted file mode 100644
index 43f2ce9..0000000
--- a/mythtv/bindings/python/MythTV/tmdb/XSLT/tmdbVideo.xsl
+++ /dev/null
@@ -1,157 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-    themoviedb.org Video data conversion to MythTV Universal Metadata Format
-    See: http://www.mythtv.org/wiki/MythTV_Universal_Metadata_Format
--->
-<xsl:stylesheet version="1.0"
-    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
-    xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/"
-    xmlns:tmdbXpath="http://www.mythtv.org/wiki/MythTV_Universal_Metadata_Format">
-
-    <xsl:output method="xml" indent="yes" version="1.0" encoding="UTF-8" omit-xml-declaration="yes"/>
-
-    <!--
-        This template calls all other templates which allows for multiple sources to be processed
-        within a single Xslt file
-    -->
-    <xsl:template match="/">
-        <xsl:if test="not(string(opensearch:totalResults)='0')">
-            <metadata>
-                <xsl:call-template name='movieVideoData'/>
-            </metadata>
-        </xsl:if>
-    </xsl:template>
-
-    <xsl:template name="movieVideoData">
-        <xsl:for-each select="//movie">
-            <item>
-                <xsl:for-each select="tmdbXpath:titleElement(string(name))">
-                    <title><xsl:value-of select="normalize-space(./@title)"/></title>
-                    <xsl:if test="./@subtitle">
-                        <subtitle><xsl:value-of select="normalize-space(./@subtitle)"/></subtitle>
-                    </xsl:if>
-                </xsl:for-each>
-                <xsl:if test="string(tagline) != ''">
-                    <tagline><xsl:value-of select="normalize-space(tagline)"/></tagline>
-                </xsl:if>
-                <language><xsl:value-of select="normalize-space(language)"/></language>
-                <description><xsl:value-of select="normalize-space(overview)"/></description>
-                <xsl:if test="string(season) != ''">
-                    <season><xsl:value-of select="normalize-space(season)"/></season>
-                </xsl:if>
-                <xsl:if test="string(episode) != ''">
-                    <episode><xsl:value-of select="normalize-space(episode)"/></episode>
-                </xsl:if>
-                <xsl:if test="./certification/text() != ''">
-                    <certifications>
-                        <xsl:for-each select=".//certification">
-                            <xsl:element name="certification">
-                                <xsl:attribute name="locale">us</xsl:attribute>
-                                <xsl:attribute name="name"><xsl:value-of select="normalize-space(.)"/></xsl:attribute>
-                            </xsl:element>
-                        </xsl:for-each>
-                    </certifications>
-                </xsl:if>
-                <xsl:if test=".//category">
-                    <categories>
-                        <xsl:for-each select=".//category">
-                            <xsl:element name="category">
-                                <xsl:attribute name="type"><xsl:value-of select="normalize-space(@type)"/></xsl:attribute>
-                                <xsl:attribute name="name"><xsl:value-of select="normalize-space(@name)"/></xsl:attribute>
-                            </xsl:element>
-                        </xsl:for-each>
-                    </categories>
-                </xsl:if>
-                <xsl:if test=".//studio">
-                    <studios>
-                        <xsl:for-each select=".//studio">
-                            <xsl:element name="studio">
-                                <xsl:attribute name="name"><xsl:value-of select="normalize-space(@name)"/></xsl:attribute>
-                            </xsl:element>
-                        </xsl:for-each>
-                    </studios>
-                </xsl:if>
-                <xsl:if test=".//country">
-                    <countries>
-                        <xsl:for-each select=".//country">
-                            <xsl:element name="country">
-                                <xsl:attribute name="name"><xsl:value-of select="normalize-space(@name)"/></xsl:attribute>
-                            </xsl:element>
-                        </xsl:for-each>
-                    </countries>
-                </xsl:if>
-                <xsl:if test="string(popularity) != ''">
-                    <popularity><xsl:value-of select="normalize-space(popularity)"/></popularity>
-                </xsl:if>
-                <xsl:if test="string(rating) != ''">
-                    <userrating><xsl:value-of select="normalize-space(rating)"/></userrating>
-                </xsl:if>
-                <xsl:if test="string(budget) != ''">
-                    <budget><xsl:value-of select="normalize-space(budget)"/></budget>
-                </xsl:if>
-                <xsl:if test="string(revenue) != ''">
-                    <revenue><xsl:value-of select="normalize-space(revenue)"/></revenue>
-                </xsl:if>
-                <xsl:if test="string(released) != ''">
-                    <year><xsl:value-of select="normalize-space(substring(string(released), 1, 4))"/></year>
-                    <releasedate><xsl:value-of select="normalize-space(released)"/></releasedate>
-                </xsl:if>
-                <lastupdated><xsl:value-of select="tmdbXpath:lastUpdated(string(last_modified_at), '%Y-%m-%d %H:%M:%S')"/></lastupdated> <!-- RFC-822 date-time -->
-                <xsl:if test="string(runtime) != ''">
-                    <runtime><xsl:value-of select="normalize-space(runtime)"/></runtime>
-                </xsl:if>
-                <inetref><xsl:value-of select="normalize-space(id)"/></inetref>
-                <xsl:if test="string(imdb_id) != ''">
-                    <imdb><xsl:value-of select="normalize-space(normalize-space(substring-after(string(imdb_id), 'tt')))"/></imdb> <!-- IMDB number -->
-                </xsl:if>
-                <homepage><xsl:value-of select="normalize-space(url)"/></homepage>
-                <xsl:if test="string(trailer) != ''">
-                    <trailer><xsl:value-of select="normalize-space(trailer)"/></trailer>
-                </xsl:if>
-                <xsl:if test="tmdbXpath:supportedJobs(.//person/@job)">
-                    <people>
-                        <xsl:for-each select=".//person">
-                            <xsl:if test="tmdbXpath:supportedJobs((@job))">
-                                <xsl:element name="person">
-                                    <xsl:attribute name="name"><xsl:value-of select="normalize-space(@name)"/></xsl:attribute>
-                                    <xsl:attribute name="job"><xsl:value-of select="normalize-space(@job)"/></xsl:attribute>
-                                    <xsl:if test="@character != ''">
-                                        <xsl:attribute name="character"><xsl:value-of select="normalize-space(@character)"/></xsl:attribute>
-                                    </xsl:if>
-                                    <xsl:if test="@thumb != ''">
-                                        <xsl:attribute name="thumb"><xsl:value-of select="normalize-space(@thumb)"/></xsl:attribute>
-                                        <xsl:attribute name="url"><xsl:value-of select="normalize-space(tmdbXpath:replaceText(@thumb, 'thumb', 'profile'))"/></xsl:attribute>
-                                    </xsl:if>
-                                    <xsl:if test="@department != ''">
-                                        <xsl:attribute name="department"><xsl:value-of select="normalize-space(@department)"/></xsl:attribute>
-                                    </xsl:if>
-                                </xsl:element>
-                            </xsl:if>
-                        </xsl:for-each>
-                    </people>
-                </xsl:if>
-                <xsl:if test="tmdbXpath:verifyName(.//image/@type)">
-                    <images>
-                        <xsl:for-each select="tmdbXpath:makeImageElements(.//image)">
-                            <image>
-                                <xsl:attribute name="type"><xsl:value-of select="normalize-space(./@type)"/></xsl:attribute>
-                                <xsl:if test="./@thumb != ''">
-                                    <xsl:attribute name="thumb"><xsl:value-of select="normalize-space(./@thumb)"/></xsl:attribute>
-                                </xsl:if>
-                                <xsl:if test="./@url != ''">
-                                    <xsl:attribute name="url"><xsl:value-of select="normalize-space(./@url)"/></xsl:attribute>
-                                </xsl:if>
-                                <xsl:if test="./@width != ''">
-                                    <xsl:attribute name="width"><xsl:value-of select="normalize-space(./@width)"/></xsl:attribute>
-                                </xsl:if>
-                                <xsl:if test="./@height != ''">
-                                    <xsl:attribute name="height"><xsl:value-of select="normalize-space(./@height)"/></xsl:attribute>
-                                </xsl:if>
-                            </image>
-                        </xsl:for-each>
-                    </images>
-                </xsl:if>
-            </item>
-        </xsl:for-each>
-    </xsl:template>
-</xsl:stylesheet>
diff --git a/mythtv/bindings/python/MythTV/tmdb/__init__.py b/mythtv/bindings/python/MythTV/tmdb/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/mythtv/bindings/python/MythTV/tmdb/tmdb_api.py b/mythtv/bindings/python/MythTV/tmdb/tmdb_api.py
deleted file mode 100644
index 5197c48..0000000
--- a/mythtv/bindings/python/MythTV/tmdb/tmdb_api.py
+++ /dev/null
@@ -1,1317 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: UTF-8 -*-
-# ----------------------
-# Name: tmdb_api.py      Simple-to-use Python interface to The TMDB's API (www.themoviedb.org)
-# Python Script
-# Author:   dbr/Ben modified by R.D. Vaughan
-# Purpose:  This python script is intended to perform a variety of utility functions to search and access text
-#           metadata and image URLs from TMDB. These routines are based on the v2.1 TMDB api. Specifications
-#           for this apu are published at http://api.themoviedb.org/2.1/
-#
-# License:Creative Commons GNU GPL v2
-# (http://creativecommons.org/licenses/GPL/2.0/)
-#-------------------------------------
-__title__ ="tmdb_api - Simple-to-use Python interface to The TMDB's API (www.themoviedb.org)";
-__author__="dbr/Ben modified by R.D. Vaughan"
-__purpose__='''
-This python script is intended to perform a variety of utility functions to search and access text
-metadata and image URLs from TMDB. These routines are based on the v2.1 TMDB api. Specifications
-for this api are published at http://api.themoviedb.org/2.1/
-'''
-
-__version__="v0.2.6"
-# 0.1.0 Initial development
-# 0.1.1 Alpha Release
-# 0.1.2 Added removal of any line-feeds from data
-# 0.1.3 Added display of URL to TMDB XML when debug was specified
-#       Added check and skipping any empty data from TMDB
-# 0.1.4 More data validation added (e.g. valid image file extentions)
-#       More data massaging added.
-# 0.1.5 Added a superclass to perform TMDB Trailer searches for the Mythnetvison grabber tmdb_nv.py
-# 0.1.6 Improved displayed error messages on an exception abort
-# 0.1.7 Fixed issues with interactive movie selection
-# 0.1.8 Fixed the error message reporting when the machines Internet connection or DNS is not working
-# 0.1.9 Fixed an abort with the People data logic due to empty data (e.g. biography) being passed by TMDB
-#       Included in this change are a number of other potential empty data checks.
-# 0.2.0 Support multi-languages. TMDB supports multi-languages with a fall back to English when the
-#       data is not in the specified language
-# 0.2.1 Add support for XML display. http://www.mythtv.org/wiki/MythTV_Universal_Metadata_Format
-# 0.2.2 Fixed a bug with XSLT title and subtitle.
-# 0.2.3 Added encoding XML declaration "<?xml version='1.0' encoding='UTF-8'?>" to output
-# 0.2.4 Added width and height attributes to images
-# 0.2.5 Added a replace text XPatch extention so that "person" full size images can be created from
-#       the thumbnail.
-# 0.2.6 Fixed processing publish date when it is a 'UTC' date
-#       Code line length clean up
-
-import os, struct, sys, time
-import urllib, urllib2
-from copy import deepcopy
-import logging
-
-from tmdb_ui import BaseUI, ConsoleUI
-from tmdb_exceptions import (TmdBaseError, TmdHttpError, TmdXmlError, TmdbUiAbort, TmdbMovieOrPersonNotFound,)
-
-
-class OutStreamEncoder(object):
-    """Wraps a stream with an encoder"""
-    def __init__(self, outstream, encoding=None):
-        self.out = outstream
-        if not encoding:
-            self.encoding = sys.getfilesystemencoding()
-        else:
-            self.encoding = encoding
-
-    def write(self, obj):
-        """Wraps the output stream, encoding Unicode strings with the specified encoding"""
-        if isinstance(obj, unicode):
-            try:
-                self.out.write(obj.encode(self.encoding))
-            except IOError:
-                pass
-        else:
-            try:
-                self.out.write(obj)
-            except IOError:
-                pass
-
-    def __getattr__(self, attr):
-        """Delegate everything but write to the stream"""
-        return getattr(self.out, attr)
-sys.stdout = OutStreamEncoder(sys.stdout, 'utf8')
-sys.stderr = OutStreamEncoder(sys.stderr, 'utf8')
-
-
-try:
-    from StringIO import StringIO
-    from lxml import etree as eTree
-except Exception, e:
-    sys.stderr.write(u'\n! Error - Importing the "lxml" and "StringIO" python libraries failed on error(%s)\n' % e)
-    sys.exit(1)
-
-# Check that the lxml library is current enough
-# From the lxml documents it states: (http://codespeak.net/lxml/installation.html)
-# "If you want to use XPath, do not use libxml2 2.6.27. We recommend libxml2 2.7.2 or later"
-# Testing was performed with the Ubuntu 9.10 "python-lxml" version "2.1.5-1ubuntu2" repository package
-version = ''
-for digit in eTree.LIBXML_VERSION:
-    version+=str(digit)+'.'
-version = version[:-1]
-if version < '2.7.2':
-    sys.stderr.write(u'''
-! Error - The installed version of the "lxml" python library "libxml" version is too old.
-          At least "libxml" version 2.7.2 must be installed. Your version is (%s).
-''' % version)
-    sys.exit(1)
-
-
-try:
-    import xml.etree.cElementTree as ElementTree
-except ImportError:
-    import xml.etree.ElementTree as ElementTree
-
-
-class XmlHandler:
-    """Deals with retrieval of XML files from API
-    """
-    def __init__(self, url):
-        self.url = url
-
-    def _grabUrl(self, url):
-        try:
-            urlhandle = urllib.urlopen(url)
-        except IOError, errormsg:
-            raise TmdHttpError(errormsg)
-        return urlhandle.read()
-
-    def getEt(self):
-        xml = self._grabUrl(self.url)
-        try:
-            et = ElementTree.fromstring(xml)
-        except SyntaxError, errormsg:
-            raise TmdXmlError(errormsg)
-        return et
-
-
-class SearchResults(list):
-    """Stores a list of Movie's that matched the search
-    """
-    def __repr__(self):
-        return u"<Search results: %s>" % (list.__repr__(self))
-
-
-class Movie(dict):
-    """A dict containing the information about the film
-    """
-    def __repr__(self):
-        return u"<Movie: %s>" % self.get(u"title")
-
-
-class MovieAttribute(dict):
-    """Base class for more complex attributes (like Poster,
-    which has multiple resolutions)
-    """
-    pass
-
-
-class Poster(MovieAttribute):
-    """Stores poster image URLs, each size is under the appropriate dict key.
-    Common sizes are: cover, mid, original, thumb
-    """
-    def __repr__(self):
-        return u"<%s with sizes %s>" % (
-            self.__class__.__name__,
-            u", ".join(
-                [u"'%s'" % x for x in sorted(self.keys())]
-            )
-        )
-
-    def set(self, poster_et):
-        """Takes an elementtree Element ('poster') and appends the poster,
-        with a the size as the dict key.
-
-        For example:
-        <image type="poster"
-            size="cover"
-            url="http://example.org/poster_original.jpg"
-            id="36431"
-        />
-
-        ..becomes:
-        poster['cover'] = ['http://example.org/poster_original.jpg, '36431']
-        """
-        size = poster_et.get(u"size").strip()
-        url = poster_et.get(u"url").strip()
-        (dirName, fileName) = os.path.split(url)
-        (fileBaseName, fileExtension)=os.path.splitext(fileName)
-        if not fileExtension[1:].lower() in self.image_extentions:
-            return
-        imageid = poster_et.get(u"id").strip()
-        if not self.has_key(size):
-            self[size] = [[url, imageid]]
-        else:
-            self[size].append([url, imageid])
-
-    def largest(self):
-        """Attempts to return largest image.
-        """
-        for cur_size in [u"original", u"mid", u"cover", u"thumb"]:
-            if cur_size in self:
-                return self[cur_size]
-
-    def medium(self):
-        """Attempts to return medium size image.
-        """
-        for cur_size in [u"cover", u"thumb", u"mid", u"original", ]:
-            if cur_size in self:
-                return self[cur_size]
-
-class Backdrop(Poster):
-    """Stores backdrop image URLs, each size under the appropriate dict key.
-    Common sizes are: mid, original, thumb
-    """
-    pass
-
-class People(MovieAttribute):
-    """Stores people in a dictionary of roles in the movie.
-    """
-    def __repr__(self):
-        return u"<%s with jobs %s>" % (
-            self.__class__.__name__,
-            u", ".join(
-                [u"'%s'" % x for x in sorted(self.keys())]
-            )
-        )
-
-    def set(self, cast_et):
-        """Takes an element tree Element ('cast') and stores a dictionary of roles,
-        for each person.
-
-        For example:
-        <cast>
-            <person
-                url="http://www.themoviedb.org/person/138"
-                name="Quentin Tarantino" job="Director"
-                character="Special Guest Director"
-                id="138"/>
-            ...
-         </cast>
-
-        ..becomes:
-        self['people']['director'] = 'Robert Rodriguez'
-        """
-        self[u'people']={}
-        people = self[u'people']
-        for node in cast_et.getchildren():
-            if node.get(u'name') != None:
-                try:
-                    key = unicode(node.get(u"job").lower(), 'utf8')
-                except (UnicodeEncodeError, TypeError):
-                    key = node.get(u"job").lower().strip()
-                try:
-                    data = unicode(node.get(u'name'), 'utf8')
-                except (UnicodeEncodeError, TypeError):
-                    data = node.get(u'name')
-                if people.has_key(key):
-                    people[key]=u"%s,%s" % (people[key], data.strip())
-                else:
-                    people[key]=data.strip()
-
-class MovieDb(object):
-    """Main interface to www.themoviedb.org
-
-    Supports several search TMDB search methods and a number of TMDB data retrieval methods.
-    The apikey is a maditory parameter when creating an instance of this class
-    """
-    def __init__(self,
-                apikey,
-                mythtv = False,
-                interactive = False,
-                select_first = False,
-                debug = False,
-                custom_ui = None,
-                language = None,
-                search_all_languages = False, ###CHANGE - Needs to be added
-                ):
-        """apikey (str/unicode):
-            Specify the themoviedb.org API key. Applications need their own key.
-            See http://api.themoviedb.org/2.1/ to get your own API key
-
-        mythtv (True/False):
-            When True, the movie metadata is being returned has the key and values massaged to match MythTV
-            When False, the movie metadata is being returned matches what TMDB returned
-
-        interactive (True/False):
-            When True, uses built-in console UI is used to select the correct show.
-            When False, the first search result is used.
-
-        select_first (True/False):
-            Automatically selects the first series search result (rather
-            than showing the user a list of more than one series).
-            Is overridden by interactive = False, or specifying a custom_ui
-
-        debug (True/False):
-             shows verbose debugging information
-
-        custom_ui (tmdb_ui.BaseUI subclass):
-            A callable subclass of tmdb_ui.BaseUI (overrides interactive option)
-
-        language (2 character language abbreviation):
-            The language of the returned data. Is also the language search
-            uses. Default is "en" (English).
-
-        search_all_languages (True/False):
-            By default, TMDB will only search in the language specified using
-            the language option. When this is True, it will search for the
-            show in any language
-
-        """
-        self.config = {}
-
-        if apikey is not None:
-            self.config['apikey'] = apikey
-        else:
-            sys.stderr.write("\n! Error: An TMDB API key must be specified. See http://api.themoviedb.org/2.1/ to get your own API key\n\n")
-            sys.exit(1)
-
-        # Set the movie details function to either massaged for MythTV or left as it is returned by TMDB
-        if mythtv:
-            self.movieDetails = self._mythtvDetails
-        else:
-            self.movieDetails = self._tmdbDetails
-
-        self.config['debug_enabled'] = debug # show debugging messages
-
-        self.log = self._initLogger() # Setups the logger (self.log.debug() etc)
-
-        self.config['custom_ui'] = custom_ui
-
-        self.config['interactive'] = interactive # prompt for correct series?
-
-        self.config['select_first'] = select_first
-
-        self.config['search_all_languages'] = search_all_languages
-
-        # The supported languages are any two chracters from
-        # http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
-        # The default is English including returned data if the movie exists but not in the
-        # specified language.
-        if language is None:
-            self.config['language'] = "en"
-        else:
-            self.config['language'] = language
-
-        # The following url_ configs are based of the
-        # http://api.themoviedb.org/2.1/
-        self.config['base_url'] = "http://api.themoviedb.org/2.1"
-
-        self.lang_url = u'/%s/xml/' # Used incase the user wants to overside the configured/default language
-
-        self.config[u'urls'] = {}
-
-        # v2.1 api calls
-        self.config[u'urls'][u'movie.search'] = \
-        u'%(base_url)s/Movie.search/%(language)s/xml/%(apikey)s/%%s' % (self.config)
-        self.config[u'urls'][u'tmdbid.search'] = \
-        u'%(base_url)s/Movie.getInfo/%(language)s/xml/%(apikey)s/%%s' % (self.config)
-        self.config[u'urls'][u'imdb.search'] = \
-        u'%(base_url)s/Movie.imdbLookup/%(language)s/xml/%(apikey)s/tt%%s'  % (self.config)
-        self.config[u'urls'][u'image.search'] = \
-        u'%(base_url)s/Movie.getImages/%(language)s/xml/%(apikey)s/%%s' % (self.config)
-        self.config[u'urls'][u'person.search'] = \
-        u'%(base_url)s/Person.search/%(language)s/xml/%(apikey)s/%%s' % (self.config)
-        self.config[u'urls'][u'person.info'] = \
-        u'%(base_url)s/Person.getInfo/%(language)s/xml/%(apikey)s/%%s' % (self.config)
-        self.config[u'urls'][u'hash.info'] = \
-        u'%(base_url)s/Hash.getInfo/%(language)s/xml/%(apikey)s/%%s' % (self.config)
-
-        # Translation of TMDB elements into MythTV keys/db grabber names
-        self.config[u'mythtv_translation'] = {\
-        u'actor': u'cast', u'backdrop': u'fanart', u'categories': u'genres',
-        u'director':  u'director', u'id': u'inetref', u'name': u'title',
-        u'overview': u'plot', u'rating': u'userrating', u'poster': u'coverart',
-        u'production_countries': u'countries', u'released': u'releasedate',
-        u'runtime': u'runtime', u'url': u'url', u'imdb_id': u'imdb',
-        u'certification': u'movierating', }
-        self.config[u'image_extentions'] = ["png", "jpg", "bmp"] # Acceptable image extentions
-        self.thumbnails = False
-        self.xml = False
-        self.pubDateFormat = u'%a, %d %b %Y %H:%M:%S GMT'
-        self.xmlParser = eTree.HTMLParser(remove_blank_text=True)
-        self.baseProcessingDir = os.path.dirname( os.path.realpath( __file__ ))
-        self.supportedJobList = [\
-        "actor", "author", "producer", "executive producer",
-        "director", "cinematographer", "composer", "editor", "casting", ]
-        self.tagTranslations = {
-            'poster': 'coverart',
-            'backdrop': 'fanart',
-            }
-        self.separatorTitleSubtitle = [
-            ':',
-            ' - ',
-            ]
-    # end __init__()
-
-
-    def _initLogger(self):
-        """Setups a logger using the logging module, returns a log object
-        """
-        logger = logging.getLogger("tmdb")
-        formatter = logging.Formatter('%(asctime)s) %(levelname)s %(message)s')
-
-        hdlr = logging.StreamHandler(sys.stdout)
-
-        hdlr.setFormatter(formatter)
-        logger.addHandler(hdlr)
-
-        if self.config['debug_enabled']:
-            logger.setLevel(logging.DEBUG)
-        else:
-            logger.setLevel(logging.WARNING)
-        return logger
-    #end initLogger
-
-
-    def textUtf8(self, text):
-        if text == None:
-            return text
-        try:
-            return unicode(text, 'utf8')
-        except (UnicodeEncodeError, TypeError):
-            return text
-    # end textUtf8()
-
-
-    def getCategories(self, categories_et):
-        """Takes an element tree Element ('categories') and create a string of comma separated film
-        categories
-        return comma separated string of film category names
-
-        For example:
-        <categories>
-            <category type="genre" url="http://themoviedb.org/encyclopedia/category/80" name="Crime"/>
-            <category type="genre" url="http://themoviedb.org/encyclopedia/category/18" name="Drama"/>
-            <category type="genre" url="http://themoviedb.org/encyclopedia/category/53" name="Thriller"/>
-        </categories>
-
-        ..becomes:
-        'Crime,Drama,Thriller'
-        """
-        cat = u''
-        for category in categories_et.getchildren():
-            if category.get(u'name') != None:
-                cat+=u"%s," % self.textUtf8(category.get(u'name').strip())
-        if len(cat):
-            cat=cat[:-1]
-        return cat
-
-
-    def getStudios(self, studios_et):
-        """Takes an element tree Element ('studios') and create a string of comma separated film
-        studios names
-        return comma separated string of film studios names
-
-        For example:
-        <studios>
-            <studio url="http://www.themoviedb.org/encyclopedia/company/20" name="Miramax Films"/>
-            <studio url="http://www.themoviedb.org/encyclopedia/company/334" name="Dimension"/>
-        </studios>
-
-        ..becomes:
-        'Miramax Films,Dimension'
-        """
-        cat = u''
-        for studio in studios_et.getchildren():
-            if studio.get(u'name') != None:
-                cat+=u"%s," % self.textUtf8(studio.get(u'name').strip())
-        if len(cat):
-            cat=cat[:-1]
-        return cat
-
-    def getProductionCountries(self, countries_et):
-        """Takes an element tree Element ('countries') and create a string of comma separated film
-        countries
-        return comma separated string of countries associated with the film
-
-        For example:
-        <countries>
-            <country url="http://www.themoviedb.org/encyclopedia/country/223" name="United States of America" code="US"/>
-        </countries>
-        ..becomes:
-        'United States of America'
-        """
-        countries = u''
-        for country in countries_et.getchildren():
-            if country.get(u'name') != None:
-                if len(countries):
-                    countries+=u", %s" % self.textUtf8(country.get(u'name').strip())
-                else:
-                    countries=self.textUtf8(country.get(u'name').strip())
-        return countries
-
-
-    def _tmdbDetails(self, movie_element):
-        '''Create a dictionary of movie details including text metadata, image URLs (poster/fanart)
-        return the dictionary of movie information
-        '''
-        cur_movie = Movie()
-        cur_poster = Poster()
-        cur_backdrop = Backdrop()
-        cur_poster.image_extentions = self.config[u'image_extentions']
-        cur_backdrop.image_extentions = self.config[u'image_extentions']
-        cur_people = People()
-
-        for item in movie_element.getchildren():
-            if item.tag.lower() == u"images":
-                for image in item.getchildren():
-                    if image.get(u"type").lower() == u"poster":
-                        cur_poster.set(image)
-                    elif image.get(u"type").lower() == u"backdrop":
-                        cur_backdrop.set(image)
-            elif item.tag.lower() == u"categories":
-                cur_movie[u'categories'] = self.getCategories(item)
-            elif item.tag.lower() == u"studios":
-                cur_movie[u'studios'] = self.getStudios(item)
-            elif item.tag.lower() == u"countries":
-                cur_movie[u'production_countries'] = self.getProductionCountries(item)
-            elif item.tag.lower() == u"cast":
-                cur_people.set(item)
-            else:
-                if item.text != None:
-                    tag = self.textUtf8(item.tag.strip())
-                    cur_movie[tag] = self.textUtf8(item.text.strip())
-
-        if cur_poster.largest() != None:
-            tmp = u''
-            for imagedata in cur_poster.largest():
-                if imagedata[0]:
-                    tmp+=u"%s," % imagedata[0]
-            if len(tmp):
-                tmp = tmp[:-1]
-                cur_movie[u'poster'] = tmp
-        if self.thumbnails and cur_poster.medium() != None:
-            tmp = u''
-            for imagedata in cur_poster.medium():
-                if imagedata[0]:
-                    tmp+=u"%s," % imagedata[0]
-            if len(tmp):
-                tmp = tmp[:-1]
-                cur_movie[self.thumbnails] = tmp
-        if cur_backdrop.largest() != None:
-            tmp = u''
-            for imagedata in cur_backdrop.largest():
-                if imagedata[0]:
-                    tmp+=u"%s," % imagedata[0]
-            if len(tmp):
-                tmp = tmp[:-1]
-                cur_movie[u'backdrop'] = tmp
-        if cur_people.has_key(u'people'):
-            if cur_people[u'people'] != None:
-                for key in cur_people[u'people']:
-                    if cur_people[u'people'][key]:
-                        cur_movie[key] = cur_people[u'people'][key]
-
-        if self._tmdbDetails == self.movieDetails:
-            data = {}
-            for key in cur_movie.keys():
-                if cur_movie[key]:
-                    data[key] = cur_movie[key]
-            return data
-        else:
-            return cur_movie
-    # end _tmdbDetails()
-
-
-    def _mythtvDetails(self, movie_element):
-        '''Massage the movie details into key value pairs as compatible with MythTV
-        return a dictionary of massaged movie details
-        '''
-        if movie_element == None:
-            return {}
-        cur_movie = self._tmdbDetails(movie_element)
-        translated={}
-        for key in cur_movie:
-            if cur_movie[key] == None or cur_movie[key] == u'None':
-                continue
-            if isinstance(cur_movie[key], str) or isinstance(cur_movie[key], unicode):
-                if cur_movie[key].strip() == u'':
-                    continue
-                else:
-                   cur_movie[key] = cur_movie[key].strip()
-            if key in [u'rating']:
-                if cur_movie[key] == 0.0 or cur_movie[key] == u'0.0':
-                    continue
-            if key in [u'popularity', u'budget', u'runtime', u'revenue', ]:
-                if cur_movie[key] == 0 or cur_movie[key] == u'0':
-                    continue
-            if key == u'imdb_id':
-                cur_movie[key] = cur_movie[key][2:]
-            if key == u'released':
-                translated[u'year'] = cur_movie[key][:4]
-            if self.config[u'mythtv_translation'].has_key(key):
-                translated[self.config[u'mythtv_translation'][key]] = cur_movie[key]
-            else:
-                translated[key] = cur_movie[key]
-            for key in translated.keys():
-                if translated[key]:
-                    translated[key] = translated[key].replace(u'\n',u' ') # Remove any line-feeds from data
-        return translated
-    # end _mythtvDetails()
-
-
-    def searchTitle(self, title, lang=False):
-        """Searches for a film by its title.
-        Returns SearchResults (a list) containing all matches (Movie instances)
-        """
-        if lang: # Override language
-            URL = self.config[u'urls'][u'movie.search'].replace(self.lang_url % self.config['language'], self.lang_url % lang)
-        else:
-            URL = self.config[u'urls'][u'movie.search']
-        org_title = title
-
-        # strip out leading periods
-        if title.startswith('.'):
-            prepend = ''
-            for char in title:
-                if char != '.':
-                    break
-                prepend += '\.'
-            title = prepend + title.lstrip('.')
-
-        # strip out question marks
-        title = title.replace('?','')
-
-        title = urllib.quote(title.encode("utf-8"))
-
-        url = URL % (title)
-        if self.config['debug_enabled']:        # URL so that raw TMDB XML data can be viewed in a browser
-            sys.stderr.write(u'\nDEBUG: XML URL:%s\n\n' % url)
-
-        # Display a XML query if it was requested
-        if self.xml:
-            self.queryXML(url)
-
-        etree = XmlHandler(url).getEt()
-        if etree is None:
-            raise TmdbMovieOrPersonNotFound(u'No Movies matching the title (%s)' % org_title)
-
-        search_results = SearchResults()
-        for cur_result in etree.find(u"movies").findall(u"movie"):
-            if cur_result == None:
-                continue
-            cur_movie = self._tmdbDetails(cur_result)
-            search_results.append(cur_movie)
-        if not len(search_results):
-            raise TmdbMovieOrPersonNotFound(u'No Movies matching the title (%s)' % org_title)
-
-        # Check if no ui has been requested and therefore just return the raw search results.
-        if (self.config['interactive'] == False and self.config['select_first'] == False and self.config['custom_ui'] == None) or not len(search_results):
-            return search_results
-
-        # Select the first result (most likely match) or invoke user interaction to select the correct movie
-        if self.config['custom_ui'] is not None:
-            self.log.debug("Using custom UI %s" % (repr(self.config['custom_ui'])))
-            ui = self.config['custom_ui'](config = self.config, log = self.log, searchTerm = org_title)
-        else:
-            if not self.config['interactive']:
-                self.log.debug('Auto-selecting first search result using BaseUI')
-                ui = BaseUI(config = self.config, log = self.log, searchTerm = org_title)
-            else:
-                self.log.debug('Interactivily selecting movie using ConsoleUI')
-                ui = ConsoleUI(config = self.config, log = self.log, searchTerm = org_title)
-        return ui.selectMovieOrPerson(search_results)
-    # end searchTitle()
-
-    def searchTMDB(self, by_id, lang=False):
-        """Searches for a film by its TMDB id number.
-        Returns a movie data dictionary
-        """
-        if lang: # Override language
-            URL = self.config[u'urls'][u'tmdbid.search'].replace(self.lang_url % self.config['language'], self.lang_url % lang)
-        else:
-            URL = self.config[u'urls'][u'tmdbid.search']
-        id_url = urllib.quote(by_id.encode("utf-8"))
-        url = URL % (id_url)
-        if self.config['debug_enabled']:        # URL so that raw TMDB XML data can be viewed in a browser
-            sys.stderr.write(u'\nDEBUG: XML URL:%s\n\n' % url)
-
-        # Display a XML video details if it was requested
-        if self.xml:
-            self.videoXML(url)
-
-        etree = XmlHandler(url).getEt()
-
-        if etree is None:
-            raise TmdbMovieOrPersonNotFound(u'No Movies matching the TMDB number (%s)' % by_id)
-        if etree.find(u"movies").find(u"movie"):
-            return self.movieDetails(etree.find(u"movies").find(u"movie"))
-        else:
-            raise TmdbMovieOrPersonNotFound(u'No Movies matching the TMDB number (%s)' % by_id)
-
-    def searchIMDB(self, by_id, lang=False):
-        """Searches for a film by its IMDB number.
-        Returns a movie data dictionary
-        """
-        if lang: # Override language
-            URL = self.config[u'urls'][u'imdb.search'].replace(self.lang_url % self.config['language'], self.lang_url % lang)
-        else:
-            URL = self.config[u'urls'][u'imdb.search']
-        id_url = urllib.quote(by_id.encode("utf-8"))
-        url = URL % (id_url)
-        if self.config['debug_enabled']:        # URL so that raw TMDB XML data can be viewed in a browser
-            sys.stderr.write(u'\nDEBUG: XML URL:%s\n\n' % url)
-
-        # Display a XML video details if it was requested
-        if self.xml:
-            self.videoXML(url)
-
-        etree = XmlHandler(url).getEt()
-
-        if etree is None:
-            raise TmdbMovieOrPersonNotFound(u'No Movies matching the IMDB number (%s)' % by_id)
-        if etree.find(u"movies").find(u"movie") == None:
-            raise TmdbMovieOrPersonNotFound(u'No Movies matching the IMDB number (%s)' % by_id)
-
-        if self._tmdbDetails(etree.find(u"movies").find(u"movie")).has_key(u'id'):
-            return self.searchTMDB(self._tmdbDetails(etree.find(u"movies").find(u"movie"))[u'id'],)
-        else:
-            raise TmdbMovieOrPersonNotFound(u'No Movies matching the IMDB number (%s)' % by_id)
-
-    def searchHash(self, by_hash, lang=False):
-        """Searches for a film by its TMDB id number.
-        Returns a movie data dictionary
-        """
-        if lang: # Override language
-            URL = self.config[u'urls'][u'hash.info'].replace(self.lang_url % self.config['language'], self.lang_url % lang)
-        else:
-            URL = self.config[u'urls'][u'hash.info']
-        id_url = urllib.quote(by_hash.encode("utf-8"))
-        url = URL % (id_url)
-        if self.config['debug_enabled']:        # URL so that raw TMDB XML data can be viewed in a browser
-            sys.stderr.write(u'\nDEBUG: XML URL:%s\n\n' % url)
-
-        # Display a XML video details if it was requested
-        if self.xml:
-            self.videoXML(url)
-
-        etree = XmlHandler(url).getEt()
-
-        if etree is None:
-            raise TmdbMovieOrPersonNotFound(u'No Movies matching the hash value (%s)' % by_hash)
-        if etree.find(u"movies").find(u"movie"):
-            return self.movieDetails(etree.find(u"movies").find(u"movie"))
-        else:
-            raise TmdbMovieOrPersonNotFound(u'No Movies matching the hash value (%s)' % by_hash)
-
-
-    def searchImage(self, by_id, lang=False, filterout=False):
-        """Searches for a film's images URLs by TMDB number.
-        Returns a image URL dictionary
-        """
-        if lang: # Override language
-            URL = self.config[u'urls'][u'image.search'].replace(self.lang_url % self.config['language'], self.lang_url % lang)
-        else:
-            URL = self.config[u'urls'][u'image.search']
-        id_url = urllib.quote(by_id.encode("utf-8"))
-        url = URL % (id_url)
-        if self.config['debug_enabled']:        # URL so that raw TMDB XML data can be viewed in a browser
-            sys.stderr.write(u'\nDEBUG: XML URL:%s\n\n' % url)
-
-        etree = XmlHandler(url).getEt()
-        if etree is None:
-            raise TmdbMovieOrPersonNotFound(u'No Movie matching the TMDB number (%s)' % by_id)
-        if not etree.find(u"movies").find(u"movie"):
-            raise TmdbMovieOrPersonNotFound(u'No Movie matching the TMDB number (%s)' % by_id)
-
-        cur_poster = {}
-        cur_backdrop = {}
-
-        for item in etree.find(u"movies").find(u"movie").getchildren():
-            if item.tag.lower() == u"images":
-                for image in item.getchildren():
-                    if image.tag == u"poster":
-                        for poster in image.getchildren():
-                            key = poster.get('size')
-                            if key in cur_poster.keys():
-                                if poster.get('url'):
-                                    cur_poster[key.strip()].append(poster.get('url').strip())
-                            else:
-                                if poster.get('url'):
-                                    cur_poster[key.strip()] = [poster.get('url').strip()]
-                    elif image.tag == u"backdrop":
-                        for backdrop in image.getchildren():
-                            key = backdrop.get('size')
-                            if key in cur_backdrop.keys():
-                                if backdrop.get('url'):
-                                    cur_backdrop[key.strip()].append(backdrop.get('url').strip())
-                            else:
-                                if backdrop.get('url'):
-                                    cur_backdrop[key.strip()] = [backdrop.get('url').strip()]
-        images = {}
-        if cur_poster.keys():
-            for cur_size in [u"original", u"mid", u"cover", u"thumb"]:
-                keyvalue = u'poster_%s' % cur_size
-                tmp = u''
-                if cur_size in cur_poster:
-                    for data in cur_poster[cur_size]:
-                        tmp+=u'%s,' % data
-                if len(tmp):
-                    tmp=tmp[:-1]
-                    images[keyvalue] = tmp
-
-        if cur_backdrop.keys():
-            for cur_size in [u"original", u"mid", u"cover", u"thumb"]:
-                keyvalue = u'fanart_%s' % cur_size
-                tmp = u''
-                if cur_size in cur_backdrop:
-                    for data in cur_backdrop[cur_size]:
-                        tmp+= u'%s,' % data
-                if len(tmp):
-                    tmp=tmp[:-1]
-                    images[keyvalue] = tmp
-        if filterout:
-            if images.has_key(filterout):
-                return images[filterout]
-            else:
-                return u''
-        else:
-            return images
-    # end searchImage()
-
-    def searchPeople(self, name, lang=False):
-        """Searches for a People by name.
-        Returns a list if matching persons and a dictionary of their attributes
-        """
-        tmp_name = name.strip().replace(u' ',u'+')
-        try:
-            id_url = urllib.quote(tmp_name.encode("utf-8"))
-        except (UnicodeEncodeError, TypeError):
-            id_url = urllib.quote(tmp_name)
-        if lang: # Override language
-            URL = self.config[u'urls'][u'person.search'].replace(self.lang_url % self.config['language'], self.lang_url % lang)
-        else:
-            URL = self.config[u'urls'][u'person.search']
-        url = URL % (id_url)
-        if self.config['debug_enabled']:        # URL so that raw TMDB XML data can be viewed in a browser
-            sys.stderr.write(u'\nDEBUG: XML URL:%s\n\n' % url)
-
-        etree = XmlHandler(url).getEt()
-        if etree is None:
-            raise TmdbMovieOrPersonNotFound(u'No People matches found for the name (%s)' % name)
-        if not etree.find(u"people").find(u"person"):
-            raise TmdbMovieOrPersonNotFound(u'No People matches found for the name (%s)' % name)
-
-        people = []
-        for item in etree.find(u"people").getchildren():
-            if item.tag == u"person":
-                person = {}
-                for p in item.getchildren():
-                    if p.tag != u'images':
-                        if p.text != None:
-                            person[p.tag] = self.textUtf8(p.text.strip())
-                    elif len(p.getchildren()):
-                        person[p.tag] = {}
-                        for image in p.getchildren():
-                            if image.get('url') != None and image.get('size') != None:
-                                person[p.tag][image.get('size')] = image.get('url').strip()
-                people.append(person)
-
-        # Check if no ui has been requested and therefore just return the raw search results.
-        if (self.config['interactive'] == False and self.config['select_first'] == False and self.config['custom_ui'] == None) or not len(people):
-            return people
-
-        # Select the first result (most likely match) or invoke user interaction to select the correct movie
-        if self.config['custom_ui'] is not None:
-            self.log.debug("Using custom UI %s" % (repr(self.config['custom_ui'])))
-            ui = self.config['custom_ui'](config = self.config, log = self.log, searchTerm = name.strip())
-        else:
-            if not self.config['interactive']:
-                self.log.debug('Auto-selecting first search result using BaseUI')
-                ui = BaseUI(config = self.config, log = self.log, searchTerm = name.strip())
-            else:
-                self.log.debug('Interactivily selecting movie using ConsoleUI')
-                ui = ConsoleUI(config = self.config, log = self.log, searchTerm = name.strip())
-        return ui.selectMovieOrPerson(people)
-    # end searchPeople()
-
-
-    def personInfo(self, by_id, lang=False):
-        """Retrieve a Person's informtaion by their TMDB id.
-        Returns dictionary of the persons information attributes
-        """
-        if lang: # Override language
-            URL = self.config[u'urls'][u'person.info'].replace(self.lang_url % self.config['language'], self.lang_url % lang)
-        else:
-            URL = self.config[u'urls'][u'person.info']
-        id_url = urllib.quote(by_id)
-        url = URL % (id_url)
-        if self.config['debug_enabled']:        # URL so that raw TMDB XML data can be viewed in a browser
-            sys.stderr.write(u'\nDEBUG: XML URL:%s\n\n' % url)
-
-        etree = XmlHandler(url).getEt()
-        if etree is None:
-            raise TmdbMovieOrPersonNotFound(u'No Person match found for the Person ID (%s)' % by_id)
-        if not etree.find(u"people").find(u"person"):
-            raise TmdbMovieOrPersonNotFound(u'No Person match found for the Person ID (%s)' % by_id)
-        person = {}
-        elements = ['also_known_as', 'filmography', 'images' ]
-
-        for elem in etree.find(u"people").find(u"person").getchildren():
-            if elem.tag in elements:
-                if elem.tag == 'also_known_as':
-                    alias = []
-                    for a in elem.getchildren():
-                        if a.text:
-                            alias.append(self.textUtf8(a.text.strip()).replace(u'\n',u' '))
-                    if len(alias):
-                        person[elem.tag] = alias
-                elif elem.tag == 'filmography':
-                    movies = []
-                    for a in elem.getchildren():
-                        details = {}
-                        for get in ['url', 'name', 'character', 'job', 'id']:
-                            if a.get(get):
-                                details[get] = a.get(get).strip()
-                        if len(details):
-                            movies.append(details)
-                    if len(movies):
-                        person[elem.tag] = movies
-                elif len(elem.getchildren()):
-                    images = {}
-                    for image in elem.getchildren():
-                        if image.get('url') == None:
-                            continue
-                        (dirName, fileName) = os.path.split(image.get('url'))
-                        (fileBaseName, fileExtension) = os.path.splitext(fileName)
-                        if not fileExtension[1:] in self.config[u'image_extentions']:
-                            continue
-                        if image.get('size') in images.keys():
-                            if image.get('url'):
-                                images[image.get('size')]+= u',%s' % image.get('url').strip()
-                        else:
-                            if image.get('url') and image.get('size'):
-                                images[image.get('size')] = u'%s' % image.get('url').strip()
-                    if len(images):
-                        person[elem.tag] = images
-            else:
-                if elem.text:
-                    person[elem.tag] = self.textUtf8(elem.text.strip()).replace(u'\n',u' ')
-        return person
-    # end personInfo()
-
-    def lastUpdated(self, context, *inputArgs):
-        '''Convert a date/time string in a specified format into a lastupdated. The default is the
-        Universal Metadata Format item format
-        return the formatted lastupdated string
-        return on error return the original date string
-        '''
-        args = []
-        for arg in inputArgs:
-            args.append(arg)
-        if args[0] == u'':
-            return datetime.datetime.now().strftime(self.pubDateFormat)
-        index = args[0].find('+')
-        if index != -1:
-            args[0] = args[0][:index].strip()
-        args[0] = args[0].replace(',', u'').replace('.', u'')
-        try:
-            if len(args) > 1:
-                args[1] = args[1].replace(',', u'').replace('.', u'')
-                for cutOff in ['GMT', 'UTC']:
-                    if args[1].find(cutOff) != -1:
-                        args[1] = args[1][:args[1].find(cutOff)].strip()
-                        args[0] = args[0][:args[0].rfind(' ')].strip()
-                    if args[0].find(cutOff) != -1:
-                        args[0] = args[0][:args[0].find(cutOff)].strip()
-                try:
-                    pubdate = time.strptime(args[0], args[1])
-                except ValueError:
-                    if args[1] == '%a %d %b %Y %H:%M:%S':
-                        pubdate = time.strptime(args[0], '%a %d %B %Y %H:%M:%S')
-                    elif args[1] == '%a %d %B %Y %H:%M:%S':
-                        pubdate = time.strptime(args[0], '%a %d %b %Y %H:%M:%S')
-                    else:
-                        pubdate = datetime.datetime.now().strftime(self.pubDateFormat)
-                if len(args) > 2:
-                    return time.strftime(args[2], pubdate)
-                else:
-                    return time.strftime(self.pubDateFormat, pubdate)
-            else:
-                return datetime.datetime.now().strftime(self.pubDateFormat)
-        except Exception, err:
-            sys.stderr.write(u'! Error: lastupdated variables(%s) error(%s)\n' % (args, err))
-        return args[0]
-    # end lastUpdated()
-
-    def supportedJobs(self, context, *inputArgs):
-        '''Validate that the job category is supported by the
-        Universal Metadata Format item format
-        return True is supported
-        return False if not supported
-        '''
-        for job in inputArgs[0]:
-            if job.lower() in self.supportedJobList:
-                return True
-        return False
-    # end supportedJobs()
-
-    def verifyName(self, context, *inputArgs):
-        '''Verify a tag name is supported in the Universal Metadata Format. Handles one or more names.
-        When there is a tuple list of names only one in the list needs to be a supported tag.
-        return True when the tag is supported
-        return False when the tag is not supported
-        '''
-        for tag in inputArgs[0]:
-            if tag.lower() in self.tagTranslations.keys():
-                return True
-        return False
-    # end verifyName()
-
-    def translateName(self, context, *inputArgs):
-        '''Translate a tag name into the Universal Metadata Format item equivalent
-        return the translated tag equivalent
-        return False if the tag has no translation value
-        '''
-        name = inputArgs[0]
-        name = name.lower()
-        if name in self.tagTranslations.keys():
-            return self.tagTranslations[name]
-        return False
-    # end translateName()
-
-    def titleElement(self, context, *inputArgs):
-        '''Check the title to see if it should be split into a title and subtitle
-        return a list containing an element with attributes for title and subtitle
-        '''
-        name = inputArgs[0]
-        titleElement = eTree.XML(u'<title></title>')
-        titleElement.attrib['title'] = name
-        for separator in self.separatorTitleSubtitle:
-            index = name.find(separator)
-            if index == -1:
-                continue
-            titleElement.attrib['title'] = name[:index].strip()
-            titleElement.attrib['subtitle'] = name[index+len(separator):].strip()
-        return [titleElement]
-    # end titleElement()
-
-    def makeImageElements(self, context, *inputArgs):
-        '''Take list of image elements and create Universal Metadata Format item image elements
-        return a list of processed image elements
-        '''
-        imageList = []
-        currentImageID = None
-        imageElement = None
-        for tmdbImage in inputArgs[0]:
-            if not tmdbImage.attrib['size'] in ['original', 'cover', 'thumb']:
-                continue
-            if currentImageID != None and currentImageID != tmdbImage.attrib['id']:
-                imageList.append(deepcopy(imageElement))
-                imageElement = None
-            if imageElement == None:
-                imageElement = eTree.XML(u'<image></image>')
-                imageElement.attrib['type'] = self.translateName('dummy', ((tmdbImage.attrib['type'])))
-                currentImageID = tmdbImage.attrib['id']
-            if tmdbImage.attrib['size'] == 'original':
-                imageElement.attrib['url'] = tmdbImage.attrib['url']
-                imageElement.attrib['width'] = tmdbImage.attrib['width']
-                imageElement.attrib['height'] = tmdbImage.attrib['height']
-                continue
-            if tmdbImage.attrib['size'] == 'cover' and imageElement.attrib['type'] == 'coverart':
-                imageElement.attrib['thumb'] = tmdbImage.attrib['url']
-                continue
-            if tmdbImage.attrib['size'] == 'thumb' and imageElement.attrib['type'] == 'fanart':
-                imageElement.attrib['thumb'] = tmdbImage.attrib['url']
-                continue
-
-        # Add any last image elements
-        if imageElement != None:
-            imageList.append(deepcopy(imageElement))
-        return imageList
-    # end makeImageElements()
-
-    def replaceText(self, context, *inputArgs):
-        '''Replace text in a string
-        return the text after a replace was performed
-        '''
-        text = inputArgs[0][0]
-        return text.replace(inputArgs[1], inputArgs[2])
-    # end replaceText()
-
-    def buildFuncDict(self):
-        """ Build a dictionary of the XPath extention function for the XSLT stylesheets
-        Returns nothing
-        """
-        self.FuncDict = {
-            'lastUpdated': self.lastUpdated,
-            'supportedJobs': self.supportedJobs,
-            'verifyName': self.verifyName,
-            'translateName': self.translateName,
-            'makeImageElements': self.makeImageElements,
-            'titleElement': self.titleElement,
-            'replaceText': self.replaceText,
-            }
-        return
-    # end buildFuncDict()
-
-    def queryXML(self, url):
-        """Display a Movie query in XML format:
-        http://www.mythtv.org/wiki/MythTV_Universal_Metadata_Format
-        Returns nothing
-        """
-        try:
-            queryResult = eTree.parse(url, parser=self.xmlParser)
-        except Exception, errmsg:
-            sys.stderr.write(u"! Error: Invalid XML was received from themoviedb.org (%s)\n" % errmsg)
-            sys.exit(1)
-
-        queryXslt = eTree.XSLT(eTree.parse(u'%s/XSLT/tmdbQuery.xsl' % self.baseProcessingDir))
-        tmdbXpath = eTree.FunctionNamespace('http://www.mythtv.org/wiki/MythTV_Universal_Metadata_Format')
-        tmdbXpath.prefix = 'tmdbXpath'
-        self.buildFuncDict()
-        for key in self.FuncDict.keys():
-            tmdbXpath[key] = self.FuncDict[key]
-
-        items = queryXslt(queryResult)
-
-        if items.getroot() != None:
-            if len(items.xpath('//item')):
-                sys.stdout.write(eTree.tostring(items, encoding='UTF-8', method="xml", xml_declaration=True, pretty_print=True, ))
-        sys.exit(0)
-    # end queryXML()
-
-    def videoXML(self, url):
-        """Display a Movie details in XML format:
-        http://www.mythtv.org/wiki/MythTV_Universal_Metadata_Format
-        Returns nothing
-        """
-        try:
-            videoResult = eTree.parse(url, parser=self.xmlParser)
-        except Exception, errmsg:
-            sys.stderr.write(u"! Error: Invalid XML was received from themoviedb.org (%s)\n" % errmsg)
-            sys.exit(1)
-
-        videoXslt = eTree.XSLT(eTree.parse(u'%s/XSLT/tmdbVideo.xsl' % self.baseProcessingDir))
-        tmdbXpath = eTree.FunctionNamespace('http://www.mythtv.org/wiki/MythTV_Universal_Metadata_Format')
-        tmdbXpath.prefix = 'tmdbXpath'
-        self.buildFuncDict()
-        for key in self.FuncDict.keys():
-            tmdbXpath[key] = self.FuncDict[key]
-        items = videoXslt(videoResult)
-
-        if items.getroot() != None:
-            if len(items.xpath('//item')):
-                sys.stdout.write(eTree.tostring(items, encoding='UTF-8', method="xml", xml_declaration=True, pretty_print=True, ))
-        sys.exit(0)
-    # end videoXML()
-
-# end MovieDb class
-
-class Videos(MovieDb):
-    """A super class of the MovieDB functionality for the MythTV Netvision plugin functionality.
-    This is done to support a common naming framework for all python Netvision plugins no matter their site
-    target.
-    """
-    def __init__(self, apikey, mythtv, interactive, select_first, debug, custom_ui, language, search_all_languages, ):
-        """Pass the configuration options
-        """
-        super(Videos, self).__init__(apikey, mythtv, interactive, select_first, debug, custom_ui, language, search_all_languages, )
-    # end __init__()
-
-    error_messages = {\
-    'TmdHttpError': u"! Error: A connection error to themoviedb.org was raised (%s)\n",
-    'TmdXmlError': u"! Error: Invalid XML was received from themoviedb.org (%s)\n",
-    'TmdBaseError': u"! Error: A user interface error was raised (%s)\n",
-    'TmdbUiAbort': u"! Error: A user interface input error was raised (%s)\n", }
-    key_translation = [{\
-    'channel_title': 'channel_title', 'channel_link': 'channel_link', 'channel_description':
-    'channel_description', 'channel_numresults': 'channel_numresults', 'channel_returned':
-    'channel_returned', 'channel_startindex': 'channel_startindex'},
-    {'title': 'item_title', 'item_author': 'item_author', 'releasedate':
-    'item_pubdate', 'overview': 'item_description', 'url': 'item_link', 'trailer': 'item_url',
-    'runtime': 'item_duration', 'userrating': 'item_rating', 'width': 'item_width', 'height':
-    'item_height', 'language': 'item_lang'}]
-
-    def searchForVideos(self, title, pagenumber):
-        """Common name for a video search. Used to interface with MythTV plugin NetVision
-        """
-        def displayMovieData(data):
-            '''Parse movie trailer metadata
-            return None if no valid data
-            return a dictionary of Movie trailer metadata
-            '''
-            if data == None:
-                return None
-            if not 'trailer' in data.keys():
-                return None
-            if data['trailer'] == u'':
-                return None
-
-            trailer_data = {}
-            for key in self.key_translation[1].keys():
-                if key in data.keys():
-                    if key == self.thumbnails:
-                        thumbnail = data[key].split(u',')
-                        trailer_data[self.key_translation[1][key]] = thumbnail[0]
-                        continue
-                    if key == 'url':    # themoviedb.org always uses Youtube for trailers
-                        trailer_data[self.key_translation[1][key]] = data['trailer']
-                        continue
-                    if key == 'releasedate':
-                        c = time.strptime(data[key],"%Y-%m-%d")
-            # <pubDate>Tue, 14 Jul 2009 17:05:00 GMT</pubDate> <pubdate>Wed, 24 Jun 2009 03:53:00 GMT</pubdate>
-                        trailer_data[self.key_translation[1][key]] = time.strftime("%a, %d %b %Y 00:%M:%S GMT",c)
-                        continue
-                    trailer_data[self.key_translation[1][key]] = data[key]
-                else:
-                    trailer_data[self.key_translation[1][key]] = u''
-            trailer_data[self.key_translation[1][u'overview']] = self.overview
-
-            return trailer_data
-        # end displayMovieData()
-
-        def movieData(tmdb_id):
-            '''Get Movie data by IMDB or TMDB number and return the details
-            '''
-            try:
-                return displayMovieData(self.searchTMDB(tmdb_id))
-            except TmdbMovieOrPersonNotFound, msg:
-                sys.stderr.write(u"%s\n" % msg)
-                return None
-            except TmdHttpError, msg:
-                sys.stderr.write(self.error_messages['TmdHttpError'] % msg)
-                sys.exit(1)
-            except TmdXmlError, msg:
-                sys.stderr.write(self.error_messages['TmdXmlError'] % msg)
-                sys.exit(1)
-            except TmdBaseError, msg:
-                sys.stderr.write(self.error_messages['TmdBaseError'] % msg)
-                sys.exit(1)
-            except TmdbUiAbort, msg:
-                sys.stderr.write(self.error_messages['TmdbUiAbort'] % msg)
-                sys.exit(1)
-            except Exception, e:
-                sys.stderr.write(u"! Error: Unknown error during a Movie (%s) information lookup\nError(%s)\n" % (tmdb_id, e))
-                sys.exit(1)
-        # end movieData()
-
-        try:
-            data = self.searchTitle(title)
-        except TmdbMovieOrPersonNotFound, msg:
-            sys.stderr.write(u"%s\n" % msg)
-            return []
-        except TmdHttpError, msg:
-            sys.stderr.write(self.error_messages['TmdHttpError'] % msg)
-            sys.exit(1)
-        except TmdXmlError, msg:
-            sys.stderr.write(self.error_messages['TmdXmlError'] % msg)
-            sys.exit(1)
-        except TmdBaseError, msg:
-            sys.stderr.write(self.error_messages['TmdBaseError'] % msg)
-            sys.exit(1)
-        except TmdbUiAbort, msg:
-            sys.stderr.write(self.error_messages['TmdbUiAbort'] % msg)
-            sys.exit(1)
-        except Exception, e:
-            sys.stderr.write(u"! Error: Unknown error during a Movie Trailer search (%s)\nError(%s)\n" % (title, e))
-            sys.exit(1)
-
-        if data == None:
-            return None
-
-        # Set the size of the thumbnail graphics that will be returned
-        self.thumbnails = 'mid'
-        self.key_translation[1][self.thumbnails] = 'item_thumbnail'
-
-        # Channel details and search results
-        channel = {\
-        'channel_title': u'themoviedb.org', 'channel_link': u'http://themoviedb.org',
-        'channel_description': u'themoviedb.org is an open wiki-style movie database',
-        'channel_numresults': 0, 'channel_returned': self.page_limit, u'channel_startindex': 0}
-
-        trailers = []
-        trailer_total = 0
-        starting_index = (int(pagenumber)-1) * self.page_limit
-        for match in data:
-            if match.has_key('overview'):
-                self.overview = match['overview']
-            else:
-                self.overview = u''
-            trailer = movieData(match[u'id'])
-            if trailer:
-                if starting_index != 0:
-                    if not trailer_total > starting_index:
-                        continue
-                trailers.append(trailer)
-                trailer_total+=1
-                if self.page_limit == trailer_total:
-                    break
-        channel['channel_numresults'] = trailer_total
-        startindex = trailer_total + starting_index
-        if startindex < int(pagenumber) * self.page_limit:
-            channel['channel_startindex'] = startindex + 1
-        else:
-            channel['channel_startindex'] = (int(pagenumber) * self.page_limit) + startindex - 1
-        return [[channel, trailers]]
-    # end searchForVideos()
-# end Videos() class
-
-def main():
-    """Simple example of using tmdb_api - it just
-    searches for any movies with the word "Avatar" in its tile and returns a list of matches with their summary
-    information in a dictionary. And gets movie details using an IMDB# and a TMDB#
-    """
-    # themoviedb.org api key given by Travis Bell for Mythtv
-    api_key = "c27cb71cff5bd76e1a7a009380562c62"
-    tmdb = MovieDb(api_key)
-    # Output a dictionary of matching movie titles
-    print tmdb.searchTitle(u'Avatar')
-    print
-    # Output a dictionary of matching movie details for IMDB number '0401792'
-    print tmdb.searchIMDB(u'0401792')
-    # Output a dictionary of matching movie details for TMDB number '19995'
-    print tmdb.searchTMDB(u'19995')
-# end main()
-
-if __name__ == '__main__':
-    main()
diff --git a/mythtv/bindings/python/MythTV/tmdb/tmdb_exceptions.py b/mythtv/bindings/python/MythTV/tmdb/tmdb_exceptions.py
deleted file mode 100644
index 4cdbbd6..0000000
--- a/mythtv/bindings/python/MythTV/tmdb/tmdb_exceptions.py
+++ /dev/null
@@ -1,45 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: UTF-8 -*-
-# ----------------------
-# Name: tmdb_exceptions - Custom exceptions used or raised by tmdb_api
-# Python Script
-# Author:   dbr/Ben modified by R.D. Vaughan
-# Purpose:  Custom exceptions used or raised by tmdb_api
-#
-# License:Creative Commons GNU GPL v2
-# (http://creativecommons.org/licenses/GPL/2.0/)
-#-------------------------------------
-__title__ ="tmdb_exceptions - Custom exceptions used or raised by tmdb_api";
-__author__="dbr/Ben modified by R.D. Vaughan"
-__version__="v0.1.4"
-# 0.1.0 Initial development
-# 0.1.1 Alpha Release
-# 0.1.2 Release bump - no changes to this code
-# 0.1.3 Release bump - no changes to this code
-# 0.1.4 Release bump - no changes to this code
-
-__all__ = ["TmdBaseError", "TmdHttpError", "TmdXmlError", "TmdbUiAbort", "TmdbMovieOrPersonNotFound", ]
-
-# Start of code used to access themoviedb.org api
-class TmdBaseError(Exception):
-    pass
-
-class TmdHttpError(TmdBaseError):
-    def __repr__(self):    # Display the type of error
-        return None
-    # end __repr__
-
-class TmdXmlError(TmdBaseError):
-    def __repr__(self):    # Display the type of error
-        return None
-    # end __repr__
-
-class TmdbMovieOrPersonNotFound(TmdBaseError):
-    def __repr__(self):
-        return None
-    # end __repr__
-
-class TmdbUiAbort(TmdBaseError):
-    def __repr__(self):
-        return None
-    # end __repr__
diff --git a/mythtv/bindings/python/MythTV/tmdb/tmdb_ui.py b/mythtv/bindings/python/MythTV/tmdb/tmdb_ui.py
deleted file mode 100644
index 6ba5241..0000000
--- a/mythtv/bindings/python/MythTV/tmdb/tmdb_ui.py
+++ /dev/null
@@ -1,266 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: UTF-8 -*-
-# ----------------------
-# Name: tmdb_ui.py  Is a simple console user interface for the tmdb_api. The interface is used selection
-#		of a movie from themoviesdb.org.
-# Python Script
-# Author:   dbr/Ben modified by R.D. Vaughan
-# Purpose:  Console interface for selecting a movie from themoviedb.org. This interface would be invoked when
-#			an exact match is not found and the invoking script has specified the "interactive = True" when
-#			creating an instance of MovieDb().
-#
-# License:Creative Commons GNU GPL v2
-# (http://creativecommons.org/licenses/GPL/2.0/)
-#-------------------------------------
-__title__ ="tmdb_ui - Is a simple console user interface for the tmdb_api. The interface is used selection of a movie oe person from themoviesdb.org.";
-__author__="dbr/Ben modified by R.D. Vaughan"
-__purpose__='''Console interface for selecting a movie from themoviedb.org. This interface would be invoked when an exact match is not found and the invoking script has specified the "interactive = True" when creating an instance of MovieDb().
-'''
-__version__="v0.1.5"
-# 0.1.0 Initial development
-# 0.1.1 Alpha Release
-# 0.1.2 Release bump - no changes to this code
-# 0.1.3 Release bump - no changes to this code
-# 0.1.4 Release bump - no changes to this code
-# 0.1.5 Modified automated selection when there was only one search result. It was causing
-#       too many incorrect selections.
-#       Also removed a duplicate initialization of the version number.
-
-
-"""Contains included user interfaces for tmdb movie/person selection.
-
-A UI is a callback. A class, it's __init__ function takes two arguments:
-
-- config, which is the tmdb config dict, setup in tmdb_api.py
-- log, which is tmdb's logger instance (which uses the logging module). You can
-call log.info() log.warning() etc
-
-It pass a dictionary "allElements", this is passed a list of dicts, each dict
-contains at least the keys "name" (human readable movie name), and "id" (the movies/person)
-ID as on themoviedb.org). for movies only if the key 'released' is included the year will be added
-to the movie title like 'Avatar (2009)' all other keys will be ignored.
-For example:
-
-[{'name': u'Avatar', 'id': u'19995', 'released': '2009-12-25'},
- {'name': u'Avatar - Sequel', 'id': u'73181'}]
-OR
-[{'name': u'Tom Cruise', 'id': u'500'},
- {'name': u'Cruise Moylan', 'id': u'77716'}]
-
-
-The "selectMovieOrPerson" method must return the appropriate dict, or it can raise
-TmdbUiAbort (if the selection is aborted), TmdbMovieOrPersonNotFound (if the movie
-or person cannot be found).
-
-A simple example callback, which returns a random movie:
-
->>> import random
->>> from tmdb_api_ui import BaseUI
->>> class RandomUI(BaseUI):
-...    def selectMovieOrPerson(self, allElements):
-...            import random
-...            return random.choice(allElements)
-
-Then to use it..
-
->>> from tmdb_api import MovieDb
->>> t = MovieDb(custom_ui = RandomUI)
->>> random_matching_movie = t.searchTitle('Avatar')
->>> type(random_matching_movie)
-[{"Avatar",'19995'}]
-"""
-
-import os, struct, sys, string
-from tmdb_exceptions import TmdbUiAbort
-
-class OutStreamEncoder(object):
-    """Wraps a stream with an encoder"""
-    def __init__(self, outstream, encoding=None):
-        self.out = outstream
-        if not encoding:
-            self.encoding = sys.getfilesystemencoding()
-        else:
-            self.encoding = encoding
-
-    def write(self, obj):
-        """Wraps the output stream, encoding Unicode strings with the specified encoding"""
-        if isinstance(obj, unicode):
-            try:
-                self.out.write(obj.encode(self.encoding))
-            except IOError:
-                pass
-        else:
-            try:
-                self.out.write(obj)
-            except IOError:
-                pass
-
-    def __getattr__(self, attr):
-        """Delegate everything but write to the stream"""
-        return getattr(self.out, attr)
-sys.stdout = OutStreamEncoder(sys.stdout, 'utf8')
-sys.stderr = OutStreamEncoder(sys.stderr, 'utf8')
-
-# Two routines used for movie title search and matching
-def is_punct_char(char):
-    '''check if char is punctuation char
-    return True if char is punctuation
-    return False if char is not punctuation
-    '''
-    return char in string.punctuation
-
-def is_not_punct_char(char):
-    '''check if char is not punctuation char
-    return True if char is not punctuation
-    return False if chaar is punctuation
-    '''
-    return not is_punct_char(char)
-
-
-def makeDict(movieORperson):
-    '''Make a dictionary out of the chosen movie data
-    return a dictionary of the movie and ancillary data
-    '''
-    selection = {}
-    for key in movieORperson.keys():
-        selection[key] = movieORperson[key]
-    return selection
-# end makeDict()
-
-
-class BaseUI:
-    """Default non-interactive UI, which auto-selects first results
-    """
-    def __init__(self, config, log, searchTerm=None):
-        self.config = config
-        self.log = log
-        self.searchTerm = searchTerm
-
-    def selectMovieOrPerson(self, allElements):
-        return makeDict([allElements[0]])
-
-
-class ConsoleUI(BaseUI):
-    """Interactively allows the user to select a movie or person from a console based UI
-    """
-
-    def removeCommonWords(self, title):
-        '''Remove common words from a title
-        return title striped of common words
-        '''
-        if not title:
-            return u' '
-        wordList = [u'the ', u'a ', u'  '] # common word list. Leave double space as the last value.
-        title = title.lower()
-        for word in wordList:
-            title = title.replace(word, u'')
-        if not title:
-            return u' '
-        title = title.strip()
-        return filter(is_not_punct_char, title)
-    # end removeCommonWords()
-
-
-    def _displayMovie(self, allElements):
-        """Helper function, lists movies or people with corresponding ID
-        """
-        print u"themoviedb.org Search Results:"
-        for i in range(len(allElements[:15])): # list first 15 search results
-            i_show = i + 1 # Start at more human readable number 1 (not 0)
-            self.log.debug('Showing allElements[%s] = %s)' % (i_show, allElements[i]))
-            if allElements[i]['name'] == u'User choses to ignore video':
-                print u"% 2s -> %s # %s" % (
-                    i_show,
-                    '99999999', "Set this video to be ignored by Jamu with a reference number of '99999999'"
-                )
-                continue
-            if not allElements[i].has_key('released'):
-            	title = allElements[i]['name']
-            elif len(allElements[i]['released']) > 3:
-            	title = u"%s (%s)" % (allElements[i]['name'], allElements[i]['released'][:4])
-            else:
-            	title = allElements[i]['name']
-            if allElements[i]['url'].find('/person/') > -1:
-                format = u"%2s -> %-30s # http://www.themoviedb.org/person/%s"
-            else:
-                format = u"%2s -> %-50s # http://www.themoviedb.org/movie/%s"
-            print format % (
-                i_show,
-                title,
-                allElements[i]['id']
-            )
-        print u"Direct search of themoviedb.org # http://themoviedb.org/"
-	# end _displayMovie()
-
-    def selectMovieOrPerson(self, allElements):
-        if allElements[0]['url'].find('/movie/') > -1:
-            morp = u'movie'
-        else:
-            morp = u'person'
-        # Add the ability to select the skip inetref of '99999999' for movies only
-        if morp == u'movie':
-            allElements.append( {'id': '99999999', 'name': u'User choses to ignore video'} )
-
-        self._displayMovie(allElements)
-
-        refsize = 5     # The number of digits required in a TMDB number is directly entered
-        if len(allElements) == 2 and morp == u'movie':
-            data = makeDict(allElements[0])
-            if self.removeCommonWords(data['name']) == self.removeCommonWords(self.searchTerm) and data.has_key('released'):
-                # Single result, return it!
-                print u"Automatically selecting only result"
-                return [data]
-
-        if len(allElements) == 1 and morp == u'person':
-            data = makeDict(allElements[0])
-            if self.removeCommonWords(data['name']) == self.removeCommonWords(self.searchTerm):
-                # Single result, return it!
-                print u"Automatically selecting only result"
-                return [data]
-
-        if self.config['select_first'] is True:
-            print u"Automatically returning first search result"
-            return [makeDict(allElements[0])]
-
-        while True: # return breaks this loop
-            try:
-                print u'Enter choice:\n("Enter" key equals first selection (1)) or input a zero padded 5 digit %s TMDB id number, ? for help):' % morp
-                ans = raw_input()
-            except KeyboardInterrupt:
-                raise TmdbUiAbort("User aborted (^c keyboard interupt)")
-            except EOFError:
-                raise TmdbUiAbort("User aborted (EOF received)")
-
-            self.log.debug(u'Got choice of: %s' % (ans))
-            try:
-                if ans == '': # Enter pressed which equates to the first selection
-					selected_id = 0
-                else:
-                    if int(ans) == 0:
-                        raise ValueError
-                    selected_id = int(ans) - 1 # The human entered 1 as first result, not zero
-            except ValueError: # Input was not number
-                if ans == "q":
-                    self.log.debug(u'Got quit command (q)')
-                    raise TmdbUiAbort("User aborted ('q' quit command)")
-                elif ans == "?":
-                    print u"## Help"
-                    print u"# Enter the number that corresponds to the correct movie."
-                    print u"# Paste a TMDB %s ID number (pad with leading zeros to make 5 digits) from themoviedb.org and hit 'Enter'" % morp
-                    print u"# ? - this help"
-                    print u"# q - abort/skip movie selection"
-                else:
-                	print '! Unknown/Invalid keypress "%s"\n' % (ans)
-                	self.log.debug('Unknown keypress %s' % (ans))
-            else:
-                self.log.debug('Trying to return ID: %d' % (selected_id))
-                try:
-                    data = makeDict(allElements[selected_id])
-                    data['userResponse'] = u'User selected'
-                    return [data]
-                except IndexError:
-                    if len(ans) == refsize:
-                        return [{'userResponse': u'User input', 'id': u'%d' % int(ans)}]
-            #end try
-        #end while not valid_input
-	# end selectMovieOrPerson()
diff --git a/mythtv/bindings/python/setup.py b/mythtv/bindings/python/setup.py
index a24dfb6..b09af75 100755
--- a/mythtv/bindings/python/setup.py
+++ b/mythtv/bindings/python/setup.py
@@ -81,10 +81,10 @@ setup(
         version='0.26.0',
         description='MythTV Python bindings.',
         long_description='Provides canned database and protocol access to the MythTV database, mythproto, mythxml, and frontend remote control.',
-        packages=['MythTV', 'MythTV/tmdb', 'MythTV/tmdb3', 'MythTV/ttvdb',
+        packages=['MythTV', 'MythTV/tmdb3', 'MythTV/ttvdb',
                   'MythTV/wikiscripts', 'MythTV/utility'],
         package_dir={'MythTV/tmdb3':'./tmdb3/tmdb3'},
-        data_files=[('MythTV/tmdb/XSLT',glob.glob('MythTV/tmdb/XSLT/*')), ('MythTV/ttvdb/XSLT', glob.glob('MythTV/ttvdb/XSLT/*'))],
+        data_files=[('MythTV/ttvdb/XSLT', glob.glob('MythTV/ttvdb/XSLT/*'))],
         url=['http://www.mythtv.org/'],
         scripts=SCRIPTS,
         requires=['MySQLdb','lxml'],
diff --git a/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py b/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py
index f6a3e64..ad63cab 100755
--- a/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py
+++ b/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py
@@ -29,15 +29,14 @@ if __name__ == '__main__':
         print "Version: "+__version__
         sys.exit(0)
 
-#   TODO: make this actually do something
-#    if opts.debug:
-#        DEBUG = True
-
     if opts.nocache:
         set_cache(engine='null')
     else:
         set_cache(engine='file', filename='/tmp/pytmdb3.cache')
 
+    if opts.debug:
+        request.DEBUG = True
+
     banner = 'PyTMDB3 Interactive Shell.'
     import code
     try:
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/pager.py b/mythtv/bindings/python/tmdb3/tmdb3/pager.py
index 6cb874c..24f1366 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/pager.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/pager.py
@@ -105,5 +105,8 @@ class PagedRequest( PagedList ):
         res = req.readJSON()
         self._len = res['total_results']
         for item in res['results']:
-            yield self._handler(item)
+            if item is None:
+                yield None
+            else:
+                yield self._handler(item)
 
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py b/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py
index 8200fcc..72141aa 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py
@@ -79,7 +79,7 @@ DEBUG = False
 def process_date(datestr):
     try:
         return datetime.date(*[int(x) for x in datestr.split('-')])
-    except ValueError:
+    except (TypeError, ValueError):
         import sys
         import warnings
         import traceback
diff --git a/mythtv/i18n/mythfrontend_de.qm b/mythtv/i18n/mythfrontend_de.qm
index a6a4dfe..bce9831 100644
Binary files a/mythtv/i18n/mythfrontend_de.qm and b/mythtv/i18n/mythfrontend_de.qm differ
diff --git a/mythtv/i18n/mythfrontend_de.ts b/mythtv/i18n/mythfrontend_de.ts
index 46dc659..068306f 100644
--- a/mythtv/i18n/mythfrontend_de.ts
+++ b/mythtv/i18n/mythfrontend_de.ts
@@ -14108,51 +14108,51 @@ Most cards can autodetect this now, so leave it at Auto unless it won&apos;t wor
         <translation>Setzen Sie einen positiven Wert, wenn dies ein prferierter Sender sein soll, oder einen Negativen, falls nicht.</translation>
     </message>
     <message>
-        <location filename="../libs/libmythtv/decoderbase.cpp" line="1038"/>
+        <location filename="../libs/libmythtv/decoderbase.cpp" line="1041"/>
         <source>Track</source>
         <translation>Spur</translation>
     </message>
     <message>
-        <location filename="../libs/libmythtv/decoderbase.cpp" line="1041"/>
+        <location filename="../libs/libmythtv/decoderbase.cpp" line="1044"/>
         <source>Audio track</source>
         <translation>Tonspur</translation>
     </message>
     <message>
-        <location filename="../libs/libmythtv/decoderbase.cpp" line="1043"/>
+        <location filename="../libs/libmythtv/decoderbase.cpp" line="1046"/>
         <source>Video track</source>
         <translation>Videospur</translation>
     </message>
     <message>
-        <location filename="../libs/libmythtv/decoderbase.cpp" line="1045"/>
+        <location filename="../libs/libmythtv/decoderbase.cpp" line="1048"/>
         <source>Subtitle track</source>
         <translation>Untertitelspur</translation>
     </message>
     <message>
-        <location filename="../libs/libmythtv/decoderbase.cpp" line="1047"/>
+        <location filename="../libs/libmythtv/decoderbase.cpp" line="1050"/>
         <source>CC</source>
         <comment>EIA-608 closed captions</comment>
         <translation>CC</translation>
     </message>
     <message>
-        <location filename="../libs/libmythtv/decoderbase.cpp" line="1049"/>
+        <location filename="../libs/libmythtv/decoderbase.cpp" line="1052"/>
         <source>ATSC CC</source>
         <comment>EIA-708 closed captions</comment>
         <translation>ATSC CC</translation>
     </message>
     <message>
-        <location filename="../libs/libmythtv/decoderbase.cpp" line="1051"/>
+        <location filename="../libs/libmythtv/decoderbase.cpp" line="1054"/>
         <source>TT CC</source>
         <comment>Teletext closed captions</comment>
         <translation>TT CC</translation>
     </message>
     <message>
-        <location filename="../libs/libmythtv/decoderbase.cpp" line="1053"/>
+        <location filename="../libs/libmythtv/decoderbase.cpp" line="1056"/>
         <source>TT Menu</source>
         <comment>Teletext Menu</comment>
         <translation>TT-Men</translation>
     </message>
     <message>
-        <location filename="../libs/libmythtv/decoderbase.cpp" line="1055"/>
+        <location filename="../libs/libmythtv/decoderbase.cpp" line="1058"/>
         <source>Text</source>
         <comment>Text stream</comment>
         <translation>Textspur</translation>
@@ -17178,7 +17178,7 @@ Verwenden Sie den Auswurfknopf am Laufwerk.</translation>
         <translation>UNBEKANNT</translation>
     </message>
     <message>
-        <location filename="../libs/libmythtv/decoderbase.cpp" line="1057"/>
+        <location filename="../libs/libmythtv/decoderbase.cpp" line="1060"/>
         <source>TXT File</source>
         <comment>Text File</comment>
         <translation>Textdatei</translation>
@@ -23731,7 +23731,7 @@ Whlen Sie eine laufende Aufnahme</translation>
     <message>
         <location filename="../themes/themestrings.h" line="525"/>
         <source>Channels :</source>
-        <translation>Sender :</translation>
+        <translation>Kanle :</translation>
     </message>
     <message>
         <location filename="../themes/themestrings.h" line="526"/>
diff --git a/mythtv/libs/libmythbase/logging.cpp b/mythtv/libs/libmythbase/logging.cpp
index d48a3a2..037cb42 100644
--- a/mythtv/libs/libmythbase/logging.cpp
+++ b/mythtv/libs/libmythbase/logging.cpp
@@ -653,7 +653,7 @@ bool LoggerThread::flush(int timeoutMS)
 {
     QTime t;
     t.start();
-    while (!m_aborted && logQueue.isEmpty() && t.elapsed() < timeoutMS)
+    while (!m_aborted && !logQueue.isEmpty() && t.elapsed() < timeoutMS)
     {
         m_waitNotEmpty->wakeAll();
         int left = timeoutMS - t.elapsed();
@@ -791,7 +791,7 @@ void logPropagateCalc(void)
         logPropagateArgs += " --quiet";
 
     if (!logPropagateOpts.dblog)
-        logPropagateArgs += " --nodblog";
+        logPropagateArgs += " --enable-dblog";
 
 #ifndef _WIN32
     if (logPropagateOpts.facility >= 0)
diff --git a/mythtv/libs/libmythbase/mythcommandlineparser.cpp b/mythtv/libs/libmythbase/mythcommandlineparser.cpp
index 3bbac88..ad7b3ce 100644
--- a/mythtv/libs/libmythbase/mythcommandlineparser.cpp
+++ b/mythtv/libs/libmythbase/mythcommandlineparser.cpp
@@ -2333,7 +2333,7 @@ void MythCommandLineParser::addUPnP(void)
 
 /** \brief Canned argument definition for all logging options, including
  *  --verbose, --logpath, --quiet, --loglevel, --syslog
- *  and --nodblog
+ *  and --enable-dblog
  */
 void MythCommandLineParser::addLogging(
     const QString &defaultVerbosity, LogLevel_t defaultLogLevel)
@@ -2375,7 +2375,7 @@ void MythCommandLineParser::addLogging(
         "Set the syslog logging facility.\nSet to \"none\" to disable, "
         "defaults to none.", "")
                 ->SetGroup("Logging");
-    add("--nodblog", "nodblog", false, "Disable database logging.", "")
+    add("--enable-dblog", "enabledblog", false, "Enable logging to database.", "")
                 ->SetGroup("Logging");
 
     add(QStringList( QStringList() << "-l" << "--logfile" ),
@@ -2534,7 +2534,7 @@ int MythCommandLineParser::ConfigureLogging(QString mask, unsigned int progress)
     }
 
     int facility = GetSyslogFacility();
-    bool dblog = !toBool("nodblog");
+    bool dblog = toBool("enabledblog");
     LogLevel_t level = GetLogLevel();
     if (level == LOG_UNKNOWN)
         return GENERIC_EXIT_INVALID_CMDLINE;
diff --git a/mythtv/libs/libmythmetadata/metadatadownload.cpp b/mythtv/libs/libmythmetadata/metadatadownload.cpp
index 0a418ba..3c8358d 100644
--- a/mythtv/libs/libmythmetadata/metadatadownload.cpp
+++ b/mythtv/libs/libmythmetadata/metadatadownload.cpp
@@ -244,9 +244,15 @@ MetadataLookupList MetadataDownload::runGrabber(QString cmd, QStringList args,
 
 QString MetadataDownload::GetMovieGrabber()
 {
-    QString def_cmd = "metadata/Movie/tmdb.py";
+    QString def_cmd = "metadata/Movie/tmdb3.py";
     QString db_cmd = gCoreContext->GetSetting("MovieGrabber", def_cmd);
 
+    // we cannot issue a schema update to force the use of tmdb3.py, so if
+    // users attempt to use the old (and now non-functional) tmdb.py, just
+    // "do the right thing" and use the new script
+    if (db_cmd == "metadata/Movie/tmdb.py")
+        db_cmd = def_cmd;
+
     return QDir::cleanPath(QString("%1/%2")
             .arg(GetShareDir())
             .arg(db_cmd));
diff --git a/mythtv/libs/libmythtv/avformatdecoder.cpp b/mythtv/libs/libmythtv/avformatdecoder.cpp
index 8f875f9..7eeafe1 100644
--- a/mythtv/libs/libmythtv/avformatdecoder.cpp
+++ b/mythtv/libs/libmythtv/avformatdecoder.cpp
@@ -3639,7 +3639,7 @@ bool AvFormatDecoder::ProcessRawTextPacket(AVPacket *pkt)
 
     QTextCodec *codec = QTextCodec::codecForName("utf-8");
     QTextDecoder *dec = codec->makeDecoder();
-    QString text      = dec->toUnicode((const char*)pkt->data, pkt->size);
+    QString text      = dec->toUnicode((const char*)pkt->data, pkt->size - 1);
     QStringList list  = text.split('\n', QString::SkipEmptyParts);
     delete dec;
 
diff --git a/mythtv/libs/libmythtv/decoderbase.cpp b/mythtv/libs/libmythtv/decoderbase.cpp
index 6a573a3..cc9b005 100644
--- a/mythtv/libs/libmythtv/decoderbase.cpp
+++ b/mythtv/libs/libmythtv/decoderbase.cpp
@@ -243,7 +243,10 @@ bool DecoderBase::PosMapFromEnc(void)
 
     // append this new position map to class's
     m_positionMap.reserve(m_positionMap.size() + posMap.size());
-    long long last_index = m_positionMap.back().index;
+    
+    long long last_index = 0;
+    if (!m_positionMap.empty())
+        last_index = m_positionMap.back().index;
     for (QMap<long long,long long>::const_iterator it = posMap.begin();
          it != posMap.end(); ++it)
     {
diff --git a/mythtv/libs/libmythtv/eithelper.cpp b/mythtv/libs/libmythtv/eithelper.cpp
index 289062e..e5a48ce 100644
--- a/mythtv/libs/libmythtv/eithelper.cpp
+++ b/mythtv/libs/libmythtv/eithelper.cpp
@@ -779,11 +779,12 @@ static void init_fixup(QMap<uint64_t,uint> &fix)
 
     // United Kingdom
     fix[ 9018U << 16] = EITFixUp::kFixUK;
-    // UK Freesat
+    // UK BBC
     fix[ 2013LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2017LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2018LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2026LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2036LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2041LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2042LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2043LL << 32 | 2U << 16] = EITFixUp::kFixUK;
@@ -794,11 +795,10 @@ static void init_fixup(QMap<uint64_t,uint> &fix)
     fix[ 2048LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2049LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2050LL << 32 | 2U << 16] = EITFixUp::kFixUK;
-    fix[ 2051LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2053LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2054LL << 32 | 2U << 16] = EITFixUp::kFixUK;
-    fix[ 2056LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2057LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2061LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2063LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2068LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2301LL << 32 | 2U << 16] = EITFixUp::kFixUK;
@@ -812,10 +812,33 @@ static void init_fixup(QMap<uint64_t,uint> &fix)
     fix[ 2313LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2314LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2401LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2411LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2412LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2413LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2602LL << 32 | 2U << 16] = EITFixUp::kFixUK;
     fix[ 2612LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2614LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    // R.caroline
+    fix[ 2315LL << 32 | 59U << 16] = EITFixUp::kFixUK;
+    // UK Sky
+    fix[ 2051LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2052LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2055LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2056LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2315LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2316LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    for (int i = 2402; i <= 2412; ++i)
+        fix[ (long long)i << 32 | 2U << 16] = EITFixUp::kFixUK;
+    for (int i = 2001; i <= 2012; ++i)
+       fix[ (long long)i << 32 | 2U << 16] = EITFixUp::kFixUK;
+    for (int i = 2014; i <= 2040; ++i)
+       fix[ (long long)i << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2611LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2612LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2601LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2613LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2603LL << 32 | 2U << 16] = EITFixUp::kFixUK;
+    fix[ 2604LL << 32 | 2U << 16] = EITFixUp::kFixUK;
 
     // ComHem Sweden
     fix[40999U << 16       ] = EITFixUp::kFixComHem;
diff --git a/mythtv/programs/mythfrontend/commandlineparser.cpp b/mythtv/programs/mythfrontend/commandlineparser.cpp
index 0153a3d..8544875 100644
--- a/mythtv/programs/mythfrontend/commandlineparser.cpp
+++ b/mythtv/programs/mythfrontend/commandlineparser.cpp
@@ -23,7 +23,7 @@ void MythFrontendCommandLineParser::LoadArguments(void)
     addLogging();
 
     add(QStringList( QStringList() << "-r" << "--reset" ), "reset", false,
-        "Resets appearance, settings, and language.", "");
+        "Resets appearance settings and language.", "");
     add(QStringList( QStringList() << "-p" << "--prompt" ), "prompt", false,
         "Always prompt for backend selection.", "");
     add(QStringList( QStringList() << "-d" << "--disable-autodiscovery" ),
diff --git a/mythtv/programs/scripts/hardwareprofile/config.py b/mythtv/programs/scripts/hardwareprofile/config.py
index c0027c7..51eff2e 100644
--- a/mythtv/programs/scripts/hardwareprofile/config.py
+++ b/mythtv/programs/scripts/hardwareprofile/config.py
@@ -9,6 +9,11 @@ SECURE = 0
 
 from MythTV import MythDB
 confdir = os.path.join(MythDB().dbconfig.confdir, 'HardwareProfile')
+try:
+    os.mkdir(confdir, 0700)
+except OSError:
+    pass
+
 HW_UUID     = os.path.join(confdir, 'hw-uuid')
 PUB_UUID    = os.path.join(confdir, 'pub-uuid')
 UUID_DB     = os.path.join(confdir, 'uuiddb.cfg')
diff --git a/mythtv/programs/scripts/hardwareprofile/distros/mythtv_data/data_mythtv.py b/mythtv/programs/scripts/hardwareprofile/distros/mythtv_data/data_mythtv.py
index 0d6b5aa..36662cd 100755
--- a/mythtv/programs/scripts/hardwareprofile/distros/mythtv_data/data_mythtv.py
+++ b/mythtv/programs/scripts/hardwareprofile/distros/mythtv_data/data_mythtv.py
@@ -48,10 +48,18 @@ class _Mythtv_data:
         for name in ['version', 'branch', 'protocol', 'libapi', 'qtversion']:
             data[name] = 'Unknown'
 
-        try:
-            mbe = MythTV.System(MythTV.static.INSTALL_PREFIX + '/bin/mythbackend')
-            res = mbe.command('--version')
-        except:
+        executables = ('mythutil', 'mythbackend', 'mythfrontend')
+
+        for executable in executables:
+            execpath = os.path.join(MythTV.static.INSTALL_PREFIX,
+                                    'bin', executable)
+            try:
+                cmd = MythTV.System(execpath)
+                res = mbe.command('--version')
+                break
+            except:
+                continue
+        else:
             return data
 
         names = {'MythTV Version'  : 'version',
diff --git a/mythtv/programs/scripts/hardwareprofile/os_detect.py b/mythtv/programs/scripts/hardwareprofile/os_detect.py
index e83c7ed..02acf53 100644
--- a/mythtv/programs/scripts/hardwareprofile/os_detect.py
+++ b/mythtv/programs/scripts/hardwareprofile/os_detect.py
@@ -286,3 +286,8 @@ class get_os_info( object ):
         p.wait()
         return p.stdout.read().strip().replace('\n', ' ')
 
+    @OSFromUname
+    def Linux(self, OS, version):
+        if OS == 'Linux':
+            return 'Unknown Linux '+version
+        return False
diff --git a/mythtv/programs/scripts/metadata/Movie/tmdb.py b/mythtv/programs/scripts/metadata/Movie/tmdb.py
deleted file mode 100755
index 13ed5d3..0000000
--- a/mythtv/programs/scripts/metadata/Movie/tmdb.py
+++ /dev/null
@@ -1,640 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: UTF-8 -*-
-# ----------------------
-# Name: tmdb.py
-# Python Script
-# Author: R.D. Vaughan
-# Purpose:
-#   This python script is intended to perform Movie data lookups
-#   based on information found on the http://themoviedb.org/ website. It
-#   follows the MythTV standards set for grabbers
-#   http://www.mythtv.org/wiki/MythVideo_Grabber_Script_Format
-#   This script uses the python module tmdb_api.py which should be included
-#   with this script.
-#   The tmdb_api.py module uses the full access v2.1 XML api published by
-#   themoviedb.org see: http://api.themoviedb.org/2.1/
-#   Users of this script are encouraged to populate themoviedb.org with Movie
-#   information, posters and fan art. The richer the source the more
-#   valuable the script.
-# Command example:
-# See help (-u and -h) options
-#
-# Design:
-#   1) Verify the command line options (display help or version and exit)
-#   2) Verify that themoviedb.org has the Movie being requested exit if does not exit
-#   3) Find the requested information and send to stdout if any found
-#
-#
-# License:Creative Commons GNU GPL v2
-# (http://creativecommons.org/licenses/GPL/2.0/)
-#-------------------------------------
-__title__ ="TheMovieDB.org";
-__author__="R.D.Vaughan"
-__version__="0.21"
-# 0.1.0 Initial development
-# 0.1.1 Alpha Release
-# 0.1.2 New movie data fields now have proper key names
-#       Dynamic CamelCoding of keys if they are not already in the translation list
-#       Fixed and re-arranged some code for minor issues.
-# 0.1.3 Fixed an abort when there is no data found for Movie and People information display
-#       Added CamelCase to all People information keys
-# 0.1.4 Added handling of all of the tmdb_api exceptions and information process exceptions with proper exit
-#       codes (0-Script Normal exit; 1-Script Exception exit)
-# 0.1.5 Corrected processing of Person images
-#       Added a specific check and error when there is an empty argument passed
-#       Changed the formatting of person information for AlsoKnownAs and Filmography
-# 0.1.6 Stopped stderr output when any TMDB meta data search or access does not find anything.
-#       This was causing issues for MythVideo.
-# 0.1.7 Change over to the installed TMDB api library
-# 0.1.8 Improved displayed messages on an exception abort
-# 0.1.9 Added support for XML output
-# 0.2.0 Make XML output the default
-# Version 1.12  Convert version information to XML
-#         1.13  Add test mode
-
-
-__usage_examples__='''
-Request tmdb.py verison number:
-> ./tmdb.py -v
-<grabber>
-  <name>TheMovieDB.org</name>
-  <author>R.D.Vaughan</author>
-  <thumbnail>tmdb.png</thumbnail>
-  <command>tmdb.py</command>
-  <type>movie</type>
-  <description>Search and metadata downloads for themoviedb.org</description>
-  <version>0.XX</version>
-</grabber>
-
-Request a list of matching movie titles:
-> ./tmdb.py -M "Avatar"
-<?xml version='1.0' encoding='UTF-8'?>
-<metadata>
-  <item>
-    <language>en</language>
-    <title>Avatar</title>
-    <subtitle>Creating the World of Pandora</subtitle>
-    <inetref>31631</inetref>
-    <imdb/>
-    <userrating>8.5</userrating>
-    <certifications>
-      <certification locale="us" name="PG"/>
-    </certifications>
-    <description>The cast and crew take you on an in-depth look at the making of James Cameron's epic.</description>
-    <releasedate>2009-12-01</releasedate>
-...
-  <item>
-    <language>en</language>
-    <title>Avatar 2</title>
-    <inetref>37739</inetref>
-    <imdb>1630029</imdb>
-    <userrating>0.0</userrating>
-    <description>soon :)</description>
-    <releasedate>2014-04-10</releasedate>
-    <lastupdated>Fri, 14 May 2010 05:41:13 GMT</lastupdated>
-  </item>
-</metadata>
-
-Request movie details using a TMDB#:
-> ./tmdb.py -D 19995
-<?xml version='1.0' encoding='UTF-8'?>
-<metadata>
-  <item>
-    <title>Avatar</title>
-    <tagline>Enter the World</tagline>
-    <language>en</language>
-    <description>A paraplegic former Marine finds a new life on the distant planet of Pandora. Only to find himself battling humankind alongside the planet's indigenous Na'vi race in this ambitious digital 3D sci-fi epic from Academy Award-winning Titanic director James Cameron.</description>
-    <certifications>
-      <certification locale="us" name="PG-13"/>
-    </certifications>
-    <categories>
-      <category type="genre" name="Action"/>
-      <category type="genre" name="Adventure"/>
-      <category type="genre" name="Fantasy"/>
-      <category type="genre" name="Science Fiction"/>
-      <category type="genre" name="Thriller"/>
-    </categories>
-    <studios>
-      <studio name="20th Century Fox"/>
-    </studios>
-...
-      <image type="fanart" thumb="http://i1.themoviedb.org/backdrops/9fa/4bc95845017a3c57fe0279fa/avatar-thumb.jpg" url="http://i2.themoviedb.org/backdrops/9fa/4bc95845017a3c57fe0279fa/avatar-original.jpg" width="1920" height="1080"/>
-      <image type="fanart" thumb="http://i2.themoviedb.org/backdrops/a1e/4bc9584d017a3c57fe027a1e/avatar-thumb.jpg" url="http://i2.themoviedb.org/backdrops/a1e/4bc9584d017a3c57fe027a1e/avatar-original.jpg" width="1920" height="1080"/>
-      <image type="fanart" thumb="http://i1.themoviedb.org/backdrops/9fe/4bc95846017a3c57fe0279fe/avatar-thumb.jpg" url="http://i3.themoviedb.org/backdrops/9fe/4bc95846017a3c57fe0279fe/avatar-original.jpg" width="1920" height="1080"/>
-    </images>
-  </item>
-</metadata>
-
-Request movie details using a IMDB#:
-> ./tmdb.py -D 0499549
-<?xml version='1.0' encoding='UTF-8'?>
-<metadata>
-  <item>
-    <title>Avatar</title>
-    <language>en</language>
-    <description>A paraplegic former Marine finds a new life on the distant planet of Pandora. Only to find himself battling humankind alongside the planet's indigenous Na'vi race in this ambitious digital 3D sci-fi epic from Academy Award-winning Titanic director James Cameron.</description>
-    <certifications>
-      <certification locale="us" name="PG-13"/>
-    </certifications>
-...
-width="1920" height="1080"/>
-      <image type="fanart" thumb="http://i1.themoviedb.org/backdrops/9fe/4bc95846017a3c57fe0279fe/avatar-thumb.jpg" url="http://i2.themoviedb.org/backdrops/9fe/4bc95846017a3c57fe0279fe/avatar-original.jpg" width="1920" height="1080"/>
-    </images>
-  </item>
-</metadata>
-
-Request a list of People matching a name:
-> ./tmdb.py -P "Cruise"
-500:Tom Cruise
-77716:Cruise Moylan
-
-Request a Person's information using their TMDB id number:
-> ./tmdb.py -I 2638
-Name:Cary Grant
-AlsoKnownAs:Alexander Archibald Leach|Archibald Alec Leach
-Birthday:1904-01-18
-Birthplace:Bristol, England
-Filmography:North by Northwest|Character:Roger O. Thornhill|Id:213|Job:Actor|URL:http://www.themoviedb.org/movie/213
-Filmography:Arsenic and Old Lace|Character:Mortimer Brewster|Id:212|Job:Actor|URL:http://www.themoviedb.org/movie/212
-...
-Filmography:The Grass Is Greener|Character:Victor Rhyall, Earl|Id:25767|Job:Actor|URL:http://www.themoviedb.org/movie/25767
-Id:2638
-Profile:http://images.themoviedb.org/profiles/11078/CG_profile.jpg,http://images.themoviedb.org/profiles/11075/CG_profile.jpg,http://images.themoviedb.org/profiles/10994/CG_profile.jpg,http://images.themoviedb.org/profiles/10991/CG_profile.jpg,http://images.themoviedb.org/profiles/10988/CG_profile.jpg,http://images.themoviedb.org/profiles/10985/CG_profile.jpg,http://images.themoviedb.org/profiles/4414/Cary_Grant_profile.jpg
-Original:http://images.themoviedb.org/profiles/11078/CG.jpg,http://images.themoviedb.org/profiles/11075/CG.jpg,http://images.themoviedb.org/profiles/10994/CG.jpg,http://images.themoviedb.org/profiles/10991/CG.jpg,http://images.themoviedb.org/profiles/10988/CG.jpg,http://images.themoviedb.org/profiles/10985/CG.jpg,http://images.themoviedb.org/profiles/4414/Cary_Grant.jpg
-Thumb:http://images.themoviedb.org/profiles/11078/CG_thumb.jpg,http://images.themoviedb.org/profiles/11075/CG_thumb.jpg,http://images.themoviedb.org/profiles/10994/CG_thumb.jpg,http://images.themoviedb.org/profiles/10991/CG_thumb.jpg,http://images.themoviedb.org/profiles/10988/CG_thumb.jpg,http://images.themoviedb.org/profiles/10985/CG_thumb.jpg,http://images.themoviedb.org/profiles/4414/Cary_Grant_thumb.jpg
-KnownMovies:25
-Popularity:2
-URL:http://www.themoviedb.org/person/2638
-
-Request Movie details using a Hash value:
-> ./tmdb.py -H "00277ff46533b155"
-<?xml version='1.0' encoding='UTF-8'?>
-<metadata>
-  <item>
-    <title>Underworld</title>
-    <language>en</language>
-    <description>Selene, a beautiful vampire warrior, is entrenched in a war between the vampire and Lycan races. Although she is aligned with the vampires, she falls in love with Michael, a recently turned Lycan whose blood may lead to the end of the war, raging for centuries.</description>
-    <categories>
-      <category type="genre" name="Action"/>
-      <category type="genre" name="Fantasy"/>
-      <category type="genre" name="Horror"/>
-      <category type="genre" name="Science Fiction"/>
-    </categories>
-...
-      <image type="fanart" thumb="http://i1.themoviedb.org/backdrops/db0/4bc90605017a3c57fe001db0/underworld-thumb.jpg" url="http://i1.themoviedb.org/backdrops/db0/4bc90605017a3c57fe001db0/underworld-original.jpg" width="1920" height="1080"/>
-    </images>
-  </item>
-</metadata>
-'''
-
-import sys, os
-from optparse import OptionParser
-import re
-from string import capitalize
-
-
-class OutStreamEncoder(object):
-    """Wraps a stream with an encoder
-    """
-    def __init__(self, outstream, encoding=None):
-        self.out = outstream
-        if not encoding:
-            self.encoding = sys.getfilesystemencoding()
-        else:
-            self.encoding = encoding
-
-    def write(self, obj):
-        """Wraps the output stream, encoding Unicode strings with the specified encoding"""
-        if isinstance(obj, unicode):
-            self.out.write(obj.encode(self.encoding))
-        else:
-            self.out.write(obj)
-
-    def __getattr__(self, attr):
-        """Delegate everything but write to the stream"""
-        return getattr(self.out, attr)
-# Sub class sys.stdout and sys.stderr as a utf8 stream. Deals with print and stdout unicode issues
-sys.stdout = OutStreamEncoder(sys.stdout)
-sys.stderr = OutStreamEncoder(sys.stderr)
-
-# Verify that the tmdb_api modules are installed and accessable
-
-
-try:
-    import MythTV.tmdb.tmdb_api as tmdb_api
-    from MythTV.tmdb.tmdb_exceptions import (TmdBaseError, TmdHttpError, TmdXmlError, TmdbUiAbort, TmdbMovieOrPersonNotFound,)
-except Exception, e:
-    sys.stderr.write('''
-The subdirectory "tmdb" containing the modules tmdb_api.py (v0.1.3 or greater), tmdb_ui.py,
-tmdb_exceptions.py must have been installed with the MythTV python bindings.
-Error:(%s)
-''' %  e)
-    sys.exit(1)
-
-if tmdb_api.__version__ < '0.1.3':
-    sys.stderr.write("\n! Error: Your current installed tmdb_api.py version is (%s)\nYou must at least have version (0.1.3) or higher.\n" % tmdb_api.__version__)
-    sys.exit(1)
-
-
-try:
-    from StringIO import StringIO
-    from lxml import etree as etree
-except Exception, e:
-    sys.stderr.write(u'\n! Error - Importing the "lxml" and "StringIO" python libraries failed on error(%s)\n' % e)
-    sys.exit(1)
-
-# Check that the lxml library is current enough
-# From the lxml documents it states: (http://codespeak.net/lxml/installation.html)
-# "If you want to use XPath, do not use libxml2 2.6.27. We recommend libxml2 2.7.2 or later"
-# Testing was performed with the Ubuntu 9.10 "python-lxml" version "2.1.5-1ubuntu2" repository package
-version = ''
-for digit in etree.LIBXML_VERSION:
-    version+=str(digit)+'.'
-version = version[:-1]
-if version < '2.7.2':
-    sys.stderr.write(u'''
-! Error - The installed version of the "lxml" python library "libxml" version is too old.
-          At least "libxml" version 2.7.2 must be installed. Your version is (%s).
-''' % version)
-    sys.exit(1)
-
-
-class moviedbQueries():
-    '''Methods that query themoviedb.org for metadata and outputs the results to stdout any errors are output
-    to stderr.
-    '''
-    def __init__(self,
-                apikey,
-                mythtv = False,
-                interactive = False,
-                select_first = False,
-                debug = False,
-                custom_ui = None,
-                language = None,
-                search_all_languages = False, ###CHANGE - Needs to be added
-                ):
-        """apikey (str/unicode):
-            Specify the themoviedb.org API key. Applications need their own key.
-            See http://api.themoviedb.org/2.1/ to get your own API key
-
-        mythtv (True/False):
-            When True, the movie metadata is being returned has the key and values massaged to match MythTV
-            When False, the movie metadata is being returned matches what TMDB returned
-
-        interactive (True/False):
-            When True, uses built-in console UI is used to select the correct show.
-            When False, the first search result is used.
-
-        select_first (True/False):
-            Automatically selects the first series search result (rather
-            than showing the user a list of more than one series).
-            Is overridden by interactive = False, or specifying a custom_ui
-
-        debug (True/False):
-             shows verbose debugging information
-
-        custom_ui (tvdb_ui.BaseUI subclass):
-            A callable subclass of tvdb_ui.BaseUI (overrides interactive option)
-
-        language (2 character language abbreviation):
-            The language of the returned data. Is also the language search
-            uses. Default is "en" (English). For full list, run..
-
-            >>> MovieDb().config['valid_languages'] #doctest: +ELLIPSIS
-            ['da', 'fi', 'nl', ...]
-
-        search_all_languages (True/False):
-            By default, TMDB will only search in the language specified using
-            the language option. When this is True, it will search for the
-            show in any language
-
-        """
-        self.config = {}
-
-        self.config['apikey'] = apikey
-        self.config['moviedb'] = tmdb_api.MovieDb(apikey, mythtv = mythtv,
-                interactive = interactive,
-                select_first = select_first,
-                debug = debug,
-                custom_ui = custom_ui,
-                language = language,
-                search_all_languages = search_all_languages,)
-        self.mythtvgrabber = [u'Title', u'Subtitle', u'Year', u'ReleaseDate', u'InetRef', u'URL', u'Director', u'Plot', u'UserRating', u'MovieRating', u'Runtime', u'Season', u'Episode', u'Coverart', u'Fanart', u'Banner', u'Screenshot', u'Cast', u'Genres', u'Countries', u'ScreenPlay', u'Studios', u'Producer', u'ProductionDesign', u'DirectorOfPhotography', u'OriginalMusicComposer', u'Story', u'CostumeDesign', u'Editor', u'Type', u'Casting', u'AssociateProducer', u'Popularity', u'Budget', u'Imdb', u'ArtDirection', u'MovieRating']
-        self.error_messages = {'TmdHttpError': u"! Error: A connection error to themoviedb.org was raised (%s)\n", 'TmdXmlError': u"! Error: Invalid XML was received from themoviedb.org (%s)\n", 'TmdBaseError': u"! Error: A user interface error was raised (%s)\n", 'TmdbUiAbort': u"! Error: A user interface input error was raised (%s)\n", }
-    # end __init__()
-
-    def movieSearch(self, title):
-        '''Search for movies that match the title and output their "tmdb#:Title" to stdout
-        '''
-        title = title.replace("-"," ")
-        try:
-            data = self.config['moviedb'].searchTitle(title)
-        except TmdbMovieOrPersonNotFound, msg:
-            #sys.stderr.write(u"%s\n" % msg)
-            return
-        except TmdHttpError, msg:
-            sys.stderr.write(self.error_messages['TmdHttpError'] % msg)
-            sys.exit(1)
-        except TmdXmlError, msg:
-            sys.stderr.write(self.error_messages['TmdXmlError'] % msg)
-            sys.exit(1)
-        except TmdBaseError, msg:
-            sys.stderr.write(self.error_messages['TmdBaseError'] % msg)
-            sys.exit(1)
-        except TmdbUiAbort, msg:
-            sys.stderr.write(self.error_messages['TmdbUiAbort'] % msg)
-            sys.exit(1)
-        except Exception, e:
-            sys.stderr.write(u"! Error: Unknown error during a Title search (%s)\nError(%s)\n" % (title, e))
-            sys.exit(1)
-
-        if data != None:
-            for match in data:
-                if not match.has_key('released'):
-                    name = match['name']
-                elif len(match['released']) > 3:
-                    name = u"%s (%s)" % (match['name'], match['released'][:4])
-                else:
-                    name = match['name']
-                sys.stdout.write( u'%s:%s\n' % (match[u'id'], name))
-    # end movieSearch()
-
-    def peopleSearch(self, persons_name):
-        '''Search for People that match the name and output their "tmdb#:Name" to stdout
-        '''
-        try:
-            for match in self.config['moviedb'].searchPeople(persons_name):
-                sys.stdout.write( u'%s:%s\n' % (match[u'id'], match['name']))
-        except TmdbMovieOrPersonNotFound, msg:
-            #sys.stderr.write(u"%s\n" % msg)
-            return
-        except TmdHttpError, msg:
-            sys.stderr.write(self.error_messages['TmdHttpError'] % msg)
-            sys.exit(1)
-        except TmdXmlError, msg:
-            sys.stderr.write(self.error_messages['TmdXmlError'] % msg)
-            sys.exit(1)
-        except TmdBaseError, msg:
-            sys.stderr.write(self.error_messages['TmdBaseError'] % msg)
-            sys.exit(1)
-        except TmdbUiAbort, msg:
-            sys.stderr.write(self.error_messages['TmdbUiAbort'] % msg)
-            sys.exit(1)
-        except Exception, e:
-            sys.stderr.write(u"! Error: Unknown error during a People search for (%s)\nError(%s)\n" % (persons_name, e))
-            sys.exit(1)
-    # end moviePeople()
-
-    def camelcase(self, value):
-        '''Make a string CamelCase
-        '''
-        if not value.strip(u'ABCEDFGHIJKLMNOPQRSTUVWXYZ'):
-            return value
-        if value == u'url':
-            return u'URL'
-        return u"".join([capitalize(w) for w in re.split(re.compile(u"[\W_]*"), value)])
-    # end camelcase()
-
-    def displayMovieData(self, data):
-        '''Display movie data to stdout
-        '''
-        if data == None:
-            return
-        data_keys = data.keys()
-        data_keys_org = data.keys()
-        for index in range(len(data_keys)):
-            data_keys[index] = data_keys[index].replace(u' ',u'').lower()
-
-        for key in self.mythtvgrabber:
-            if  key.lower() in data_keys:
-                sys.stdout.write(u"%s:%s\n" % (key, data[data_keys_org[data_keys.index(key.lower())]]))
-
-        mythtvgrabber = []
-        for item in self.mythtvgrabber:
-            mythtvgrabber.append(item.lower())
-        for key in data_keys:
-            if not key in mythtvgrabber:
-                sys.stdout.write(u"%s:%s\n" % (self.camelcase(data_keys_org[data_keys.index(key)]), data[data_keys_org[data_keys.index(key)]]))
-    # end displayMovieData(()
-
-
-    def movieData(self, tmdb_id):
-        '''Get Movie data by IMDB or TMDB number and display "key:value" pairs to stdout
-        '''
-        try:
-            if len(tmdb_id) == 7:
-                self.displayMovieData(self.config['moviedb'].searchIMDB(tmdb_id))
-            else:
-                self.displayMovieData(self.config['moviedb'].searchTMDB(tmdb_id))
-        except TmdbMovieOrPersonNotFound, msg:
-            #sys.stderr.write(u"%s\n" % msg)
-            return
-        except TmdHttpError, msg:
-            sys.stderr.write(self.error_messages['TmdHttpError'] % msg)
-            sys.exit(1)
-        except TmdXmlError, msg:
-            sys.stderr.write(self.error_messages['TmdXmlError'] % msg)
-            sys.exit(1)
-        except TmdBaseError, msg:
-            sys.stderr.write(self.error_messages['TmdBaseError'] % msg)
-            sys.exit(1)
-        except TmdbUiAbort, msg:
-            sys.stderr.write(self.error_messages['TmdbUiAbort'] % msg)
-            sys.exit(1)
-        except Exception, e:
-            sys.stderr.write(u"! Error: Unknown error during a Movie (%s) information display\nError(%s)\n" % (tmdb_id, e))
-            sys.exit(1)
-    # end movieData()
-
-    def peopleData(self, person_id):
-        '''Get People data by TMDB people id number and display "key:value" pairs to stdout
-        '''
-        try:
-            data = self.config['moviedb'].personInfo(person_id)
-        except TmdbMovieOrPersonNotFound, msg:
-            #sys.stderr.write(u"%s\n" % msg)
-            return
-        except TmdHttpError, msg:
-            sys.stderr.write(self.error_messages['TmdHttpError'] % msg)
-            sys.exit(1)
-        except TmdXmlError, msg:
-            sys.stderr.write(self.error_messages['TmdXmlError'] % msg)
-            sys.exit(1)
-        except TmdBaseError, msg:
-            sys.stderr.write(self.error_messages['TmdBaseError'] % msg)
-            sys.exit(1)
-        except TmdbUiAbort, msg:
-            sys.stderr.write(self.error_messages['TmdbUiAbort'] % msg)
-            sys.exit(1)
-        except Exception, e:
-            sys.stderr.write(u"! Error: Unknown error during a Person (%s) information display\n" % (person_id, e))
-            sys.exit(1)
-
-        if data == None:
-            return
-        sys.stdout.write(u'%s:%s\n' % (u'Name', data[u'name']))
-        keys = sorted(data.keys())
-        images = {}
-        for key in keys:
-            if key == u'name':
-                continue
-            if key in ['also_known_as', 'filmography', 'images' ]:
-                if key == 'images':
-                    images = {}
-                    for k in data[key].keys():
-                        images[k] = u''
-                if key == 'also_known_as':
-                    alias = u''
-                    for k in data[key]:
-                        alias+=u'%s|' % k.replace(u'|', u' ')
-                    if alias:
-                       sys.stdout.write(u'%s:%s\n' % (self.camelcase(key), alias[:-1]))
-                    continue
-                for k in data[key]:
-                    if key == 'filmography':
-                        kys = sorted(k.keys())
-                        filmography = u''
-                        for c in kys:
-                            if c == u'name':
-                                continue
-                            filmography+=u'%s:%s|' % (self.camelcase(c.replace(u'|', u' ')), k[c].replace(u'|', u' '))
-                        if filmography:
-                            sys.stdout.write(u'%s:%s|%s\n' % (self.camelcase(key), k[u'name'].replace(u'|', u' '), filmography[:-1]))
-                    elif key == 'images':
-                        sys.stdout.write(u'%s:%s\n' % (self.camelcase(k), data[key][k]))
-            else:
-                sys.stdout.write(u'%s:%s\n' % (self.camelcase(key), data[key]))
-    # end peopleData()
-
-    def hashData(self, hash_value):
-        '''Get Movie data by Hash value and display "key:value" pairs to stdout
-        '''
-        try:
-            self.displayMovieData(self.config['moviedb'].searchHash(hash_value))
-        except TmdbMovieOrPersonNotFound, msg:
-            #sys.stderr.write(u"%s\n" % msg)
-            return
-        except TmdHttpError, msg:
-            sys.stderr.write(self.error_messages['TmdHttpError'] % msg)
-            sys.exit(1)
-        except TmdXmlError, msg:
-            sys.stderr.write(self.error_messages['TmdXmlError'] % msg)
-            sys.exit(1)
-        except TmdBaseError, msg:
-            sys.stderr.write(self.error_messages['TmdBaseError'] % msg)
-            sys.exit(1)
-        except TmdbUiAbort, msg:
-            sys.stderr.write(self.error_messages['TmdbUiAbort'] % msg)
-            sys.exit(1)
-        except Exception, e:
-            sys.stderr.write(u"! Error: Unknown error during a Hash value Movie information display for (%s)\nError(%s)\n" % (hash_value, e))
-            sys.exit(1)
-    # end hashData()
-
-# end Class moviedbQueries()
-
-
-def main():
-    """Gets movie details using an IMDB# and a TMDB# OR get People information using a name
-    """
-    # themoviedb.org api key given by Travis Bell for Mythtv
-    apikey = "c27cb71cff5bd76e1a7a009380562c62"
-
-    parser = OptionParser(usage=u"%prog usage: tmdb -hdruviomMPFBDS [parameters]\n <series name or 'series and season number' or 'series and season number and episode number'>\n\nFor details on using tmdb with Mythvideo see the tmdb wiki page at:\nhttp://www.mythtv.org/wiki/tmdb.py")
-
-    parser.add_option(  "-d", "--debug", action="store_true", default=False, dest="debug",
-                        help=u"Show debugging info")
-    parser.add_option(  "-r", "--raw", action="store_true",default=False, dest="raw",
-                        help=u"Dump raw data only")
-    parser.add_option(  "-u", "--usage", action="store_true", default=False, dest="usage",
-                        help=u"Display examples for executing the tmdb script")
-    parser.add_option(  "-v", "--version", action="store_true", default=False, dest="version",
-                        help=u"Display version and author")
-    parser.add_option(  "-i", "--interactive", action="store_true", default=False, dest="interactive",
-                        help=u"Interaction mode (allows selection of a specific Movie or Person)")
-    parser.add_option(  "-l", "--language", metavar="LANGUAGE", default=u'en', dest="language",
-                        help=u"Select data that matches the specified language fall back to english if nothing found (e.g. 'es' Espaol, 'de' Deutsch ... etc)")
-    parser.add_option(  "-M", "--movielist", action="store_true", default=False, dest="movielist",
-                        help=u"Get matching Movie list")
-    parser.add_option(  "-D", "--moviedata", action="store_true", default=False, dest="moviedata",
-                        help=u"Get Movie metadata including graphic URLs")
-    parser.add_option(  "-H", "--moviehash", action="store_true", default=False, dest="moviehash",
-                        help=u"Get Movie metadata including graphic URLs using a Hash value.\nSee: http://api.themoviedb.org/2.1/methods/Hash.getInfo")
-    parser.add_option(  "-P", "--peoplelist", action="store_true", default=False, dest="peoplelist",
-                        help=u"Get matching People list")
-    parser.add_option(  "-I", "--peopleinfo", action="store_true", default=False, dest="peopleinfo",
-                        help=u"Get A Person's metadata including graphic URLs")
-    parser.add_option(  "-t", action="store_true", default=False, dest="test",
-                        help=u"Test for the availability of runtime dependencies")
-
-    opts, args = parser.parse_args()
-
-    # Test mode, if we've made it here, everything is ok
-    if opts.test:
-        print "Everything appears to be in order"
-        sys.exit(0)
-
-    # Make all command line arguments unicode utf8
-    for index in range(len(args)):
-        args[index] = unicode(args[index], 'utf8')
-
-    if opts.debug:
-        sys.stdout.write("\nopts: %s\n" % opts)
-        sys.stdout.write("\nargs: %s\n\n" % args)
-
-    # Process version command line requests
-    if opts.version:
-        version = etree.XML(u'<grabber></grabber>')
-        etree.SubElement(version, "name").text = __title__
-        etree.SubElement(version, "author").text = __author__
-        etree.SubElement(version, "thumbnail").text = 'tmdb.png'
-        etree.SubElement(version, "command").text = 'tmdb.py'
-        etree.SubElement(version, "type").text = 'movie'
-        etree.SubElement(version, "description").text = 'Search and metadata downloads for themoviedb.org'
-        etree.SubElement(version, "version").text = __version__
-        sys.stdout.write(etree.tostring(version, encoding='UTF-8', pretty_print=True))
-        sys.exit(0)
-
-    # Process usage command line requests
-    if opts.usage:
-        sys.stdout.write(__usage_examples__)
-        sys.exit(0)
-
-    if not len(args) == 1:
-        sys.stderr.write("! Error: There must be one value for any option. Your options are (%s)\n" % (args))
-        sys.exit(1)
-
-    if args[0] == u'':
-        sys.stderr.write("! Error: There must be a non-empty argument, yours is empty.\n")
-        sys.exit(1)
-
-    Queries = moviedbQueries(apikey,
-                mythtv = True,
-                interactive = opts.interactive,
-                select_first = False,
-                debug = opts.debug,
-                custom_ui = None,
-                language = opts.language,
-                search_all_languages = False,)
-
-    # Display in XML format
-    # See: http://www.mythtv.org/wiki/MythTV_Universal_Metadata_Format
-    Queries.config['moviedb'].xml = True
-
-    # Process requested option
-    if opts.movielist:                  # Movie Search -M
-       Queries.movieSearch(args[0])
-    elif opts.moviedata:                # Movie metadata -D
-       Queries.movieData(args[0])
-    elif opts.peoplelist:               # People Search -P
-       Queries.peopleSearch(args[0])
-    elif opts.peopleinfo:               # Person metadata -I
-       Queries.peopleData(args[0])
-    elif opts.moviehash:                # Movie metadata using a hash value -H
-       Queries.hashData(args[0])
-
-    sys.exit(0)
-# end main()
-
-if __name__ == '__main__':
-    main()
diff --git a/mythtv/programs/scripts/metadata/Movie/tmdb3.py b/mythtv/programs/scripts/metadata/Movie/tmdb3.py
index cc1ca16..9e4edcb 100755
--- a/mythtv/programs/scripts/metadata/Movie/tmdb3.py
+++ b/mythtv/programs/scripts/metadata/Movie/tmdb3.py
@@ -11,7 +11,7 @@
 #-----------------------
 __title__ = "TheMovieDB.org V3"
 __author__ = "Raymond Wagner"
-__version__ = "0.3.5"
+__version__ = "0.3.6"
 # 0.1.0 Initial version
 # 0.2.0 Add language support, move cache to home directory
 # 0.3.0 Enable version detection to allow use in MythTV
@@ -21,6 +21,9 @@ __version__ = "0.3.5"
 # 0.3.3 Use translated title if available
 # 0.3.4 Add support for finding by IMDB under -D (simulate previous version)
 # 0.3.5 Add debugging mode
+# 0.3.6 Add handling for TMDB site and library returning null results in
+#       search. This should only need to be a temporary fix, and should be
+#       resolved upstream.
 
 from optparse import OptionParser
 import sys
@@ -116,6 +119,9 @@ def buildList(query, opts):
 
     count = 0
     for res in results:
+        if res is None:
+            continue
+
         m = VideoMetadata()
         for i,j in mapping:
             if getattr(res, j):
