 mythplugins/mythmusic/mythmusic/importmusic.cpp    |    2 +-
 mythplugins/mythmusic/mythmusic/musicplayer.cpp    |    6 +
 mythplugins/mythmusic/mythmusic/smartplaylist.cpp  |   13 +-
 mythtv/external/FFmpeg/README.sync                 |    3 +-
 mythtv/external/FFmpeg/RELEASE                     |    2 +-
 mythtv/external/FFmpeg/VERSION                     |    2 +-
 mythtv/external/FFmpeg/doc/Doxyfile                |    2 +-
 mythtv/external/FFmpeg/ffmpeg_filter.c             |    9 +-
 mythtv/external/FFmpeg/libavcodec/aac.h            |    2 +-
 mythtv/external/FFmpeg/libavcodec/adpcmenc.c       |    3 +-
 mythtv/external/FFmpeg/libavcodec/alsdec.c         |    2 +-
 mythtv/external/FFmpeg/libavcodec/dirac_arith.h    |    3 +-
 mythtv/external/FFmpeg/libavcodec/diracdec.c       |   49 +-
 mythtv/external/FFmpeg/libavcodec/g723_1.c         |    3 +-
 mythtv/external/FFmpeg/libavcodec/golomb-test.c    |    2 +-
 .../FFmpeg/libavcodec/h264_mp4toannexb_bsf.c       |    2 +-
 mythtv/external/FFmpeg/libavcodec/libvorbisenc.c   |    3 +-
 mythtv/external/FFmpeg/libavcodec/libx264.c        |   26 +-
 mythtv/external/FFmpeg/libavcodec/mjpegdec.c       |    2 +-
 mythtv/external/FFmpeg/libavcodec/mjpegenc.c       |    2 +-
 mythtv/external/FFmpeg/libavcodec/mjpegenc.h       |    2 +-
 mythtv/external/FFmpeg/libavcodec/mlpdec.c         |    2 +-
 mythtv/external/FFmpeg/libavcodec/msrle.c          |    3 +
 mythtv/external/FFmpeg/libavcodec/mss34dsp.c       |    4 +-
 mythtv/external/FFmpeg/libavcodec/mss4.c           |    2 +-
 mythtv/external/FFmpeg/libavcodec/utvideodec.c     |    2 +-
 mythtv/external/FFmpeg/libavcodec/vc1dec.c         |    3 +-
 mythtv/external/FFmpeg/libavcodec/wma.c            |    6 +-
 .../FFmpeg/libavcodec/x86/idct_sse2_xvid.c         |    2 +-
 .../FFmpeg/libavcodec/x86/mpegvideoenc_template.c  |    2 +-
 mythtv/external/FFmpeg/libavfilter/filtfmts.c      |   10 +-
 mythtv/external/FFmpeg/libavfilter/graphdump.c     |    3 +-
 mythtv/external/FFmpeg/libavfilter/vf_deshake.c    |    4 +-
 mythtv/external/FFmpeg/libavformat/aiffdec.c       |    2 +-
 mythtv/external/FFmpeg/libavformat/asfdec.c        |    5 +-
 mythtv/external/FFmpeg/libavformat/avidec.c        |    2 +-
 mythtv/external/FFmpeg/libavformat/flvenc.c        |   12 +
 mythtv/external/FFmpeg/libavformat/h263dec.c       |    2 +-
 mythtv/external/FFmpeg/libavformat/id3v2.c         |   17 +-
 mythtv/external/FFmpeg/libavformat/id3v2.h         |    4 +-
 mythtv/external/FFmpeg/libavformat/mpc.c           |    2 +-
 mythtv/external/FFmpeg/libavformat/mpegts.c        |    2 +-
 mythtv/external/FFmpeg/libavformat/mux.c           |    6 +
 mythtv/external/FFmpeg/libavformat/omadec.c        |    2 +-
 mythtv/external/FFmpeg/libavformat/utils.c         |    2 +-
 mythtv/external/FFmpeg/libavutil/cpu.c             |   18 +
 mythtv/external/FFmpeg/libavutil/lzo.c             |   13 +-
 mythtv/external/FFmpeg/libavutil/opt.c             |    6 +-
 mythtv/external/FFmpeg/libswresample/dither.c      |    2 +-
 mythtv/external/FFmpeg/libswresample/rematrix.c    |    5 +
 mythtv/external/FFmpeg/libswresample/resample.c    |    7 +-
 mythtv/external/FFmpeg/libswscale/swscale.c        |    7 +-
 .../FFmpeg/libswscale/x86/swscale_template.c       |   78 +-
 mythtv/external/FFmpeg/tests/ref/fate/vc1_sa10143  |   28 +-
 mythtv/libs/libmyth/audio/audiooutputbase.cpp      |    9 +-
 mythtv/libs/libmyth/mediamonitor-darwin.cpp        |   10 +
 mythtv/libs/libmythbase/mythcorecontext.cpp        |    3 +-
 mythtv/libs/libmythbase/mythversion.h              |    2 +-
 mythtv/libs/libmythdvdnav/dvdnav/dvdnav.c          |    2 +-
 mythtv/libs/libmythdvdnav/dvdnav/dvdnav.h          |    2 +-
 mythtv/libs/libmythdvdnav/dvdnav/remap.c           |    1 +
 mythtv/libs/libmythdvdnav/dvdnav/searching.c       |   32 +-
 mythtv/libs/libmythdvdnav/dvdnav/vm/vm.c           |    6 +-
 mythtv/libs/libmythdvdnav/dvdread/dvd_input.c      |   44 +-
 mythtv/libs/libmythdvdnav/dvdread/dvd_reader.c     |    1 +
 mythtv/libs/libmythdvdnav/dvdread/dvd_udf.c        |    5 +-
 mythtv/libs/libmythdvdnav/dvdread/ifo_print.c      |    4 +-
 mythtv/libs/libmythdvdnav/dvdread/ifo_read.c       |   23 +-
 mythtv/libs/libmythmetadata/libmythmetadata.pro    |    4 +-
 mythtv/libs/libmythmetadata/metadatacommon.cpp     |   95 +-
 mythtv/libs/libmythmetadata/metadatacommon.h       |   52 +-
 mythtv/libs/libmythmetadata/metadatadownload.cpp   |  339 +-
 mythtv/libs/libmythmetadata/metadatafactory.cpp    |   69 +-
 mythtv/libs/libmythmetadata/metadatafactory.h      |    2 +
 mythtv/libs/libmythmetadata/metadatagrabber.cpp    |  595 +++
 mythtv/libs/libmythmetadata/metadatagrabber.h      |  100 +
 .../libs/libmythmetadata/metadataimagedownload.cpp |  150 +-
 .../libs/libmythmetadata/metadataimagedownload.h   |    1 +
 mythtv/libs/libmythmetadata/videometadata.cpp      |   17 +-
 .../requesthandler/fileserverhandler.cpp           |    3 +-
 mythtv/libs/libmythtv/avformatdecoder.cpp          |   48 +-
 mythtv/libs/libmythtv/cc608decoder.cpp             |    2 +-
 mythtv/libs/libmythtv/cc708reader.cpp              |    2 +-
 .../libs/libmythtv/channelscan/channelscan_sm.cpp  |   19 +-
 mythtv/libs/libmythtv/channelscan/channelscan_sm.h |    2 +
 mythtv/libs/libmythtv/eitcache.cpp                 |    4 +-
 mythtv/libs/libmythtv/eitfixup.cpp                 |    4 +-
 mythtv/libs/libmythtv/lzoconf.h                    |  219 +-
 mythtv/libs/libmythtv/lzodefs.h                    | 2527 ++++++++----
 mythtv/libs/libmythtv/metadataimagehelper.cpp      |    3 +
 mythtv/libs/libmythtv/minilzo.cpp                  | 4191 ++++++++++++++------
 mythtv/libs/libmythtv/minilzo.h                    |   20 +-
 mythtv/libs/libmythtv/mpeg/dvbstreamdata.cpp       |    8 +
 mythtv/libs/libmythtv/mythplayer.cpp               |  141 +-
 mythtv/libs/libmythtv/openglvideo.cpp              |    2 +-
 mythtv/libs/libmythtv/programdata.cpp              |   41 +-
 mythtv/libs/libmythtv/ringbuffer.cpp               |   19 +-
 mythtv/libs/libmythtv/subtitlescreen.cpp           |   58 +-
 mythtv/libs/libmythtv/tv_play.cpp                  |    8 +-
 mythtv/libs/libmythtv/videobuffers.cpp             |    6 +
 mythtv/libs/libmythtv/videoout_nullvdpau.cpp       |    4 +-
 mythtv/libs/libmythtv/videoout_opengl.cpp          |    6 +-
 mythtv/libs/libmythui/mythuiwebbrowser.cpp         |    2 +-
 mythtv/libs/libmythupnp/upnpcds.h                  |    2 +-
 mythtv/libs/libmythupnp/upnpcmgr.h                 |    2 +-
 mythtv/programs/mythbackend/main_helpers.cpp       |    9 +-
 mythtv/programs/mythbackend/mainserver.cpp         |   20 +-
 mythtv/programs/mythbackend/upnpcdstv.cpp          |   27 +-
 mythtv/programs/mythbackend/upnpcdsvideo.cpp       |    2 +-
 mythtv/programs/mythfrontend/editvideometadata.cpp |   10 +-
 mythtv/programs/mythfrontend/grabbersettings.cpp   |  125 +-
 mythtv/programs/mythfrontend/grabbersettings.h     |    7 +-
 mythtv/programs/mythfrontend/playbackbox.cpp       |  158 +-
 mythtv/programs/mythfrontend/playbackbox.h         |   13 +-
 mythtv/programs/mythfrontend/scheduleeditor.cpp    |   76 +-
 mythtv/programs/mythfrontend/scheduleeditor.h      |    1 +
 mythtv/programs/mythmetadatalookup/lookup.cpp      |   12 +-
 mythtv/programs/mythmetadatalookup/main.cpp        |   12 +
 mythtv/programs/mythtranscode/mpeg2fix.cpp         |   23 +-
 mythtv/programs/mythtranscode/mpeg2fix.h           |    4 +
 .../programs/mythtranscode/videodecodebuffer.cpp   |   36 +-
 mythtv/programs/mythtranscode/videodecodebuffer.h  |   25 +-
 mythtv/themes/classic/tv_schedule.xml              |    2 +-
 123 files changed, 7006 insertions(+), 2872 deletions(-)

diff --git a/mythplugins/mythmusic/mythmusic/importmusic.cpp b/mythplugins/mythmusic/mythmusic/importmusic.cpp
index d0faf12..31a89da 100644
--- a/mythplugins/mythmusic/mythmusic/importmusic.cpp
+++ b/mythplugins/mythmusic/mythmusic/importmusic.cpp
@@ -127,7 +127,7 @@ ImportMusicDialog::~ImportMusicDialog()
     if (gPlayer->getCurrentMetadata() && m_playingMetaData)
     {
         if (gPlayer->isPlaying() && gPlayer->getCurrentMetadata()->Filename() == m_playingMetaData->Filename())
-            gPlayer->stop();
+            gPlayer->stop(true);
     }
 
     if (m_locationEdit)
diff --git a/mythplugins/mythmusic/mythmusic/musicplayer.cpp b/mythplugins/mythmusic/mythmusic/musicplayer.cpp
index ea46a3d..867c765 100644
--- a/mythplugins/mythmusic/mythmusic/musicplayer.cpp
+++ b/mythplugins/mythmusic/mythmusic/musicplayer.cpp
@@ -261,6 +261,12 @@ void MusicPlayer::stop(bool stopAll)
         m_output->Reset();
     }
 
+    if (m_oneshotMetadata)
+    {
+        delete m_oneshotMetadata;
+        m_oneshotMetadata = NULL;
+    }
+
     m_isPlaying = false;
 
     if (stopAll && getDecoder())
diff --git a/mythplugins/mythmusic/mythmusic/smartplaylist.cpp b/mythplugins/mythmusic/mythmusic/smartplaylist.cpp
index de952e8..0fc546d 100644
--- a/mythplugins/mythmusic/mythmusic/smartplaylist.cpp
+++ b/mythplugins/mythmusic/mythmusic/smartplaylist.cpp
@@ -52,10 +52,8 @@ static SmartPLField SmartPLFields[] =
     { "Play Count",    "music_songs.numplays",           ftNumeric,  0,    9999, 0 },
     { "Compilation",   "music_albums.compilation",       ftBoolean,  0,    0,    0 },
     { "Comp. Artist",  "music_comp_artists.artist_name", ftString,   0,    0,    0 },
-    { "Last Play",     "FROM_DAYS(TO_DAYS(music_songs.lastplay))",
-                                                         ftDate,     0,    0,    0 },
-    { "Date Imported", "FROM_DAYS(TO_DAYS(music_songs.date_entered))",
-                                                         ftDate,     0,    0,    0 },
+    { "Last Play",     "music_songs.lastplay",           ftDate,     0,    0,    0 },
+    { "Date Imported", "music_songs.date_entered",       ftDate,     0,    0,    0 },
 };
 
 struct SmartPLOperator
@@ -334,7 +332,7 @@ bool SmartPLCriteriaRow::saveToDatabase(int smartPlaylistID)
     query.bindValue(":FIELD", Field);
     query.bindValue(":OPERATOR", Operator);
     query.bindValue(":VALUE1", Value1);
-    query.bindValue(":VALUE2", Value2);
+    query.bindValue(":VALUE2", Value2.isNull() ? "" : Value2);
 
     if (!query.exec())
     {
@@ -750,7 +748,7 @@ void SmartPlaylistEditor::updateMatches(void)
 
     m_matchesText->SetText(QString::number(m_matchesCount));
 
-    m_playlistIsValid = (m_matchesCount > 0);
+    m_playlistIsValid = (m_criteriaRows.size() > 0);
     m_showResultsButton->SetEnabled((m_matchesCount > 0));
     titleChanged();
 }
@@ -1015,6 +1013,9 @@ QString SmartPlaylistEditor::getOrderByClause(void)
 
 QString SmartPlaylistEditor::getWhereClause(void)
 {
+    if (m_criteriaRows.size() == 0)
+        return QString();
+
     bool bFirst = true;
     QString sql = "WHERE ";
 
diff --git a/mythtv/external/FFmpeg/README.sync b/mythtv/external/FFmpeg/README.sync
index a91b793..2bf19c5 100644
--- a/mythtv/external/FFmpeg/README.sync
+++ b/mythtv/external/FFmpeg/README.sync
@@ -14,7 +14,8 @@ git://source.ffmpeg.org/ffmpeg.git at SHA1 59549b5a on June 20th, 2013 (jya) (re
 git://source.ffmpeg.org/ffmpeg.git at SHA1 c9ea1f7f on July 16th, 2013 (jya) (release/1.2 branch)
 git://source.ffmpeg.org/ffmpeg.git at SHA1 875649bf on July 27th, 2013 (jya) (release/1.2 branch)
 git://source.ffmpeg.org/ffmpeg.git at SHA1 f9c87262 on August 12th, 2013 (jya) (release/1.2 branch)
-git://source.ffmpeg.org/ffmpeg.git at SHA1 3d79041f on May 4th, 2014 (jya) (release/1.2 branch, release 1.2.6))
+git://source.ffmpeg.org/ffmpeg.git at SHA1 3d79041f on May 4th, 2014 (jya) (release/1.2 branch, release 1.2.6)
+git://source.ffmpeg.org/ffmpeg.git at n1.2.7 on July 9h, 2014 (jya) (release/1.2 branch, release 1.2.7)
 
 List of files modified from original FFmpeg:
 Makefile
diff --git a/mythtv/external/FFmpeg/RELEASE b/mythtv/external/FFmpeg/RELEASE
index 3c43790..c04c650 100644
--- a/mythtv/external/FFmpeg/RELEASE
+++ b/mythtv/external/FFmpeg/RELEASE
@@ -1 +1 @@
-1.2.6
+1.2.7
diff --git a/mythtv/external/FFmpeg/VERSION b/mythtv/external/FFmpeg/VERSION
index 3c43790..c04c650 100644
--- a/mythtv/external/FFmpeg/VERSION
+++ b/mythtv/external/FFmpeg/VERSION
@@ -1 +1 @@
-1.2.6
+1.2.7
diff --git a/mythtv/external/FFmpeg/doc/Doxyfile b/mythtv/external/FFmpeg/doc/Doxyfile
index e803996..ff719a4 100644
--- a/mythtv/external/FFmpeg/doc/Doxyfile
+++ b/mythtv/external/FFmpeg/doc/Doxyfile
@@ -31,7 +31,7 @@ PROJECT_NAME           = FFmpeg
 # This could be handy for archiving the generated documentation or
 # if some version control system is used.
 
-PROJECT_NUMBER         = 1.2.6
+PROJECT_NUMBER         = 1.2.7
 
 # With the PROJECT_LOGO tag one can specify an logo or icon that is included
 # in the documentation. The maximum height of the logo should not exceed 55
diff --git a/mythtv/external/FFmpeg/ffmpeg_filter.c b/mythtv/external/FFmpeg/ffmpeg_filter.c
index bdf4363..be2114b 100644
--- a/mythtv/external/FFmpeg/ffmpeg_filter.c
+++ b/mythtv/external/FFmpeg/ffmpeg_filter.c
@@ -43,12 +43,15 @@ enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodec *codec, enum AVPixelFo
         const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(target);
         int has_alpha = desc ? desc->nb_components % 2 == 0 : 0;
         enum AVPixelFormat best= AV_PIX_FMT_NONE;
+        const enum AVPixelFormat mjpeg_formats[] = { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE };
+        const enum AVPixelFormat ljpeg_formats[] = { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P,
+                                                     AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE };
+
         if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {
             if (st->codec->codec_id == AV_CODEC_ID_MJPEG) {
-                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE };
+                p = mjpeg_formats;
             } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) {
-                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P,
-                                                 AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE };
+                p =ljpeg_formats;
             }
         }
         for (; *p != AV_PIX_FMT_NONE; p++) {
diff --git a/mythtv/external/FFmpeg/libavcodec/aac.h b/mythtv/external/FFmpeg/libavcodec/aac.h
index d586e27..e24351e 100644
--- a/mythtv/external/FFmpeg/libavcodec/aac.h
+++ b/mythtv/external/FFmpeg/libavcodec/aac.h
@@ -81,7 +81,7 @@ enum BandType {
     INTENSITY_BT   = 15,    ///< Scalefactor data are intensity stereo positions.
 };
 
-#define IS_CODEBOOK_UNSIGNED(x) ((x - 1) & 10)
+#define IS_CODEBOOK_UNSIGNED(x) (((x) - 1) & 10)
 
 enum ChannelPosition {
     AAC_CHANNEL_OFF   = 0,
diff --git a/mythtv/external/FFmpeg/libavcodec/adpcmenc.c b/mythtv/external/FFmpeg/libavcodec/adpcmenc.c
index 59f016b..5bcaeb1 100644
--- a/mythtv/external/FFmpeg/libavcodec/adpcmenc.c
+++ b/mythtv/external/FFmpeg/libavcodec/adpcmenc.c
@@ -557,10 +557,11 @@ static int adpcm_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
             put_bits(&pb, 7,  status->step_index);
             if (avctx->trellis > 0) {
                 uint8_t buf[64];
-                adpcm_compress_trellis(avctx, &samples_p[ch][1], buf, status,
+                adpcm_compress_trellis(avctx, &samples_p[ch][0], buf, status,
                                        64, 1);
                 for (i = 0; i < 64; i++)
                     put_bits(&pb, 4, buf[i ^ 1]);
+                status->prev_sample = status->predictor;
             } else {
                 for (i = 0; i < 64; i += 2) {
                     int t1, t2;
diff --git a/mythtv/external/FFmpeg/libavcodec/alsdec.c b/mythtv/external/FFmpeg/libavcodec/alsdec.c
index a6d70d4..7a7733a 100644
--- a/mythtv/external/FFmpeg/libavcodec/alsdec.c
+++ b/mythtv/external/FFmpeg/libavcodec/alsdec.c
@@ -284,7 +284,7 @@ static av_cold int read_specific_config(ALSDecContext *ctx)
     GetBitContext gb;
     uint64_t ht_size;
     int i, config_offset;
-    MPEG4AudioConfig m4ac;
+    MPEG4AudioConfig m4ac = {0};
     ALSSpecificConfig *sconf = &ctx->sconf;
     AVCodecContext *avctx    = ctx->avctx;
     uint32_t als_id, header_size, trailer_size;
diff --git a/mythtv/external/FFmpeg/libavcodec/dirac_arith.h b/mythtv/external/FFmpeg/libavcodec/dirac_arith.h
index f9a8bba..089c71a 100644
--- a/mythtv/external/FFmpeg/libavcodec/dirac_arith.h
+++ b/mythtv/external/FFmpeg/libavcodec/dirac_arith.h
@@ -28,6 +28,7 @@
 #ifndef AVCODEC_DIRAC_ARITH_H
 #define AVCODEC_DIRAC_ARITH_H
 
+#include "libavutil/x86/asm.h"
 #include "bytestream.h"
 #include "get_bits.h"
 
@@ -134,7 +135,7 @@ static inline int dirac_get_arith_bit(DiracArith *c, int ctx)
 
     range_times_prob = (c->range * prob_zero) >> 16;
 
-#if HAVE_FAST_CMOV && HAVE_INLINE_ASM
+#if HAVE_FAST_CMOV && HAVE_INLINE_ASM && HAVE_6REGS
     low   -= range_times_prob << 16;
     range -= range_times_prob;
     bit = 0;
diff --git a/mythtv/external/FFmpeg/libavcodec/diracdec.c b/mythtv/external/FFmpeg/libavcodec/diracdec.c
index a791e88..08771e5 100644
--- a/mythtv/external/FFmpeg/libavcodec/diracdec.c
+++ b/mythtv/external/FFmpeg/libavcodec/diracdec.c
@@ -201,6 +201,7 @@ typedef struct DiracContext {
 
     uint16_t *mctmp;            /* buffer holding the MC data multipled by OBMC weights */
     uint8_t *mcscratch;
+    int buffer_stride;
 
     DECLARE_ALIGNED(16, uint8_t, obmc_weight)[3][MAX_BLOCKSIZE*MAX_BLOCKSIZE];
 
@@ -343,19 +344,41 @@ static int alloc_sequence_buffers(DiracContext *s)
             return AVERROR(ENOMEM);
     }
 
-    w = s->source.width;
-    h = s->source.height;
-
     /* fixme: allocate using real stride here */
-    s->sbsplit  = av_malloc(sbwidth * sbheight);
-    s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion));
-    s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE);
+    s->sbsplit  = av_malloc_array(sbwidth, sbheight);
+    s->blmotion = av_malloc_array(sbwidth, sbheight * 16 * sizeof(*s->blmotion));
+
+    if (!s->sbsplit || !s->blmotion)
+        return AVERROR(ENOMEM);
+    return 0;
+}
+
+static int alloc_buffers(DiracContext *s, int stride)
+{
+    int w = s->source.width;
+    int h = s->source.height;
+
+    av_assert0(stride >= w);
+    stride += 64;
+
+    if (s->buffer_stride >= stride)
+        return 0;
+    s->buffer_stride = 0;
+
+    av_freep(&s->edge_emu_buffer_base);
+    memset(s->edge_emu_buffer, 0, sizeof(s->edge_emu_buffer));
+    av_freep(&s->mctmp);
+    av_freep(&s->mcscratch);
 
-    s->mctmp     = av_malloc((w+64+MAX_BLOCKSIZE) * (h+MAX_BLOCKSIZE) * sizeof(*s->mctmp));
-    s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE);
+    s->edge_emu_buffer_base = av_malloc_array(stride, MAX_BLOCKSIZE);
 
-    if (!s->sbsplit || !s->blmotion || !s->mctmp || !s->mcscratch)
+    s->mctmp     = av_malloc_array((stride+MAX_BLOCKSIZE), (h+MAX_BLOCKSIZE) * sizeof(*s->mctmp));
+    s->mcscratch = av_malloc_array(stride, MAX_BLOCKSIZE);
+
+    if (!s->edge_emu_buffer_base || !s->mctmp || !s->mcscratch)
         return AVERROR(ENOMEM);
+
+    s->buffer_stride = stride;
     return 0;
 }
 
@@ -382,6 +405,7 @@ static void free_sequence_buffers(DiracContext *s)
         av_freep(&s->plane[i].idwt_tmp);
     }
 
+    s->buffer_stride = 0;
     av_freep(&s->sbsplit);
     av_freep(&s->blmotion);
     av_freep(&s->edge_emu_buffer_base);
@@ -1343,8 +1367,8 @@ static int mc_subpel(DiracContext *s, DiracBlock *block, const uint8_t *src[5],
         motion_y >>= s->chroma_y_shift;
     }
 
-    mx         = motion_x & ~(-1 << s->mv_precision);
-    my         = motion_y & ~(-1 << s->mv_precision);
+    mx         = motion_x & ~(-1U << s->mv_precision);
+    my         = motion_y & ~(-1U << s->mv_precision);
     motion_x >>= s->mv_precision;
     motion_y >>= s->mv_precision;
     /* normalize subpel coordinates to epel */
@@ -1818,6 +1842,9 @@ static int dirac_decode_data_unit(AVCodecContext *avctx, const uint8_t *buf, int
         s->plane[1].stride = pic->avframe.linesize[1];
         s->plane[2].stride = pic->avframe.linesize[2];
 
+        if (alloc_buffers(s, FFMAX3(FFABS(s->plane[0].stride), FFABS(s->plane[1].stride), FFABS(s->plane[2].stride))) < 0)
+            return AVERROR(ENOMEM);
+
         /* [DIRAC_STD] 11.1 Picture parse. picture_parse() */
         if (dirac_decode_picture_header(s))
             return -1;
diff --git a/mythtv/external/FFmpeg/libavcodec/g723_1.c b/mythtv/external/FFmpeg/libavcodec/g723_1.c
index d2cde8a..7b3ac0a 100644
--- a/mythtv/external/FFmpeg/libavcodec/g723_1.c
+++ b/mythtv/external/FFmpeg/libavcodec/g723_1.c
@@ -2288,7 +2288,8 @@ static int pack_bitstream(G723_1_Context *p, unsigned char *frame, int size)
     if (p->cur_rate == RATE_6300) {
         info_bits = 0;
         put_bits(&pb, 2, info_bits);
-    }
+    }else
+        av_assert0(0);
 
     put_bits(&pb, 8, p->lsp_index[2]);
     put_bits(&pb, 8, p->lsp_index[1]);
diff --git a/mythtv/external/FFmpeg/libavcodec/golomb-test.c b/mythtv/external/FFmpeg/libavcodec/golomb-test.c
index 8adcdf6..2dfe917 100644
--- a/mythtv/external/FFmpeg/libavcodec/golomb-test.c
+++ b/mythtv/external/FFmpeg/libavcodec/golomb-test.c
@@ -58,7 +58,7 @@ int main(void)
         }
     }
 
-#define EXTEND(i) (i << 3 | i & 7)
+#define EXTEND(i) ((i) << 3 | (i) & 7)
     init_put_bits(&pb, temp, SIZE);
     for (i = 0; i < COUNT; i++)
         set_ue_golomb(&pb, EXTEND(i));
diff --git a/mythtv/external/FFmpeg/libavcodec/h264_mp4toannexb_bsf.c b/mythtv/external/FFmpeg/libavcodec/h264_mp4toannexb_bsf.c
index 2dea933..f9c3621 100644
--- a/mythtv/external/FFmpeg/libavcodec/h264_mp4toannexb_bsf.c
+++ b/mythtv/external/FFmpeg/libavcodec/h264_mp4toannexb_bsf.c
@@ -154,7 +154,7 @@ pps:
             goto fail;
 
         /* prepend only to the first type 5 NAL unit of an IDR picture */
-        if (ctx->first_idr && unit_type == 5) {
+        if (ctx->first_idr && (unit_type == 5 || unit_type == 7 || unit_type == 8)) {
             if ((ret=alloc_and_copy(poutbuf, poutbuf_size,
                                avctx->extradata, avctx->extradata_size,
                                buf, nal_size)) < 0)
diff --git a/mythtv/external/FFmpeg/libavcodec/libvorbisenc.c b/mythtv/external/FFmpeg/libavcodec/libvorbisenc.c
index 1c0dab6..21cc441 100644
--- a/mythtv/external/FFmpeg/libavcodec/libvorbisenc.c
+++ b/mythtv/external/FFmpeg/libavcodec/libvorbisenc.c
@@ -362,7 +362,8 @@ static int oggvorbis_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
             avctx->delay              = duration;
             av_assert0(!s->afq.remaining_delay);
             s->afq.frames->duration  += duration;
-            s->afq.frames->pts       -= duration;
+            if (s->afq.frames->pts != AV_NOPTS_VALUE)
+                s->afq.frames->pts       -= duration;
             s->afq.remaining_samples += duration;
         }
         ff_af_queue_remove(&s->afq, duration, &avpkt->pts, &avpkt->duration);
diff --git a/mythtv/external/FFmpeg/libavcodec/libx264.c b/mythtv/external/FFmpeg/libavcodec/libx264.c
index 7e8fa65..9157ab3 100644
--- a/mythtv/external/FFmpeg/libavcodec/libx264.c
+++ b/mythtv/external/FFmpeg/libavcodec/libx264.c
@@ -343,19 +343,6 @@ static av_cold int X264_init(AVCodecContext *avctx)
 
     OPT_STR("level", x4->level);
 
-    if(x4->x264opts){
-        const char *p= x4->x264opts;
-        while(p){
-            char param[256]={0}, val[256]={0};
-            if(sscanf(p, "%255[^:=]=%255[^:]", param, val) == 1){
-                OPT_STR(param, "1");
-            }else
-                OPT_STR(param, val);
-            p= strchr(p, ':');
-            p+=!!p;
-        }
-    }
-
     if (avctx->i_quant_factor > 0)
         x4->params.rc.f_ip_factor         = 1 / fabs(avctx->i_quant_factor);
 
@@ -525,6 +512,19 @@ static av_cold int X264_init(AVCodecContext *avctx)
     if (avctx->flags & CODEC_FLAG_GLOBAL_HEADER)
         x4->params.b_repeat_headers = 0;
 
+    if(x4->x264opts){
+        const char *p= x4->x264opts;
+        while(p){
+            char param[256]={0}, val[256]={0};
+            if(sscanf(p, "%255[^:=]=%255[^:]", param, val) == 1){
+                OPT_STR(param, "1");
+            }else
+                OPT_STR(param, val);
+            p= strchr(p, ':');
+            p+=!!p;
+        }
+    }
+
     if (x4->x264_params) {
         AVDictionary *dict    = NULL;
         AVDictionaryEntry *en = NULL;
diff --git a/mythtv/external/FFmpeg/libavcodec/mjpegdec.c b/mythtv/external/FFmpeg/libavcodec/mjpegdec.c
index 27b0e5b..b9c6950 100644
--- a/mythtv/external/FFmpeg/libavcodec/mjpegdec.c
+++ b/mythtv/external/FFmpeg/libavcodec/mjpegdec.c
@@ -1144,7 +1144,7 @@ static int mjpeg_decode_scan_progressive_ac(MJpegDecodeContext *s, int ss,
     }
 
     if (!Al) {
-        s->coefs_finished[c] |= (1LL << (se + 1)) - (1LL << ss);
+        s->coefs_finished[c] |= (2LL << se) - (1LL << ss);
         last_scan = !~s->coefs_finished[c];
     }
 
diff --git a/mythtv/external/FFmpeg/libavcodec/mjpegenc.c b/mythtv/external/FFmpeg/libavcodec/mjpegenc.c
index 80a4022..9460d7b 100644
--- a/mythtv/external/FFmpeg/libavcodec/mjpegenc.c
+++ b/mythtv/external/FFmpeg/libavcodec/mjpegenc.c
@@ -454,7 +454,7 @@ static void encode_block(MpegEncContext *s, int16_t *block, int n)
         put_bits(&s->pb, huff_size_ac[0], huff_code_ac[0]);
 }
 
-void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[6][64])
+void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])
 {
     int i;
     if (s->chroma_format == CHROMA_444) {
diff --git a/mythtv/external/FFmpeg/libavcodec/mjpegenc.h b/mythtv/external/FFmpeg/libavcodec/mjpegenc.h
index ce0c1cc..041f026 100644
--- a/mythtv/external/FFmpeg/libavcodec/mjpegenc.h
+++ b/mythtv/external/FFmpeg/libavcodec/mjpegenc.h
@@ -56,6 +56,6 @@ void ff_mjpeg_encode_picture_trailer(MpegEncContext *s);
 void ff_mjpeg_encode_stuffing(MpegEncContext *s);
 void ff_mjpeg_encode_dc(MpegEncContext *s, int val,
                         uint8_t *huff_size, uint16_t *huff_code);
-void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[6][64]);
+void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64]);
 
 #endif /* AVCODEC_MJPEGENC_H */
diff --git a/mythtv/external/FFmpeg/libavcodec/mlpdec.c b/mythtv/external/FFmpeg/libavcodec/mlpdec.c
index c763624..b8c69ef 100644
--- a/mythtv/external/FFmpeg/libavcodec/mlpdec.c
+++ b/mythtv/external/FFmpeg/libavcodec/mlpdec.c
@@ -813,7 +813,7 @@ static int read_decoding_params(MLPDecodeContext *m, GetBitContext *gbp,
     return 0;
 }
 
-#define MSB_MASK(bits)  (-1u << bits)
+#define MSB_MASK(bits)  (-1u << (bits))
 
 /** Generate PCM samples using the prediction filters and residual values
  *  read from the data stream, and update the filter state. */
diff --git a/mythtv/external/FFmpeg/libavcodec/msrle.c b/mythtv/external/FFmpeg/libavcodec/msrle.c
index a836e33..c1498b5 100644
--- a/mythtv/external/FFmpeg/libavcodec/msrle.c
+++ b/mythtv/external/FFmpeg/libavcodec/msrle.c
@@ -118,6 +118,9 @@ static int msrle_decode_frame(AVCodecContext *avctx,
         uint8_t *buf = avpkt->data + (avctx->height-1)*istride;
         int i, j;
 
+        if (linesize < 0)
+            return linesize;
+
         for (i = 0; i < avctx->height; i++) {
             if (avctx->bits_per_coded_sample == 4) {
                 for (j = 0; j < avctx->width - 1; j += 2) {
diff --git a/mythtv/external/FFmpeg/libavcodec/mss34dsp.c b/mythtv/external/FFmpeg/libavcodec/mss34dsp.c
index e4d4299..0397add 100644
--- a/mythtv/external/FFmpeg/libavcodec/mss34dsp.c
+++ b/mythtv/external/FFmpeg/libavcodec/mss34dsp.c
@@ -84,8 +84,8 @@ void ff_mss34_gen_quant_mat(uint16_t *qmat, int quality, int luma)
     blk[6 * step] = (-(t3 + t7) + t8 + tA) >> shift;                \
     blk[7 * step] = (-(t1 + t6) + t9 + tB) >> shift;                \
 
-#define SOP_ROW(a) ((a) << 16) + 0x2000
-#define SOP_COL(a) ((a + 32) << 16)
+#define SOP_ROW(a) (((a) << 16) + 0x2000)
+#define SOP_COL(a) (((a) + 32) << 16)
 
 void ff_mss34_dct_put(uint8_t *dst, int stride, int *block)
 {
diff --git a/mythtv/external/FFmpeg/libavcodec/mss4.c b/mythtv/external/FFmpeg/libavcodec/mss4.c
index 977e1e5..f2a8aa6 100644
--- a/mythtv/external/FFmpeg/libavcodec/mss4.c
+++ b/mythtv/external/FFmpeg/libavcodec/mss4.c
@@ -363,7 +363,7 @@ static int get_value_cached(GetBitContext *gb, int vec_pos, uint8_t *vec,
     return prev[component];
 }
 
-#define MKVAL(vals)  (vals[0] | (vals[1] << 3) | (vals[2] << 6))
+#define MKVAL(vals)  ((vals)[0] | ((vals)[1] << 3) | ((vals)[2] << 6))
 
 /* Image mode - the hardest to comprehend MSS4 coding mode.
  *
diff --git a/mythtv/external/FFmpeg/libavcodec/utvideodec.c b/mythtv/external/FFmpeg/libavcodec/utvideodec.c
index 259030a..3108159 100644
--- a/mythtv/external/FFmpeg/libavcodec/utvideodec.c
+++ b/mythtv/external/FFmpeg/libavcodec/utvideodec.c
@@ -70,7 +70,7 @@ static int build_huff(const uint8_t *src, VLC *vlc, int *fsym)
         code += 0x80000000u >> (he[i].len - 1);
     }
 
-    return ff_init_vlc_sparse(vlc, FFMIN(he[last].len, 9), last + 1,
+    return ff_init_vlc_sparse(vlc, FFMIN(he[last].len, 11), last + 1,
                               bits,  sizeof(*bits),  sizeof(*bits),
                               codes, sizeof(*codes), sizeof(*codes),
                               syms,  sizeof(*syms),  sizeof(*syms), 0);
diff --git a/mythtv/external/FFmpeg/libavcodec/vc1dec.c b/mythtv/external/FFmpeg/libavcodec/vc1dec.c
index 2130c74..2a0d9f4 100644
--- a/mythtv/external/FFmpeg/libavcodec/vc1dec.c
+++ b/mythtv/external/FFmpeg/libavcodec/vc1dec.c
@@ -1867,9 +1867,10 @@ static void vc1_interp_mc(VC1Context *v)
     uvmx = (mx + ((mx & 3) == 3)) >> 1;
     uvmy = (my + ((my & 3) == 3)) >> 1;
     if (v->field_mode) {
-        if (v->cur_field_type != v->ref_field_type[1])
+        if (v->cur_field_type != v->ref_field_type[1]) {
             my   = my   - 2 + 4 * v->cur_field_type;
             uvmy = uvmy - 2 + 4 * v->cur_field_type;
+        }
     }
     if (v->fastuvmc) {
         uvmx = uvmx + ((uvmx < 0) ? -(uvmx & 1) : (uvmx & 1));
diff --git a/mythtv/external/FFmpeg/libavcodec/wma.c b/mythtv/external/FFmpeg/libavcodec/wma.c
index e704223..5888363 100644
--- a/mythtv/external/FFmpeg/libavcodec/wma.c
+++ b/mythtv/external/FFmpeg/libavcodec/wma.c
@@ -385,9 +385,9 @@ int ff_wma_end(AVCodecContext *avctx)
     }
     for (i = 0; i < 2; i++) {
         ff_free_vlc(&s->coef_vlc[i]);
-        av_free(s->run_table[i]);
-        av_free(s->level_table[i]);
-        av_free(s->int_table[i]);
+        av_freep(&s->run_table[i]);
+        av_freep(&s->level_table[i]);
+        av_freep(&s->int_table[i]);
     }
 
 #if FF_API_OLD_ENCODE_AUDIO
diff --git a/mythtv/external/FFmpeg/libavcodec/x86/idct_sse2_xvid.c b/mythtv/external/FFmpeg/libavcodec/x86/idct_sse2_xvid.c
index b51466c..86c7cf4 100644
--- a/mythtv/external/FFmpeg/libavcodec/x86/idct_sse2_xvid.c
+++ b/mythtv/external/FFmpeg/libavcodec/x86/idct_sse2_xvid.c
@@ -343,7 +343,7 @@ DECLARE_ASM_CONST(16, int32_t, walkenIdctRounders)[] = {
     "movdqa   %%xmm6, 4*16("dct")     \n\t" \
     "movdqa   "SREG2", 7*16("dct")    \n\t"
 
-inline void ff_idct_xvid_sse2(short *block)
+av_extern_inline void ff_idct_xvid_sse2(short *block)
 {
     __asm__ volatile(
     "movq     "MANGLE(m127)", %%mm0                              \n\t"
diff --git a/mythtv/external/FFmpeg/libavcodec/x86/mpegvideoenc_template.c b/mythtv/external/FFmpeg/libavcodec/x86/mpegvideoenc_template.c
index 1e0505e..b0ba234 100644
--- a/mythtv/external/FFmpeg/libavcodec/x86/mpegvideoenc_template.c
+++ b/mythtv/external/FFmpeg/libavcodec/x86/mpegvideoenc_template.c
@@ -216,7 +216,7 @@ static int RENAME(dct_quantize)(MpegEncContext *s,
         "psubusw "MM"1, "MM"4               \n\t"
         "packuswb "MM"4, "MM"4              \n\t"
 #if COMPILE_TEMPLATE_SSE2
-        "packuswb "MM"4, "MM"4              \n\t"
+        "packsswb "MM"4, "MM"4              \n\t"
 #endif
         "movd "MM"4, %0                     \n\t" // *overflow
         : "=g" (*overflow)
diff --git a/mythtv/external/FFmpeg/libavfilter/filtfmts.c b/mythtv/external/FFmpeg/libavfilter/filtfmts.c
index 7286729..789d10d 100644
--- a/mythtv/external/FFmpeg/libavfilter/filtfmts.c
+++ b/mythtv/external/FFmpeg/libavfilter/filtfmts.c
@@ -38,7 +38,7 @@ static void print_formats(AVFilterContext *filter_ctx)
             for (j = 0; j < fmts->format_count; j++)                    \
                 if(av_get_pix_fmt_name(fmts->formats[j]))               \
                 printf(#INOUT "PUT[%d] %s: fmt:%s\n",                   \
-                       i, filter_ctx->filter->inout##puts[i].name,      \
+                       i, filter_ctx->inout##put_pads[i].name,      \
                        av_get_pix_fmt_name(fmts->formats[j]));          \
         } else if (filter_ctx->inout##puts[i]->type == AVMEDIA_TYPE_AUDIO) { \
             AVFilterFormats *fmts;                                      \
@@ -47,7 +47,7 @@ static void print_formats(AVFilterContext *filter_ctx)
             fmts = filter_ctx->inout##puts[i]->outin##_formats;         \
             for (j = 0; j < fmts->format_count; j++)                    \
                 printf(#INOUT "PUT[%d] %s: fmt:%s\n",                   \
-                       i, filter_ctx->filter->inout##puts[i].name,      \
+                       i, filter_ctx->inout##put_pads[i].name,      \
                        av_get_sample_fmt_name(fmts->formats[j]));       \
                                                                         \
             layouts = filter_ctx->inout##puts[i]->outin##_channel_layouts; \
@@ -56,7 +56,7 @@ static void print_formats(AVFilterContext *filter_ctx)
                 av_get_channel_layout_string(buf, sizeof(buf), -1,      \
                                              layouts->channel_layouts[j]);         \
                 printf(#INOUT "PUT[%d] %s: chlayout:%s\n",              \
-                       i, filter_ctx->filter->inout##puts[i].name, buf); \
+                       i, filter_ctx->inout##put_pads[i].name, buf); \
             }                                                           \
         }                                                               \
     }                                                                   \
@@ -106,12 +106,12 @@ int main(int argc, char **argv)
     /* create a link for each of the input pads */
     for (i = 0; i < filter_ctx->input_count; i++) {
         AVFilterLink *link = av_mallocz(sizeof(AVFilterLink));
-        link->type = filter_ctx->filter->inputs[i].type;
+        link->type = filter_ctx->input_pads[i].type;
         filter_ctx->inputs[i] = link;
     }
     for (i = 0; i < filter_ctx->output_count; i++) {
         AVFilterLink *link = av_mallocz(sizeof(AVFilterLink));
-        link->type = filter_ctx->filter->outputs[i].type;
+        link->type = filter_ctx->output_pads[i].type;
         filter_ctx->outputs[i] = link;
     }
 
diff --git a/mythtv/external/FFmpeg/libavfilter/graphdump.c b/mythtv/external/FFmpeg/libavfilter/graphdump.c
index 45f64c0..478afc6 100644
--- a/mythtv/external/FFmpeg/libavfilter/graphdump.c
+++ b/mythtv/external/FFmpeg/libavfilter/graphdump.c
@@ -31,9 +31,10 @@ static int print_link_prop(AVBPrint *buf, AVFilterLink *link)
 {
     char *format;
     char layout[64];
+    AVBPrint dummy_buffer = { 0 };
 
     if (!buf)
-        buf = &(AVBPrint){ 0 }; /* dummy buffer */
+        buf = &dummy_buffer;
     switch (link->type) {
         case AVMEDIA_TYPE_VIDEO:
             format = av_x_if_null(av_get_pix_fmt_name(link->format), "?");
diff --git a/mythtv/external/FFmpeg/libavfilter/vf_deshake.c b/mythtv/external/FFmpeg/libavfilter/vf_deshake.c
index 26f92f4..f9e42ac 100644
--- a/mythtv/external/FFmpeg/libavfilter/vf_deshake.c
+++ b/mythtv/external/FFmpeg/libavfilter/vf_deshake.c
@@ -346,8 +346,8 @@ static void find_motion(DeshakeContext *deshake, uint8_t *src1, uint8_t *src2,
         //av_log(NULL, AV_LOG_ERROR, "\n");
     }
 
-    p_x = (center_x - width / 2);
-    p_y = (center_y - height / 2);
+    p_x = (center_x - width / 2.0);
+    p_y = (center_y - height / 2.0);
     t->vector.x += (cos(t->angle)-1)*p_x  - sin(t->angle)*p_y;
     t->vector.y += sin(t->angle)*p_x  + (cos(t->angle)-1)*p_y;
 
diff --git a/mythtv/external/FFmpeg/libavformat/aiffdec.c b/mythtv/external/FFmpeg/libavformat/aiffdec.c
index 396abb1..4a26298 100644
--- a/mythtv/external/FFmpeg/libavformat/aiffdec.c
+++ b/mythtv/external/FFmpeg/libavformat/aiffdec.c
@@ -237,7 +237,7 @@ static int aiff_read_header(AVFormatContext *s)
             break;
         case MKTAG('I', 'D', '3', ' '):
             position = avio_tell(pb);
-            ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta, size);
+            ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta);
             if (id3v2_extra_meta)
                 if ((ret = ff_id3v2_parse_apic(s, &id3v2_extra_meta)) < 0) {
                     ff_id3v2_free_extra_meta(&id3v2_extra_meta);
diff --git a/mythtv/external/FFmpeg/libavformat/asfdec.c b/mythtv/external/FFmpeg/libavformat/asfdec.c
index 74201cf..7c7105a 100644
--- a/mythtv/external/FFmpeg/libavformat/asfdec.c
+++ b/mythtv/external/FFmpeg/libavformat/asfdec.c
@@ -268,7 +268,7 @@ static void get_id3_tag(AVFormatContext *s, int len)
 {
     ID3v2ExtraMeta *id3v2_extra_meta = NULL;
 
-    ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta, len);
+    ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta);
     if (id3v2_extra_meta)
         ff_id3v2_parse_apic(s, &id3v2_extra_meta);
     ff_id3v2_free_extra_meta(&id3v2_extra_meta);
@@ -378,7 +378,8 @@ static int asf_read_stream_properties(AVFormatContext *s, int64_t size)
 
     if (!(asf->hdr.flags & 0x01)) { // if we aren't streaming...
         int64_t fsize = avio_size(pb);
-        if (fsize <= 0 || (int64_t)asf->hdr.file_size <= 0 || FFABS(fsize - (int64_t)asf->hdr.file_size) < 10000)
+        if (fsize <= 0 || (int64_t)asf->hdr.file_size <= 0 ||
+            FFABS(fsize - (int64_t)asf->hdr.file_size) / (float)FFMIN(fsize, asf->hdr.file_size) < 0.05)
             st->duration = asf->hdr.play_time /
                        (10000000 / 1000) - start_time;
     }
diff --git a/mythtv/external/FFmpeg/libavformat/avidec.c b/mythtv/external/FFmpeg/libavformat/avidec.c
index f568a28..a2cfeb9 100644
--- a/mythtv/external/FFmpeg/libavformat/avidec.c
+++ b/mythtv/external/FFmpeg/libavformat/avidec.c
@@ -1529,7 +1529,7 @@ static int avi_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp
             continue;
 
 //        av_assert1(st2->codec->block_align);
-        av_assert0((int64_t)st2->time_base.num*ast2->rate == (int64_t)st2->time_base.den*ast2->scale);
+        av_assert0(fabs(av_q2d(st2->time_base) - ast2->scale / (double)ast2->rate) < av_q2d(st2->time_base) * 0.00000001);
         index = av_index_search_timestamp(
                 st2,
                 av_rescale_q(timestamp, st->time_base, st2->time_base) * FFMAX(ast2->sample_size, 1),
diff --git a/mythtv/external/FFmpeg/libavformat/flvenc.c b/mythtv/external/FFmpeg/libavformat/flvenc.c
index e1dd43f..c5ed800 100644
--- a/mythtv/external/FFmpeg/libavformat/flvenc.c
+++ b/mythtv/external/FFmpeg/libavformat/flvenc.c
@@ -218,6 +218,18 @@ static int flv_write_header(AVFormatContext *s)
                        avcodec_get_name(enc->codec_id), i);
                 return AVERROR(EINVAL);
             }
+            if (enc->codec_id == AV_CODEC_ID_MPEG4 ||
+                enc->codec_id == AV_CODEC_ID_H263) {
+                int error = enc->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL;
+                av_log(s, error ? AV_LOG_ERROR : AV_LOG_WARNING,
+                       "Codec %s is not supported in the official FLV specification,\n", avcodec_get_name(enc->codec_id));
+
+                if (error) {
+                    av_log(s, AV_LOG_ERROR,
+                           "use vstrict=-1 / -strict -1 to use it anyway.\n");
+                    return AVERROR(EINVAL);
+                }
+            }
             break;
         case AVMEDIA_TYPE_AUDIO:
             audio_enc = enc;
diff --git a/mythtv/external/FFmpeg/libavformat/h263dec.c b/mythtv/external/FFmpeg/libavformat/h263dec.c
index 667fdbd..30fd454 100644
--- a/mythtv/external/FFmpeg/libavformat/h263dec.c
+++ b/mythtv/external/FFmpeg/libavformat/h263dec.c
@@ -35,7 +35,7 @@ static int h263_probe(AVProbeData *p)
     for(i=0; i<p->buf_size; i++){
         code = (code<<8) + p->buf[i];
         if ((code & 0xfffffc0000) == 0x800000) {
-            src_fmt= (code>>2)&3;
+            src_fmt= (code>>2)&7;
             if(   src_fmt != last_src_fmt
                && last_src_fmt>0 && last_src_fmt<6
                && src_fmt<6)
diff --git a/mythtv/external/FFmpeg/libavformat/id3v2.c b/mythtv/external/FFmpeg/libavformat/id3v2.c
index 8fdcc8a..2cab5ac 100644
--- a/mythtv/external/FFmpeg/libavformat/id3v2.c
+++ b/mythtv/external/FFmpeg/libavformat/id3v2.c
@@ -777,28 +777,17 @@ seek:
     return;
 }
 
-void ff_id3v2_read(AVFormatContext *s, const char *magic, ID3v2ExtraMeta **extra_meta,
-                   unsigned int max_search_size)
+void ff_id3v2_read(AVFormatContext *s, const char *magic, ID3v2ExtraMeta **extra_meta)
 {
     int len, ret;
     uint8_t buf[ID3v2_HEADER_SIZE];
     int     found_header;
-    int64_t start, off;
+    int64_t off;
 
-    if (max_search_size && max_search_size < ID3v2_HEADER_SIZE)
-        return;
-
-    start = avio_tell(s->pb);
     do {
         /* save the current offset in case there's nothing to read/skip */
         off = avio_tell(s->pb);
         ret = avio_read(s->pb, buf, ID3v2_HEADER_SIZE);
-        if (max_search_size && off - start >= max_search_size - ID3v2_HEADER_SIZE) {
-            avio_seek(s->pb, off, SEEK_SET);
-            break;
-        }
-
-        ret = avio_read(s->pb, buf, ID3v2_HEADER_SIZE);
         if (ret != ID3v2_HEADER_SIZE) {
             avio_seek(s->pb, off, SEEK_SET);
             break;
@@ -833,8 +822,6 @@ void ff_id3v2_free_extra_meta(ID3v2ExtraMeta **extra_meta)
         av_freep(&current);
         current = next;
     }
-
-    *extra_meta = NULL;
 }
 
 int ff_id3v2_parse_apic(AVFormatContext *s, ID3v2ExtraMeta **extra_meta)
diff --git a/mythtv/external/FFmpeg/libavformat/id3v2.h b/mythtv/external/FFmpeg/libavformat/id3v2.h
index 4fe59a5..f727010 100644
--- a/mythtv/external/FFmpeg/libavformat/id3v2.h
+++ b/mythtv/external/FFmpeg/libavformat/id3v2.h
@@ -93,10 +93,8 @@ int ff_id3v2_tag_len(const uint8_t *buf);
  * Read an ID3v2 tag, including supported extra metadata
  * @param extra_meta If not NULL, extra metadata is parsed into a list of
  * ID3v2ExtraMeta structs and *extra_meta points to the head of the list
- * @param[opt] max_search_search restrict ID3 magic number search (bytes from start)
  */
-void ff_id3v2_read(AVFormatContext *s, const char *magic, ID3v2ExtraMeta **extra_meta,
-                   unsigned int max_search_size);
+void ff_id3v2_read(AVFormatContext *s, const char *magic, ID3v2ExtraMeta **extra_meta);
 
 /**
  * Initialize an ID3v2 tag.
diff --git a/mythtv/external/FFmpeg/libavformat/mpc.c b/mythtv/external/FFmpeg/libavformat/mpc.c
index b0f6f53..a46919ba 100644
--- a/mythtv/external/FFmpeg/libavformat/mpc.c
+++ b/mythtv/external/FFmpeg/libavformat/mpc.c
@@ -153,7 +153,7 @@ static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt)
     }
     c->curbits = (curbits + size2) & 0x1F;
 
-    if ((ret = av_new_packet(pkt, size)) < 0)
+    if ((ret = av_new_packet(pkt, size + 4)) < 0)
         return ret;
 
     pkt->data[0] = curbits;
diff --git a/mythtv/external/FFmpeg/libavformat/mpegts.c b/mythtv/external/FFmpeg/libavformat/mpegts.c
index 4cb1af1..0e06d84 100644
--- a/mythtv/external/FFmpeg/libavformat/mpegts.c
+++ b/mythtv/external/FFmpeg/libavformat/mpegts.c
@@ -1265,7 +1265,7 @@ static void m4sl_cb(MpegTSFilter *filter, const uint8_t *section, int section_le
             AVStream *st;
             if (ts->pids[pid]->es_id != mp4_descr[i].es_id)
                 continue;
-            if (!(ts->pids[pid] && ts->pids[pid]->type == MPEGTS_PES)) {
+            if (ts->pids[pid]->type != MPEGTS_PES) {
                 av_log(s, AV_LOG_ERROR, "pid %x is not PES\n", pid);
                 continue;
             }
diff --git a/mythtv/external/FFmpeg/libavformat/mux.c b/mythtv/external/FFmpeg/libavformat/mux.c
index 98ec7a4..14c1262 100644
--- a/mythtv/external/FFmpeg/libavformat/mux.c
+++ b/mythtv/external/FFmpeg/libavformat/mux.c
@@ -410,6 +410,12 @@ static int compute_pkt_fields2(AVFormatContext *s, AVStream *st, AVPacket *pkt)
     av_dlog(s, "compute_pkt_fields2: pts:%s dts:%s cur_dts:%s b:%d size:%d st:%d\n",
             av_ts2str(pkt->pts), av_ts2str(pkt->dts), av_ts2str(st->cur_dts), delay, pkt->size, pkt->stream_index);
 
+    if (pkt->duration < 0 && st->codec->codec_type != AVMEDIA_TYPE_SUBTITLE) {
+        av_log(s, AV_LOG_WARNING, "Packet with invalid duration %d in stream %d\n",
+               pkt->duration, pkt->stream_index);
+        pkt->duration = 0;
+    }
+
     /* duration field */
     if (pkt->duration == 0) {
         ff_compute_frame_duration(&num, &den, st, NULL, pkt);
diff --git a/mythtv/external/FFmpeg/libavformat/omadec.c b/mythtv/external/FFmpeg/libavformat/omadec.c
index 34d63a3..8d29675 100644
--- a/mythtv/external/FFmpeg/libavformat/omadec.c
+++ b/mythtv/external/FFmpeg/libavformat/omadec.c
@@ -275,7 +275,7 @@ static int oma_read_header(AVFormatContext *s)
     ID3v2ExtraMeta *extra_meta = NULL;
     OMAContext *oc = s->priv_data;
 
-    ff_id3v2_read(s, ID3v2_EA3_MAGIC, &extra_meta, 0);
+    ff_id3v2_read(s, ID3v2_EA3_MAGIC, &extra_meta);
     ret = avio_read(s->pb, buf, EA3_HEADER_SIZE);
     if (ret < EA3_HEADER_SIZE)
         return -1;
diff --git a/mythtv/external/FFmpeg/libavformat/utils.c b/mythtv/external/FFmpeg/libavformat/utils.c
index 163c1d6..2851895 100644
--- a/mythtv/external/FFmpeg/libavformat/utils.c
+++ b/mythtv/external/FFmpeg/libavformat/utils.c
@@ -656,7 +656,7 @@ int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputForma
 
     /* e.g. AVFMT_NOFILE formats will not have a AVIOContext */
     if (s->pb)
-        ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta, 0);
+        ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta);
 
     if (!(s->flags&AVFMT_FLAG_PRIV_OPT) && s->iformat->read_header)
         if ((ret = s->iformat->read_header(s)) < 0)
diff --git a/mythtv/external/FFmpeg/libavutil/cpu.c b/mythtv/external/FFmpeg/libavutil/cpu.c
index a1d1547..85bc2d6 100644
--- a/mythtv/external/FFmpeg/libavutil/cpu.c
+++ b/mythtv/external/FFmpeg/libavutil/cpu.c
@@ -23,6 +23,24 @@
 static int flags, checked;
 
 void av_force_cpu_flags(int arg){
+    if (   (arg & ( AV_CPU_FLAG_3DNOW    |
+                    AV_CPU_FLAG_3DNOWEXT |
+                    AV_CPU_FLAG_SSE      |
+                    AV_CPU_FLAG_SSE2     |
+                    AV_CPU_FLAG_SSE2SLOW |
+                    AV_CPU_FLAG_SSE3     |
+                    AV_CPU_FLAG_SSE3SLOW |
+                    AV_CPU_FLAG_SSSE3    |
+                    AV_CPU_FLAG_SSE4     |
+                    AV_CPU_FLAG_SSE42    |
+                    AV_CPU_FLAG_AVX      |
+                    AV_CPU_FLAG_XOP      |
+                    AV_CPU_FLAG_FMA4     ))
+        && !(arg & AV_CPU_FLAG_MMX)) {
+        av_log(NULL, AV_LOG_WARNING, "MMX implied by specified flags\n");
+        arg |= AV_CPU_FLAG_MMX;
+    }
+
     flags   = arg;
     checked = arg != -1;
 }
diff --git a/mythtv/external/FFmpeg/libavutil/lzo.c b/mythtv/external/FFmpeg/libavutil/lzo.c
index c723257..6104fc3 100644
--- a/mythtv/external/FFmpeg/libavutil/lzo.c
+++ b/mythtv/external/FFmpeg/libavutil/lzo.c
@@ -22,6 +22,7 @@
 #include <string.h>
 
 #include "avutil.h"
+#include "avassert.h"
 #include "common.h"
 #include "intreadwrite.h"
 #include "lzo.h"
@@ -65,8 +66,13 @@ static inline int get_len(LZOContext *c, int x, int mask)
 {
     int cnt = x & mask;
     if (!cnt) {
-        while (!(x = get_byte(c)))
+        while (!(x = get_byte(c))) {
+            if (cnt >= INT_MAX - 1000) {
+                c->error |= AV_LZO_ERROR;
+                break;
+            }
             cnt += 255;
+        }
         cnt += mask + x;
     }
     return cnt;
@@ -80,6 +86,7 @@ static inline void copy(LZOContext *c, int cnt)
 {
     register const uint8_t *src = c->in;
     register uint8_t *dst       = c->out;
+    av_assert0(cnt >= 0);
     if (cnt > c->in_end - src) {
         cnt       = FFMAX(c->in_end - src, 0);
         c->error |= AV_LZO_INPUT_DEPLETED;
@@ -110,9 +117,9 @@ static inline void copy(LZOContext *c, int cnt)
  */
 static inline void copy_backptr(LZOContext *c, int back, int cnt)
 {
-    register const uint8_t *src = &c->out[-back];
     register uint8_t *dst       = c->out;
-    if (src < c->out_start || src > dst) {
+    av_assert0(cnt > 0);
+    if (dst - c->out_start < back) {
         c->error |= AV_LZO_INVALID_BACKPTR;
         return;
     }
diff --git a/mythtv/external/FFmpeg/libavutil/opt.c b/mythtv/external/FFmpeg/libavutil/opt.c
index eeb72fd..4100d02 100644
--- a/mythtv/external/FFmpeg/libavutil/opt.c
+++ b/mythtv/external/FFmpeg/libavutil/opt.c
@@ -1291,8 +1291,10 @@ void av_opt_freep_ranges(AVOptionRanges **rangesp)
 
     for (i = 0; i < ranges->nb_ranges; i++) {
         AVOptionRange *range = ranges->range[i];
-        av_freep(&range->str);
-        av_freep(&ranges->range[i]);
+        if (range) {
+            av_freep(&range->str);
+            av_freep(&ranges->range[i]);
+        }
     }
     av_freep(&ranges->range);
     av_freep(rangesp);
diff --git a/mythtv/external/FFmpeg/libswresample/dither.c b/mythtv/external/FFmpeg/libswresample/dither.c
index d0193dd..ce8581c 100644
--- a/mythtv/external/FFmpeg/libswresample/dither.c
+++ b/mythtv/external/FFmpeg/libswresample/dither.c
@@ -26,7 +26,7 @@
 void swri_get_dither(SwrContext *s, void *dst, int len, unsigned seed, enum AVSampleFormat noise_fmt) {
     double scale = s->dither.noise_scale;
 #define TMP_EXTRA 2
-    double *tmp = av_malloc((len + TMP_EXTRA) * sizeof(double));
+    double *tmp = av_malloc_array(len + TMP_EXTRA, sizeof(double));
     int i;
 
     for(i=0; i<len + TMP_EXTRA; i++){
diff --git a/mythtv/external/FFmpeg/libswresample/rematrix.c b/mythtv/external/FFmpeg/libswresample/rematrix.c
index 541f46a..392eec8 100644
--- a/mythtv/external/FFmpeg/libswresample/rematrix.c
+++ b/mythtv/external/FFmpeg/libswresample/rematrix.c
@@ -122,6 +122,11 @@ av_cold static int auto_matrix(SwrContext *s)
     )
         out_ch_layout = AV_CH_LAYOUT_STEREO;
 
+    if(    in_ch_layout == AV_CH_LAYOUT_STEREO_DOWNMIX
+       && (out_ch_layout & AV_CH_LAYOUT_STEREO_DOWNMIX) == 0
+    )
+        in_ch_layout = AV_CH_LAYOUT_STEREO;
+
     if(!sane_layout(in_ch_layout)){
         av_get_channel_layout_string(buf, sizeof(buf), -1, s->in_ch_layout);
         av_log(s, AV_LOG_ERROR, "Input channel layout '%s' is not supported\n", buf);
diff --git a/mythtv/external/FFmpeg/libswresample/resample.c b/mythtv/external/FFmpeg/libswresample/resample.c
index fb9da7c..93c86aa 100644
--- a/mythtv/external/FFmpeg/libswresample/resample.c
+++ b/mythtv/external/FFmpeg/libswresample/resample.c
@@ -95,7 +95,7 @@ static int build_filter(ResampleContext *c, void *filter, double factor, int tap
                         int filter_type, int kaiser_beta){
     int ph, i;
     double x, y, w;
-    double *tab = av_malloc(tap_count * sizeof(*tab));
+    double *tab = av_malloc_array(tap_count,  sizeof(*tab));
     const int center= (tap_count-1)/2;
 
     if (!tab)
@@ -229,6 +229,11 @@ static ResampleContext *resample_init(ResampleContext *c, int out_rate, int in_r
             av_assert0(0);
         }
 
+        if (filter_size/factor > INT32_MAX/256) {
+            av_log(NULL, AV_LOG_ERROR, "Filter length too large\n");
+            goto error;
+        }
+
         c->phase_shift   = phase_shift;
         c->phase_mask    = phase_count - 1;
         c->linear        = linear;
diff --git a/mythtv/external/FFmpeg/libswscale/swscale.c b/mythtv/external/FFmpeg/libswscale/swscale.c
index bb90819..5d81a95 100644
--- a/mythtv/external/FFmpeg/libswscale/swscale.c
+++ b/mythtv/external/FFmpeg/libswscale/swscale.c
@@ -208,8 +208,9 @@ static void lumRangeToJpeg16_c(int16_t *_dst, int width)
 {
     int i;
     int32_t *dst = (int32_t *) _dst;
-    for (i = 0; i < width; i++)
-        dst[i] = (FFMIN(dst[i], 30189 << 4) * 4769 - (39057361 << 2)) >> 12;
+    for (i = 0; i < width; i++) {
+        dst[i] = ((int)(FFMIN(dst[i], 30189 << 4) * 4769U - (39057361 << 2))) >> 12;
+    }
 }
 
 static void lumRangeFromJpeg16_c(int16_t *_dst, int width)
@@ -802,7 +803,7 @@ int attribute_align_arg sws_scale(struct SwsContext *c,
     uint8_t *dst2[4];
     uint8_t *rgb0_tmp = NULL;
 
-    if (!srcSlice || !dstStride || !dst || !srcSlice) {
+    if (!srcStride || !dstStride || !dst || !srcSlice) {
         av_log(c, AV_LOG_ERROR, "One of the input parameters to sws_scale() is NULL, please check the calling code\n");
         return 0;
     }
diff --git a/mythtv/external/FFmpeg/libswscale/x86/swscale_template.c b/mythtv/external/FFmpeg/libswscale/x86/swscale_template.c
index f2567c1..98a3dc8 100644
--- a/mythtv/external/FFmpeg/libswscale/x86/swscale_template.c
+++ b/mythtv/external/FFmpeg/libswscale/x86/swscale_template.c
@@ -332,7 +332,7 @@ static void RENAME(yuv2yuvX)(const int16_t *filter, int filterSize,
     MOVNTQ(   q3, 24(dst, index, 4))\
 \
     "add      $8, "#index"      \n\t"\
-    "cmp "#dstw", "#index"      \n\t"\
+    "cmp  "dstw", "#index"      \n\t"\
     " jb      1b                \n\t"
 #define WRITEBGR32(dst, dstw, index, b, g, r, a, q0, q2, q3, t)  REAL_WRITEBGR32(dst, dstw, index, b, g, r, a, q0, q2, q3, t)
 
@@ -358,13 +358,13 @@ static void RENAME(yuv2rgb32_X_ar)(SwsContext *c, const int16_t *lumFilter,
         "psraw                        $3, %%mm1         \n\t"
         "psraw                        $3, %%mm7         \n\t"
         "packuswb                  %%mm7, %%mm1         \n\t"
-        WRITEBGR32(%4, %5, %%REGa, %%mm3, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm2, %%mm6)
+        WRITEBGR32(%4, "%5", %%REGa, %%mm3, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm2, %%mm6)
         YSCALEYUV2PACKEDX_END
     } else {
         YSCALEYUV2PACKEDX_ACCURATE
         YSCALEYUV2RGBX
         "pcmpeqd %%mm7, %%mm7 \n\t"
-        WRITEBGR32(%4, %5, %%REGa, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
+        WRITEBGR32(%4, "%5", %%REGa, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
         YSCALEYUV2PACKEDX_END
     }
 }
@@ -387,13 +387,13 @@ static void RENAME(yuv2rgb32_X)(SwsContext *c, const int16_t *lumFilter,
         "psraw                        $3, %%mm1         \n\t"
         "psraw                        $3, %%mm7         \n\t"
         "packuswb                  %%mm7, %%mm1         \n\t"
-        WRITEBGR32(%4, %5, %%REGa, %%mm2, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm3, %%mm6)
+        WRITEBGR32(%4, "%5", %%REGa, %%mm2, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm3, %%mm6)
         YSCALEYUV2PACKEDX_END
     } else {
         YSCALEYUV2PACKEDX
         YSCALEYUV2RGBX
         "pcmpeqd %%mm7, %%mm7 \n\t"
-        WRITEBGR32(%4, %5, %%REGa, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
+        WRITEBGR32(%4, "%5", %%REGa, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
         YSCALEYUV2PACKEDX_END
     }
 }
@@ -422,7 +422,7 @@ static void RENAME(yuv2rgb32_X)(SwsContext *c, const int16_t *lumFilter,
     MOVNTQ(%%mm1, 8(dst, index, 2))\
 \
     "add             $8, "#index"   \n\t"\
-    "cmp        "#dstw", "#index"   \n\t"\
+    "cmp         "dstw", "#index"   \n\t"\
     " jb             1b             \n\t"
 #define WRITERGB16(dst, dstw, index)  REAL_WRITERGB16(dst, dstw, index)
 
@@ -446,7 +446,7 @@ static void RENAME(yuv2rgb565_X_ar)(SwsContext *c, const int16_t *lumFilter,
     "paddusb "GREEN_DITHER"(%0), %%mm4\n\t"
     "paddusb "RED_DITHER"(%0), %%mm5\n\t"
 #endif
-    WRITERGB16(%4, %5, %%REGa)
+    WRITERGB16(%4, "%5", %%REGa)
     YSCALEYUV2PACKEDX_END
 }
 
@@ -470,7 +470,7 @@ static void RENAME(yuv2rgb565_X)(SwsContext *c, const int16_t *lumFilter,
     "paddusb "GREEN_DITHER"(%0), %%mm4  \n\t"
     "paddusb "RED_DITHER"(%0), %%mm5  \n\t"
 #endif
-    WRITERGB16(%4, %5, %%REGa)
+    WRITERGB16(%4, "%5", %%REGa)
     YSCALEYUV2PACKEDX_END
 }
 
@@ -499,7 +499,7 @@ static void RENAME(yuv2rgb565_X)(SwsContext *c, const int16_t *lumFilter,
     MOVNTQ(%%mm1, 8(dst, index, 2))\
 \
     "add             $8, "#index"   \n\t"\
-    "cmp        "#dstw", "#index"   \n\t"\
+    "cmp         "dstw", "#index"   \n\t"\
     " jb             1b             \n\t"
 #define WRITERGB15(dst, dstw, index)  REAL_WRITERGB15(dst, dstw, index)
 
@@ -523,7 +523,7 @@ static void RENAME(yuv2rgb555_X_ar)(SwsContext *c, const int16_t *lumFilter,
     "paddusb "GREEN_DITHER"(%0), %%mm4\n\t"
     "paddusb "RED_DITHER"(%0), %%mm5\n\t"
 #endif
-    WRITERGB15(%4, %5, %%REGa)
+    WRITERGB15(%4, "%5", %%REGa)
     YSCALEYUV2PACKEDX_END
 }
 
@@ -547,7 +547,7 @@ static void RENAME(yuv2rgb555_X)(SwsContext *c, const int16_t *lumFilter,
     "paddusb "GREEN_DITHER"(%0), %%mm4  \n\t"
     "paddusb "RED_DITHER"(%0), %%mm5  \n\t"
 #endif
-    WRITERGB15(%4, %5, %%REGa)
+    WRITERGB15(%4, "%5", %%REGa)
     YSCALEYUV2PACKEDX_END
 }
 
@@ -601,7 +601,7 @@ static void RENAME(yuv2rgb555_X)(SwsContext *c, const int16_t *lumFilter,
     "add         $24, "#dst"    \n\t"\
 \
     "add          $8, "#index"  \n\t"\
-    "cmp     "#dstw", "#index"  \n\t"\
+    "cmp      "dstw", "#index"  \n\t"\
     " jb          1b            \n\t"
 
 #define WRITEBGR24MMXEXT(dst, dstw, index) \
@@ -649,7 +649,7 @@ static void RENAME(yuv2rgb555_X)(SwsContext *c, const int16_t *lumFilter,
     "add      $24, "#dst"       \n\t"\
 \
     "add       $8, "#index"     \n\t"\
-    "cmp  "#dstw", "#index"     \n\t"\
+    "cmp   "dstw", "#index"     \n\t"\
     " jb       1b               \n\t"
 
 #if COMPILE_TEMPLATE_MMXEXT
@@ -676,7 +676,7 @@ static void RENAME(yuv2bgr24_X_ar)(SwsContext *c, const int16_t *lumFilter,
     "pxor %%mm7, %%mm7 \n\t"
     "lea (%%"REG_a", %%"REG_a", 2), %%"REG_c"\n\t" //FIXME optimize
     "add %4, %%"REG_c"                        \n\t"
-    WRITEBGR24(%%REGc, %5, %%REGa)
+    WRITEBGR24(%%REGc, "%5", %%REGa)
     :: "r" (&c->redDither),
        "m" (dummy), "m" (dummy), "m" (dummy),
        "r" (dest), "m" (dstW_reg), "m"(uv_off)
@@ -700,7 +700,7 @@ static void RENAME(yuv2bgr24_X)(SwsContext *c, const int16_t *lumFilter,
     "pxor                    %%mm7, %%mm7       \n\t"
     "lea (%%"REG_a", %%"REG_a", 2), %%"REG_c"   \n\t" //FIXME optimize
     "add                        %4, %%"REG_c"   \n\t"
-    WRITEBGR24(%%REGc, %5, %%REGa)
+    WRITEBGR24(%%REGc, "%5", %%REGa)
     :: "r" (&c->redDither),
        "m" (dummy), "m" (dummy), "m" (dummy),
        "r" (dest),  "m" (dstW_reg), "m"(uv_off)
@@ -721,7 +721,7 @@ static void RENAME(yuv2bgr24_X)(SwsContext *c, const int16_t *lumFilter,
     MOVNTQ(%%mm7, 8(dst, index, 2))\
 \
     "add          $8, "#index"  \n\t"\
-    "cmp     "#dstw", "#index"  \n\t"\
+    "cmp      "dstw", "#index"  \n\t"\
     " jb          1b            \n\t"
 #define WRITEYUY2(dst, dstw, index)  REAL_WRITEYUY2(dst, dstw, index)
 
@@ -742,7 +742,7 @@ static void RENAME(yuv2yuyv422_X_ar)(SwsContext *c, const int16_t *lumFilter,
     "psraw $3, %%mm4    \n\t"
     "psraw $3, %%mm1    \n\t"
     "psraw $3, %%mm7    \n\t"
-    WRITEYUY2(%4, %5, %%REGa)
+    WRITEYUY2(%4, "%5", %%REGa)
     YSCALEYUV2PACKEDX_END
 }
 
@@ -763,7 +763,7 @@ static void RENAME(yuv2yuyv422_X)(SwsContext *c, const int16_t *lumFilter,
     "psraw $3, %%mm4    \n\t"
     "psraw $3, %%mm1    \n\t"
     "psraw $3, %%mm7    \n\t"
-    WRITEYUY2(%4, %5, %%REGa)
+    WRITEYUY2(%4, "%5", %%REGa)
     YSCALEYUV2PACKEDX_END
 }
 
@@ -864,7 +864,7 @@ static void RENAME(yuv2rgb32_2)(SwsContext *c, const int16_t *buf[2],
             "psraw                  $3, %%mm1       \n\t" /* abuf0[eax] - abuf1[eax] >>7*/
             "psraw                  $3, %%mm7       \n\t" /* abuf0[eax] - abuf1[eax] >>7*/
             "packuswb            %%mm7, %%mm1       \n\t"
-            WRITEBGR32(%4, 8280(%5), %%r8, %%mm2, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm3, %%mm6)
+            WRITEBGR32(%4, DSTW_OFFSET"(%5)", %%r8, %%mm2, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm3, %%mm6)
             :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "r" (dest),
                "a" (&c->redDither),
                "r" (abuf0), "r" (abuf1)
@@ -888,7 +888,7 @@ static void RENAME(yuv2rgb32_2)(SwsContext *c, const int16_t *buf[2],
             "packuswb            %%mm7, %%mm1       \n\t"
             "pop                    %1              \n\t"
             "pop                    %0              \n\t"
-            WRITEBGR32(%%REGb, 8280(%5), %%REGBP, %%mm2, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm3, %%mm6)
+            WRITEBGR32(%%REGb, DSTW_OFFSET"(%5)", %%REGBP, %%mm2, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm3, %%mm6)
             "pop %%"REG_BP"                         \n\t"
             "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
             :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -902,7 +902,7 @@ static void RENAME(yuv2rgb32_2)(SwsContext *c, const int16_t *buf[2],
             "push %%"REG_BP"                        \n\t"
             YSCALEYUV2RGB(%%REGBP, %5)
             "pcmpeqd %%mm7, %%mm7                   \n\t"
-            WRITEBGR32(%%REGb, 8280(%5), %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
+            WRITEBGR32(%%REGb, DSTW_OFFSET"(%5)", %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
             "pop %%"REG_BP"                         \n\t"
             "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
             :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -919,14 +919,13 @@ static void RENAME(yuv2bgr24_2)(SwsContext *c, const int16_t *buf[2],
     const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                   *ubuf0 = ubuf[0], *ubuf1 = ubuf[1];
 
-    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(
     __asm__ volatile(
         "mov %%"REG_b", "ESP_OFFSET"(%5)        \n\t"
         "mov        %4, %%"REG_b"               \n\t"
         "push %%"REG_BP"                        \n\t"
         YSCALEYUV2RGB(%%REGBP, %5)
         "pxor    %%mm7, %%mm7                   \n\t"
-        WRITEBGR24(%%REGb, 8280(%5), %%REGBP)
+        WRITEBGR24(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
         "pop %%"REG_BP"                         \n\t"
         "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
         :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -942,7 +941,6 @@ static void RENAME(yuv2rgb555_2)(SwsContext *c, const int16_t *buf[2],
     const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                   *ubuf0 = ubuf[0], *ubuf1 = ubuf[1];
 
-    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(
     __asm__ volatile(
         "mov %%"REG_b", "ESP_OFFSET"(%5)        \n\t"
         "mov        %4, %%"REG_b"               \n\t"
@@ -955,7 +953,7 @@ static void RENAME(yuv2rgb555_2)(SwsContext *c, const int16_t *buf[2],
         "paddusb "GREEN_DITHER"(%5), %%mm4      \n\t"
         "paddusb "RED_DITHER"(%5), %%mm5      \n\t"
 #endif
-        WRITERGB15(%%REGb, 8280(%5), %%REGBP)
+        WRITERGB15(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
         "pop %%"REG_BP"                         \n\t"
         "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
         :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -971,7 +969,6 @@ static void RENAME(yuv2rgb565_2)(SwsContext *c, const int16_t *buf[2],
     const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                   *ubuf0 = ubuf[0], *ubuf1 = ubuf[1];
 
-    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(
     __asm__ volatile(
         "mov %%"REG_b", "ESP_OFFSET"(%5)        \n\t"
         "mov        %4, %%"REG_b"               \n\t"
@@ -984,7 +981,7 @@ static void RENAME(yuv2rgb565_2)(SwsContext *c, const int16_t *buf[2],
         "paddusb "GREEN_DITHER"(%5), %%mm4      \n\t"
         "paddusb "RED_DITHER"(%5), %%mm5      \n\t"
 #endif
-        WRITERGB16(%%REGb, 8280(%5), %%REGBP)
+        WRITERGB16(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
         "pop %%"REG_BP"                         \n\t"
         "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
         :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1040,13 +1037,12 @@ static void RENAME(yuv2yuyv422_2)(SwsContext *c, const int16_t *buf[2],
     const int16_t *buf0  = buf[0],  *buf1  = buf[1],
                   *ubuf0 = ubuf[0], *ubuf1 = ubuf[1];
 
-    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(
     __asm__ volatile(
         "mov %%"REG_b", "ESP_OFFSET"(%5)        \n\t"
         "mov %4, %%"REG_b"                        \n\t"
         "push %%"REG_BP"                        \n\t"
         YSCALEYUV2PACKED(%%REGBP, %5)
-        WRITEYUY2(%%REGb, 8280(%5), %%REGBP)
+        WRITEYUY2(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
         "pop %%"REG_BP"                         \n\t"
         "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
         :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1189,7 +1185,7 @@ static void RENAME(yuv2rgb32_1)(SwsContext *c, const int16_t *buf0,
                 "push %%"REG_BP"                        \n\t"
                 YSCALEYUV2RGB1(%%REGBP, %5)
                 YSCALEYUV2RGB1_ALPHA(%%REGBP)
-                WRITEBGR32(%%REGb, 8280(%5), %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
+                WRITEBGR32(%%REGb, DSTW_OFFSET"(%5)", %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
                 "pop %%"REG_BP"                         \n\t"
                 "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
                 :: "c" (buf0), "d" (abuf0), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1202,7 +1198,7 @@ static void RENAME(yuv2rgb32_1)(SwsContext *c, const int16_t *buf0,
                 "push %%"REG_BP"                        \n\t"
                 YSCALEYUV2RGB1(%%REGBP, %5)
                 "pcmpeqd %%mm7, %%mm7                   \n\t"
-                WRITEBGR32(%%REGb, 8280(%5), %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
+                WRITEBGR32(%%REGb, DSTW_OFFSET"(%5)", %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
                 "pop %%"REG_BP"                         \n\t"
                 "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
                 :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1218,7 +1214,7 @@ static void RENAME(yuv2rgb32_1)(SwsContext *c, const int16_t *buf0,
                 "push %%"REG_BP"                        \n\t"
                 YSCALEYUV2RGB1b(%%REGBP, %5)
                 YSCALEYUV2RGB1_ALPHA(%%REGBP)
-                WRITEBGR32(%%REGb, 8280(%5), %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
+                WRITEBGR32(%%REGb, DSTW_OFFSET"(%5)", %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
                 "pop %%"REG_BP"                         \n\t"
                 "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
                 :: "c" (buf0), "d" (abuf0), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1231,7 +1227,7 @@ static void RENAME(yuv2rgb32_1)(SwsContext *c, const int16_t *buf0,
                 "push %%"REG_BP"                        \n\t"
                 YSCALEYUV2RGB1b(%%REGBP, %5)
                 "pcmpeqd %%mm7, %%mm7                   \n\t"
-                WRITEBGR32(%%REGb, 8280(%5), %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
+                WRITEBGR32(%%REGb, DSTW_OFFSET"(%5)", %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6)
                 "pop %%"REG_BP"                         \n\t"
                 "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
                 :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1257,7 +1253,7 @@ static void RENAME(yuv2bgr24_1)(SwsContext *c, const int16_t *buf0,
             "push %%"REG_BP"                        \n\t"
             YSCALEYUV2RGB1(%%REGBP, %5)
             "pxor    %%mm7, %%mm7                   \n\t"
-            WRITEBGR24(%%REGb, 8280(%5), %%REGBP)
+            WRITEBGR24(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
             "pop %%"REG_BP"                         \n\t"
             "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
             :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1271,7 +1267,7 @@ static void RENAME(yuv2bgr24_1)(SwsContext *c, const int16_t *buf0,
             "push %%"REG_BP"                        \n\t"
             YSCALEYUV2RGB1b(%%REGBP, %5)
             "pxor    %%mm7, %%mm7                   \n\t"
-            WRITEBGR24(%%REGb, 8280(%5), %%REGBP)
+            WRITEBGR24(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
             "pop %%"REG_BP"                         \n\t"
             "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
             :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1302,7 +1298,7 @@ static void RENAME(yuv2rgb555_1)(SwsContext *c, const int16_t *buf0,
             "paddusb "GREEN_DITHER"(%5), %%mm4      \n\t"
             "paddusb "RED_DITHER"(%5), %%mm5      \n\t"
 #endif
-            WRITERGB15(%%REGb, 8280(%5), %%REGBP)
+            WRITERGB15(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
             "pop %%"REG_BP"                         \n\t"
             "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
             :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1322,7 +1318,7 @@ static void RENAME(yuv2rgb555_1)(SwsContext *c, const int16_t *buf0,
             "paddusb "GREEN_DITHER"(%5), %%mm4      \n\t"
             "paddusb "RED_DITHER"(%5), %%mm5      \n\t"
 #endif
-            WRITERGB15(%%REGb, 8280(%5), %%REGBP)
+            WRITERGB15(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
             "pop %%"REG_BP"                         \n\t"
             "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
             :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1353,7 +1349,7 @@ static void RENAME(yuv2rgb565_1)(SwsContext *c, const int16_t *buf0,
             "paddusb "GREEN_DITHER"(%5), %%mm4      \n\t"
             "paddusb "RED_DITHER"(%5), %%mm5      \n\t"
 #endif
-            WRITERGB16(%%REGb, 8280(%5), %%REGBP)
+            WRITERGB16(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
             "pop %%"REG_BP"                         \n\t"
             "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
             :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1373,7 +1369,7 @@ static void RENAME(yuv2rgb565_1)(SwsContext *c, const int16_t *buf0,
             "paddusb "GREEN_DITHER"(%5), %%mm4      \n\t"
             "paddusb "RED_DITHER"(%5), %%mm5      \n\t"
 #endif
-            WRITERGB16(%%REGb, 8280(%5), %%REGBP)
+            WRITERGB16(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
             "pop %%"REG_BP"                         \n\t"
             "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
             :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1434,7 +1430,7 @@ static void RENAME(yuv2yuyv422_1)(SwsContext *c, const int16_t *buf0,
             "mov        %4, %%"REG_b"               \n\t"
             "push %%"REG_BP"                        \n\t"
             YSCALEYUV2PACKED1(%%REGBP, %5)
-            WRITEYUY2(%%REGb, 8280(%5), %%REGBP)
+            WRITEYUY2(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
             "pop %%"REG_BP"                         \n\t"
             "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
             :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
@@ -1447,7 +1443,7 @@ static void RENAME(yuv2yuyv422_1)(SwsContext *c, const int16_t *buf0,
             "mov        %4, %%"REG_b"               \n\t"
             "push %%"REG_BP"                        \n\t"
             YSCALEYUV2PACKED1b(%%REGBP, %5)
-            WRITEYUY2(%%REGb, 8280(%5), %%REGBP)
+            WRITEYUY2(%%REGb, DSTW_OFFSET"(%5)", %%REGBP)
             "pop %%"REG_BP"                         \n\t"
             "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"
             :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),
diff --git a/mythtv/external/FFmpeg/tests/ref/fate/vc1_sa10143 b/mythtv/external/FFmpeg/tests/ref/fate/vc1_sa10143
index 6a5137f..c0ecc3b 100644
--- a/mythtv/external/FFmpeg/tests/ref/fate/vc1_sa10143
+++ b/mythtv/external/FFmpeg/tests/ref/fate/vc1_sa10143
@@ -1,31 +1,31 @@
 #tb 0: 1/25
 0,          0,          0,        1,   518400, 0x89407f55
-0,          2,          2,        1,   518400, 0x8611849c
+0,          2,          2,        1,   518400, 0xaa896afd
 0,          3,          3,        1,   518400, 0x0e69ff59
-0,          4,          4,        1,   518400, 0xf31adb03
+0,          4,          4,        1,   518400, 0x0c30bfa0
 0,          5,          5,        1,   518400, 0x1a5b6a69
-0,          6,          6,        1,   518400, 0x6ae6232e
+0,          6,          6,        1,   518400, 0x23470858
 0,          7,          7,        1,   518400, 0x9a4e3c54
-0,          8,          8,        1,   518400, 0xe5852b45
+0,          8,          8,        1,   518400, 0xad63160b
 0,          9,          9,        1,   518400, 0x0fcfeebc
-0,         10,         10,        1,   518400, 0x06e22dc3
+0,         10,         10,        1,   518400, 0x20b31777
 0,         11,         11,        1,   518400, 0x9d79df09
-0,         12,         12,        1,   518400, 0xcb2c716f
+0,         12,         12,        1,   518400, 0x3e86766f
 0,         13,         13,        1,   518400, 0x638a8746
-0,         14,         14,        1,   518400, 0xf7032efd
+0,         14,         14,        1,   518400, 0x7a6c1a0e
 0,         15,         15,        1,   518400, 0x306f6cef
-0,         16,         16,        1,   518400, 0xe83d2518
+0,         16,         16,        1,   518400, 0x81f81281
 0,         17,         17,        1,   518400, 0x49ab5bf5
-0,         18,         18,        1,   518400, 0x6b336b6f
+0,         18,         18,        1,   518400, 0x8f316e44
 0,         19,         19,        1,   518400, 0x95ae00c9
-0,         20,         20,        1,   518400, 0x68ddb64f
+0,         20,         20,        1,   518400, 0xf71bb7f5
 0,         21,         21,        1,   518400, 0x5205ea68
-0,         22,         22,        1,   518400, 0xb088e617
+0,         22,         22,        1,   518400, 0x74a1d8b9
 0,         23,         23,        1,   518400, 0xa3217616
-0,         24,         24,        1,   518400, 0x1723bc53
+0,         24,         24,        1,   518400, 0x2b28bbf8
 0,         25,         25,        1,   518400, 0xf024872a
-0,         26,         26,        1,   518400, 0x2e81a8bb
+0,         26,         26,        1,   518400, 0x2fdbaaf3
 0,         27,         27,        1,   518400, 0xa3a2418e
-0,         28,         28,        1,   518400, 0xb7beffed
+0,         28,         28,        1,   518400, 0x55bfe435
 0,         29,         29,        1,   518400, 0x50fb6c94
 0,         30,         30,        1,   518400, 0x5584bb40
diff --git a/mythtv/libs/libmyth/audio/audiooutputbase.cpp b/mythtv/libs/libmyth/audio/audiooutputbase.cpp
index c2d47f2..4c5dfe3 100644
--- a/mythtv/libs/libmyth/audio/audiooutputbase.cpp
+++ b/mythtv/libs/libmyth/audio/audiooutputbase.cpp
@@ -1813,8 +1813,15 @@ int AudioOutputBase::GetAudioData(uchar *buffer, int size, bool full_buffer,
  */
 void AudioOutputBase::Drain()
 {
-    while (audioready() > fragment_size)
+    while (!pauseaudio && audioready() > fragment_size)
         usleep(1000);
+    if (pauseaudio)
+    {
+        // Audio is paused and can't be drained, clear ringbuffer
+        QMutexLocker lock(&audio_buflock);
+
+        waud = raud = 0;
+    }
 }
 
 /**
diff --git a/mythtv/libs/libmyth/mediamonitor-darwin.cpp b/mythtv/libs/libmyth/mediamonitor-darwin.cpp
index aeadec0..8fa0c84 100644
--- a/mythtv/libs/libmyth/mediamonitor-darwin.cpp
+++ b/mythtv/libs/libmyth/mediamonitor-darwin.cpp
@@ -307,6 +307,16 @@ void diskAppearedCallback(DADiskRef disk, void *context)
     }
 
     model     = getModel(details);
+
+    if (model.contains("Apple Disk Image"))
+    {
+        LOG(VB_MEDIA, LOG_INFO, msg + QString("DMG %1 mounted, ignoring")
+            .arg(BSDname));
+        CFRelease(details);
+        free(volName);
+        return;
+    }
+
     mediaType = MediaTypeForBSDName(BSDname);
     isCDorDVD = (mediaType == MEDIATYPE_DVD) || (mediaType == MEDIATYPE_AUDIO);
 
diff --git a/mythtv/libs/libmythbase/mythcorecontext.cpp b/mythtv/libs/libmythbase/mythcorecontext.cpp
index c97c1e8..c610df2 100644
--- a/mythtv/libs/libmythbase/mythcorecontext.cpp
+++ b/mythtv/libs/libmythbase/mythcorecontext.cpp
@@ -643,7 +643,8 @@ bool MythCoreContext::IsThisHost(const QString &addr, const QString &host)
     QString thisip  = GetBackendServerIP4(host);
     QString thisip6 = GetBackendServerIP6(host);
 
-    return ((addrstr == thisip) || (addrstr == thisip6));
+    return (addrfix.protocol() == QAbstractSocket::IPv4Protocol && thisip == addrstr) ||
+           (addrfix.protocol() == QAbstractSocket::IPv6Protocol && thisip6 == addrstr);
 }
 
 bool MythCoreContext::IsFrontendOnly(void)
diff --git a/mythtv/libs/libmythbase/mythversion.h b/mythtv/libs/libmythbase/mythversion.h
index c189c40..b097b21 100644
--- a/mythtv/libs/libmythbase/mythversion.h
+++ b/mythtv/libs/libmythbase/mythversion.h
@@ -12,7 +12,7 @@
 /// Update this whenever the plug-in ABI changes.
 /// Including changes in the libmythbase, libmyth, libmythtv, libmythav* and
 /// libmythui class methods in exported headers.
-#define MYTH_BINARY_VERSION "0.27.20140702-1"
+#define MYTH_BINARY_VERSION "0.27.20140719-1"
 
 /** \brief Increment this whenever the MythTV network protocol changes.
  *
diff --git a/mythtv/libs/libmythdvdnav/dvdnav/dvdnav.c b/mythtv/libs/libmythdvdnav/dvdnav/dvdnav.c
index 3a7952e..f4b5ecb 100644
--- a/mythtv/libs/libmythdvdnav/dvdnav/dvdnav.c
+++ b/mythtv/libs/libmythdvdnav/dvdnav/dvdnav.c
@@ -203,7 +203,7 @@ int64_t dvdnav_convert_time(dvd_time_t *time) {
   int64_t result;
   int64_t frames;
 
-  result  = (time->hour    >> 4  ) * 10 * 60 * 60 * 90000;
+  result  = (time->hour    >> 4  ) * 10 * 60 * 60 * 90000ull;
   result += (time->hour    & 0x0f)      * 60 * 60 * 90000;
   result += (time->minute  >> 4  )      * 10 * 60 * 90000;
   result += (time->minute  & 0x0f)           * 60 * 90000;
diff --git a/mythtv/libs/libmythdvdnav/dvdnav/dvdnav.h b/mythtv/libs/libmythdvdnav/dvdnav/dvdnav.h
index 1e7fa08..a5a76de 100644
--- a/mythtv/libs/libmythdvdnav/dvdnav/dvdnav.h
+++ b/mythtv/libs/libmythdvdnav/dvdnav/dvdnav.h
@@ -29,7 +29,7 @@
 #define MP_DVDNAV 1
 
 // Change this only when syncing to mplayer dvdnav trunk
-#define DVDNAV_SVN_REV "svnR1251"
+#define DVDNAV_SVN_REV "svnR1294"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/mythtv/libs/libmythdvdnav/dvdnav/remap.c b/mythtv/libs/libmythdvdnav/dvdnav/remap.c
index f1dea93..4632a49 100644
--- a/mythtv/libs/libmythdvdnav/dvdnav/remap.c
+++ b/mythtv/libs/libmythdvdnav/dvdnav/remap.c
@@ -22,6 +22,7 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include <strings.h>
 #include <stdio.h>
 
 #ifndef _MSC_VER
diff --git a/mythtv/libs/libmythdvdnav/dvdnav/searching.c b/mythtv/libs/libmythdvdnav/dvdnav/searching.c
index 8a6f403..839c7a5 100644
--- a/mythtv/libs/libmythdvdnav/dvdnav/searching.c
+++ b/mythtv/libs/libmythdvdnav/dvdnav/searching.c
@@ -787,13 +787,41 @@ uint32_t dvdnav_describe_title_chapters(dvdnav_t *this, int32_t title, uint64_t
   length = 0;
   for(i=0; i<parts; i++) {
     uint32_t cellnr, endcellnr;
+    if (ptt[i].pgcn == 0 || ptt[i].pgcn > ifo->vts_pgcit->nr_of_pgci_srp) {
+      printerr("PGCN out of bounds.");
+      continue;
+    }
+    if (ifo->vts_pgcit->pgci_srp[ptt[i].pgcn-1].pgc_start_byte >= ifo->vts_pgcit->last_byte) {
+      printerr("PGC start out of bounds");
+      continue;
+    }
     pgc = ifo->vts_pgcit->pgci_srp[ptt[i].pgcn-1].pgc;
-    if(ptt[i].pgn > pgc->nr_of_programs) {
+    if (pgc == NULL) {
+      printerr("PGC missing.");
+      continue;
+    }
+    if (pgc->program_map == NULL) {
+      printerr("Program map missing.");
+      continue;
+    }
+    if(ptt[i].pgn == 0 || ptt[i].pgn > pgc->nr_of_programs) {
       printerr("WRONG part number.");
       goto fail;
     }
 
-    cellnr = pgc->program_map[ptt[i].pgn-1];
+    if (pgc->nr_of_cells == 0) {
+      printerr("Number of cells cannot be 0");
+      continue;
+    }
+    if ((cellnr = pgc->program_map[ptt[i].pgn-1]) == 0) {
+      printerr("Cell new row cannot be 0");
+      continue;
+    }
+    if (pgc->cell_playback == NULL) {
+      printerr("Cell missing");
+      continue;
+    }
+
     if(ptt[i].pgn < pgc->nr_of_programs)
       endcellnr = pgc->program_map[ptt[i].pgn];
     else
diff --git a/mythtv/libs/libmythdvdnav/dvdnav/vm/vm.c b/mythtv/libs/libmythdvdnav/dvdnav/vm/vm.c
index 572cbde..ccdea87 100644
--- a/mythtv/libs/libmythdvdnav/dvdnav/vm/vm.c
+++ b/mythtv/libs/libmythdvdnav/dvdnav/vm/vm.c
@@ -62,7 +62,7 @@
 #include "mythiowrapper.h"
 
 /*
-#define STRICT
+#define DVDNAV_STRICT
 */
 
 /* Local prototypes */
@@ -266,7 +266,7 @@ static int ifoOpenNewVTSI(vm_t *vm, dvd_reader_t *dvd, int vtsN) {
 /* Initialisation & Destruction */
 
 vm_t* vm_new_vm() {
-  return (vm_t*)calloc(sizeof(vm_t), sizeof(char));
+  return (vm_t*)calloc(1, sizeof(vm_t));
 }
 
 void vm_free_vm(vm_t *vm) {
@@ -1155,7 +1155,7 @@ static link_t play_Cell(vm_t *vm) {
     case 1: /*  Angle block */
       /* Loop and check each cell instead? So we don't get outside the block? */
       (vm->state).cellN += (vm->state).AGL_REG - 1;
-#ifdef STRICT
+#ifdef DVDNAV_STRICT
       assert((vm->state).cellN <= (vm->state).pgc->nr_of_cells);
       assert((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_mode != 0);
       assert((vm->state).pgc->cell_playback[(vm->state).cellN - 1].block_type == 1);
diff --git a/mythtv/libs/libmythdvdnav/dvdread/dvd_input.c b/mythtv/libs/libmythdvdnav/dvdread/dvd_input.c
index 99cb76f..92292d3 100644
--- a/mythtv/libs/libmythdvdnav/dvdread/dvd_input.c
+++ b/mythtv/libs/libmythdvdnav/dvdread/dvd_input.c
@@ -44,7 +44,6 @@ char *      (*dvdinput_error) (dvd_input_t);
 #define DVDcss_open(a) dvdcss_open((char*)(a))
 #define DVDcss_close   dvdcss_close
 #define DVDcss_seek    dvdcss_seek
-#define DVDcss_title   dvdcss_title
 #define DVDcss_read    dvdcss_read
 #define DVDcss_error   dvdcss_error
 #else
@@ -61,19 +60,19 @@ char *      (*dvdinput_error) (dvd_input_t);
 #include <CoreFoundation/CFBundle.h>
 #endif
 
-typedef struct dvdcss_s *dvdcss_handle;
-static dvdcss_handle (*DVDcss_open)  (const char *);
-static int           (*DVDcss_close) (dvdcss_handle);
-static int           (*DVDcss_seek)  (dvdcss_handle, int, int);
-static int           (*DVDcss_title) (dvdcss_handle, int);
-static int           (*DVDcss_read)  (dvdcss_handle, void *, int, int);
-static char *        (*DVDcss_error) (dvdcss_handle);
+typedef struct dvdcss_s *dvdcss_t;
+static dvdcss_t (*DVDcss_open)  (const char *);
+static int      (*DVDcss_close) (dvdcss_t);
+static int      (*DVDcss_seek)  (dvdcss_t, int, int);
+static int      (*DVDcss_read)  (dvdcss_t, void *, int, int);
+static char *   (*DVDcss_error) (dvdcss_t);
+#define DVDCSS_SEEK_KEY (1 << 1)
 #endif
 
 /* The DVDinput handle, add stuff here for new input methods. */
 struct dvd_input_s {
   /* libdvdcss handle */
-  dvdcss_handle dvdcss;
+  dvdcss_t dvdcss;
 
   /* dummy file input */
   int fd;
@@ -127,7 +126,7 @@ static int css_seek(dvd_input_t dev, int blocks)
  */
 static int css_title(dvd_input_t dev, int block)
 {
-  return DVDcss_title(dev->dvdcss, block);
+  return DVDcss_seek(dev->dvdcss, block, DVDCSS_SEEK_KEY);
 }
 
 /**
@@ -277,13 +276,10 @@ static int file_close(dvd_input_t dev)
 int dvdinput_setup(const char *path)
 {
   void *dvdcss_library = NULL;
-  char **dvdcss_version = NULL;
 
 #ifdef HAVE_DVDCSS_DVDCSS_H
   /* linking to libdvdcss */
   dvdcss_library = &dvdcss_library;  /* Give it some value != NULL */
-  /* the DVDcss_* functions have been #defined at the top */
-  dvdcss_version = &dvdcss_interface_2;
 
 #else
   /* dlopening libdvdcss */
@@ -291,7 +287,7 @@ int dvdinput_setup(const char *path)
 #ifdef __APPLE__
   #define CSS_LIB "libdvdcss.2.dylib"
 #elif defined(WIN32)
-  #define CSS_LIB "libdvdcss.dll"
+  #define CSS_LIB "libdvdcss-2.dll"
 #elif defined(__OS2__)
   #define CSS_LIB "dvdcss.dll"
 #else
@@ -332,21 +328,17 @@ int dvdinput_setup(const char *path)
 #else
 #define U_S
 #endif
-    DVDcss_open = (dvdcss_handle (*)(const char*))
+    DVDcss_open = (dvdcss_t (*)(const char*))
       dlsym(dvdcss_library, U_S "dvdcss_open");
-    DVDcss_close = (int (*)(dvdcss_handle))
+    DVDcss_close = (int (*)(dvdcss_t))
       dlsym(dvdcss_library, U_S "dvdcss_close");
-    DVDcss_title = (int (*)(dvdcss_handle, int))
-      dlsym(dvdcss_library, U_S "dvdcss_title");
-    DVDcss_seek = (int (*)(dvdcss_handle, int, int))
+    DVDcss_seek = (int (*)(dvdcss_t, int, int))
       dlsym(dvdcss_library, U_S "dvdcss_seek");
-    DVDcss_read = (int (*)(dvdcss_handle, void*, int, int))
+    DVDcss_read = (int (*)(dvdcss_t, void*, int, int))
       dlsym(dvdcss_library, U_S "dvdcss_read");
-    DVDcss_error = (char* (*)(dvdcss_handle))
+    DVDcss_error = (char* (*)(dvdcss_t))
       dlsym(dvdcss_library, U_S "dvdcss_error");
 
-    dvdcss_version = (char **)dlsym(dvdcss_library, U_S "dvdcss_interface_2");
-
     if(dlsym(dvdcss_library, U_S "dvdcss_crack")) {
       fprintf(stderr,
               "libdvdread: Old (pre-0.0.2) version of libdvdcss found.\n"
@@ -354,8 +346,8 @@ int dvdinput_setup(const char *path)
               "http://www.videolan.org/\n" );
       dlclose(dvdcss_library);
       dvdcss_library = NULL;
-    } else if(!DVDcss_open  || !DVDcss_close || !DVDcss_title || !DVDcss_seek
-              || !DVDcss_read || !DVDcss_error || !dvdcss_version) {
+    } else if(!DVDcss_open  || !DVDcss_close || !DVDcss_seek
+              || !DVDcss_read || !DVDcss_error) {
       fprintf(stderr,  "libdvdread: Missing symbols in %s, "
               "this shouldn't happen !\n", CSS_LIB);
       dlclose(dvdcss_library);
@@ -371,8 +363,6 @@ int dvdinput_setup(const char *path)
     fprintf(stderr, "DVDCSS_METHOD %s\n", psz_method);
     fprintf(stderr, "DVDCSS_VERBOSE %s\n", psz_verbose);
     */
-    fprintf(stderr, "libdvdread: Using libdvdcss version %s for DVD access\n",
-            dvdcss_version ? *dvdcss_version : "");
 
     /* libdvdcss wrapper functions */
     dvdinput_open  = css_open;
diff --git a/mythtv/libs/libmythdvdnav/dvdread/dvd_reader.c b/mythtv/libs/libmythdvdnav/dvdread/dvd_reader.c
index fd00d6c..fb6e79e 100644
--- a/mythtv/libs/libmythdvdnav/dvdread/dvd_reader.c
+++ b/mythtv/libs/libmythdvdnav/dvdread/dvd_reader.c
@@ -28,6 +28,7 @@
 #include <stdio.h>
 #include <errno.h>
 #include <string.h>
+#include <strings.h>
 #include <ctype.h>
 #include <unistd.h>
 #include <limits.h>
diff --git a/mythtv/libs/libmythdvdnav/dvdread/dvd_udf.c b/mythtv/libs/libmythdvdnav/dvdread/dvd_udf.c
index fb932b6..78eb4c8 100644
--- a/mythtv/libs/libmythdvdnav/dvdread/dvd_udf.c
+++ b/mythtv/libs/libmythdvdnav/dvdread/dvd_udf.c
@@ -31,6 +31,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <strings.h>
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -593,8 +594,10 @@ static int UDFScanDir( dvd_reader_t *device, struct AD Dir, char *FileName,
     } else
       in_cache = 1;
 
-    if(cached_dir == NULL)
+    if(cached_dir == NULL) {
+      free(cached_dir_base);
       return 0;
+    }
 
     p = 0;
 
diff --git a/mythtv/libs/libmythdvdnav/dvdread/ifo_print.c b/mythtv/libs/libmythdvdnav/dvdread/ifo_print.c
index 976f68b..531ffb8 100644
--- a/mythtv/libs/libmythdvdnav/dvdread/ifo_print.c
+++ b/mythtv/libs/libmythdvdnav/dvdread/ifo_print.c
@@ -1189,10 +1189,10 @@ void ifo_print(dvd_reader_t *dvd, int title) {
     if(ifohandle->menu_vobu_admap) {
       ifoPrint_VOBU_ADMAP(ifohandle->menu_vobu_admap);
     } else {
-      printf("No Menu VOBU address map present\n");
+      printf("No Menu VOBU Address map present\n");
     }
 
-    printf("\nCell Adress table\n");
+    printf("\nCell Address table\n");
     printf(  "-----------------\n");
     ifoPrint_C_ADT(ifohandle->vts_c_adt);
 
diff --git a/mythtv/libs/libmythdvdnav/dvdread/ifo_read.c b/mythtv/libs/libmythdvdnav/dvdread/ifo_read.c
index 464b8ff..2ce917b 100644
--- a/mythtv/libs/libmythdvdnav/dvdread/ifo_read.c
+++ b/mythtv/libs/libmythdvdnav/dvdread/ifo_read.c
@@ -568,6 +568,8 @@ static int ifoRead_VMG(ifo_handle_t *ifofile) {
 
   CHECK_ZERO(vmgi_mat->zero_1);
   CHECK_ZERO(vmgi_mat->zero_2);
+  /* DVDs created by VDR-to-DVD device LG RC590M violate the following check with
+   * vmgi_mat->zero_3 = 0x00000000010000000000000000000000000000. */
   CHECK_ZERO(vmgi_mat->zero_3);
   CHECK_ZERO(vmgi_mat->zero_4);
   CHECK_ZERO(vmgi_mat->zero_5);
@@ -1184,8 +1186,22 @@ int ifoRead_VTS_PTT_SRPT(ifo_handle_t *ifofile) {
     fprintf(stderr, "libdvdread: PTT search table too small.\n");
     goto fail;
   }
+
+  if(vts_ptt_srpt->nr_of_srpts == 0) {
+    fprintf(stderr, "libdvdread: Zero entries in PTT search table.\n");
+    goto fail;
+  }
+
   for(i = 0; i < vts_ptt_srpt->nr_of_srpts; i++) {
-    B2N_32(data[i]);
+    /* Transformers 3 has PTT start bytes that point outside the SRPT PTT */
+    uint32_t start = data[i];
+    B2N_32(start);
+    if(start + sizeof(ptt_info_t) > vts_ptt_srpt->last_byte + 1) {
+      /* don't mess with any bytes beyond the end of the allocation */
+      vts_ptt_srpt->nr_of_srpts = i;
+      break;
+    }
+    data[i] = start;
     /* assert(data[i] + sizeof(ptt_info_t) <= vts_ptt_srpt->last_byte + 1);
        Magic Knight Rayearth Daybreak is mastered very strange and has
        Titles with 0 PTTs. They all have a data[i] offsets beyond the end of
@@ -1211,6 +1227,7 @@ int ifoRead_VTS_PTT_SRPT(ifo_handle_t *ifofile) {
        Titles with 0 PTTs. */
     if(n < 0) n = 0;
 
+    /* DVDs created by the VDR-to-DVD device LG RC590M violate the following requirement */
     CHECK_VALUE(n % 4 == 0);
 
     vts_ptt_srpt->title[i].nr_of_ptts = n / 4;
@@ -1293,7 +1310,7 @@ int ifoRead_PTL_MAIT(ifo_handle_t *ifofile) {
   if(!ifofile->vmgi_mat)
     return 0;
 
-  if(ifofile->vmgi_mat->ptl_mait == NULL)
+  if(ifofile->vmgi_mat->ptl_mait == 0)
     return 1;
 
   if(!DVDFileSeek_(ifofile->file, ifofile->vmgi_mat->ptl_mait * DVD_BLOCK_LEN))
@@ -1374,6 +1391,7 @@ int ifoRead_PTL_MAIT(ifo_handle_t *ifofile) {
       ifofile->ptl_mait = NULL;
       return 0;
     }
+    memset(pf_temp, 0, info_length);
     if(!(DVDReadBytes(ifofile->file, pf_temp, info_length))) {
       fprintf(stderr, "libdvdread: Unable to read PTL_MAIT table at index %d.\n",i);
       free(pf_temp);
@@ -1436,6 +1454,7 @@ int ifoRead_VTS_TMAPT(ifo_handle_t *ifofile) {
 
   if(ifofile->vtsi_mat->vts_tmapt == 0) { /* optional(?) */
     ifofile->vts_tmapt = NULL;
+    fprintf(stderr,"libdvdread: No VTS_TMAPT available - skipping.\n");
     return 1;
   }
 
diff --git a/mythtv/libs/libmythmetadata/libmythmetadata.pro b/mythtv/libs/libmythmetadata/libmythmetadata.pro
index 54cb344..8fa8ff3 100644
--- a/mythtv/libs/libmythmetadata/libmythmetadata.pro
+++ b/mythtv/libs/libmythmetadata/libmythmetadata.pro
@@ -25,6 +25,7 @@ HEADERS += mythuiimageresults.h
 HEADERS += musicmetadata.h musicutils.h metaio.h metaiotaglib.h
 HEADERS += metaioflacvorbis.h metaioavfcomment.h metaiomp4.h
 HEADERS += metaiowavpack.h metaioid3.h metaiooggvorbis.h
+HEADERS += metadatagrabber.h
 
 SOURCES += cleanup.cpp  dbaccess.cpp  dirscan.cpp  globals.cpp
 SOURCES += parentalcontrols.cpp  videoscan.cpp  videoutils.cpp
@@ -35,6 +36,7 @@ SOURCES += mythuiimageresults.cpp
 SOURCES += musicmetadata.cpp musicutils.cpp metaio.cpp metaiotaglib.cpp
 SOURCES += metaioflacvorbis.cpp metaioavfcomment.cpp metaiomp4.cpp
 SOURCES += metaiowavpack.cpp metaioid3.cpp metaiooggvorbis.cpp
+SOURCES += metadatagrabber.cpp
 
 INCLUDEPATH += ../libmythbase ../libmythtv
 INCLUDEPATH += ../.. ../ ./ ../libmythupnp ../libmythui
@@ -81,7 +83,7 @@ inc.files = cleanup.h  dbaccess.h  dirscan.h  globals.h  parentalcontrols.h
 inc.files += videoscan.h  videoutils.h  videometadata.h  videometadatalistmanager.h
 inc.files += quicksp.h metadatacommon.h metadatadownload.h metadataimagedownload.h
 inc.files += bluraymetadata.h mythmetaexp.h metadatafactory.h mythuimetadataresults.h
-inc.files += mythuiimageresults.h metadataimagehelper.h
+inc.files += mythuiimageresults.h metadataimagehelper.h metadatagrabber.h
 inc.files += musicmetadata.h musicutils.h
 inc.files += metaio.h metaiotaglib.h
 inc.files += metaioflacvorbis.h metaioavfcomment.h metaiomp4.h
diff --git a/mythtv/libs/libmythmetadata/metadatacommon.cpp b/mythtv/libs/libmythmetadata/metadatacommon.cpp
index 8a4c598..ea3716f 100644
--- a/mythtv/libs/libmythmetadata/metadatacommon.cpp
+++ b/mythtv/libs/libmythmetadata/metadatacommon.cpp
@@ -75,6 +75,7 @@ MetadataLookup::MetadataLookup(void) :
     m_collectionref(),
     m_tmsref(),
     m_imdb(),
+    m_iscollection(false),
     m_people(),
     m_studios(),
     m_homepage(),
@@ -210,6 +211,7 @@ MetadataLookup::MetadataLookup(
     m_collectionref(collectionref),
     m_tmsref(tmsref),
     m_imdb(imdb),
+    m_iscollection(false),
     m_people(people),
     m_studios(studios),
     m_homepage(homepage),
@@ -303,7 +305,8 @@ MetadataLookup::MetadataLookup(
     m_releasedate(releasedate),
     m_lastupdated(lastupdated),
     m_runtime(runtime),
-    m_runtimesecs(runtimesecs)
+    m_runtimesecs(runtimesecs),
+    m_iscollection(false)
 {
     m_tracknum = 0;
     m_popularity = 0;
@@ -379,6 +382,7 @@ MetadataLookup::MetadataLookup(
     m_runtime(runtime),
     m_runtimesecs(runtimesecs),
     m_inetref(inetref),
+    m_iscollection(false),
     m_people(people),
     m_trailerURL(trailerURL),
     m_artwork(artwork),
@@ -1159,23 +1163,30 @@ MetadataLookup* ParseMetadataItem(const QDomElement& item,
         season = lookup->GetSeason();
         episode = lookup->GetEpisode();
     }
-    else
+
+    if (lookup->GetPreferDVDOrdering())
     {
-        if (lookup->GetPreferDVDOrdering())
+        if (!season)
         {
             season = item.firstChildElement("dvdseason").text().toUInt();
-            episode = item.firstChildElement("dvdepisode").text().toUInt();
         }
-
-        if ((season == 0) && (episode == 0))
+        if (!episode)
         {
-            season = item.firstChildElement("season").text().toUInt();
-            episode = item.firstChildElement("episode").text().toUInt();
+            episode = item.firstChildElement("dvdepisode").text().toUInt();
         }
-        LOG(VB_GENERAL, LOG_INFO, QString("Result Found, Season %1 Episode %2")
-            .arg(season).arg(episode));
     }
 
+    if (!season)
+    {
+        season = item.firstChildElement("season").text().toUInt();
+    }
+    if (!episode)
+    {
+        episode = item.firstChildElement("episode").text().toUInt();
+    }
+    LOG(VB_GENERAL, LOG_INFO, QString("Result Found, Season %1 Episode %2")
+        .arg(season).arg(episode));
+
     return new MetadataLookup(lookup->GetType(), lookup->GetSubtype(),
         lookup->GetData(), lookup->GetStep(), lookup->GetAutomatic(),
         lookup->GetHandleImages(), lookup->GetAllowOverwrites(),
@@ -1496,68 +1507,4 @@ QDateTime RFC822TimeToQDateTime(const QString& t)
     return result;
 }
 
-MetaGrabberScript::MetaGrabberScript(
-    const QString &name,
-    const QString &author,
-    const QString &thumbnail,
-    const QString &command,
-    const GrabberType type,
-    const QString &typestring,
-    const QString &description,
-    const float version
-    ) :
-    m_name(name),
-    m_author(author),
-    m_thumbnail(thumbnail),
-    m_command(command),
-    m_type(type),
-    m_typestring(typestring),
-    m_description(description),
-    m_version(version)
-{
-}
-
-MetaGrabberScript::~MetaGrabberScript()
-{
-}
 
-MetaGrabberScript* ParseGrabberVersion(const QDomElement& item)
-{
-    QString name, author, thumbnail, command, description, typestring;
-    float version = 0;
-    GrabberType type = kGrabberMovie;
-
-    name = item.firstChildElement("name").text();
-    author = item.firstChildElement("author").text();
-    thumbnail = item.firstChildElement("thumbnail").text();
-    command = item.firstChildElement("command").text();
-    description = item.firstChildElement("description").text();
-    version = item.firstChildElement("version").text().toFloat();
-    typestring = item.firstChildElement("type").text();
-
-    if (!typestring.isEmpty())
-    {
-        if (typestring.toLower() == "movie")
-            type = kGrabberMovie;
-        else if (typestring.toLower() == "television")
-            type = kGrabberTelevision;
-        else if (typestring.toLower() == "game")
-            type = kGrabberGame;
-        else if (typestring.toLower() == "music")
-            type = kGrabberMusic;
-    }
-
-    return new MetaGrabberScript(name, author, thumbnail, command,
-                             type, typestring, description, version);
-}
-
-void MetaGrabberScript::toMap(InfoMap &metadataMap)
-{
-    metadataMap["name"] = m_name;
-    metadataMap["author"] = m_author;
-    metadataMap["thumbnailfilename"] = m_thumbnail;
-    metadataMap["command"] = m_command;
-    metadataMap["description"] = m_description;
-    metadataMap["version"] = QString::number(m_version);
-    metadataMap["type"] = m_typestring;
-}
diff --git a/mythtv/libs/libmythmetadata/metadatacommon.h b/mythtv/libs/libmythmetadata/metadatacommon.h
index 05e90c0..21f5ec8 100644
--- a/mythtv/libs/libmythmetadata/metadatacommon.h
+++ b/mythtv/libs/libmythmetadata/metadatacommon.h
@@ -15,6 +15,7 @@
 #include "mythmetaexp.h"
 #include "metadataimagehelper.h"
 #include "referencecounterlist.h"
+#include "metadatagrabber.h"
 
 class ProgramInfo;
 
@@ -259,6 +260,7 @@ class META_PUBLIC MetadataLookup : public QObject, public ReferenceCounter
     void SetCollectionref(const QString &collectionref)
                              { m_collectionref = collectionref; };
     void SetTMSref(const QString &tmsref) { m_tmsref = tmsref; };
+    void SetIsCollection(bool collection) { m_iscollection = collection; };
     void SetPreferDVDOrdering(bool preferdvdorder)
                              { m_dvdorder = preferdvdorder; };
 
@@ -344,6 +346,7 @@ class META_PUBLIC MetadataLookup : public QObject, public ReferenceCounter
     QString GetCollectionref() const { return m_collectionref; };
     QString GetIMDB() const { return m_imdb; };
     QString GetTMSref() const { return m_tmsref; };
+    bool    GetIsCollection() const { return m_iscollection; };
 
     // People
     QList<PersonInfo> GetPeople(PeopleType type) const;
@@ -429,6 +432,7 @@ class META_PUBLIC MetadataLookup : public QObject, public ReferenceCounter
     QString m_collectionref;
     QString m_tmsref;
     QString m_imdb;
+    bool    m_iscollection;
 
     // People - Video
     const PeopleMap m_people;
@@ -482,54 +486,6 @@ META_PUBLIC QString nearestName(const QString &actual,
 
 META_PUBLIC QDateTime RFC822TimeToQDateTime(const QString &t);
 
-enum GrabberType {
-    kGrabberMovie = 0,
-    kGrabberTelevision = 1,
-    kGrabberMusic = 2,
-    kGrabberGame = 3
-};
-
-class META_PUBLIC MetaGrabberScript : public QObject
-{
-  public:
-    MetaGrabberScript();
-    ~MetaGrabberScript();
-
-    MetaGrabberScript(
-        const QString &name,
-        const QString &author,
-        const QString &thumbnail,
-        const QString &command,
-        const GrabberType type,
-        const QString &typestring,
-        const QString &description,
-        const float version);
-
-    QString GetName(void) const { return m_name; };
-    QString GetAuthor(void) const { return m_author; };
-    QString GetThumbnail(void) const { return m_thumbnail; };
-    QString GetCommand(void) const { return m_command; };
-    GrabberType GetType(void) const { return m_type; };
-    QString GetTypeString(void) const { return m_typestring; };
-    QString GetDescription(void) const { return m_description; };
-    float GetVersion(void) const { return m_version; };
-
-    void toMap(InfoMap &metadataMap);
-
-  private:
-    QString m_name;
-    QString m_author;
-    QString m_thumbnail;
-    QString m_command;
-    GrabberType m_type;
-    QString m_typestring;
-    QString m_description;
-    float m_version;
-};
-
-META_PUBLIC MetaGrabberScript *ParseGrabberVersion(const QDomElement &item);
-
-Q_DECLARE_METATYPE(MetaGrabberScript*)
 Q_DECLARE_METATYPE(MetadataLookup*)
 Q_DECLARE_METATYPE(RefCountHandler<MetadataLookup>)
 
diff --git a/mythtv/libs/libmythmetadata/metadatadownload.cpp b/mythtv/libs/libmythmetadata/metadatadownload.cpp
index a2cca15..78d0543 100644
--- a/mythtv/libs/libmythmetadata/metadatadownload.cpp
+++ b/mythtv/libs/libmythmetadata/metadatadownload.cpp
@@ -11,6 +11,7 @@
 #include "mythsystemlegacy.h"
 #include "storagegroup.h"
 #include "metadatadownload.h"
+#include "metadatafactory.h"
 #include "mythmiscutil.h"
 #include "remotefile.h"
 #include "mythlogging.h"
@@ -92,44 +93,30 @@ void MetadataDownload::run()
         MetadataLookupList list;
 
         // Go go gadget Metadata Lookup
-        if (lookup->GetType() == kMetadataVideo)
+        if (lookup->GetType() == kMetadataVideo ||
+            lookup->GetType() == kMetadataRecording)
         {
             if (lookup->GetSubtype() == kProbableTelevision)
                 list = handleTelevision(lookup);
             else if (lookup->GetSubtype() == kProbableMovie)
                 list = handleMovie(lookup);
             else
-                list = handleVideoUndetermined(lookup);
-
-            if (list.isEmpty() &&
-                lookup->GetSubtype() == kUnknownVideo)
             {
-                list = handleMovie(lookup);
+                // will try both movie and TV
+                list = handleVideoUndetermined(lookup);
             }
-        }
-        else if (lookup->GetType() == kMetadataRecording)
-        {
-            if (lookup->GetSubtype() == kProbableTelevision)
-            {
-                if (lookup->GetSeason() > 0 || lookup->GetEpisode() > 0)
-                    list = handleTelevision(lookup);
-                else if (!lookup->GetSubtitle().isEmpty())
-                    list = handleVideoUndetermined(lookup);
 
-                if (list.isEmpty())
-                    list = handleRecordingGeneric(lookup);
-            }
-            else if (lookup->GetSubtype() == kProbableMovie)
+            if ((list.isEmpty() ||
+                 (list.size() > 1 && !lookup->GetAutomatic())) &&
+                lookup->GetSubtype() == kProbableTelevision)
             {
-                list = handleMovie(lookup);
-                if (lookup->GetInetref().isEmpty())
-                    list.append(handleRecordingGeneric(lookup));
+                list.append(handleMovie(lookup));
             }
-            else
+            else if ((list.isEmpty() ||
+                      (list.size() > 1 && !lookup->GetAutomatic())) &&
+                     lookup->GetSubtype() == kProbableMovie)
             {
-                list = handleRecordingGeneric(lookup);
-                if (lookup->GetInetref().isEmpty())
-                    list.append(handleMovie(lookup));
+                list.append(handleTelevision(lookup));
             }
         }
         else if (lookup->GetType() == kMetadataGame)
@@ -144,8 +131,15 @@ void MetadataDownload::run()
             if (list.count() == 1 && list[0]->GetStep() == kLookupSearch)
             {
                 MetadataLookup *newlookup = list.takeFirst();
+
                 newlookup->SetStep(kLookupData);
                 prependLookup(newlookup);
+                // Type may have changed
+                LookupType ret = GuessLookupType(newlookup);
+                if (ret != kUnknownVideo)
+                {
+                    newlookup->SetSubtype(ret);
+                }
                 continue;
             }
 
@@ -158,9 +152,16 @@ void MetadataDownload::run()
                 if (bestLookup)
                 {
                     MetadataLookup *newlookup = bestLookup;
+
                     // bestlookup is owned by list, we need an extra reference
                     newlookup->IncrRef();
                     newlookup->SetStep(kLookupData);
+                    // Type may have changed
+                    LookupType ret = GuessLookupType(newlookup);
+                    if (ret != kUnknownVideo)
+                    {
+                        newlookup->SetSubtype(ret);
+                    }
                     prependLookup(newlookup);
                     continue;
                 }
@@ -256,8 +257,8 @@ MetadataLookup* MetadataDownload::findBestMatch(MetadataLookupList list,
                     .arg(originaltitle).arg(bestTitle));
 
     // Grab the one item that matches the besttitle (IMPERFECT)
-    for (MetadataLookupList::const_iterator i = list.begin();
-            i != list.end(); ++i)
+    MetadataLookupList::const_iterator i = list.begin();
+    for (; i != list.end(); ++i)
     {
         if ((*i)->GetTitle() == bestTitle)
         {
@@ -291,8 +292,7 @@ MetadataLookupList MetadataDownload::runGrabber(QString cmd, QStringList args,
 
         while (!item.isNull())
         {
-            MetadataLookup *tmp = ParseMetadataItem(item, lookup,
-                passseas);
+            MetadataLookup *tmp = ParseMetadataItem(item, lookup, passseas);
             list.append(tmp);
             // MetadataLookup is to be owned by list
             tmp->DecrRef();
@@ -304,48 +304,22 @@ MetadataLookupList MetadataDownload::runGrabber(QString cmd, QStringList args,
 
 QString MetadataDownload::GetMovieGrabber()
 {
-    QString def_cmd = "metadata/Movie/tmdb3.py";
-    QString db_cmd = gCoreContext->GetSetting("MovieGrabber", def_cmd);
-
-    return QDir::cleanPath(QString("%1/%2")
-            .arg(GetShareDir())
-            .arg(db_cmd));
+    return MetaGrabberScript::GetType(kGrabberMovie).GetPath();
 }
 
 QString MetadataDownload::GetTelevisionGrabber()
 {
-    QString def_cmd = "metadata/Television/ttvdb.py";
-    QString db_cmd = gCoreContext->GetSetting("TelevisionGrabber", def_cmd);
-
-    return QDir::cleanPath(QString("%1/%2")
-            .arg(GetShareDir())
-            .arg(db_cmd));
+    return MetaGrabberScript::GetType(kGrabberTelevision).GetPath();
 }
 
 QString MetadataDownload::GetGameGrabber()
 {
-    QString def_cmd = "metadata/Game/giantbomb.py";
-    QString db_cmd = gCoreContext->GetSetting("mythgame.MetadataGrabber", def_cmd);
-
-    return QDir::cleanPath(QString("%1/%2")
-            .arg(GetShareDir())
-            .arg(db_cmd));
+    return MetaGrabberScript::GetType(kGrabberGame).GetPath();
 }
 
 bool MetadataDownload::runGrabberTest(const QString &grabberpath)
 {
-    QStringList args;
-    args.append("-t");
-
-    MythSystemLegacy grabber(grabberpath, args, kMSStdOut);
-
-    grabber.Run();
-    uint exitcode = grabber.Wait();
-
-    if (exitcode != 0)
-        return false;
-
-    return true;
+    return MetaGrabberScript(grabberpath).Test();
 }
 
 bool MetadataDownload::MovieGrabberWorks()
@@ -440,9 +414,11 @@ MetadataLookupList MetadataDownload::readNFO(QString NFOpath,
         if (rf->isOpen())
         {
             bool loaded = rf->SaveAs(nforaw);
+
             if (loaded)
             {
                 QDomDocument doc;
+
                 if (doc.setContent(nforaw, true))
                 {
                     lookup->SetStep(kLookupData);
@@ -463,6 +439,7 @@ MetadataLookupList MetadataDownload::readNFO(QString NFOpath,
         if (!error)
         {
             MetadataLookup *tmp = ParseMetadataMovieNFO(item, lookup);
+
             list.append(tmp);
             // MetadataLookup is owned by the MetadataLookupList returned
             tmp->DecrRef();
@@ -475,38 +452,45 @@ MetadataLookupList MetadataDownload::readNFO(QString NFOpath,
 MetadataLookupList MetadataDownload::handleGame(MetadataLookup *lookup)
 {
     MetadataLookupList list;
-
-    QString cmd = GetGameGrabber();
-
-    QStringList args;
-    args.append(QString("-l")); // Language Flag
-    args.append(gCoreContext->GetLanguage()); // UI Language
-    args.append(QString("-a"));
-    args.append(gCoreContext->GetLocale()->GetCountryCode());
+    MetaGrabberScript grabber =
+        MetaGrabberScript::GetGrabber(kGrabberGame, lookup);
 
     // If the inetref is populated, even in kLookupSearch mode,
     // become a kLookupData grab and use that.
     if (lookup->GetStep() == kLookupSearch &&
         (!lookup->GetInetref().isEmpty() &&
          lookup->GetInetref() != "00000000"))
+    {
         lookup->SetStep(kLookupData);
+    }
 
     if (lookup->GetStep() == kLookupSearch)
     {
-        args.append(QString("-M"));
-        QString title = lookup->GetTitle();
-        args.append(title);
+        if (lookup->GetTitle().isEmpty())
+        {
+            // no point searching on nothing...
+            return list;
+        }
+        // we're searching
+        list = grabber.Search(lookup->GetTitle(), lookup);
     }
     else if (lookup->GetStep() == kLookupData)
     {
-        args.append(QString("-D"));
-        args.append(lookup->GetInetref());
+        // we're just grabbing data
+        list = grabber.LookupData(lookup->GetInetref(), lookup);
     }
-    list = runGrabber(cmd, args, lookup);
 
     return list;
 }
 
+/**
+ * handleMovie:
+ * attempt to find movie data via the following (in order)
+ * 1- Local MXML
+ * 2- Local NFO
+ * 3- By title
+ * 4- By inetref (if present)
+ */
 MetadataLookupList MetadataDownload::handleMovie(MetadataLookup *lookup)
 {
     MetadataLookupList list;
@@ -525,98 +509,125 @@ MetadataLookupList MetadataDownload::handleMovie(MetadataLookup *lookup)
     else if (!nfo.isEmpty())
         list = readNFO(nfo, lookup);
 
-    if (list.isEmpty())
-    {
-        QString cmd = GetMovieGrabber();
-
-        QStringList args;
-        args.append(QString("-l")); // Language Flag
-        args.append(gCoreContext->GetLanguage()); // UI Language
-
-        args.append(QString("-a"));
-        args.append(gCoreContext->GetLocale()->GetCountryCode());
+    if (!list.isEmpty())
+        return list;
 
-        // If the inetref is populated, even in kLookupSearch mode,
-        // become a kLookupData grab and use that.
-        if (lookup->GetStep() == kLookupSearch &&
-            (!lookup->GetInetref().isEmpty() &&
-             lookup->GetInetref() != "00000000"))
-            lookup->SetStep(kLookupData);
+    MetaGrabberScript grabber =
+        MetaGrabberScript::GetGrabber(kGrabberMovie, lookup);
 
-        if (lookup->GetStep() == kLookupSearch)
-        {
-            args.append(QString("-M"));
-            QString title = lookup->GetTitle();
-            args.append(title);
-        }
-        else if (lookup->GetStep() == kLookupData)
+    // initial search mode
+    if (!lookup->GetInetref().isEmpty() && lookup->GetInetref() != "00000000" &&
+        (lookup->GetStep() == kLookupSearch || lookup->GetStep() == kLookupData))
+    {
+        // with inetref
+        lookup->SetStep(kLookupData);
+        // we're just grabbing data
+        list = grabber.LookupData(lookup->GetInetref(), lookup);
+    }
+    else if (lookup->GetStep() == kLookupSearch)
+    {
+        if (lookup->GetTitle().isEmpty())
         {
-            args.append(QString("-D"));
-            args.append(lookup->GetInetref());
+            // no point searching on nothing...
+            return list;
         }
-        list = runGrabber(cmd, args, lookup);
+        list = grabber.Search(lookup->GetTitle(), lookup);
     }
 
     return list;
 }
 
+/**
+ * handleTelevision
+ * attempt to find television data via the following (in order)
+ * 1- By inetref with subtitle
+ * 2- By inetref with season and episode
+ * 3- By inetref
+ * 4- By title and subtitle
+ * 5- By title
+ */
 MetadataLookupList MetadataDownload::handleTelevision(MetadataLookup *lookup)
 {
     MetadataLookupList list;
+    MetaGrabberScript grabber =
+        MetaGrabberScript::GetGrabber(kGrabberTelevision, lookup);
+    bool searchcollection = false;
 
-    QString cmd = GetTelevisionGrabber();
-
-    QStringList args;
-    args.append(QString("-l")); // Language Flag
-    args.append(gCoreContext->GetLanguage()); // UI Language
-    args.append(QString("-a"));
-    args.append(gCoreContext->GetLocale()->GetCountryCode());
-
-    // If the inetref is populated, even in kLookupSearch mode,
-    // become a kLookupData grab and use that.
-    if (lookup->GetStep() == kLookupSearch &&
-        (!lookup->GetInetref().isEmpty() &&
-         lookup->GetInetref() != "00000000"))
+    // initial search mode
+    if (!lookup->GetInetref().isEmpty() && lookup->GetInetref() != "00000000" &&
+        (lookup->GetStep() == kLookupSearch || lookup->GetStep() == kLookupData))
+    {
+        // with inetref
         lookup->SetStep(kLookupData);
+        if (!lookup->GetSubtitle().isEmpty())
+        {
+            list = grabber.SearchSubtitle(lookup->GetInetref(),
+                                          lookup->GetTitle() /* unused */,
+                                          lookup->GetSubtitle(), lookup, false);
+        }
 
-    if (lookup->GetStep() == kLookupSearch)
-    {
-        args.append(QString("-M"));
-        if (lookup->GetInetref().isEmpty() ||
-            lookup->GetInetref() == "00000000")
+        if (list.isEmpty() && lookup->GetSeason() && lookup->GetEpisode())
         {
-            QString title = lookup->GetTitle();
-            args.append(title);
+            list = grabber.LookupData(lookup->GetInetref(), lookup->GetSeason(),
+                                      lookup->GetEpisode(), lookup);
         }
-        else
+
+        if (list.isEmpty() && !lookup->GetCollectionref().isEmpty())
+        {
+            list = grabber.LookupCollection(lookup->GetCollectionref(), lookup);
+            searchcollection = true;
+        }
+        else if (list.isEmpty())
         {
-            QString inetref = lookup->GetInetref();
-            args.append(inetref);
+            // We do not store CollectionRef in our database
+            // so try with the inetref, for all purposes with TVDB, they are
+            // always identical
+            list = grabber.LookupCollection(lookup->GetInetref(), lookup);
+            searchcollection = true;
         }
     }
-    else if (lookup->GetStep() == kLookupData)
+    else if (lookup->GetStep() == kLookupSearch)
     {
-        args.append(QString("-D"));
-        args.append(lookup->GetInetref());
-        args.append(QString::number(lookup->GetSeason()));
-        args.append(QString::number(lookup->GetEpisode()));
+        if (lookup->GetTitle().isEmpty())
+        {
+            // no point searching on nothing...
+            return list;
+        }
+        if (!lookup->GetSubtitle().isEmpty())
+        {
+            list = grabber.SearchSubtitle(lookup->GetTitle(),
+                                          lookup->GetSubtitle(), lookup, false);
+        }
+        if (list.isEmpty())
+        {
+            list = grabber.Search(lookup->GetTitle(), lookup);
+        }
     }
     else if (lookup->GetStep() == kLookupCollection)
     {
-        args.append(QString("-C"));
-        args.append(lookup->GetCollectionref());
+        list = grabber.LookupCollection(lookup->GetCollectionref(), lookup);
     }
-    list = runGrabber(cmd, args, lookup);
 
     // Collection Fallback
     // If the lookup allows generic metadata, and the specific
     // season and episode are not available, try for series metadata.
-    if (list.isEmpty() &&
-        lookup->GetAllowGeneric() &&
-        lookup->GetStep() == kLookupData)
+    if (!searchcollection && list.isEmpty() &&
+        !lookup->GetCollectionref().isEmpty() &&
+        lookup->GetAllowGeneric() && lookup->GetStep() == kLookupData)
     {
         lookup->SetStep(kLookupCollection);
-        list = handleTelevision(lookup);
+        list = grabber.LookupCollection(lookup->GetCollectionref(), lookup);
+    }
+
+    if (!list.isEmpty())
+    {
+        // mark all results so that search collection is properly handled later
+        lookup->SetIsCollection(searchcollection);
+        for (MetadataLookupList::iterator it = list.begin();
+             it != list.end(); ++it)
+        {
+            (*it)->SetIsCollection(searchcollection);
+        }
     }
 
     return list;
@@ -626,36 +637,21 @@ MetadataLookupList MetadataDownload::handleVideoUndetermined(MetadataLookup *loo
 {
     MetadataLookupList list;
 
-    QString cmd = GetTelevisionGrabber();
-
-    // Can't trust the inetref with so little information.
-
-    QStringList args;
-    args.append(QString("-l")); // Language Flag
-    args.append(gCoreContext->GetLanguage()); // UI Language
-
-    args.append(QString("-a"));
-    args.append(gCoreContext->GetLocale()->GetCountryCode());
-
-    args.append(QString("-N"));
-    if (!lookup->GetInetref().isEmpty())
+    if (lookup->GetSubtype() != kProbableMovie &&
+        !lookup->GetSubtitle().isEmpty())
     {
-        QString inetref = lookup->GetInetref();
-        args.append(inetref);
+        list.append(handleTelevision(lookup));
     }
-    else
+
+    if (lookup->GetSubtype() != kProbableTelevision)
     {
-        QString title = lookup->GetTitle();
-        args.append(title);
+        list.append(handleMovie(lookup));
     }
-    QString subtitle = lookup->GetSubtitle();
-    args.append(subtitle);
-
-    // Try to do a title/subtitle lookup
-    list = runGrabber(cmd, args, lookup, false);
 
     if (list.count() == 1)
+    {
         list[0]->SetStep(kLookupData);
+    }
 
     return list;
 }
@@ -669,36 +665,31 @@ MetadataLookupList MetadataDownload::handleRecordingGeneric(MetadataLookup *look
 
     MetadataLookupList list;
 
-    QString cmd = GetTelevisionGrabber();
-
-    QStringList args;
-
-    args.append(QString("-l")); // Language Flag
-    args.append(gCoreContext->GetLanguage()); // UI Language
-
-    args.append(QString("-a"));
-    args.append(gCoreContext->GetLocale()->GetCountryCode());
+    if (lookup->GetTitle().isEmpty())
+    {
+        // no point searching on nothing...
+        return list;
+    }
 
+    // no inetref known, just pull the default grabber
+    MetaGrabberScript grabber = MetaGrabberScript::GetType(kGrabberTelevision);
 
-    args.append("-M");
-    QString title = lookup->GetTitle();
-    args.append(title);
+    // cache some initial values so we can change them in the lookup later
     LookupType origtype = lookup->GetSubtype();
     int origseason = lookup->GetSeason();
     int origepisode = lookup->GetEpisode();
 
-    lookup->SetSubtype(kProbableGenericTelevision);
-
     if (origseason == 0 && origepisode == 0)
     {
         lookup->SetSeason(1);
         lookup->SetEpisode(1);
     }
 
-    list = runGrabber(cmd, args, lookup, true);
+    list = grabber.Search(lookup->GetTitle(), lookup);
 
     if (list.count() == 1)
     {
+        // search was successful, rerun as normal television mode
         lookup->SetInetref(list[0]->GetInetref());
         lookup->SetCollectionref(list[0]->GetCollectionref());
         list = handleTelevision(lookup);
@@ -732,6 +723,7 @@ QString MetadataDownload::getMXMLPath(QString filename)
     {
         StorageGroup sg;
         QString fn = sg.FindFile(xurl.path());
+
         if (!fn.isEmpty() && QFile::exists(fn))
             ret = xmlname;
     }
@@ -760,6 +752,7 @@ QString MetadataDownload::getNFOPath(QString filename)
     {
         StorageGroup sg;
         QString fn = sg.FindFile(nurl.path());
+
         if (!fn.isEmpty() && QFile::exists(fn))
             ret = nfoname;
     }
diff --git a/mythtv/libs/libmythmetadata/metadatafactory.cpp b/mythtv/libs/libmythmetadata/metadatafactory.cpp
index 0109213..5c66bef 100644
--- a/mythtv/libs/libmythmetadata/metadatafactory.cpp
+++ b/mythtv/libs/libmythmetadata/metadatafactory.cpp
@@ -135,12 +135,7 @@ void MetadataFactory::Lookup(VideoMetadata *metadata, bool automatic,
 
     lookup->SetStep(kLookupSearch);
     lookup->SetType(kMetadataVideo);
-    if (metadata->GetSeason() > 0 || metadata->GetEpisode() > 0)
-        lookup->SetSubtype(kProbableTelevision);
-    else if (metadata->GetSubtitle().isEmpty())
-        lookup->SetSubtype(kProbableMovie);
-    else
-        lookup->SetSubtype(kUnknownVideo);
+    lookup->SetSubtype(GuessLookupType(metadata));
     lookup->SetData(qVariantFromValue(metadata));
     lookup->SetAutomatic(automatic);
     lookup->SetHandleImages(getimages);
@@ -296,7 +291,7 @@ void MetadataFactory::OnSingleResult(MetadataLookup *lookup)
         {
             ArtworkInfo info;
             int index = fanartlist.size();
-            int season = (int)lookup->GetSeason();
+            int season = lookup->GetIsCollection() ? 0 : (int)lookup->GetSeason();
             if (season > 0)
                 index = max(0, index-season);
             else
@@ -313,7 +308,7 @@ void MetadataFactory::OnSingleResult(MetadataLookup *lookup)
             map.insert(kArtworkBanner, info);
         }
 
-        if (!lookup->GetType() == kMetadataRecording)
+        if (lookup->GetType() != kMetadataRecording)
         {
             ArtworkList screenshotlist = lookup->GetArtwork(kArtworkScreenshot);
             if (screenshotlist.size())
@@ -627,7 +622,10 @@ void MetadataFactory::customEvent(QEvent *levent)
 
 LookupType GuessLookupType(ProgramInfo *pginfo)
 {
-    LookupType ret = kUnknownVideo;
+    LookupType ret = GuessLookupType(pginfo->GetInetRef());
+
+    if (ret != kUnknownVideo)
+        return ret;
 
     ProgramInfo::CategoryType catType = pginfo->GetCategoryType();
     if (catType == ProgramInfo::kCategoryNone)
@@ -672,7 +670,10 @@ LookupType GuessLookupType(ProgramInfo *pginfo)
 
 LookupType GuessLookupType(MetadataLookup *lookup)
 {
-    LookupType ret = kUnknownVideo;
+    LookupType ret = GuessLookupType(lookup->GetInetref());
+
+    if (ret != kUnknownVideo)
+        return ret;
 
     if (lookup->GetSeason() > 0 || lookup->GetEpisode() > 0 ||
         !lookup->GetSubtitle().isEmpty())
@@ -683,10 +684,28 @@ LookupType GuessLookupType(MetadataLookup *lookup)
     return ret;
 }
 
+LookupType GuessLookupType(VideoMetadata *metadata)
+{
+    LookupType ret = GuessLookupType(metadata->GetInetRef());
+
+    if (ret != kUnknownVideo)
+        return ret;
+
+    if (metadata->GetSeason() > 0 || metadata->GetEpisode() > 0 ||
+        !metadata->GetSubtitle().isEmpty())
+        ret = kProbableTelevision;
+    else
+        ret = kProbableMovie;
+
+    return ret;
+}
 
 LookupType GuessLookupType(RecordingRule *recrule)
 {
-    LookupType ret = kUnknownVideo;
+    LookupType ret = GuessLookupType(recrule->m_inetref);
+
+    if (ret != kUnknownVideo)
+        return ret;
 
     if (recrule->m_season > 0 || recrule->m_episode > 0 ||
         !recrule->m_subtitle.isEmpty())
@@ -697,3 +716,31 @@ LookupType GuessLookupType(RecordingRule *recrule)
     return ret;
 }
 
+LookupType GuessLookupType(const QString &inetref)
+{
+    if (inetref.isEmpty() || inetref == "00000000" ||
+        inetref == MetaGrabberScript::CleanedInetref(inetref))
+    {
+        // can't determine subtype from inetref
+        return kUnknownVideo;
+    }
+
+    // inetref is defined, see if we have a pre-defined grabber
+    MetaGrabberScript grabber =
+        MetaGrabberScript::FromInetref(inetref);
+
+    if (!grabber.IsValid())
+    {
+        return kUnknownVideo;
+    }
+
+    switch (grabber.GetType())
+    {
+        case kGrabberMovie:
+            return kProbableMovie;
+        case kGrabberTelevision:
+            return kProbableTelevision;
+        default:
+            return kUnknownVideo;
+    }
+}
diff --git a/mythtv/libs/libmythmetadata/metadatafactory.h b/mythtv/libs/libmythmetadata/metadatafactory.h
index 54de5d2..ec13335 100644
--- a/mythtv/libs/libmythmetadata/metadatafactory.h
+++ b/mythtv/libs/libmythmetadata/metadatafactory.h
@@ -152,6 +152,8 @@ class META_PUBLIC MetadataFactory : public QObject
 
 META_PUBLIC LookupType GuessLookupType(ProgramInfo *pginfo);
 META_PUBLIC LookupType GuessLookupType(MetadataLookup *lookup);
+META_PUBLIC LookupType GuessLookupType(VideoMetadata *metadata);
 META_PUBLIC LookupType GuessLookupType(RecordingRule *recrule);
+META_PUBLIC LookupType GuessLookupType(const QString& inetref);
 
 #endif
diff --git a/mythtv/libs/libmythmetadata/metadatagrabber.cpp b/mythtv/libs/libmythmetadata/metadatagrabber.cpp
new file mode 100644
index 0000000..64050ea
--- /dev/null
+++ b/mythtv/libs/libmythmetadata/metadatagrabber.cpp
@@ -0,0 +1,595 @@
+// Qt headers
+#include <QMap>
+#include <QDir>
+#include <QMutex>
+#include <QRegExp>
+#include <QDateTime>
+#include <QMutexLocker>
+
+// MythTV headers
+#include "metadatagrabber.h"
+#include "metadatacommon.h"
+#include "mythsystemlegacy.h"
+#include "exitcodes.h"
+#include "mythdate.h"
+#include "mythdirs.h"
+
+#define LOC QString("Metadata Grabber: ")
+#define kGrabberRefresh 60
+
+static GrabberList     grabberList;
+static QMutex          grabberLock;
+static QDateTime       grabberAge;
+
+typedef struct GrabberOpts {
+    QString     path;
+    QString     setting;
+    QString     def;
+} GrabberOpts;
+
+// TODO
+// it would be nice to statically compile these, but I can't manage to get it
+// to compile.  apparently initializer lists are supported in QT5/CPP11 that
+// will make this work.  for now, use a lock and initialize on first access.
+// https://bugreports.qt-project.org/browse/QTBUG-25679
+static QMap<GrabberType, GrabberOpts> grabberTypes;
+static QMap<QString, GrabberType> grabberTypeStrings;
+static bool initialized = false;
+static QMutex typeLock;
+
+static GrabberOpts GrabberOptsMaker (const QString &thepath, const QString &thesetting, const QString &thedefault)
+{
+    GrabberOpts opts;
+
+    opts.path = thepath;
+    opts.setting = thesetting;
+    opts.def = thedefault;
+
+    return opts;
+}
+
+void InitializeStaticMaps(void)
+{
+    if (!initialized)
+    {
+        QMutexLocker lock(&typeLock);
+
+        // double check now that we have the lock
+        if (initialized)
+            return;
+
+        grabberTypes[kGrabberMovie] =
+              GrabberOptsMaker ("%1metadata/Movie/",
+                                "MovieGrabber",
+                                "metadata/Movie/tmdb3.py" );
+        grabberTypes[kGrabberTelevision] =
+             GrabberOptsMaker ( "%1metadata/Television/",
+                                "TelevisionGrabber",
+                                "metadata/Television/ttvdb.py" );
+        grabberTypes[kGrabberGame]       =
+             GrabberOptsMaker ( "%1metadata/Game/",
+                                "mythgame.MetadataGrabber",
+                                "metadata/Game/giantbomb.py" );
+        grabberTypes[kGrabberMusic]      =
+             GrabberOptsMaker ( "%1metadata/Music",
+                                "",
+                                "" );
+
+        grabberTypeStrings["movie"]      = kGrabberMovie;
+        grabberTypeStrings["television"] = kGrabberTelevision;
+        grabberTypeStrings["game"]       = kGrabberGame;
+        grabberTypeStrings["music"]      = kGrabberMusic;
+
+
+        initialized = true;
+    }
+}
+
+GrabberList MetaGrabberScript::GetList(bool refresh)
+{
+    return MetaGrabberScript::GetList(kGrabberAll, refresh);
+}
+
+GrabberList MetaGrabberScript::GetList(const QString &type, bool refresh)
+{
+    QString tmptype = type.toLower();
+    if (!grabberTypeStrings.contains(tmptype))
+        // unknown type, return empty list
+        return GrabberList();
+
+    return MetaGrabberScript::GetList(grabberTypeStrings[tmptype], refresh);
+}
+
+GrabberList MetaGrabberScript::GetList(GrabberType type,
+                                       bool refresh)
+{
+    InitializeStaticMaps();
+
+    GrabberList tmpGrabberList, retGrabberList;
+    {
+        QMutexLocker listLock(&grabberLock);
+        QDateTime now = MythDate::current();
+
+        // refresh grabber scripts every 60 seconds
+        // this might have to be revised, or made more intelligent if
+        // the delay during refreshes is too great
+        if (refresh || !grabberAge.isValid() ||
+            (grabberAge.secsTo(now) > kGrabberRefresh))
+        {
+            grabberList.clear();
+            LOG(VB_GENERAL, LOG_DEBUG, LOC + "Clearing grabber cache");
+
+            // loop through different types of grabber scripts and the 
+            // directories they are stored in
+            QMap<GrabberType, GrabberOpts>::const_iterator it;
+            for (it = grabberTypes.begin(); it != grabberTypes.end(); ++it)
+            {
+                QString path = (it->path).arg(GetShareDir());
+                QStringList scripts = QDir(path).entryList(QDir::Files);
+                if (scripts.count() == 0)
+                    // no scripts found
+                    continue;
+
+                // loop through discovered scripts
+                QStringList::const_iterator it2 = scripts.begin();
+                for (; it2 != scripts.end(); ++it2)
+                {
+                    QString cmd = QString("%1%2").arg(path).arg(*it2);
+                    MetaGrabberScript script(cmd);
+
+                    if (script.IsValid())
+                    {
+                        LOG(VB_GENERAL, LOG_DEBUG, LOC + "Adding " + script.m_command);
+                        grabberList.append(script);
+                    }
+                 }
+            }
+
+            grabberAge = now;
+        }
+
+        tmpGrabberList = grabberList;
+    }
+
+    GrabberList::const_iterator it = tmpGrabberList.begin();
+    for (; it != tmpGrabberList.end(); ++it)
+    {
+        if ((type == kGrabberAll) || (it->GetType() == type))
+            retGrabberList.append(*it);
+    }
+
+    return retGrabberList;
+}
+
+MetaGrabberScript MetaGrabberScript::GetGrabber(GrabberType defaultType,
+                                                const MetadataLookup *lookup)
+{
+    if (!lookup)
+    {
+        return GetType(defaultType);
+    }
+
+    if (!lookup->GetInetref().isEmpty() &&
+        lookup->GetInetref() != "00000000")
+    {
+        // inetref is defined, see if we have a pre-defined grabber
+        MetaGrabberScript grabber = FromInetref(lookup->GetInetref());
+
+        if (grabber.IsValid())
+        {
+            return grabber;
+        }
+        // matching grabber was not found, just use the default
+        // fall through
+    }
+
+    return GetType(defaultType);
+}
+
+MetaGrabberScript MetaGrabberScript::GetType(const QString &type)
+{
+    QString tmptype = type.toLower();
+    if (!grabberTypeStrings.contains(tmptype))
+        // unknown type, return empty grabber
+        return MetaGrabberScript();
+
+    return MetaGrabberScript::GetType(grabberTypeStrings[tmptype]);
+}
+
+MetaGrabberScript MetaGrabberScript::GetType(const GrabberType type)
+{
+    InitializeStaticMaps();
+
+    QString cmd = gCoreContext->GetSetting(grabberTypes[type].setting,
+                                           grabberTypes[type].def);
+
+    if (cmd.isEmpty())
+    {
+        // should the python bindings had not been installed at any stage
+        // the settings could have been set to an empty string, so use default
+        cmd = grabberTypes[type].def;
+    }
+
+    if (grabberAge.isValid() && grabberAge.secsTo(MythDate::current()) <= kGrabberRefresh)
+    {
+        // just pull it from the cache
+        GrabberList list = GetList();
+        GrabberList::const_iterator it = list.begin();
+
+        for (; it != list.end(); ++it)
+            if (it->GetPath().endsWith(cmd))
+                return *it;
+    }
+
+    // polling the cache will cause a refresh, so lets just grab and
+    // process the script directly
+    QString fullcmd = QString("%1%2").arg(GetShareDir()).arg(cmd);
+    MetaGrabberScript script(fullcmd);
+
+    if (script.IsValid())
+    {
+        return script;
+    }
+
+    return MetaGrabberScript();
+}
+
+MetaGrabberScript MetaGrabberScript::FromTag(const QString &tag,
+                                            bool absolute)
+{
+    GrabberList list = GetList();
+    GrabberList::const_iterator it = list.begin();
+
+    // search for direct match on tag
+    for (; it != list.end(); ++it)
+    {
+        if (it->GetCommand() == tag)
+        {
+            return *it;
+        }
+    }
+
+    // no direct match. do we require a direct match? search for one that works
+    if (!absolute)
+    {
+        for (it = list.begin(); it != list.end(); ++it)
+        {
+            if (it->Accepts(tag))
+            {
+                return *it;
+            }
+        }
+    }
+
+    // no working match. return a blank
+    return MetaGrabberScript();
+}
+
+MetaGrabberScript MetaGrabberScript::FromInetref(const QString &inetref,
+                                                 bool absolute)
+{
+    static QRegExp retagref("^([a-zA-Z0-9_\\-\\.]+\\.[a-zA-Z0-9]{1,3})_(.*)");
+    static QRegExp retagref2("^([a-zA-Z0-9_\\-\\.]+\\.[a-zA-Z0-9]{1,3}):(.*)");
+    static QMutex reLock;
+    QMutexLocker lock(&reLock);
+    QString tag;
+
+    if (retagref.indexIn(inetref) > -1)
+    {
+        tag = retagref.cap(1);
+    }
+    else if (retagref2.indexIn(inetref) > -1)
+    {
+        tag = retagref2.cap(1);
+    }
+    if (!tag.isEmpty())
+    {
+        // match found, pull out the grabber
+        MetaGrabberScript script = MetaGrabberScript::FromTag(tag, absolute);
+        if (script.IsValid())
+            return script;
+    }
+
+    // no working match, return a blank
+    return MetaGrabberScript();
+}
+
+QString MetaGrabberScript::CleanedInetref(const QString &inetref)
+{
+    static QRegExp retagref("^([a-zA-Z0-9_\\-\\.]+\\.[a-zA-Z0-9]{1,3})_(.*)");
+    static QRegExp retagref2("^([a-zA-Z0-9_\\-\\.]+\\.[a-zA-Z0-9]{1,3}):(.*)");
+    static QMutex reLock;
+    QMutexLocker lock(&reLock);
+
+    // try to strip grabber tag from inetref
+    if (retagref.indexIn(inetref) > -1)
+        return retagref.cap(2);
+    if (retagref2.indexIn(inetref) > -1)
+        return retagref2.cap(2);
+
+    return inetref;
+}
+
+MetaGrabberScript::MetaGrabberScript(void) :
+    m_name(""), m_author(""), m_thumbnail(""), m_fullcommand(""), m_command(""),
+    m_type(kGrabberInvalid), m_typestring(""), m_description(""), m_accepts(),
+    m_version(0.0), m_valid(false)
+{
+}
+
+MetaGrabberScript::MetaGrabberScript(const QString &path,
+                                     const QDomElement &dom) :
+    m_valid(false)
+{
+    m_fullcommand = path;
+    ParseGrabberVersion(dom);
+}
+
+MetaGrabberScript::MetaGrabberScript(const QDomElement &dom) :
+    m_valid(false)
+{
+    ParseGrabberVersion(dom);
+    
+}
+
+MetaGrabberScript::MetaGrabberScript(const QString &path) :
+    m_valid(false)
+{
+    if (path.isEmpty())
+        return;
+    m_fullcommand = path;
+    if (path[0] != '/')
+        m_fullcommand.prepend(QString("%1metadata").arg(GetShareDir()));
+
+    MythSystemLegacy grabber(path, QStringList() << "-v",
+                             kMSRunShell | kMSStdOut);
+    grabber.Run();
+    if (grabber.Wait() != GENERIC_EXIT_OK)
+        // script failed
+        return;
+
+    QByteArray result = grabber.ReadAll();
+    if (result.isEmpty())
+        // no output
+        return;
+
+    QDomDocument doc;
+    doc.setContent(result, true);
+    QDomElement root = doc.documentElement();
+    if (root.isNull())
+        // no valid XML
+        return;
+
+    ParseGrabberVersion(root);
+    if (m_name.isEmpty())
+        // XML not processed correctly
+        return;
+
+    m_valid = true;
+}
+
+MetaGrabberScript::MetaGrabberScript(const MetaGrabberScript &other) :
+    m_name(other.m_name), m_author(other.m_author),
+    m_thumbnail(other.m_thumbnail), m_fullcommand(other.m_fullcommand),
+    m_command(other.m_command), m_type(other.m_type),
+    m_typestring(other.m_typestring), m_description(other.m_description),
+    m_accepts(other.m_accepts), m_version(other.m_version),
+    m_valid(other.m_valid)
+{
+}
+
+MetaGrabberScript& MetaGrabberScript::operator=(const MetaGrabberScript &other)
+{
+    if (this != &other)
+    {
+        m_name = other.m_name;
+        m_author = other.m_author;
+        m_thumbnail = other.m_thumbnail;
+        m_command = other.m_command;
+        m_fullcommand = other.m_fullcommand;
+        m_type = other.m_type;
+        m_typestring = other.m_typestring;
+        m_description = other.m_description;
+        m_accepts = other.m_accepts;
+        m_version = other.m_version;
+        m_valid = other.m_valid;
+    }
+
+    return *this;
+}
+
+
+void MetaGrabberScript::ParseGrabberVersion(const QDomElement &item)
+{
+    m_name          = item.firstChildElement("name").text();
+    m_author        = item.firstChildElement("author").text();
+    m_thumbnail     = item.firstChildElement("thumbnail").text();
+    m_command       = item.firstChildElement("command").text();
+    m_description   = item.firstChildElement("description").text();
+    m_version       = item.firstChildElement("version").text().toFloat();
+    m_typestring    = item.firstChildElement("type").text().toLower();
+
+    if (!m_typestring.isEmpty() && grabberTypeStrings.contains(m_typestring))
+        m_type = grabberTypeStrings[m_typestring];
+    else
+        m_type = kGrabberMovie;
+
+    QDomElement accepts = item.firstChildElement("accepts");
+    if (!accepts.isNull())
+    {
+        while (!accepts.isNull())
+        {
+            m_accepts.append(accepts.text());
+            accepts = accepts.nextSiblingElement("accepts");
+        }
+    }
+}
+
+bool MetaGrabberScript::Test(void)
+{
+    if (!m_valid || m_fullcommand.isEmpty())
+        return false;
+
+    QStringList args; args << "-t";
+    MythSystemLegacy grabber(m_fullcommand, args, kMSStdOut);
+
+    grabber.Run();
+    if (grabber.Wait() != GENERIC_EXIT_OK)
+        return false;
+
+    return true;
+}
+
+// TODO
+// using the MetadataLookup object as both argument input, and parsed output,
+// is clumsy. break the inputs out into a separate object, and spawn a new
+// MetadataLookup object in ParseMetadataItem, rather than requiring an
+// existing one to reuse.
+MetadataLookupList MetaGrabberScript::RunGrabber(const QStringList &args,
+                        MetadataLookup *lookup, bool passseas)
+{
+    MythSystemLegacy grabber(m_fullcommand, args, kMSStdOut);
+    MetadataLookupList list;
+
+    LOG(VB_GENERAL, LOG_INFO, QString("Running Grabber: %1 %2")
+        .arg(m_fullcommand).arg(args.join(" ")));
+
+    grabber.Run();
+    if (grabber.Wait() != GENERIC_EXIT_OK)
+        return list;
+
+    QByteArray result = grabber.ReadAll();
+    if (!result.isEmpty())
+    {
+        QDomDocument doc;
+        doc.setContent(result, true);
+        QDomElement root = doc.documentElement();
+        QDomElement item = root.firstChildElement("item");
+
+        while (!item.isNull())
+        {
+            MetadataLookup *tmp = ParseMetadataItem(item, lookup, passseas);
+            tmp->SetInetref(QString("%1_%2").arg(m_command)
+                                            .arg(tmp->GetInetref()));
+            if (!tmp->GetCollectionref().isEmpty())
+            {
+                tmp->SetCollectionref(QString("%1_%2").arg(m_command)
+                                .arg(tmp->GetCollectionref()));
+            }
+            list.append(tmp);
+            // MetadataLookup is to be owned by the list
+            tmp->DecrRef();
+            item = item.nextSiblingElement("item");
+        }
+    }
+    return list;
+}
+
+QString MetaGrabberScript::GetRelPath(void) const
+{
+    QString share = GetShareDir();
+    if (m_fullcommand.startsWith(share))
+        return m_fullcommand.right(m_fullcommand.size() - share.size());
+
+    return QString();
+}
+
+void MetaGrabberScript::toMap(InfoMap &metadataMap) const
+{
+    metadataMap["name"] = m_name;
+    metadataMap["author"] = m_author;
+    metadataMap["thumbnailfilename"] = m_thumbnail;
+    metadataMap["command"] = m_command;
+    metadataMap["description"] = m_description;
+    metadataMap["version"] = QString::number(m_version);
+    metadataMap["type"] = m_typestring;
+}
+
+void MetaGrabberScript::SetDefaultArgs(QStringList &args)
+{
+    args << "-l"
+         << gCoreContext->GetLanguage()
+         << "-a"
+         << gCoreContext->GetLocale()->GetCountryCode();
+}
+
+MetadataLookupList MetaGrabberScript::Search(const QString &title,
+                        MetadataLookup *lookup, bool passseas)
+{
+    QStringList args;
+    SetDefaultArgs(args);
+
+    args << "-M"
+         << title;
+
+    return RunGrabber(args, lookup, passseas);
+}
+
+MetadataLookupList MetaGrabberScript::SearchSubtitle(const QString &title,
+                        const QString &subtitle, MetadataLookup *lookup,
+                        bool passseas)
+{
+    QStringList args;
+    SetDefaultArgs(args);
+
+    args << "-N"
+         << title
+         << subtitle;
+
+    return RunGrabber(args, lookup, passseas);
+}
+
+MetadataLookupList MetaGrabberScript::SearchSubtitle(const QString &inetref,
+                        const QString &title, const QString &subtitle,
+                        MetadataLookup *lookup, bool passseas)
+{
+    (void)title;
+    QStringList args;
+    SetDefaultArgs(args);
+
+    args << "-N"
+         << CleanedInetref(inetref)
+         << subtitle;
+
+    return RunGrabber(args, lookup, passseas);
+}
+
+MetadataLookupList MetaGrabberScript::LookupData(const QString &inetref,
+                        MetadataLookup *lookup, bool passseas)
+{
+    QStringList args;
+    SetDefaultArgs(args);
+
+    args << "-D"
+         << CleanedInetref(inetref);
+
+    return RunGrabber(args, lookup, passseas);
+}
+
+MetadataLookupList MetaGrabberScript::LookupData(const QString &inetref,
+                        int season, int episode, MetadataLookup *lookup,
+                        bool passseas)
+{
+    QStringList args;
+    SetDefaultArgs(args);
+
+    args << "-D"
+         << CleanedInetref(inetref)
+         << QString::number(season)
+         << QString::number(episode);
+
+    return RunGrabber(args, lookup, passseas);
+}
+
+MetadataLookupList MetaGrabberScript::LookupCollection(
+                        const QString &collectionref, MetadataLookup *lookup,
+                        bool passseas)
+{
+    QStringList args;
+    SetDefaultArgs(args);
+
+    args << "-C"
+         << CleanedInetref(collectionref);
+
+    return RunGrabber(args, lookup, passseas);
+}
diff --git a/mythtv/libs/libmythmetadata/metadatagrabber.h b/mythtv/libs/libmythmetadata/metadatagrabber.h
new file mode 100644
index 0000000..0a54d39
--- /dev/null
+++ b/mythtv/libs/libmythmetadata/metadatagrabber.h
@@ -0,0 +1,100 @@
+#ifndef METADATAGRABBER_H_
+#define METADATAGRABBER_H_
+
+#include <QList>
+#include <QString>
+#include <QVariant>
+#include <QStringList>
+#include <QDomDocument>
+
+#include "mythtypes.h"
+#include "mythmetaexp.h"
+//#include "metadatacommon.h"
+#include "referencecounterlist.h"
+class MetadataLookup;
+typedef RefCountedList<MetadataLookup> MetadataLookupList;
+
+class MetaGrabberScript;
+typedef QList<MetaGrabberScript> GrabberList;
+
+enum GrabberType {
+    kGrabberAll,
+    kGrabberMovie,
+    kGrabberTelevision,
+    kGrabberMusic,
+    kGrabberGame,
+    kGrabberInvalid
+};
+
+class META_PUBLIC MetaGrabberScript : public QObject
+{
+  public:
+    MetaGrabberScript();
+    MetaGrabberScript(const QDomElement &dom);
+    MetaGrabberScript(const QString &path);
+    MetaGrabberScript(const QString &path, const QDomElement &dom);
+    MetaGrabberScript(const MetaGrabberScript &other);
+
+    MetaGrabberScript& operator=(const MetaGrabberScript &other);
+
+    static GrabberList          GetList(bool refresh=false);
+    static GrabberList          GetList(const QString &type, bool refresh=false);
+    static GrabberList          GetList(GrabberType type,
+                                        bool refresh=false);
+
+    static MetaGrabberScript    GetGrabber(GrabberType defaultType,
+                                           const MetadataLookup *lookup = NULL);
+    static MetaGrabberScript    GetType(const QString &type);
+    static MetaGrabberScript    GetType(GrabberType type);
+    static MetaGrabberScript    FromTag(const QString &tag,
+                                        bool absolute=false);
+    static MetaGrabberScript    FromInetref(const QString &inetref,
+                                            bool absolute=false);
+    static QString              CleanedInetref(const QString &inetref);
+
+    bool          IsValid(void) const         { return m_valid; }
+
+    QString       GetCommand(void) const      { return m_command; }
+    QString       GetRelPath(void) const;
+    QString       GetPath(void) const         { return m_fullcommand; }
+
+    QString       GetName(void) const         { return m_name; }
+    QString       GetAuthor(void) const       { return m_author; }
+    QString       GetThumbnail(void) const    { return m_thumbnail; }
+    GrabberType   GetType(void) const         { return m_type; }
+    QString       GetTypeString(void) const   { return m_typestring; }
+    QString       GetDescription(void) const  { return m_description; }
+
+    bool Accepts(const QString &tag) const { return m_accepts.contains(tag); }
+
+    void          toMap(InfoMap &metadataMap) const;
+
+    bool                Test(void);
+    MetadataLookupList  Search(const QString &title, MetadataLookup *lookup, bool passseas=true);
+    MetadataLookupList  SearchSubtitle(const QString &title, const QString &subtitle, MetadataLookup *lookup, bool passseas=true);
+    MetadataLookupList  SearchSubtitle(const QString &inetref, const QString &title, const QString &subtitle, MetadataLookup *lookup, bool passseas=true);
+    MetadataLookupList  LookupData(const QString &inetref, MetadataLookup *lookup, bool passseas=true);
+    MetadataLookupList  LookupData(const QString &inetref, int season, int episode, MetadataLookup *lookup, bool passseas=true);
+    MetadataLookupList  LookupCollection(const QString &collectionref, MetadataLookup *lookup, bool passseas=true);
+
+  private:
+    QString m_name;
+    QString m_author;
+    QString m_thumbnail;
+    QString m_fullcommand;
+    QString m_command;
+    GrabberType m_type;
+    QString m_typestring;
+    QString m_description;
+    QStringList m_accepts;
+    float m_version;
+    bool m_valid;
+
+    void ParseGrabberVersion(const QDomElement &item);
+    MetadataLookupList RunGrabber(const QStringList &args, MetadataLookup *lookup, bool passseas);
+    void SetDefaultArgs(QStringList &args);
+};
+
+Q_DECLARE_METATYPE(MetaGrabberScript*)
+
+#endif // METADATAGRABBER_H_
diff --git a/mythtv/libs/libmythmetadata/metadataimagedownload.cpp b/mythtv/libs/libmythmetadata/metadataimagedownload.cpp
index fb31810..96410c9 100644
--- a/mythtv/libs/libmythmetadata/metadataimagedownload.cpp
+++ b/mythtv/libs/libmythmetadata/metadataimagedownload.cpp
@@ -143,14 +143,16 @@ void MetadataImageDownload::run()
                 QString path = getLocalWritePath(lookup->GetType(), type);
                 QDir dirPath(path);
                 if (!dirPath.exists())
+                {
                     if (!dirPath.mkpath(path))
                     {
                         LOG(VB_GENERAL, LOG_ERR,
                             QString("Metadata Image Download: Unable to create "
                                     "path %1, aborting download.").arg(path));
                         errored = true;
-                        continue;
+                        break;
                     }
+                }
                 QString finalfile = path + "/" + filename;
                 QString oldurl = info.url;
                 info.url = finalfile;
@@ -167,29 +169,27 @@ void MetadataImageDownload::run()
                     LOG(VB_GENERAL, LOG_INFO,
                         QString("Metadata Image Download: %1 ->%2")
                          .arg(oldurl).arg(finalfile));
-                    QByteArray *download = new QByteArray();
-                    GetMythDownloadManager()->download(oldurl, download);
+                    QByteArray download;
+                    GetMythDownloadManager()->download(oldurl, &download);
 
                     QImage testImage;
-                    bool didLoad = testImage.loadFromData(*download);
+                    bool didLoad = testImage.loadFromData(download);
                     if (!didLoad)
                     {
                         LOG(VB_GENERAL, LOG_ERR,
                             QString("Tried to write %1, but it appears to be "
                                     "an HTML redirect (filesize %2).")
-                                .arg(oldurl).arg(download->size()));
-                        delete download;
-                        download = NULL;
+                                .arg(oldurl).arg(download.size()));
                         errored = true;
-                        continue;
+                        break;
                     }
 
                     if (dest_file.open(QIODevice::WriteOnly))
                     {
-                        off_t size = dest_file.write(*download,
-                                                     download->size());
+                        off_t size = dest_file.write(download,
+                                                     download.size());
                         dest_file.close();
-                        if (size != download->size())
+                        if (size != download.size())
                         {
                             // File creation failed for some reason, delete it
                             RemoteFile::DeleteFile(finalfile);
@@ -197,15 +197,10 @@ void MetadataImageDownload::run()
                                 QString("Image Download: Error Writing Image "
                                         "to file: %1").arg(finalfile));
                             errored = true;
+                            break;
                         }
-                        else
-                            downloaded.insert(type, info);
                     }
-
-                    delete download;
                 }
-                else
-                    downloaded.insert(type, info);
             }
             else
             {
@@ -216,12 +211,13 @@ void MetadataImageDownload::run()
                 bool exists = false;
                 bool onMaster = false;
                 QString resolvedFN;
-                if ((lookup->GetHost().toLower() == gCoreContext->GetHostName().toLower()) ||
-                    (gCoreContext->IsThisHost(lookup->GetHost())))
+                if (gCoreContext->IsMasterBackend() &&
+                    ((lookup->GetHost().toLower() == gCoreContext->GetHostName().toLower()) ||
+                     gCoreContext->IsThisHost(lookup->GetHost())))
                 {
-                    StorageGroup sg;
+                    StorageGroup sg(getStorageGroupName(type), lookup->GetHost());
                     resolvedFN = sg.FindFile(filename);
-                    exists = QFile::exists(resolvedFN);
+                    exists = !resolvedFN.isEmpty() && QFile::exists(resolvedFN);
                     if (!exists)
                     {
                         resolvedFN = getLocalStorageGroupPath(type,
@@ -234,7 +230,6 @@ void MetadataImageDownload::run()
 
                 if (!exists || lookup->GetAllowOverwrites())
                 {
-
                     if (exists && !onMaster)
                     {
                         QFileInfo fi(finalfile);
@@ -247,56 +242,48 @@ void MetadataImageDownload::run()
                     LOG(VB_GENERAL, LOG_INFO,
                         QString("Metadata Image Download: %1 -> %2")
                             .arg(oldurl).arg(finalfile));
-                    QByteArray *download = new QByteArray();
-                    GetMythDownloadManager()->download(oldurl, download);
+                    QByteArray download;
+                    GetMythDownloadManager()->download(oldurl, &download);
 
                     QImage testImage;
-                    bool didLoad = testImage.loadFromData(*download);
+                    bool didLoad = testImage.loadFromData(download);
                     if (!didLoad)
                     {
                         LOG(VB_GENERAL, LOG_ERR,
                             QString("Tried to write %1, but it appears to be "
                                     "an HTML redirect or corrupt file "
                                     "(filesize %2).")
-                                .arg(oldurl).arg(download->size()));
-                        delete download;
-                        download = NULL;
+                                .arg(oldurl).arg(download.size()));
                         errored = true;
-                        continue;
+                        break;
                     }
 
                     if (!onMaster)
                     {
-                        RemoteFile *outFile = new RemoteFile(finalfile, true);
-                        if (!outFile->isOpen())
+                        RemoteFile outFile(finalfile, true);
+
+                        if (!outFile.isOpen())
                         {
                             LOG(VB_GENERAL, LOG_ERR,
                                 QString("Image Download: Failed to open "
                                         "remote file (%1) for write.  Does "
                                         "Storage Group Exist?")
                                         .arg(finalfile));
-                            delete outFile;
-                            outFile = NULL;
                             errored = true;
+                            break;
                         }
-                        else
+                        off_t written = outFile.Write(download,
+                                                      download.size());
+                        if (written != download.size())
                         {
-                            off_t written = outFile->Write(*download,
-                                                           download->size());
-                            delete outFile;
-                            outFile = NULL;
-                            if (written != download->size())
-                            {
-                                // File creation failed for some reason, delete it
-                                RemoteFile::DeleteFile(finalfile);
+                            // File creation failed for some reason, delete it
+                            RemoteFile::DeleteFile(finalfile);
 
-                                LOG(VB_GENERAL, LOG_ERR,
-                                    QString("Image Download: Error Writing Image "
-                                            "to file: %1").arg(finalfile));
-                                errored = true;
-                            }
-                            else
-                                downloaded.insert(type, info);
+                            LOG(VB_GENERAL, LOG_ERR,
+                                QString("Image Download: Error Writing Image "
+                                        "to file: %1").arg(finalfile));
+                            errored = true;
+                            break;
                         }
                     }
                     else
@@ -304,10 +291,10 @@ void MetadataImageDownload::run()
                         QFile dest_file(resolvedFN);
                         if (dest_file.open(QIODevice::WriteOnly))
                         {
-                            off_t size = dest_file.write(*download,
-                                                         download->size());
+                            off_t size = dest_file.write(download,
+                                                         download.size());
                             dest_file.close();
-                            if (size != download->size())
+                            if (size != download.size())
                             {
                                 // File creation failed for some reason, delete it
                                 RemoteFile::DeleteFile(resolvedFN);
@@ -315,22 +302,24 @@ void MetadataImageDownload::run()
                                     QString("Image Download: Error Writing Image "
                                             "to file: %1").arg(finalfile));
                                 errored = true;
+                                break;
                             }
-                            else
-                                downloaded.insert(type, info);
                         }
                     }
-
-                    delete download;
                 }
-                else
-                    downloaded.insert(type, info);
+            }
+            if (!errored)
+            {
+                // update future Artwork Map with what we've successfully
+                // retrieved (either downloaded or already existing
+                downloaded.insert(type, info);
             }
         }
         if (errored)
         {
             QCoreApplication::postEvent(m_parent,
                     new ImageDLFailureEvent(lookup));
+            errored = false;
         }
         lookup->SetDownloads(downloaded);
         QCoreApplication::postEvent(m_parent, new ImageDLEvent(lookup));
@@ -388,7 +377,7 @@ QString getDownloadFilename(VideoArtworkType type, MetadataLookup *lookup,
     uint season = lookup->GetSeason();
     uint episode = lookup->GetEpisode();
     QString system = lookup->GetSystem();
-    if (season > 0 || episode > 0)
+    if (!lookup->GetIsCollection() && (season > 0 || episode > 0))
     {
         title = lookup->GetTitle();
         if (title.contains("/"))
@@ -472,21 +461,10 @@ QString getLocalWritePath(MetadataType metadatatype, VideoArtworkType type)
 
 QString getStorageGroupURL(VideoArtworkType type, QString host)
 {
-    QString sgroup;
+    QString sgroup = getStorageGroupName(type);
     QString ip = gCoreContext->GetBackendServerIP(host);
     uint port = gCoreContext->GetBackendServerPort(host);
 
-    if (type == kArtworkCoverart)
-        sgroup = "Coverart";
-    else if (type == kArtworkFanart)
-        sgroup = "Fanart";
-    else if (type == kArtworkBanner)
-        sgroup = "Banners";
-    else if (type == kArtworkScreenshot)
-        sgroup = "Screenshots";
-    else
-        sgroup = "Default";
-
     return gCoreContext->GenMythURL(ip,port,"",sgroup);
 }
 
@@ -494,24 +472,30 @@ QString getLocalStorageGroupPath(VideoArtworkType type, QString host)
 {
     QString path;
 
-    StorageGroup sg;
-
-    if (type == kArtworkCoverart)
-        sg.Init("Coverart", host);
-    else if (type == kArtworkFanart)
-        sg.Init("Fanart", host);
-    else if (type == kArtworkBanner)
-        sg.Init("Banners", host);
-    else if (type == kArtworkScreenshot)
-        sg.Init("Screenshots", host);
-    else
-        sg.Init("Default", host);
+    StorageGroup sg(getStorageGroupName(type), host);
 
     path = sg.FindNextDirMostFree();
 
     return path;
 }
 
+QString getStorageGroupName(VideoArtworkType type)
+{
+    switch (type)
+    {
+        case kArtworkCoverart:
+            return "Coverart";
+        case kArtworkFanart:
+            return "Fanart";
+        case kArtworkBanner:
+            return "Banners";
+        case kArtworkScreenshot:
+            return "Screenshots";
+        default:
+            return "Default";
+    }
+}
+
 void cleanThumbnailCacheDir()
 {
     QString cache = QString("%1/thumbcache")
diff --git a/mythtv/libs/libmythmetadata/metadataimagedownload.h b/mythtv/libs/libmythmetadata/metadataimagedownload.h
index aa9073f..6fe3ed5 100644
--- a/mythtv/libs/libmythmetadata/metadataimagedownload.h
+++ b/mythtv/libs/libmythmetadata/metadataimagedownload.h
@@ -115,6 +115,7 @@ META_PUBLIC QString getDownloadFilename(VideoArtworkType type, MetadataLookup *l
 META_PUBLIC QString getLocalWritePath(MetadataType metadatatype, VideoArtworkType type);
 META_PUBLIC QString getStorageGroupURL(VideoArtworkType type, QString host);
 META_PUBLIC QString getLocalStorageGroupPath(VideoArtworkType type, QString host);
+META_PUBLIC QString getStorageGroupName(VideoArtworkType type);
 
 META_PUBLIC void cleanThumbnailCacheDir(void);
 
diff --git a/mythtv/libs/libmythmetadata/videometadata.cpp b/mythtv/libs/libmythmetadata/videometadata.cpp
index 4dabcd3..309e271 100644
--- a/mythtv/libs/libmythmetadata/videometadata.cpp
+++ b/mythtv/libs/libmythmetadata/videometadata.cpp
@@ -1066,19 +1066,20 @@ int VideoMetadata::UpdateHashedDBRecord(const QString &hash,
 QString VideoMetadata::VideoFileHash(const QString &file_name,
                            const QString &host)
 {
-    if (!host.isEmpty() && !gCoreContext->IsMasterHost(host))
-    {
-        QString url = generate_file_url("Videos", host, file_name);
-        return RemoteFile::GetFileHash(url);
-    }
-    else if (!host.isEmpty())
+    if (host.isEmpty())
+        return FileHash(file_name);
+
+    if (gCoreContext->IsMasterBackend() && gCoreContext->IsThisHost(host))
     {
         StorageGroup sgroup("Videos", host);
         QString fullname = sgroup.FindFile(file_name);
+
         return FileHash(fullname);
     }
-    else
-        return FileHash(file_name);
+
+    QString url = generate_file_url("Videos", host, file_name);
+
+    return RemoteFile::GetFileHash(url);
 }
 
 QString VideoMetadata::FilenameToMeta(const QString &file_name, int position)
diff --git a/mythtv/libs/libmythprotoserver/requesthandler/fileserverhandler.cpp b/mythtv/libs/libmythprotoserver/requesthandler/fileserverhandler.cpp
index a5cfa9d..02753fb 100644
--- a/mythtv/libs/libmythprotoserver/requesthandler/fileserverhandler.cpp
+++ b/mythtv/libs/libmythprotoserver/requesthandler/fileserverhandler.cpp
@@ -665,7 +665,8 @@ bool FileServerHandler::HandleQueryFileHash(SocketHandler *socket,
 
     QString hash = "";
 
-    if (hostname == gCoreContext->GetHostName())
+    if (hostname == gCoreContext->GetHostName() ||
+        gCoreContext->IsThisHost(hostname))
     {
         // looking for file on me, return directly
         StorageGroup sgroup(storageGroup, gCoreContext->GetHostName());
diff --git a/mythtv/libs/libmythtv/avformatdecoder.cpp b/mythtv/libs/libmythtv/avformatdecoder.cpp
index 3129536..6a975af 100644
--- a/mythtv/libs/libmythtv/avformatdecoder.cpp
+++ b/mythtv/libs/libmythtv/avformatdecoder.cpp
@@ -10,6 +10,7 @@
 using namespace std;
 
 #include <QTextCodec>
+#include <QFileInfo>
 
 // MythTV headers
 #include "mythtvexp.h"
@@ -845,7 +846,26 @@ void AvFormatDecoder::SeekReset(long long newKey, uint skipFrames,
     }
 
     // Skip all the desired number of skipFrames
-    for (;skipFrames > 0 && !ateof; skipFrames--)
+
+    // Some seeks can be very slow.  The most common example comes
+    // from HD-PVR recordings, where keyframes are 128 frames apart
+    // and decoding (even hardware decoding) may not be much faster
+    // than realtime, causing some exact seeks to take 2-4 seconds.
+    // If exact seeking is not required, we take some shortcuts.
+    // First, we impose an absolute maximum time we are willing to
+    // spend (maxSeekTimeMs) on the forward frame-by-frame skip.
+    // After that much time has elapsed, we give up and stop the
+    // frame-by-frame seeking.  Second, after skipping a few frames,
+    // we predict whether the situation is hopeless, i.e. the total
+    // skipping would take longer than giveUpPredictionMs, and if so,
+    // stop skipping right away.
+    bool exactSeeks = !GetSeekSnap();
+    const int maxSeekTimeMs = 200;
+    int profileFrames = 0;
+    MythTimer begin(MythTimer::kStartRunning);
+    for (; (skipFrames > 0 && !ateof &&
+            (exactSeeks || begin.elapsed() < maxSeekTimeMs));
+         --skipFrames, ++profileFrames)
     {
         GetFrame(kDecodeVideo);
         if (decoded_video_frame)
@@ -853,6 +873,19 @@ void AvFormatDecoder::SeekReset(long long newKey, uint skipFrames,
             m_parent->DiscardVideoFrame(decoded_video_frame);
             decoded_video_frame = NULL;
         }
+        if (!exactSeeks && profileFrames >= 5 && profileFrames < 10)
+        {
+            const int giveUpPredictionMs = 400;
+            int remainingTimeMs =
+                skipFrames * (float)begin.elapsed() / profileFrames;
+            if (remainingTimeMs > giveUpPredictionMs)
+            {
+              LOG(VB_PLAYBACK, LOG_DEBUG,
+                  QString("Frame-by-frame seeking would take "
+                          "%1 ms to finish, skipping.").arg(remainingTimeMs));
+              break;
+            }
+        }
     }
 
     if (doflush)
@@ -1214,6 +1247,17 @@ int AvFormatDecoder::OpenFile(RingBuffer *rbuffer, bool novideo,
         av_update_stream_timings_video(ic);
     }
 
+    // FLAC, MP3 or M4A file may contains an artwork image, a single frame MJPEG,
+    // we need to ignore it as we don't handle single frames or images in place of video
+    // TODO: display single frame
+    QString extension = QFileInfo(fnames).suffix();
+    if (!strcmp(fmt->name, "mp3") || !strcmp(fmt->name, "flac") ||
+        !strcmp(fmt->name, "ogg") ||
+        !extension.compare("m4a", Qt::CaseInsensitive))
+    {
+        novideo = true;
+    }
+
     // Scan for the initial A/V streams
     int ret = ScanStreams(novideo);
     if (-1 == ret)
@@ -3430,6 +3474,8 @@ int AvFormatDecoder::H264PreProcessPkt(AVStream *stream, AVPacket *pkt)
                     (enc->codec) && (enc->thread_count>1))
                 {
                     QMutexLocker locker(avcodeclock);
+                    // flush all buffers
+                    avcodec_flush_buffers(enc);
                     const AVCodec *codec = enc->codec;
                     avcodec_close(enc);
                     int open_val = avcodec_open2(enc, codec, NULL);
diff --git a/mythtv/libs/libmythtv/cc608decoder.cpp b/mythtv/libs/libmythtv/cc608decoder.cpp
index e055718..f9768c1 100644
--- a/mythtv/libs/libmythtv/cc608decoder.cpp
+++ b/mythtv/libs/libmythtv/cc608decoder.cpp
@@ -844,7 +844,7 @@ int CC608Decoder::NewRowCC(int mode, int len)
     lastrow[mode] = newrow[mode];
     newrow[mode] = 0;
 
-    int limit = (newattr[mode] ? newcol[mode] - 1 : newcol[mode]);
+    int limit = newcol[mode];
     for (int x = 0; x < limit; x++)
     {
         ccbuf[mode] += ' ';
diff --git a/mythtv/libs/libmythtv/cc708reader.cpp b/mythtv/libs/libmythtv/cc708reader.cpp
index 877930d..8f645f0 100644
--- a/mythtv/libs/libmythtv/cc708reader.cpp
+++ b/mythtv/libs/libmythtv/cc708reader.cpp
@@ -276,7 +276,7 @@ void CC708Reader::Reset(uint service_num)
 {
     CHECKENABLED;
     LOG(VB_VBI, LOG_INFO, LOC + QString("Reset(%1)").arg(service_num));
-    DeleteWindows(service_num, 0x7);
+    DeleteWindows(service_num, 0xff);
     DelayCancel(service_num);
 }
 
diff --git a/mythtv/libs/libmythtv/channelscan/channelscan_sm.cpp b/mythtv/libs/libmythtv/channelscan/channelscan_sm.cpp
index 3f02209..568246a 100644
--- a/mythtv/libs/libmythtv/channelscan/channelscan_sm.cpp
+++ b/mythtv/libs/libmythtv/channelscan/channelscan_sm.cpp
@@ -36,6 +36,7 @@ using namespace std;
 
 // Qt includes
 #include <QObject>
+#include <QMutexLocker>
 
 // MythTV includes - General
 #include "channelscan_sm.h"
@@ -741,6 +742,8 @@ void ChannelScanSM::UpdateScanTransports(const NetworkInformationTable *nit)
 
 bool ChannelScanSM::UpdateChannelInfo(bool wait_until_complete)
 {
+    QMutexLocker locker(&m_mutex);
+
     if (current == scanTransports.end())
         return true;
 
@@ -1044,10 +1047,20 @@ static void update_info(ChannelInsertInfo &info,
                         const ServiceDescriptionTable *sdt, uint i,
                         const QMap<uint64_t, QString> &defAuthorities)
 {
-    // HACK beg -- special exception for this network
+    // HACK beg -- special exception for these networks
+    // this enables useonairguide by default for all matching channels
     //             (dbver == "1067")
-    bool force_guide_present = (sdt->OriginalNetworkID() == 70);
-    // HACK end -- special exception for this network
+    bool force_guide_present = (
+        // Telenor (NO)
+        (sdt->OriginalNetworkID() ==    70) ||
+#if 0 // #9592#comment:23 - meanwhile my provider changed his signaling
+        // Kabelplus (AT) formerly Kabelsignal, registered to NDS, see #9592
+        (sdt->OriginalNetworkID() ==   222) ||
+#endif
+        // ERT (GR) from the private temporary allocation, see #9592:comment:17
+        (sdt->OriginalNetworkID() == 65330)
+    );
+    // HACK end -- special exception for these networks
 
     // Figure out best service name and callsign...
     ServiceDescriptor *desc = sdt->GetServiceDescriptor(i);
diff --git a/mythtv/libs/libmythtv/channelscan/channelscan_sm.h b/mythtv/libs/libmythtv/channelscan/channelscan_sm.h
index 813113a..5504fa2 100644
--- a/mythtv/libs/libmythtv/channelscan/channelscan_sm.h
+++ b/mythtv/libs/libmythtv/channelscan/channelscan_sm.h
@@ -37,6 +37,7 @@
 #include <QPair>
 #include <QMap>
 #include <QSet>
+#include <QMutex>
 
 // MythTV includes
 #include "frequencytables.h"
@@ -248,6 +249,7 @@ class ChannelScanSM : public MPEGStreamListener,
 
     /// Scanner thread, runs ChannelScanSM::run()
     MThread          *scannerThread;
+    QMutex           m_mutex;
 };
 
 inline void ChannelScanSM::UpdateScanPercentCompleted(void)
diff --git a/mythtv/libs/libmythtv/eitcache.cpp b/mythtv/libs/libmythtv/eitcache.cpp
index c087d9c..ae7c98d 100644
--- a/mythtv/libs/libmythtv/eitcache.cpp
+++ b/mythtv/libs/libmythtv/eitcache.cpp
@@ -274,14 +274,14 @@ void EITCache::WriteChannelToDB(QStringList &value_clauses, uint chanid)
                 updated++;
                 *it &= ~(uint64_t)0 >> 1; // mark as synced
             }
+            ++it;
         }
         else
         {
             // Event is too old; remove from eit cache in memory
-            eventMap->remove(it.key());
+            it = eventMap->erase(it);
             removed++;
         }
-        ++it;
     }
     unlock_channel(chanid, updated);
 
diff --git a/mythtv/libs/libmythtv/eitfixup.cpp b/mythtv/libs/libmythtv/eitfixup.cpp
index 7ed15b2..78a20ac 100644
--- a/mythtv/libs/libmythtv/eitfixup.cpp
+++ b/mythtv/libs/libmythtv/eitfixup.cpp
@@ -42,7 +42,7 @@ EITFixUp::EITFixUp()
       m_ukSpaceColonStart("^[ |:]*"),
       m_ukSpaceStart("^ "),
       m_ukSeries("\\s*\\(?\\s*(?:Episode|Part|Pt)?\\s*(\\d{1,2})\\s*(?:of|/)\\s*(\\d{1,2})\\s*\\)?\\s*(?:\\.|:)?", Qt::CaseInsensitive),
-      m_ukCC("\\[(?:(AD|SL|S|W),?)+\\]"),
+      m_ukCC("\\[(?:(AD|SL|S|W|HD),?)+\\]"),
       m_ukYear("[\\[\\(]([\\d]{4})[\\)\\]]"),
       m_uk24ep("^\\d{1,2}:00[ap]m to \\d{1,2}:00[ap]m: "),
       m_ukStarring("(?:Western\\s)?[Ss]tarring ([\\w\\s\\-']+)[Aa]nd\\s([\\w\\s\\-']+)[\\.|,](?:\\s)*(\\d{4})?(?:\\.\\s)?"),
@@ -740,6 +740,8 @@ void EITFixUp::FixUK(DBEventEIT &event) const
         QStringList tmpCCitems = tmpCC.cap(0).remove("[").remove("]").split(",");
         if (tmpCCitems.contains("AD"))
             event.audioProps |= AUD_VISUALIMPAIR;
+        if (tmpCCitems.contains("HD"))
+            event.videoProps |= VID_HDTV;
         if (tmpCCitems.contains("S"))
             event.subtitleType |= SUB_NORMAL;
         if (tmpCCitems.contains("SL"))
diff --git a/mythtv/libs/libmythtv/lzoconf.h b/mythtv/libs/libmythtv/lzoconf.h
index cc437f1..02fb202 100644
--- a/mythtv/libs/libmythtv/lzoconf.h
+++ b/mythtv/libs/libmythtv/lzoconf.h
@@ -1,20 +1,8 @@
-/* lzoconf.h -- configuration for the LZO real-time data compression library
+/* lzoconf.h -- configuration of the LZO data compression library
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,11 +27,11 @@
 
 
 #ifndef __LZOCONF_H_INCLUDED
-#define __LZOCONF_H_INCLUDED
+#define __LZOCONF_H_INCLUDED 1
 
-#define LZO_VERSION             0x2030
-#define LZO_VERSION_STRING      "2.03"
-#define LZO_VERSION_DATE        "Apr 30 2008"
+#define LZO_VERSION             0x2070
+#define LZO_VERSION_STRING      "2.07"
+#define LZO_VERSION_DATE        "Jun 25 2014"
 
 /* internal Autoconf configuration file - only used when building LZO */
 #if defined(LZO_HAVE_CONFIG_H)
@@ -60,7 +48,7 @@
 #if !defined(CHAR_BIT) || (CHAR_BIT != 8)
 #  error "invalid CHAR_BIT"
 #endif
-#if !defined(UCHAR_MAX) || !defined(UINT_MAX) || !defined(ULONG_MAX)
+#if !defined(UCHAR_MAX) || !defined(USHRT_MAX) || !defined(UINT_MAX) || !defined(ULONG_MAX)
 #  error "check your compiler installation"
 #endif
 #if (USHRT_MAX < 1) || (UINT_MAX < 1) || (ULONG_MAX < 1)
@@ -82,14 +70,6 @@ extern "C" {
 // some core defines
 ************************************************************************/
 
-#if !defined(LZO_UINT32_C)
-#  if (UINT_MAX < LZO_0xffffffffL)
-#    define LZO_UINT32_C(c)     c ## UL
-#  else
-#    define LZO_UINT32_C(c)     ((c) + 0U)
-#  endif
-#endif
-
 /* memory checkers */
 #if !defined(__LZO_CHECKER)
 #  if defined(__BOUNDS_CHECKING_ON)
@@ -108,28 +88,31 @@ extern "C" {
 // integral and pointer types
 ************************************************************************/
 
-/* lzo_uint should match size_t */
+/* lzo_uint must match size_t */
 #if !defined(LZO_UINT_MAX)
-#  if defined(LZO_ABI_LLP64) /* WIN64 */
-#    if defined(LZO_OS_WIN64)
+#  if (LZO_ABI_LLP64)
+#    if (LZO_OS_WIN64)
      typedef unsigned __int64   lzo_uint;
      typedef __int64            lzo_int;
 #    else
-     typedef unsigned long long lzo_uint;
-     typedef long long          lzo_int;
+     typedef lzo_ullong_t       lzo_uint;
+     typedef lzo_llong_t        lzo_int;
 #    endif
+#    define LZO_SIZEOF_LZO_UINT 8
 #    define LZO_UINT_MAX        0xffffffffffffffffull
 #    define LZO_INT_MAX         9223372036854775807LL
 #    define LZO_INT_MIN         (-1LL - LZO_INT_MAX)
-#  elif defined(LZO_ABI_IP32L64) /* MIPS R5900 */
+#  elif (LZO_ABI_IP32L64) /* MIPS R5900 */
      typedef unsigned int       lzo_uint;
      typedef int                lzo_int;
+#    define LZO_SIZEOF_LZO_UINT LZO_SIZEOF_INT
 #    define LZO_UINT_MAX        UINT_MAX
 #    define LZO_INT_MAX         INT_MAX
 #    define LZO_INT_MIN         INT_MIN
 #  elif (ULONG_MAX >= LZO_0xffffffffL)
      typedef unsigned long      lzo_uint;
      typedef long               lzo_int;
+#    define LZO_SIZEOF_LZO_UINT LZO_SIZEOF_LONG
 #    define LZO_UINT_MAX        ULONG_MAX
 #    define LZO_INT_MAX         LONG_MAX
 #    define LZO_INT_MIN         LONG_MIN
@@ -138,42 +121,22 @@ extern "C" {
 #  endif
 #endif
 
-/* Integral types with 32 bits or more. */
-#if !defined(LZO_UINT32_MAX)
-#  if (UINT_MAX >= LZO_0xffffffffL)
-     typedef unsigned int       lzo_uint32;
-     typedef int                lzo_int32;
-#    define LZO_UINT32_MAX      UINT_MAX
-#    define LZO_INT32_MAX       INT_MAX
-#    define LZO_INT32_MIN       INT_MIN
-#  elif (ULONG_MAX >= LZO_0xffffffffL)
-     typedef unsigned long      lzo_uint32;
-     typedef long               lzo_int32;
-#    define LZO_UINT32_MAX      ULONG_MAX
-#    define LZO_INT32_MAX       LONG_MAX
-#    define LZO_INT32_MIN       LONG_MIN
-#  else
-#    error "lzo_uint32"
-#  endif
-#endif
-
-/* The larger type of lzo_uint and lzo_uint32. */
-#if (LZO_UINT_MAX >= LZO_UINT32_MAX)
+/* The larger type of lzo_uint and lzo_uint32_t. */
+#if (LZO_SIZEOF_LZO_UINT >= 4)
 #  define lzo_xint              lzo_uint
 #else
-#  define lzo_xint              lzo_uint32
+#  define lzo_xint              lzo_uint32_t
 #endif
 
-/* Memory model that allows to access memory at offsets of lzo_uint. */
-#if !defined(__LZO_MMODEL)
-#  if (LZO_UINT_MAX <= UINT_MAX)
-#    define __LZO_MMODEL
-#  elif defined(LZO_HAVE_MM_HUGE_PTR)
-#    define __LZO_MMODEL_HUGE   1
-#    define __LZO_MMODEL        __huge
-#  else
-#    define __LZO_MMODEL
-#  endif
+typedef int lzo_bool;
+
+/* sanity checks */
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == LZO_SIZEOF_LZO_UINT)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_xint) >= sizeof(lzo_uint))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_xint) >= sizeof(lzo_uint32_t))
+
+#ifndef __LZO_MMODEL
+#define __LZO_MMODEL            /*empty*/
 #endif
 
 /* no typedef here because of const-pointer issues */
@@ -182,17 +145,52 @@ extern "C" {
 #define lzo_voidp               void __LZO_MMODEL *
 #define lzo_shortp              short __LZO_MMODEL *
 #define lzo_ushortp             unsigned short __LZO_MMODEL *
-#define lzo_uint32p             lzo_uint32 __LZO_MMODEL *
-#define lzo_int32p              lzo_int32 __LZO_MMODEL *
-#define lzo_uintp               lzo_uint __LZO_MMODEL *
 #define lzo_intp                lzo_int __LZO_MMODEL *
+#define lzo_uintp               lzo_uint __LZO_MMODEL *
 #define lzo_xintp               lzo_xint __LZO_MMODEL *
 #define lzo_voidpp              lzo_voidp __LZO_MMODEL *
 #define lzo_bytepp              lzo_bytep __LZO_MMODEL *
-/* deprecated - use `lzo_bytep' instead of `lzo_byte *' */
-#define lzo_byte                unsigned char __LZO_MMODEL
 
-typedef int lzo_bool;
+#define lzo_int8_tp             lzo_int8_t __LZO_MMODEL *
+#define lzo_uint8_tp            lzo_uint8_t __LZO_MMODEL *
+#define lzo_int16_tp            lzo_int16_t __LZO_MMODEL *
+#define lzo_uint16_tp           lzo_uint16_t __LZO_MMODEL *
+#define lzo_int32_tp            lzo_int32_t __LZO_MMODEL *
+#define lzo_uint32_tp           lzo_uint32_t __LZO_MMODEL *
+#if defined(lzo_int64_t)
+#define lzo_int64_tp            lzo_int64_t __LZO_MMODEL *
+#define lzo_uint64_tp           lzo_uint64_t __LZO_MMODEL *
+#endif
+
+/* Older LZO versions used to support ancient systems and memory models
+ * like 16-bit MSDOS with __huge pointers and Cray PVP, but these
+ * obsolete configurations are not supported any longer.
+ */
+#if defined(__LZO_MMODEL_HUGE)
+#error "__LZO_MMODEL_HUGE is unsupported"
+#endif
+#if (LZO_MM_PVP)
+#error "LZO_MM_PVP is unsupported"
+#endif
+#if (LZO_SIZEOF_INT < 4)
+#error "LZO_SIZEOF_INT < 4 is unsupported"
+#endif
+#if (__LZO_UINTPTR_T_IS_POINTER)
+#error "__LZO_UINTPTR_T_IS_POINTER is unsupported"
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(int) >= 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) >= 4)
+/* Strange configurations where sizeof(lzo_uint) != sizeof(size_t) should
+ * work but have not received much testing lately, so be strict here.
+ */
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == sizeof(size_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == sizeof(ptrdiff_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == sizeof(lzo_uintptr_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(void *)   == sizeof(lzo_uintptr_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(char *)   == sizeof(lzo_uintptr_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long *)   == sizeof(lzo_uintptr_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(void *)   == sizeof(lzo_voidp))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(char *)   == sizeof(lzo_bytep))
 
 
 /***********************************************************************
@@ -215,10 +213,10 @@ typedef int lzo_bool;
 
 /* DLL export information */
 #if !defined(__LZO_EXPORT1)
-#  define __LZO_EXPORT1
+#  define __LZO_EXPORT1         /*empty*/
 #endif
 #if !defined(__LZO_EXPORT2)
-#  define __LZO_EXPORT2
+#  define __LZO_EXPORT2         /*empty*/
 #endif
 
 /* __cdecl calling convention for public C and assembly functions */
@@ -287,7 +285,7 @@ struct lzo_callback_t
     /* a progress indicator callback function (set to 0 to disable) */
     lzo_progress_func_t nprogress;
 
-    /* NOTE: the first parameter "self" of the nalloc/nfree/nprogress
+    /* INFO: the first parameter "self" of the nalloc/nfree/nprogress
      * callbacks points back to this struct, so you are free to store
      * some extra info in the following variables. */
     lzo_voidp user1;
@@ -306,7 +304,7 @@ struct lzo_callback_t
  */
 #define LZO_E_OK                    0
 #define LZO_E_ERROR                 (-1)
-#define LZO_E_OUT_OF_MEMORY         (-2)    /* [not used right now] */
+#define LZO_E_OUT_OF_MEMORY         (-2)    /* [lzo_alloc_func_t failure] */
 #define LZO_E_NOT_COMPRESSIBLE      (-3)    /* [not used right now] */
 #define LZO_E_INPUT_OVERRUN         (-4)
 #define LZO_E_OUTPUT_OVERRUN        (-5)
@@ -314,6 +312,10 @@ struct lzo_callback_t
 #define LZO_E_EOF_NOT_FOUND         (-7)
 #define LZO_E_INPUT_NOT_CONSUMED    (-8)
 #define LZO_E_NOT_YET_IMPLEMENTED   (-9)    /* [not used right now] */
+#define LZO_E_INVALID_ARGUMENT      (-10)
+#define LZO_E_INVALID_ALIGNMENT     (-11)   /* pointer argument is not properly aligned */
+#define LZO_E_OUTPUT_NOT_CONSUMED   (-12)
+#define LZO_E_INTERNAL_ERROR        (-99)
 
 
 #ifndef lzo_sizeof_dict_t
@@ -327,7 +329,7 @@ struct lzo_callback_t
  * compiler's view of various types are consistent.
  */
 #define lzo_init() __lzo_init_v2(LZO_VERSION,(int)sizeof(short),(int)sizeof(int),\
-    (int)sizeof(long),(int)sizeof(lzo_uint32),(int)sizeof(lzo_uint),\
+    (int)sizeof(long),(int)sizeof(lzo_uint32_t),(int)sizeof(lzo_uint),\
     (int)lzo_sizeof_dict_t,(int)sizeof(char *),(int)sizeof(lzo_voidp),\
     (int)sizeof(lzo_callback_t))
 LZO_EXTERN(int) __lzo_init_v2(unsigned,int,int,int,int,int,int,int,int,int);
@@ -341,38 +343,63 @@ LZO_EXTERN(const lzo_charp) _lzo_version_date(void);
 
 /* string functions */
 LZO_EXTERN(int)
-lzo_memcmp(const lzo_voidp _s1, const lzo_voidp _s2, lzo_uint _len);
+    lzo_memcmp(const lzo_voidp a, const lzo_voidp b, lzo_uint len);
 LZO_EXTERN(lzo_voidp)
-lzo_memcpy(lzo_voidp _dest, const lzo_voidp _src, lzo_uint _len);
+    lzo_memcpy(lzo_voidp dst, const lzo_voidp src, lzo_uint len);
 LZO_EXTERN(lzo_voidp)
-lzo_memmove(lzo_voidp _dest, const lzo_voidp _src, lzo_uint _len);
+    lzo_memmove(lzo_voidp dst, const lzo_voidp src, lzo_uint len);
 LZO_EXTERN(lzo_voidp)
-lzo_memset(lzo_voidp _s, int _c, lzo_uint _len);
+    lzo_memset(lzo_voidp buf, int c, lzo_uint len);
 
 /* checksum functions */
-LZO_EXTERN(lzo_uint32)
-lzo_adler32(lzo_uint32 _adler, const lzo_bytep _buf, lzo_uint _len);
-LZO_EXTERN(lzo_uint32)
-lzo_crc32(lzo_uint32 _c, const lzo_bytep _buf, lzo_uint _len);
-LZO_EXTERN(const lzo_uint32p)
-lzo_get_crc32_table(void);
+LZO_EXTERN(lzo_uint32_t)
+    lzo_adler32(lzo_uint32_t c, const lzo_bytep buf, lzo_uint len);
+LZO_EXTERN(lzo_uint32_t)
+    lzo_crc32(lzo_uint32_t c, const lzo_bytep buf, lzo_uint len);
+LZO_EXTERN(const lzo_uint32_tp)
+    lzo_get_crc32_table(void);
 
 /* misc. */
 LZO_EXTERN(int) _lzo_config_check(void);
-typedef union { lzo_bytep p; lzo_uint u; } __lzo_pu_u;
-typedef union { lzo_bytep p; lzo_uint32 u32; } __lzo_pu32_u;
-typedef union { void *vp; lzo_bytep bp; lzo_uint32 u32; long l; } lzo_align_t;
+typedef union {
+    lzo_voidp a00; lzo_bytep a01; lzo_uint a02; lzo_xint a03; lzo_uintptr_t a04;
+    void *a05; unsigned char *a06; unsigned long a07; size_t a08; ptrdiff_t a09;
+#if defined(lzo_int64_t)
+    lzo_uint64_t a10;
+#endif
+} lzo_align_t;
 
-/* align a char pointer on a boundary that is a multiple of `size' */
-LZO_EXTERN(unsigned) __lzo_align_gap(const lzo_voidp _ptr, lzo_uint _size);
-#define LZO_PTR_ALIGN_UP(_ptr,_size) \
-    ((_ptr) + (lzo_uint) __lzo_align_gap((const lzo_voidp)(_ptr),(lzo_uint)(_size)))
+/* align a char pointer on a boundary that is a multiple of 'size' */
+LZO_EXTERN(unsigned) __lzo_align_gap(const lzo_voidp p, lzo_uint size);
+#define LZO_PTR_ALIGN_UP(p,size) \
+    ((p) + (lzo_uint) __lzo_align_gap((const lzo_voidp)(p),(lzo_uint)(size)))
 
 
 /***********************************************************************
-// deprecated macros - only for backward compatibility with LZO v1.xx
+// deprecated macros - only for backward compatibility
 ************************************************************************/
 
+/* deprecated - use 'lzo_bytep' instead of 'lzo_byte *' */
+#define lzo_byte                unsigned char
+/* deprecated type names */
+#define lzo_int32               lzo_int32_t
+#define lzo_uint32              lzo_uint32_t
+#define lzo_int32p              lzo_int32_t __LZO_MMODEL *
+#define lzo_uint32p             lzo_uint32_t __LZO_MMODEL *
+#define LZO_INT32_MAX           LZO_INT32_C(2147483647)
+#define LZO_UINT32_MAX          LZO_UINT32_C(4294967295)
+#if defined(lzo_int64_t)
+#define lzo_int64               lzo_int64_t
+#define lzo_uint64              lzo_uint64_t
+#define lzo_int64p              lzo_int64_t __LZO_MMODEL *
+#define lzo_uint64p             lzo_uint64_t __LZO_MMODEL *
+#define LZO_INT64_MAX           LZO_INT64_C(9223372036854775807)
+#define LZO_UINT64_MAX          LZO_UINT64_C(18446744073709551615)
+#endif
+/* deprecated types */
+typedef union { lzo_bytep a; lzo_uint b; } __lzo_pu_u;
+typedef union { lzo_bytep a; lzo_uint32_t b; } __lzo_pu32_u;
+
 #if defined(LZO_CFG_COMPAT)
 
 #define __LZOCONF_H 1
@@ -395,8 +422,8 @@ LZO_EXTERN(unsigned) __lzo_align_gap(const lzo_voidp _ptr, lzo_uint _size);
 #  define __LZO_WIN 1
 #endif
 
-#define __LZO_CMODEL
-#define __LZO_DMODEL
+#define __LZO_CMODEL            /*empty*/
+#define __LZO_DMODEL            /*empty*/
 #define __LZO_ENTRY             __LZO_CDECL
 #define LZO_EXTERN_CDECL        LZO_EXTERN
 #define LZO_ALIGN               LZO_PTR_ALIGN_UP
diff --git a/mythtv/libs/libmythtv/lzodefs.h b/mythtv/libs/libmythtv/lzodefs.h
index 18056372..f4ae948 100644
--- a/mythtv/libs/libmythtv/lzodefs.h
+++ b/mythtv/libs/libmythtv/lzodefs.h
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -44,12 +32,6 @@
 #if defined(__CYGWIN32__) && !defined(__CYGWIN__)
 #  define __CYGWIN__ __CYGWIN32__
 #endif
-#if defined(__IBMCPP__) && !defined(__IBMC__)
-#  define __IBMC__ __IBMCPP__
-#endif
-#if defined(__ICL) && defined(_WIN32) && !defined(__INTEL_COMPILER)
-#  define __INTEL_COMPILER __ICL
-#endif
 #if 1 && defined(__INTERIX) && defined(__GNUC__) && !defined(_ALL_SOURCE)
 #  define _ALL_SOURCE 1
 #endif
@@ -58,19 +40,30 @@
 #    define __LONG_MAX__ 9223372036854775807L
 #  endif
 #endif
-#if defined(__INTEL_COMPILER) && defined(__linux__)
+#if !defined(LZO_CFG_NO_DISABLE_WUNDEF)
+#if defined(__ARMCC_VERSION)
+#  pragma diag_suppress 193
+#elif defined(__clang__) && defined(__clang_minor__)
+#  pragma clang diagnostic ignored "-Wundef"
+#elif defined(__INTEL_COMPILER)
 #  pragma warning(disable: 193)
-#endif
-#if defined(__KEIL__) && defined(__C166__)
-#  pragma warning disable = 322
-#elif 0 && defined(__C251__)
+#elif defined(__KEIL__) && defined(__C166__)
 #  pragma warning disable = 322
-#endif
-#if defined(_MSC_VER) && !defined(__INTEL_COMPILER) && !defined(__MWERKS__)
-#  if (_MSC_VER >= 1300)
+#elif defined(__GNUC__) && defined(__GNUC_MINOR__) && !defined(__PATHSCALE__)
+#  if ((__GNUC__-0) >= 5 || ((__GNUC__-0) == 4 && (__GNUC_MINOR__-0) >= 2))
+#    pragma GCC diagnostic ignored "-Wundef"
+#  endif
+#elif defined(_MSC_VER) && !defined(__clang__) && !defined(__INTEL_COMPILER) && !defined(__MWERKS__)
+#  if ((_MSC_VER-0) >= 1300)
 #    pragma warning(disable: 4668)
 #  endif
 #endif
+#endif
+#if 0 && defined(__POCC__) && defined(_WIN32)
+#  if (__POCC__ >= 400)
+#    pragma warn(disable: 2216)
+#  endif
+#endif
 #if 0 && defined(__WATCOMC__)
 #  if (__WATCOMC__ >= 1050) && (__WATCOMC__ < 1060)
 #    pragma warning 203 9
@@ -79,13 +72,29 @@
 #if defined(__BORLANDC__) && defined(__MSDOS__) && !defined(__FLAT__)
 #  pragma option -h
 #endif
+#if !(LZO_CFG_NO_DISABLE_WCRTNONSTDC)
+#ifndef _CRT_NONSTDC_NO_DEPRECATE
+#define _CRT_NONSTDC_NO_DEPRECATE 1
+#endif
+#ifndef _CRT_NONSTDC_NO_WARNINGS
+#define _CRT_NONSTDC_NO_WARNINGS 1
+#endif
+#ifndef _CRT_SECURE_NO_DEPRECATE
+#define _CRT_SECURE_NO_DEPRECATE 1
+#endif
+#ifndef _CRT_SECURE_NO_WARNINGS
+#define _CRT_SECURE_NO_WARNINGS 1
+#endif
+#endif
 #if 0
-#define LZO_0xffffL             0xfffful
-#define LZO_0xffffffffL         0xfffffffful
+#define LZO_0xffffUL            0xfffful
+#define LZO_0xffffffffUL        0xfffffffful
 #else
-#define LZO_0xffffL             65535ul
-#define LZO_0xffffffffL         4294967295ul
+#define LZO_0xffffUL            65535ul
+#define LZO_0xffffffffUL        4294967295ul
 #endif
+#define LZO_0xffffL             LZO_0xffffUL
+#define LZO_0xffffffffL         LZO_0xffffffffUL
 #if (LZO_0xffffL == LZO_0xffffffffL)
 #  error "your preprocessor is broken 1"
 #endif
@@ -100,6 +109,13 @@
 #  error "your preprocessor is broken 4"
 #endif
 #endif
+#if defined(__COUNTER__)
+#  ifndef LZO_CFG_USE_COUNTER
+#  define LZO_CFG_USE_COUNTER 1
+#  endif
+#else
+#  undef LZO_CFG_USE_COUNTER
+#endif
 #if (UINT_MAX == LZO_0xffffL)
 #if defined(__ZTC__) && defined(__I86__) && !defined(__OS2__)
 #  if !defined(MSDOS)
@@ -121,7 +137,7 @@
 #endif
 #if defined(_MSC_VER) && defined(M_I86HM) && (UINT_MAX == LZO_0xffffL)
 #  define ptrdiff_t long
-#  define _PTRDIFF_T_DEFINED
+#  define _PTRDIFF_T_DEFINED 1
 #endif
 #if (UINT_MAX == LZO_0xffffL)
 #  undef __LZO_RENAME_A
@@ -230,14 +246,31 @@
 #endif
 #define LZO_PP_STRINGIZE(x)             #x
 #define LZO_PP_MACRO_EXPAND(x)          LZO_PP_STRINGIZE(x)
+#define LZO_PP_CONCAT0()                /*empty*/
+#define LZO_PP_CONCAT1(a)               a
 #define LZO_PP_CONCAT2(a,b)             a ## b
 #define LZO_PP_CONCAT3(a,b,c)           a ## b ## c
 #define LZO_PP_CONCAT4(a,b,c,d)         a ## b ## c ## d
 #define LZO_PP_CONCAT5(a,b,c,d,e)       a ## b ## c ## d ## e
+#define LZO_PP_CONCAT6(a,b,c,d,e,f)     a ## b ## c ## d ## e ## f
+#define LZO_PP_CONCAT7(a,b,c,d,e,f,g)   a ## b ## c ## d ## e ## f ## g
+#define LZO_PP_ECONCAT0()               LZO_PP_CONCAT0()
+#define LZO_PP_ECONCAT1(a)              LZO_PP_CONCAT1(a)
 #define LZO_PP_ECONCAT2(a,b)            LZO_PP_CONCAT2(a,b)
 #define LZO_PP_ECONCAT3(a,b,c)          LZO_PP_CONCAT3(a,b,c)
 #define LZO_PP_ECONCAT4(a,b,c,d)        LZO_PP_CONCAT4(a,b,c,d)
 #define LZO_PP_ECONCAT5(a,b,c,d,e)      LZO_PP_CONCAT5(a,b,c,d,e)
+#define LZO_PP_ECONCAT6(a,b,c,d,e,f)    LZO_PP_CONCAT6(a,b,c,d,e,f)
+#define LZO_PP_ECONCAT7(a,b,c,d,e,f,g)  LZO_PP_CONCAT7(a,b,c,d,e,f,g)
+#define LZO_PP_EMPTY                    /*empty*/
+#define LZO_PP_EMPTY0()                 /*empty*/
+#define LZO_PP_EMPTY1(a)                /*empty*/
+#define LZO_PP_EMPTY2(a,b)              /*empty*/
+#define LZO_PP_EMPTY3(a,b,c)            /*empty*/
+#define LZO_PP_EMPTY4(a,b,c,d)          /*empty*/
+#define LZO_PP_EMPTY5(a,b,c,d,e)        /*empty*/
+#define LZO_PP_EMPTY6(a,b,c,d,e,f)      /*empty*/
+#define LZO_PP_EMPTY7(a,b,c,d,e,f,g)    /*empty*/
 #if 1
 #define LZO_CPP_STRINGIZE(x)            #x
 #define LZO_CPP_MACRO_EXPAND(x)         LZO_CPP_STRINGIZE(x)
@@ -245,12 +278,16 @@
 #define LZO_CPP_CONCAT3(a,b,c)          a ## b ## c
 #define LZO_CPP_CONCAT4(a,b,c,d)        a ## b ## c ## d
 #define LZO_CPP_CONCAT5(a,b,c,d,e)      a ## b ## c ## d ## e
+#define LZO_CPP_CONCAT6(a,b,c,d,e,f)    a ## b ## c ## d ## e ## f
+#define LZO_CPP_CONCAT7(a,b,c,d,e,f,g)  a ## b ## c ## d ## e ## f ## g
 #define LZO_CPP_ECONCAT2(a,b)           LZO_CPP_CONCAT2(a,b)
 #define LZO_CPP_ECONCAT3(a,b,c)         LZO_CPP_CONCAT3(a,b,c)
 #define LZO_CPP_ECONCAT4(a,b,c,d)       LZO_CPP_CONCAT4(a,b,c,d)
 #define LZO_CPP_ECONCAT5(a,b,c,d,e)     LZO_CPP_CONCAT5(a,b,c,d,e)
+#define LZO_CPP_ECONCAT6(a,b,c,d,e,f)   LZO_CPP_CONCAT6(a,b,c,d,e,f)
+#define LZO_CPP_ECONCAT7(a,b,c,d,e,f,g) LZO_CPP_CONCAT7(a,b,c,d,e,f,g)
 #endif
-#define __LZO_MASK_GEN(o,b)     (((((o) << ((b)-1)) - (o)) << 1) + (o))
+#define __LZO_MASK_GEN(o,b)     (((((o) << ((b)-!!(b))) - (o)) << 1) + (o)*!!(b))
 #if 1 && defined(__cplusplus)
 #  if !defined(__STDC_CONSTANT_MACROS)
 #    define __STDC_CONSTANT_MACROS 1
@@ -260,14 +297,18 @@
 #  endif
 #endif
 #if defined(__cplusplus)
-#  define LZO_EXTERN_C extern "C"
+#  define LZO_EXTERN_C          extern "C"
+#  define LZO_EXTERN_C_BEGIN    extern "C" {
+#  define LZO_EXTERN_C_END      }
 #else
-#  define LZO_EXTERN_C extern
+#  define LZO_EXTERN_C          extern
+#  define LZO_EXTERN_C_BEGIN    /*empty*/
+#  define LZO_EXTERN_C_END      /*empty*/
 #endif
 #if !defined(__LZO_OS_OVERRIDE)
-#if defined(LZO_OS_FREESTANDING)
+#if (LZO_OS_FREESTANDING)
 #  define LZO_INFO_OS           "freestanding"
-#elif defined(LZO_OS_EMBEDDED)
+#elif (LZO_OS_EMBEDDED)
 #  define LZO_INFO_OS           "embedded"
 #elif 1 && defined(__IAR_SYSTEMS_ICC__)
 #  define LZO_OS_EMBEDDED       1
@@ -363,12 +404,12 @@
 #elif defined(__VMS)
 #  define LZO_OS_VMS            1
 #  define LZO_INFO_OS           "vms"
-#elif ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
+#elif (defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__)
 #  define LZO_OS_CONSOLE        1
 #  define LZO_OS_CONSOLE_PS2    1
 #  define LZO_INFO_OS           "console"
 #  define LZO_INFO_OS_CONSOLE   "ps2"
-#elif (defined(__mips__) && defined(__psp__))
+#elif defined(__mips__) && defined(__psp__)
 #  define LZO_OS_CONSOLE        1
 #  define LZO_OS_CONSOLE_PSP    1
 #  define LZO_INFO_OS           "console"
@@ -396,9 +437,18 @@
 #  elif defined(__linux__) || defined(__linux) || defined(__LINUX__)
 #    define LZO_OS_POSIX_LINUX      1
 #    define LZO_INFO_OS_POSIX       "linux"
-#  elif defined(__APPLE__) || defined(__MACOS__)
-#    define LZO_OS_POSIX_MACOSX     1
-#    define LZO_INFO_OS_POSIX       "macosx"
+#  elif defined(__APPLE__) && defined(__MACH__)
+#    if ((__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__-0) >= 20000)
+#      define LZO_OS_POSIX_DARWIN     1040
+#      define LZO_INFO_OS_POSIX       "darwin_iphone"
+#    elif ((__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__-0) >= 1040)
+#      define LZO_OS_POSIX_DARWIN     __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
+#      define LZO_INFO_OS_POSIX       "darwin"
+#    else
+#      define LZO_OS_POSIX_DARWIN     1
+#      define LZO_INFO_OS_POSIX       "darwin"
+#    endif
+#    define LZO_OS_POSIX_MACOSX     LZO_OS_POSIX_DARWIN
 #  elif defined(__minix__) || defined(__minix)
 #    define LZO_OS_POSIX_MINIX      1
 #    define LZO_INFO_OS_POSIX       "minix"
@@ -433,18 +483,18 @@
 #endif
 #if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
 #  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #if (LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_WIN32 || LZO_OS_WIN64)
 #  if (UINT_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #if defined(CIL) && defined(_GNUCC) && defined(__GNUC__)
@@ -460,48 +510,73 @@
 #  define LZO_INFO_CC           "sdcc"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(SDCC)
 #elif defined(__PATHSCALE__) && defined(__PATHCC_PATCHLEVEL__)
-#  define LZO_CC_PATHSCALE      (__PATHCC__ * 0x10000L + __PATHCC_MINOR__ * 0x100 + __PATHCC_PATCHLEVEL__)
+#  define LZO_CC_PATHSCALE      (__PATHCC__ * 0x10000L + (__PATHCC_MINOR__-0) * 0x100 + (__PATHCC_PATCHLEVEL__-0))
 #  define LZO_INFO_CC           "Pathscale C"
 #  define LZO_INFO_CCVER        __PATHSCALE__
-#elif defined(__INTEL_COMPILER)
-#  define LZO_CC_INTELC         1
+#  if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_PATHSCALE_GNUC (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  endif
+#elif defined(__INTEL_COMPILER) && ((__INTEL_COMPILER-0) > 0)
+#  define LZO_CC_INTELC         __INTEL_COMPILER
 #  define LZO_INFO_CC           "Intel C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__INTEL_COMPILER)
-#  if defined(_WIN32) || defined(_WIN64)
-#    define LZO_CC_SYNTAX_MSC 1
-#  else
-#    define LZO_CC_SYNTAX_GNUC 1
+#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#    define LZO_CC_INTELC_MSC   _MSC_VER
+#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_INTELC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
 #  endif
 #elif defined(__POCC__) && defined(_WIN32)
 #  define LZO_CC_PELLESC        1
 #  define LZO_INFO_CC           "Pelles C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__POCC__)
-#elif defined(__llvm__) && defined(__GNUC__) && defined(__VERSION__)
-#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_LLVM         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
+#elif defined(__ARMCC_VERSION) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#  if defined(__GNUC_PATCHLEVEL__)
+#    define LZO_CC_ARMCC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
 #  else
-#    define LZO_CC_LLVM         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
+#    define LZO_CC_ARMCC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
 #  endif
-#  define LZO_INFO_CC           "llvm-gcc"
+#  define LZO_CC_ARMCC          __ARMCC_VERSION
+#  define LZO_INFO_CC           "ARM C Compiler"
 #  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__GNUC__) && defined(__VERSION__)
-#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  elif defined(__GNUC_MINOR__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
+#elif defined(__clang__) && defined(__llvm__) && defined(__VERSION__)
+#  if defined(__clang_major__) && defined(__clang_minor__) && defined(__clang_patchlevel__)
+#    define LZO_CC_CLANG        (__clang_major__ * 0x10000L + (__clang_minor__-0) * 0x100 + (__clang_patchlevel__-0))
 #  else
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L)
+#    define LZO_CC_CLANG        0x010000L
 #  endif
-#  define LZO_INFO_CC           "gcc"
+#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#    define LZO_CC_CLANG_MSC    _MSC_VER
+#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  endif
+#  define LZO_INFO_CC           "clang"
+#  define LZO_INFO_CCVER        __VERSION__
+#elif defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#  if defined(__GNUC_PATCHLEVEL__)
+#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  else
+#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
+#  endif
+#  define LZO_CC_LLVM           LZO_CC_LLVM_GNUC
+#  define LZO_INFO_CC           "llvm-gcc"
 #  define LZO_INFO_CCVER        __VERSION__
 #elif defined(__ACK__) && defined(_ACK)
 #  define LZO_CC_ACK            1
 #  define LZO_INFO_CC           "Amsterdam Compiler Kit C"
 #  define LZO_INFO_CCVER        "unknown"
+#elif defined(__ARMCC_VERSION) && !defined(__GNUC__)
+#  define LZO_CC_ARMCC          __ARMCC_VERSION
+#  define LZO_CC_ARMCC_ARMCC    __ARMCC_VERSION
+#  define LZO_INFO_CC           "ARM C Compiler"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__ARMCC_VERSION)
 #elif defined(__AZTEC_C__)
 #  define LZO_CC_AZTECC         1
 #  define LZO_INFO_CC           "Aztec C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__AZTEC_C__)
+#elif defined(__CODEGEARC__)
+#  define LZO_CC_CODEGEARC      1
+#  define LZO_INFO_CC           "CodeGear C"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__CODEGEARC__)
 #elif defined(__BORLANDC__)
 #  define LZO_CC_BORLANDC       1
 #  define LZO_INFO_CC           "Borland C"
@@ -518,10 +593,23 @@
 #  define LZO_CC_DECC           1
 #  define LZO_INFO_CC           "DEC C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DECC)
+#elif (defined(__ghs) || defined(__ghs__)) && defined(__GHS_VERSION_NUMBER) && ((__GHS_VERSION_NUMBER-0) > 0)
+#  define LZO_CC_GHS            1
+#  define LZO_INFO_CC           "Green Hills C"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__GHS_VERSION_NUMBER)
+#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#    define LZO_CC_GHS_MSC      _MSC_VER
+#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_GHS_GNUC     (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  endif
 #elif defined(__HIGHC__)
 #  define LZO_CC_HIGHC          1
 #  define LZO_INFO_CC           "MetaWare High C"
 #  define LZO_INFO_CCVER        "unknown"
+#elif defined(__HP_aCC) && ((__HP_aCC-0) > 0)
+#  define LZO_CC_HPACC          __HP_aCC
+#  define LZO_INFO_CC           "HP aCC"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__HP_aCC)
 #elif defined(__IAR_SYSTEMS_ICC__)
 #  define LZO_CC_IARC           1
 #  define LZO_INFO_CC           "IAR C"
@@ -530,10 +618,14 @@
 #  else
 #    define LZO_INFO_CCVER      "unknown"
 #  endif
-#elif defined(__IBMC__)
-#  define LZO_CC_IBMC           1
+#elif defined(__IBMC__) && ((__IBMC__-0) > 0)
+#  define LZO_CC_IBMC           __IBMC__
 #  define LZO_INFO_CC           "IBM C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMC__)
+#elif defined(__IBMCPP__) && ((__IBMCPP__-0) > 0)
+#  define LZO_CC_IBMC           __IBMCPP__
+#  define LZO_INFO_CC           "IBM C"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMCPP__)
 #elif defined(__KEIL__) && defined(__C166__)
 #  define LZO_CC_KEILC          1
 #  define LZO_INFO_CC           "Keil C"
@@ -550,16 +642,8 @@
 #  else
 #    define LZO_INFO_CCVER      "unknown"
 #  endif
-#elif defined(_MSC_VER)
-#  define LZO_CC_MSC            1
-#  define LZO_INFO_CC           "Microsoft C"
-#  if defined(_MSC_FULL_VER)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER) "." LZO_PP_MACRO_EXPAND(_MSC_FULL_VER)
-#  else
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER)
-#  endif
-#elif defined(__MWERKS__)
-#  define LZO_CC_MWERKS         1
+#elif defined(__MWERKS__) && ((__MWERKS__-0) > 0)
+#  define LZO_CC_MWERKS         __MWERKS__
 #  define LZO_INFO_CC           "Metrowerks C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__MWERKS__)
 #elif (defined(__NDPC__) || defined(__NDPX__)) && defined(__i386)
@@ -570,6 +654,15 @@
 #  define LZO_CC_PACIFICC       1
 #  define LZO_INFO_CC           "Pacific C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PACIFIC__)
+#elif defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__)
+#  if defined(__PGIC_PATCHLEVEL__)
+#    define LZO_CC_PGI          (__PGIC__ * 0x10000L + (__PGIC_MINOR__-0) * 0x100 + (__PGIC_PATCHLEVEL__-0))
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__PGIC__) "." LZO_PP_MACRO_EXPAND(__PGIC_MINOR__) "." LZO_PP_MACRO_EXPAND(__PGIC_PATCHLEVEL__)
+#  else
+#    define LZO_CC_PGI          (__PGIC__ * 0x10000L + (__PGIC_MINOR__-0) * 0x100)
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__PGIC__) "." LZO_PP_MACRO_EXPAND(__PGIC_MINOR__) ".0"
+#  endif
+#  define LZO_INFO_CC           "Portland Group PGI C"
 #elif defined(__PGI) && (defined(__linux__) || defined(__WIN32__))
 #  define LZO_CC_PGI            1
 #  define LZO_INFO_CC           "Portland Group PGI C"
@@ -584,7 +677,7 @@
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__SC__)
 #elif defined(__SUNPRO_C)
 #  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_C)+0 > 0)
+#  if ((__SUNPRO_C-0) > 0)
 #    define LZO_CC_SUNPROC      __SUNPRO_C
 #    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_C)
 #  else
@@ -593,7 +686,7 @@
 #  endif
 #elif defined(__SUNPRO_CC)
 #  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_CC)+0 > 0)
+#  if ((__SUNPRO_CC-0) > 0)
 #    define LZO_CC_SUNPROC      __SUNPRO_CC
 #    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_CC)
 #  else
@@ -619,20 +712,50 @@
 #elif defined(__ZTC__)
 #  define LZO_CC_ZORTECHC       1
 #  define LZO_INFO_CC           "Zortech C"
-#  if (__ZTC__ == 0x310)
+#  if ((__ZTC__-0) == 0x310)
 #    define LZO_INFO_CCVER      "0x310"
 #  else
 #    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__ZTC__)
 #  endif
+#elif defined(__GNUC__) && defined(__VERSION__)
+#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
+#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  elif defined(__GNUC_MINOR__)
+#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
+#  else
+#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L)
+#  endif
+#  define LZO_INFO_CC           "gcc"
+#  define LZO_INFO_CCVER        __VERSION__
+#elif defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#  define LZO_CC_MSC            _MSC_VER
+#  define LZO_INFO_CC           "Microsoft C"
+#  if defined(_MSC_FULL_VER)
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER) "." LZO_PP_MACRO_EXPAND(_MSC_FULL_VER)
+#  else
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER)
+#  endif
 #else
 #  define LZO_CC_UNKNOWN        1
 #  define LZO_INFO_CC           "unknown"
 #  define LZO_INFO_CCVER        "unknown"
 #endif
+#if (LZO_CC_GNUC) && defined(__OPEN64__)
+#  if defined(__OPENCC__) && defined(__OPENCC_MINOR__) && defined(__OPENCC_PATCHLEVEL__)
+#    define LZO_CC_OPEN64       (__OPENCC__ * 0x10000L + (__OPENCC_MINOR__-0) * 0x100 + (__OPENCC_PATCHLEVEL__-0))
+#    define LZO_CC_OPEN64_GNUC  LZO_CC_GNUC
+#  endif
+#endif
+#if (LZO_CC_GNUC) && defined(__PCC__)
+#  if defined(__PCC__) && defined(__PCC_MINOR__) && defined(__PCC_MINORMINOR__)
+#    define LZO_CC_PCC          (__PCC__ * 0x10000L + (__PCC_MINOR__-0) * 0x100 + (__PCC_MINORMINOR__-0))
+#    define LZO_CC_PCC_GNUC     LZO_CC_GNUC
+#  endif
+#endif
 #if 0 && (LZO_CC_MSC && (_MSC_VER >= 1200)) && !defined(_MSC_FULL_VER)
 #  error "LZO_CC_MSC: _MSC_FULL_VER is not defined"
 #endif
-#if !defined(__LZO_ARCH_OVERRIDE) && !defined(LZO_ARCH_GENERIC) && defined(_CRAY)
+#if !defined(__LZO_ARCH_OVERRIDE) && !(LZO_ARCH_GENERIC) && defined(_CRAY)
 #  if (UINT_MAX > LZO_0xffffffffL) && defined(_CRAY)
 #    if defined(_CRAYMPP) || defined(_CRAYT3D) || defined(_CRAYT3E)
 #      define LZO_ARCH_CRAY_MPP     1
@@ -642,12 +765,14 @@
 #  endif
 #endif
 #if !defined(__LZO_ARCH_OVERRIDE)
-#if defined(LZO_ARCH_GENERIC)
+#if (LZO_ARCH_GENERIC)
 #  define LZO_INFO_ARCH             "generic"
 #elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
 #  define LZO_ARCH_I086             1
-#  define LZO_ARCH_IA16             1
 #  define LZO_INFO_ARCH             "i086"
+#elif defined(__aarch64__)
+#  define LZO_ARCH_ARM64            1
+#  define LZO_INFO_ARCH             "arm64"
 #elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
 #  define LZO_ARCH_ALPHA            1
 #  define LZO_INFO_ARCH             "alpha"
@@ -663,10 +788,10 @@
 #  define LZO_INFO_ARCH             "arm_thumb"
 #elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCARM__)
 #  define LZO_ARCH_ARM              1
-#  if defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 1)
+#  if defined(__CPU_MODE__) && ((__CPU_MODE__-0) == 1)
 #    define LZO_ARCH_ARM_THUMB      1
 #    define LZO_INFO_ARCH           "arm_thumb"
-#  elif defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 2)
+#  elif defined(__CPU_MODE__) && ((__CPU_MODE__-0) == 2)
 #    define LZO_INFO_ARCH           "arm"
 #  else
 #    define LZO_INFO_ARCH           "arm"
@@ -677,6 +802,9 @@
 #elif (UINT_MAX <= LZO_0xffffL) && defined(__AVR__)
 #  define LZO_ARCH_AVR              1
 #  define LZO_INFO_ARCH             "avr"
+#elif defined(__avr32__) || defined(__AVR32__)
+#  define LZO_ARCH_AVR32            1
+#  define LZO_INFO_ARCH             "avr32"
 #elif defined(__bfin__)
 #  define LZO_ARCH_BLACKFIN         1
 #  define LZO_INFO_ARCH             "blackfin"
@@ -781,53 +909,147 @@
 #  error "FIXME - missing define for CPU architecture"
 #endif
 #if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN32)
-#  error "FIXME - missing WIN32 define for CPU architecture"
+#  error "FIXME - missing LZO_OS_WIN32 define for CPU architecture"
 #endif
 #if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN64)
-#  error "FIXME - missing WIN64 define for CPU architecture"
+#  error "FIXME - missing LZO_OS_WIN64 define for CPU architecture"
 #endif
 #if (LZO_OS_OS216 || LZO_OS_WIN16)
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #elif 1 && (LZO_OS_DOS16 && defined(BLX286))
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #elif 1 && (LZO_OS_DOS16 && defined(DOSX286))
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #elif 1 && (LZO_OS_DOS16 && LZO_CC_BORLANDC && defined(__DPMI16__))
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #endif
-#if defined(LZO_ARCH_ARM_THUMB) && !defined(LZO_ARCH_ARM)
-#  error "this should not happen"
+#if (LZO_ARCH_AMD64 && !LZO_ARCH_X64)
+#  define LZO_ARCH_X64              1
+#elif (!LZO_ARCH_AMD64 && LZO_ARCH_X64) && defined(__LZO_ARCH_OVERRIDE)
+#  define LZO_ARCH_AMD64            1
+#endif
+#if (LZO_ARCH_ARM64 && !LZO_ARCH_AARCH64)
+#  define LZO_ARCH_AARCH64          1
+#elif (!LZO_ARCH_ARM64 && LZO_ARCH_AARCH64) && defined(__LZO_ARCH_OVERRIDE)
+#  define LZO_ARCH_ARM64            1
+#endif
+#if (LZO_ARCH_I386 && !LZO_ARCH_X86)
+#  define LZO_ARCH_X86              1
+#elif (!LZO_ARCH_I386 && LZO_ARCH_X86) && defined(__LZO_ARCH_OVERRIDE)
+#  define LZO_ARCH_I386            1
+#endif
+#if (LZO_ARCH_AMD64 && !LZO_ARCH_X64) || (!LZO_ARCH_AMD64 && LZO_ARCH_X64)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM64 && !LZO_ARCH_AARCH64) || (!LZO_ARCH_ARM64 && LZO_ARCH_AARCH64)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_I386 && !LZO_ARCH_X86) || (!LZO_ARCH_I386 && LZO_ARCH_X86)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM_THUMB && !LZO_ARCH_ARM)
+#  error "unexpected configuration - check your compiler defines"
 #endif
-#if defined(LZO_ARCH_I086PM) && !defined(LZO_ARCH_I086)
-#  error "this should not happen"
+#if (LZO_ARCH_ARM_THUMB1 && !LZO_ARCH_ARM_THUMB)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM_THUMB2 && !LZO_ARCH_ARM_THUMB)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM_THUMB1 && LZO_ARCH_ARM_THUMB2)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_I086PM && !LZO_ARCH_I086)
+#  error "unexpected configuration - check your compiler defines"
 #endif
 #if (LZO_ARCH_I086)
 #  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #if (LZO_ARCH_I386)
 #  if (UINT_MAX != LZO_0xffffL) && defined(__i386_int16__)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (UINT_MAX != LZO_0xffffffffL) && !defined(__i386_int16__)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
+#  endif
+#endif
+#if (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+#  if !defined(LZO_TARGET_FEATURE_SSE2)
+#    if defined(__SSE2__)
+#      define LZO_TARGET_FEATURE_SSE2       1
+#    elif defined(_MSC_VER) && ((defined(_M_IX86_FP) && ((_M_IX86_FP)+0 >= 2)) || defined(_M_AMD64))
+#      define LZO_TARGET_FEATURE_SSE2       1
+#    endif
+#  endif
+#  if !defined(LZO_TARGET_FEATURE_SSSE3)
+#  if (LZO_TARGET_FEATURE_SSE2)
+#    if defined(__SSSE3__)
+#      define LZO_TARGET_FEATURE_SSSE3      1
+#    elif defined(_MSC_VER) && defined(__AVX__)
+#      define LZO_TARGET_FEATURE_SSSE3      1
+#    endif
+#  endif
+#  endif
+#  if !defined(LZO_TARGET_FEATURE_SSE4_2)
+#  if (LZO_TARGET_FEATURE_SSSE3)
+#    if defined(__SSE4_2__)
+#      define LZO_TARGET_FEATURE_SSE4_2     1
+#    endif
+#  endif
+#  endif
+#  if !defined(LZO_TARGET_FEATURE_AVX)
+#  if (LZO_TARGET_FEATURE_SSSE3)
+#    if defined(__AVX__)
+#      define LZO_TARGET_FEATURE_AVX        1
+#    endif
+#  endif
+#  endif
+#  if !defined(LZO_TARGET_FEATURE_AVX2)
+#  if (LZO_TARGET_FEATURE_AVX)
+#    if defined(__AVX2__)
+#      define LZO_TARGET_FEATURE_AVX2       1
+#    endif
+#  endif
+#  endif
+#endif
+#if (LZO_TARGET_FEATURE_SSSE3 && !(LZO_TARGET_FEATURE_SSE2))
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_TARGET_FEATURE_SSE4_2 && !(LZO_TARGET_FEATURE_SSSE3))
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_TARGET_FEATURE_AVX && !(LZO_TARGET_FEATURE_SSSE3))
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_TARGET_FEATURE_AVX2 && !(LZO_TARGET_FEATURE_AVX))
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM)
+#  if !defined(LZO_TARGET_FEATURE_NEON)
+#    if defined(__ARM_NEON__)
+#      define LZO_TARGET_FEATURE_NEON       1
+#    endif
+#  endif
+#elif (LZO_ARCH_ARM64)
+#  if !defined(LZO_TARGET_FEATURE_NEON)
+#    if 1
+#      define LZO_TARGET_FEATURE_NEON       1
+#    endif
 #  endif
 #endif
-#if !defined(__LZO_MM_OVERRIDE)
+#if 0
+#elif !defined(__LZO_MM_OVERRIDE)
 #if (LZO_ARCH_I086)
 #if (UINT_MAX != LZO_0xffffL)
-#  error "this should not happen"
+#  error "unexpected configuration - check your compiler defines"
 #endif
 #if defined(__TINY__) || defined(M_I86TM) || defined(_M_I86TM)
 #  define LZO_MM_TINY           1
@@ -854,7 +1076,7 @@
 #elif (LZO_CC_ZORTECHC && defined(__VCM__))
 #  define LZO_MM_LARGE          1
 #else
-#  error "unknown memory model"
+#  error "unknown LZO_ARCH_I086 memory model"
 #endif
 #if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
 #define LZO_HAVE_MM_HUGE_PTR        1
@@ -875,12 +1097,12 @@
 #elif (LZO_CC_TURBOC && (__TURBOC__ < 0x0295))
 #  undef LZO_HAVE_MM_HUGE_ARRAY
 #endif
-#if (LZO_ARCH_I086PM) && !defined(LZO_HAVE_MM_HUGE_PTR)
+#if (LZO_ARCH_I086PM) && !(LZO_HAVE_MM_HUGE_PTR)
 #  if (LZO_OS_DOS16)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  elif (LZO_CC_ZORTECHC)
 #  else
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #ifdef __cplusplus
@@ -912,7 +1134,7 @@ extern "C" {
 #endif
 #elif (LZO_ARCH_C166)
 #if !defined(__MODEL__)
-#  error "FIXME - C166 __MODEL__"
+#  error "FIXME - LZO_ARCH_C166 __MODEL__"
 #elif ((__MODEL__) == 0)
 #  define LZO_MM_SMALL          1
 #elif ((__MODEL__) == 1)
@@ -926,11 +1148,11 @@ extern "C" {
 #elif ((__MODEL__) == 5)
 #  define LZO_MM_XSMALL         1
 #else
-#  error "FIXME - C166 __MODEL__"
+#  error "FIXME - LZO_ARCH_C166 __MODEL__"
 #endif
 #elif (LZO_ARCH_MCS251)
 #if !defined(__MODEL__)
-#  error "FIXME - MCS251 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS251 __MODEL__"
 #elif ((__MODEL__) == 0)
 #  define LZO_MM_SMALL          1
 #elif ((__MODEL__) == 2)
@@ -942,11 +1164,11 @@ extern "C" {
 #elif ((__MODEL__) == 5)
 #  define LZO_MM_XSMALL         1
 #else
-#  error "FIXME - MCS251 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS251 __MODEL__"
 #endif
 #elif (LZO_ARCH_MCS51)
 #if !defined(__MODEL__)
-#  error "FIXME - MCS51 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS51 __MODEL__"
 #elif ((__MODEL__) == 1)
 #  define LZO_MM_SMALL          1
 #elif ((__MODEL__) == 2)
@@ -958,7 +1180,7 @@ extern "C" {
 #elif ((__MODEL__) == 5)
 #  define LZO_MM_XSMALL         1
 #else
-#  error "FIXME - MCS51 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS51 __MODEL__"
 #endif
 #elif (LZO_ARCH_CRAY_PVP)
 #  define LZO_MM_PVP            1
@@ -985,454 +1207,270 @@ extern "C" {
 #  error "unknown memory model"
 #endif
 #endif
-#if defined(SIZEOF_SHORT)
-#  define LZO_SIZEOF_SHORT          (SIZEOF_SHORT)
+#if !defined(__lzo_gnuc_extension__)
+#if (LZO_CC_GNUC >= 0x020800ul)
+#  define __lzo_gnuc_extension__    __extension__
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_gnuc_extension__    __extension__
+#elif (LZO_CC_IBMC >= 600)
+#  define __lzo_gnuc_extension__    __extension__
+#else
 #endif
-#if defined(SIZEOF_INT)
-#  define LZO_SIZEOF_INT            (SIZEOF_INT)
 #endif
-#if defined(SIZEOF_LONG)
-#  define LZO_SIZEOF_LONG           (SIZEOF_LONG)
+#if !defined(__lzo_gnuc_extension__)
+#  define __lzo_gnuc_extension__    /*empty*/
 #endif
-#if defined(SIZEOF_LONG_LONG)
-#  define LZO_SIZEOF_LONG_LONG      (SIZEOF_LONG_LONG)
+#if !defined(LZO_CFG_USE_NEW_STYLE_CASTS) && defined(__cplusplus) && 0
+#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul))
+#    define LZO_CFG_USE_NEW_STYLE_CASTS 0
+#  elif (LZO_CC_INTELC && (__INTEL_COMPILER < 1200))
+#    define LZO_CFG_USE_NEW_STYLE_CASTS 0
+#  else
+#    define LZO_CFG_USE_NEW_STYLE_CASTS 1
+#  endif
 #endif
-#if defined(SIZEOF___INT16)
-#  define LZO_SIZEOF___INT16        (SIZEOF___INT16)
+#if !defined(LZO_CFG_USE_NEW_STYLE_CASTS)
+#  define LZO_CFG_USE_NEW_STYLE_CASTS 0
 #endif
-#if defined(SIZEOF___INT32)
-#  define LZO_SIZEOF___INT32        (SIZEOF___INT32)
+#if !defined(__cplusplus)
+#  if defined(LZO_CFG_USE_NEW_STYLE_CASTS)
+#    undef LZO_CFG_USE_NEW_STYLE_CASTS
+#  endif
+#  define LZO_CFG_USE_NEW_STYLE_CASTS 0
 #endif
-#if defined(SIZEOF___INT64)
-#  define LZO_SIZEOF___INT64        (SIZEOF___INT64)
+#if !defined(LZO_REINTERPRET_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_REINTERPRET_CAST(t,e)       (reinterpret_cast<t> (e))
+#  endif
 #endif
-#if defined(SIZEOF_VOID_P)
-#  define LZO_SIZEOF_VOID_P         (SIZEOF_VOID_P)
+#if !defined(LZO_REINTERPRET_CAST)
+#  define LZO_REINTERPRET_CAST(t,e)         ((t) (e))
 #endif
-#if defined(SIZEOF_SIZE_T)
-#  define LZO_SIZEOF_SIZE_T         (SIZEOF_SIZE_T)
+#if !defined(LZO_STATIC_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_STATIC_CAST(t,e)            (static_cast<t> (e))
+#  endif
 #endif
-#if defined(SIZEOF_PTRDIFF_T)
-#  define LZO_SIZEOF_PTRDIFF_T      (SIZEOF_PTRDIFF_T)
+#if !defined(LZO_STATIC_CAST)
+#  define LZO_STATIC_CAST(t,e)              ((t) (e))
 #endif
-#define __LZO_LSR(x,b)    (((x)+0ul) >> (b))
-#if !defined(LZO_SIZEOF_SHORT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (USHRT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,7) == 1)
-#    define LZO_SIZEOF_SHORT        1
-#  elif (__LZO_LSR(USHRT_MAX,15) == 1)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,31) == 1)
-#    define LZO_SIZEOF_SHORT        4
-#  elif (__LZO_LSR(USHRT_MAX,63) == 1)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (__LZO_LSR(USHRT_MAX,127) == 1)
-#    define LZO_SIZEOF_SHORT        16
-#  else
-#    error "LZO_SIZEOF_SHORT"
-#  endif
+#if !defined(LZO_STATIC_CAST2)
+#  define LZO_STATIC_CAST2(t1,t2,e)         LZO_STATIC_CAST(t1, LZO_STATIC_CAST(t2, e))
 #endif
-#if !defined(LZO_SIZEOF_INT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_INT          8
-#  elif (UINT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_INT          2
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,7) == 1)
-#    define LZO_SIZEOF_INT          1
-#  elif (__LZO_LSR(UINT_MAX,15) == 1)
-#    define LZO_SIZEOF_INT          2
-#  elif (__LZO_LSR(UINT_MAX,31) == 1)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,63) == 1)
-#    define LZO_SIZEOF_INT          8
-#  elif (__LZO_LSR(UINT_MAX,127) == 1)
-#    define LZO_SIZEOF_INT          16
-#  else
-#    error "LZO_SIZEOF_INT"
+#if !defined(LZO_UNCONST_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNCONST_CAST(t,e)           (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNCONST_CAST(t,e)           ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNCONST_CAST(t,e)           ((t) ((void *) ((lzo_uintptr_t) ((const void *) (e)))))
 #  endif
 #endif
-#if !defined(LZO_SIZEOF_LONG)
-#  if (ULONG_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,7) == 1)
-#    define LZO_SIZEOF_LONG         1
-#  elif (__LZO_LSR(ULONG_MAX,15) == 1)
-#    define LZO_SIZEOF_LONG         2
-#  elif (__LZO_LSR(ULONG_MAX,31) == 1)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,63) == 1)
-#    define LZO_SIZEOF_LONG         8
-#  elif (__LZO_LSR(ULONG_MAX,127) == 1)
-#    define LZO_SIZEOF_LONG         16
-#  else
-#    error "LZO_SIZEOF_LONG"
+#if !defined(LZO_UNCONST_CAST)
+#  define LZO_UNCONST_CAST(t,e)             ((t) ((void *) ((const void *) (e))))
+#endif
+#if !defined(LZO_UNCONST_VOLATILE_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNCONST_VOLATILE_CAST(t,e)  (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNCONST_VOLATILE_CAST(t,e)  ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNCONST_VOLATILE_CAST(t,e)  ((t) ((volatile void *) ((lzo_uintptr_t) ((volatile const void *) (e)))))
 #  endif
 #endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#  if defined(__LONG_MAX__) && defined(__LONG_LONG_MAX__)
-#    if (LZO_CC_GNUC >= 0x030300ul)
-#      if ((__LONG_MAX__)+0 == (__LONG_LONG_MAX__)+0)
-#        define LZO_SIZEOF_LONG_LONG      LZO_SIZEOF_LONG
-#      elif (__LZO_LSR(__LONG_LONG_MAX__,30) == 1)
-#        define LZO_SIZEOF_LONG_LONG      4
-#      endif
-#    endif
+#if !defined(LZO_UNCONST_VOLATILE_CAST)
+#  define LZO_UNCONST_VOLATILE_CAST(t,e)    ((t) ((volatile void *) ((volatile const void *) (e))))
+#endif
+#if !defined(LZO_UNVOLATILE_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNVOLATILE_CAST(t,e)        (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNVOLATILE_CAST(t,e)        ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNVOLATILE_CAST(t,e)        ((t) ((void *) ((lzo_uintptr_t) ((volatile void *) (e)))))
 #  endif
 #endif
+#if !defined(LZO_UNVOLATILE_CAST)
+#  define LZO_UNVOLATILE_CAST(t,e)          ((t) ((void *) ((volatile void *) (e))))
 #endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#if (LZO_ARCH_I086 && LZO_CC_DMC)
-#elif (LZO_CC_CILLY) && defined(__GNUC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif ((LZO_OS_WIN32 || LZO_OS_WIN64 || defined(_WIN32)) && LZO_CC_MSC && (_MSC_VER >= 1400))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_OS_WIN64 || defined(_WIN64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_DMC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_SYMANTECC && (__SC__ >= 0x700)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC && defined(__linux__)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_MWERKS || LZO_CC_PELLESC || LZO_CC_PGI || LZO_CC_SUNPROC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC || LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif ((LZO_OS_WIN32 || defined(_WIN32)) && (LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0520)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_WATCOMC && (__WATCOMC__ >= 1100)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_CC_WATCOMC && defined(_INTEGRAL_MAX_BITS) && (_INTEGRAL_MAX_BITS == 64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_SDCC) && (LZO_SIZEOF_INT == 2)
-#elif 1 && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define LZO_SIZEOF_LONG_LONG      8
+#if !defined(LZO_UNVOLATILE_CONST_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNVOLATILE_CONST_CAST(t,e)  (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNVOLATILE_CONST_CAST(t,e)  ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNVOLATILE_CONST_CAST(t,e)  ((t) ((const void *) ((lzo_uintptr_t) ((volatile const void *) (e)))))
+#  endif
 #endif
+#if !defined(LZO_UNVOLATILE_CONST_CAST)
+#  define LZO_UNVOLATILE_CONST_CAST(t,e)    ((t) ((const void *) ((volatile const void *) (e))))
 #endif
+#if !defined(LZO_PCAST)
+#  if (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_PCAST(t,e)                  ((t) (e))
+#  endif
 #endif
-#if defined(__cplusplus) && defined(LZO_CC_GNUC)
-#  if (LZO_CC_GNUC < 0x020800ul)
-#    undef LZO_SIZEOF_LONG_LONG
+#if !defined(LZO_PCAST)
+#  define LZO_PCAST(t,e)                    LZO_STATIC_CAST(t, LZO_STATIC_CAST(void *, e))
+#endif
+#if !defined(LZO_CCAST)
+#  if (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_CCAST(t,e)                  ((t) (e))
 #  endif
 #endif
-#if defined(LZO_CFG_NO_LONG_LONG) || defined(__NO_LONG_LONG)
-#  undef LZO_SIZEOF_LONG_LONG
+#if !defined(LZO_CCAST)
+#  define LZO_CCAST(t,e)                    LZO_STATIC_CAST(t, LZO_STATIC_CAST(const void *, e))
 #endif
-#if !defined(LZO_SIZEOF_VOID_P)
-#if (LZO_ARCH_I086)
-#  define __LZO_WORDSIZE            2
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
-#    define LZO_SIZEOF_VOID_P       2
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    error "LZO_MM"
+#if !defined(LZO_ICONV)
+#  define LZO_ICONV(t,e)                    LZO_STATIC_CAST(t, e)
+#endif
+#if !defined(LZO_ICAST)
+#  define LZO_ICAST(t,e)                    LZO_STATIC_CAST(t, e)
+#endif
+#if !defined(LZO_ITRUNC)
+#  define LZO_ITRUNC(t,e)                   LZO_STATIC_CAST(t, e)
+#endif
+#if !defined(__lzo_cte)
+#  if (LZO_CC_MSC || LZO_CC_WATCOMC)
+#    define __lzo_cte(e)            ((void)0,(e))
+#  elif 1
+#    define __lzo_cte(e)            ((void)0,(e))
 #  endif
-#elif (LZO_ARCH_AVR || LZO_ARCH_Z80)
-#  define __LZO_WORDSIZE            1
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_C166 || LZO_ARCH_MCS51 || LZO_ARCH_MCS251 || LZO_ARCH_MSP430)
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_H8300)
-#  if defined(__NORMAL_MODE__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       2
-#  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define __LZO_WORDSIZE          2
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_SIZEOF_INT == 4)
-#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_INT
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_INT
-#  endif
-#elif (LZO_ARCH_M16C)
-#  define __LZO_WORDSIZE            2
-#  if defined(__m32c_cpu__) || defined(__m32cm_cpu__)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         4
-#elif defined(__LLP64__) || defined(__LLP64) || defined(_LLP64) || defined(_WIN64)
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_OS_OS400 || defined(__OS400__))
-#  define __LZO_WORDSIZE            LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_VOID_P         16
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_VOID_P         8
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_ARCH_SPU)
-# if 0
-#  define __LZO_WORDSIZE            16
-# endif
-#  define LZO_SIZEOF_VOID_P         4
-#else
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
 #endif
+#if !defined(__lzo_cte)
+#  define __lzo_cte(e)              (e)
 #endif
-#if !defined(LZO_WORDSIZE)
-#  if defined(__LZO_WORDSIZE)
-#    define LZO_WORDSIZE            __LZO_WORDSIZE
+#if !defined(LZO_BLOCK_BEGIN)
+#  define LZO_BLOCK_BEGIN           do {
+#  define LZO_BLOCK_END             } while __lzo_cte(0)
+#endif
+#if !defined(LZO_UNUSED)
+#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
+#    define LZO_UNUSED(var)         ((void) &var)
+#  elif (LZO_CC_BORLANDC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PELLESC || LZO_CC_TURBOC)
+#    define LZO_UNUSED(var)         if (&var) ; else
+#  elif (LZO_CC_CLANG && (LZO_CC_CLANG >= 0x030200ul))
+#    define LZO_UNUSED(var)         ((void) &var)
+#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNUSED(var)         ((void) var)
+#  elif (LZO_CC_MSC && (_MSC_VER < 900))
+#    define LZO_UNUSED(var)         if (&var) ; else
+#  elif (LZO_CC_KEILC)
+#    define LZO_UNUSED(var)         {LZO_EXTERN_C int lzo_unused__[1-2*!(sizeof(var)>0)];}
+#  elif (LZO_CC_PACIFICC)
+#    define LZO_UNUSED(var)         ((void) sizeof(var))
+#  elif (LZO_CC_WATCOMC) && defined(__cplusplus)
+#    define LZO_UNUSED(var)         ((void) var)
 #  else
-#    define LZO_WORDSIZE            LZO_SIZEOF_VOID_P
+#    define LZO_UNUSED(var)         ((void) &var)
 #  endif
 #endif
-#if !defined(LZO_SIZEOF_SIZE_T)
-#if (LZO_ARCH_I086 || LZO_ARCH_M16C)
-#  define LZO_SIZEOF_SIZE_T         2
-#else
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_VOID_P
-#endif
-#endif
-#if !defined(LZO_SIZEOF_PTRDIFF_T)
-#if (LZO_ARCH_I086)
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM || LZO_MM_HUGE)
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_VOID_P
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE)
-#    if (LZO_CC_BORLANDC || LZO_CC_TURBOC)
-#      define LZO_SIZEOF_PTRDIFF_T  4
-#    else
-#      define LZO_SIZEOF_PTRDIFF_T  2
-#    endif
+#if !defined(LZO_UNUSED_FUNC)
+#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
+#    define LZO_UNUSED_FUNC(func)   ((void) func)
+#  elif (LZO_CC_BORLANDC || LZO_CC_NDPC || LZO_CC_TURBOC)
+#    define LZO_UNUSED_FUNC(func)   if (func) ; else
+#  elif (LZO_CC_CLANG || LZO_CC_LLVM)
+#    define LZO_UNUSED_FUNC(func)   ((void) &func)
+#  elif (LZO_CC_MSC && (_MSC_VER < 900))
+#    define LZO_UNUSED_FUNC(func)   if (func) ; else
+#  elif (LZO_CC_MSC)
+#    define LZO_UNUSED_FUNC(func)   ((void) &func)
+#  elif (LZO_CC_KEILC || LZO_CC_PELLESC)
+#    define LZO_UNUSED_FUNC(func)   {LZO_EXTERN_C int lzo_unused_func__[1-2*!(sizeof((int)func)>0)];}
 #  else
-#    error "LZO_MM"
+#    define LZO_UNUSED_FUNC(func)   ((void) func)
 #  endif
-#else
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_SIZE_T
-#endif
 #endif
-#if defined(LZO_ABI_NEUTRAL_ENDIAN)
-#  undef LZO_ABI_BIG_ENDIAN
-#  undef LZO_ABI_LITTLE_ENDIAN
-#elif !defined(LZO_ABI_BIG_ENDIAN) && !defined(LZO_ABI_LITTLE_ENDIAN)
-#if (LZO_ARCH_ALPHA) && (LZO_ARCH_CRAY_MPP)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif (LZO_ARCH_ALPHA || LZO_ARCH_AMD64 || LZO_ARCH_BLACKFIN || LZO_ARCH_CRIS || LZO_ARCH_I086 || LZO_ARCH_I386 || LZO_ARCH_MSP430)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif (LZO_ARCH_M68K || LZO_ARCH_S390)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__IAR_SYSTEMS_ICC__) && defined(__LITTLE_ENDIAN__)
-#  if (__LITTLE_ENDIAN__ == 1)
-#    define LZO_ABI_LITTLE_ENDIAN   1
+#if !defined(LZO_UNUSED_LABEL)
+#  if (LZO_CC_CLANG >= 0x020800ul)
+#    define LZO_UNUSED_LABEL(l)     (__lzo_gnuc_extension__ ((void) ((const void *) &&l)))
+#  elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_INTELC || LZO_CC_WATCOMC)
+#    define LZO_UNUSED_LABEL(l)     if __lzo_cte(0) goto l
 #  else
-#    define LZO_ABI_BIG_ENDIAN      1
+#    define LZO_UNUSED_LABEL(l)     switch (0) case 1:goto l
 #  endif
-#elif 1 && defined(__BIG_ENDIAN__) && !defined(__LITTLE_ENDIAN__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEB__) && !defined(__ARMEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEL__) && !defined(__ARMEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEB__) && !defined(__MIPSEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEL__) && !defined(__MIPSEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#endif
-#endif
-#if defined(LZO_ABI_BIG_ENDIAN) && defined(LZO_ABI_LITTLE_ENDIAN)
-#  error "this should not happen"
-#endif
-#if defined(LZO_ABI_BIG_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "be"
-#elif defined(LZO_ABI_LITTLE_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "le"
-#elif defined(LZO_ABI_NEUTRAL_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "neutral"
-#endif
-#if (LZO_SIZEOF_INT == 1 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_I8LP16         1
-#  define LZO_INFO_ABI_PM       "i8lp16"
-#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_ILP16         1
-#  define LZO_INFO_ABI_PM       "ilp16"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_ILP32         1
-#  define LZO_INFO_ABI_PM       "ilp32"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 8 && LZO_SIZEOF_SIZE_T == 8)
-#  define LZO_ABI_LLP64         1
-#  define LZO_INFO_ABI_PM       "llp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_LP64          1
-#  define LZO_INFO_ABI_PM       "lp64"
-#elif (LZO_SIZEOF_INT == 8 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_ILP64         1
-#  define LZO_INFO_ABI_PM       "ilp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_IP32L64       1
-#  define LZO_INFO_ABI_PM       "ip32l64"
 #endif
-#if !defined(__LZO_LIBC_OVERRIDE)
-#if defined(LZO_LIBC_NAKED)
-#  define LZO_INFO_LIBC         "naked"
-#elif defined(LZO_LIBC_FREESTANDING)
-#  define LZO_INFO_LIBC         "freestanding"
-#elif defined(LZO_LIBC_MOSTLY_FREESTANDING)
-#  define LZO_INFO_LIBC         "mfreestanding"
-#elif defined(LZO_LIBC_ISOC90)
-#  define LZO_INFO_LIBC         "isoc90"
-#elif defined(LZO_LIBC_ISOC99)
-#  define LZO_INFO_LIBC         "isoc99"
-#elif defined(__dietlibc__)
-#  define LZO_LIBC_DIETLIBC     1
-#  define LZO_INFO_LIBC         "dietlibc"
-#elif defined(_NEWLIB_VERSION)
-#  define LZO_LIBC_NEWLIB       1
-#  define LZO_INFO_LIBC         "newlib"
-#elif defined(__UCLIBC__) && defined(__UCLIBC_MAJOR__) && defined(__UCLIBC_MINOR__)
-#  if defined(__UCLIBC_SUBLEVEL__)
-#    define LZO_LIBC_UCLIBC     (__UCLIBC_MAJOR__ * 0x10000L + __UCLIBC_MINOR__ * 0x100 + __UCLIBC_SUBLEVEL__)
+#if !defined(LZO_DEFINE_UNINITIALIZED_VAR)
+#  if 0
+#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var
+#  elif 0 && (LZO_CC_GNUC)
+#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = var
 #  else
-#    define LZO_LIBC_UCLIBC     0x00090bL
+#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = init
 #  endif
-#  define LZO_INFO_LIBC         "uclibc"
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__)
-#  define LZO_LIBC_GLIBC        (__GLIBC__ * 0x10000L + __GLIBC_MINOR__ * 0x100)
-#  define LZO_INFO_LIBC         "glibc"
-#elif (LZO_CC_MWERKS) && defined(__MSL__)
-#  define LZO_LIBC_MSL          __MSL__
-#  define LZO_INFO_LIBC         "msl"
-#elif 1 && defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_LIBC_ISOC90       1
-#  define LZO_INFO_LIBC         "isoc90"
-#else
-#  define LZO_LIBC_DEFAULT      1
-#  define LZO_INFO_LIBC         "default"
-#endif
-#endif
-#if !defined(__lzo_gnuc_extension__)
-#if (LZO_CC_GNUC >= 0x020800ul)
-#  define __lzo_gnuc_extension__    __extension__
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_gnuc_extension__    __extension__
-#else
-#  define __lzo_gnuc_extension__
-#endif
-#endif
-#if !defined(__lzo_ua_volatile)
-#  define __lzo_ua_volatile     volatile
-#endif
-#if !defined(__lzo_alignof)
-#if (LZO_CC_CILLY || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 700))
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_alignof(e)      __alignof(e)
-#endif
-#endif
-#if defined(__lzo_alignof)
-#  define __lzo_HAVE_alignof 1
-#endif
-#if !defined(__lzo_constructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_constructor     __attribute__((__constructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#endif
-#endif
-#if defined(__lzo_constructor)
-#  define __lzo_HAVE_constructor 1
-#endif
-#if !defined(__lzo_destructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_destructor      __attribute__((__destructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#endif
-#endif
-#if defined(__lzo_destructor)
-#  define __lzo_HAVE_destructor 1
-#endif
-#if defined(__lzo_HAVE_destructor) && !defined(__lzo_HAVE_constructor)
-#  error "this should not happen"
 #endif
 #if !defined(__lzo_inline)
 #if (LZO_CC_TURBOC && (__TURBOC__ <= 0x0295))
 #elif defined(__cplusplus)
 #  define __lzo_inline          inline
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__-0 >= 199901L)
+#  define __lzo_inline          inline
 #elif (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0550))
 #  define __lzo_inline          __inline
-#elif (LZO_CC_CILLY || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
 #  define __lzo_inline          __inline__
 #elif (LZO_CC_DMC)
 #  define __lzo_inline          __inline
+#elif (LZO_CC_GHS)
+#  define __lzo_inline          __inline__
+#elif (LZO_CC_IBMC >= 600)
+#  define __lzo_inline          __inline__
 #elif (LZO_CC_INTELC)
 #  define __lzo_inline          __inline
 #elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x2405))
 #  define __lzo_inline          __inline
 #elif (LZO_CC_MSC && (_MSC_VER >= 900))
 #  define __lzo_inline          __inline
-#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define __lzo_inline          inline
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_inline          __inline__
 #endif
 #endif
 #if defined(__lzo_inline)
+#  ifndef __lzo_HAVE_inline
 #  define __lzo_HAVE_inline 1
+#  endif
 #else
-#  define __lzo_inline
+#  define __lzo_inline          /*empty*/
 #endif
 #if !defined(__lzo_forceinline)
 #if (LZO_CC_GNUC >= 0x030200ul)
 #  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450))
 #  define __lzo_forceinline     __forceinline
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
 #  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
 #  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
 #elif (LZO_CC_MSC && (_MSC_VER >= 1200))
 #  define __lzo_forceinline     __forceinline
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
 #endif
 #endif
 #if defined(__lzo_forceinline)
+#  ifndef __lzo_HAVE_forceinline
 #  define __lzo_HAVE_forceinline 1
+#  endif
 #else
-#  define __lzo_forceinline
+#  define __lzo_forceinline     __lzo_inline
 #endif
 #if !defined(__lzo_noinline)
 #if 1 && (LZO_ARCH_I386) && (LZO_CC_GNUC >= 0x040000ul) && (LZO_CC_GNUC < 0x040003ul)
 #  define __lzo_noinline        __attribute__((__noinline__,__used__))
 #elif (LZO_CC_GNUC >= 0x030200ul)
 #  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_MSC)
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_noinline        __attribute__((__noinline__))
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 600))
 #  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
 #  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
 #  define __lzo_noinline        __attribute__((__noinline__))
 #elif (LZO_CC_MSC && (_MSC_VER >= 1300))
 #  define __lzo_noinline        __declspec(noinline)
@@ -1441,173 +1479,414 @@ extern "C" {
 #  else
 #    define __lzo_noinline      __declspec(noinline)
 #  endif
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_noinline        __attribute__((__noinline__))
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_noinline        __attribute__((__noinline__))
 #endif
 #endif
 #if defined(__lzo_noinline)
+#  ifndef __lzo_HAVE_noinline
 #  define __lzo_HAVE_noinline 1
+#  endif
+#else
+#  define __lzo_noinline        /*empty*/
+#endif
+#if (__lzo_HAVE_forceinline || __lzo_HAVE_noinline) && !(__lzo_HAVE_inline)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if !defined(__lzo_static_inline)
+#if (LZO_CC_IBMC)
+#  define __lzo_static_inline       __lzo_gnuc_extension__ static __lzo_inline
+#endif
+#endif
+#if !defined(__lzo_static_inline)
+#  define __lzo_static_inline       static __lzo_inline
+#endif
+#if !defined(__lzo_static_forceinline)
+#if (LZO_CC_IBMC)
+#  define __lzo_static_forceinline  __lzo_gnuc_extension__ static __lzo_forceinline
+#endif
+#endif
+#if !defined(__lzo_static_forceinline)
+#  define __lzo_static_forceinline  static __lzo_forceinline
+#endif
+#if !defined(__lzo_static_noinline)
+#if (LZO_CC_IBMC)
+#  define __lzo_static_noinline     __lzo_gnuc_extension__ static __lzo_noinline
+#endif
+#endif
+#if !defined(__lzo_static_noinline)
+#  define __lzo_static_noinline     static __lzo_noinline
+#endif
+#if !defined(__lzo_c99_extern_inline)
+#if defined(__GNUC_GNU_INLINE__)
+#  define __lzo_c99_extern_inline   __lzo_inline
+#elif defined(__GNUC_STDC_INLINE__)
+#  define __lzo_c99_extern_inline   extern __lzo_inline
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__-0 >= 199901L)
+#  define __lzo_c99_extern_inline   extern __lzo_inline
+#endif
+#if !defined(__lzo_c99_extern_inline) && (__lzo_HAVE_inline)
+#  define __lzo_c99_extern_inline   __lzo_inline
+#endif
+#endif
+#if defined(__lzo_c99_extern_inline)
+#  ifndef __lzo_HAVE_c99_extern_inline
+#  define __lzo_HAVE_c99_extern_inline 1
+#  endif
 #else
-#  define __lzo_noinline
+#  define __lzo_c99_extern_inline   /*empty*/
 #endif
-#if (defined(__lzo_HAVE_forceinline) || defined(__lzo_HAVE_noinline)) && !defined(__lzo_HAVE_inline)
-#  error "this should not happen"
+#if !defined(__lzo_may_alias)
+#if (LZO_CC_GNUC >= 0x030400ul)
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#elif (LZO_CC_CLANG >= 0x020900ul)
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 1210)) && 0
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#elif (LZO_CC_PGI >= 0x0d0a00ul) && 0
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#endif
+#endif
+#if defined(__lzo_may_alias)
+#  ifndef __lzo_HAVE_may_alias
+#  define __lzo_HAVE_may_alias 1
+#  endif
+#else
+#  define __lzo_may_alias       /*empty*/
 #endif
 #if !defined(__lzo_noreturn)
 #if (LZO_CC_GNUC >= 0x020700ul)
 #  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_noreturn        __attribute__((__noreturn__))
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450))
 #  define __lzo_noreturn        __declspec(noreturn)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 600))
 #  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
 #  define __lzo_noreturn        __attribute__((__noreturn__))
 #elif (LZO_CC_MSC && (_MSC_VER >= 1200))
 #  define __lzo_noreturn        __declspec(noreturn)
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_noreturn        __attribute__((__noreturn__))
 #endif
 #endif
 #if defined(__lzo_noreturn)
+#  ifndef __lzo_HAVE_noreturn
 #  define __lzo_HAVE_noreturn 1
+#  endif
 #else
-#  define __lzo_noreturn
+#  define __lzo_noreturn        /*empty*/
 #endif
 #if !defined(__lzo_nothrow)
 #if (LZO_CC_GNUC >= 0x030300ul)
 #  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC) && defined(__cplusplus)
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450)) && defined(__cplusplus)
 #  define __lzo_nothrow         __declspec(nothrow)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 900))
 #  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
 #  define __lzo_nothrow         __attribute__((__nothrow__))
 #elif (LZO_CC_MSC && (_MSC_VER >= 1200)) && defined(__cplusplus)
 #  define __lzo_nothrow         __declspec(nothrow)
 #endif
 #endif
 #if defined(__lzo_nothrow)
+#  ifndef __lzo_HAVE_nothrow
 #  define __lzo_HAVE_nothrow 1
+#  endif
 #else
-#  define __lzo_nothrow
+#  define __lzo_nothrow         /*empty*/
 #endif
 #if !defined(__lzo_restrict)
 #if (LZO_CC_GNUC >= 0x030400ul)
 #  define __lzo_restrict        __restrict__
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
+#elif (LZO_CC_IBMC >= 800) && !defined(__cplusplus)
 #  define __lzo_restrict        __restrict__
-#elif (LZO_CC_LLVM)
+#elif (LZO_CC_IBMC >= 1210)
+#  define __lzo_restrict        __restrict__
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 600))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 600))
+#  define __lzo_restrict        __restrict__
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM)
 #  define __lzo_restrict        __restrict__
 #elif (LZO_CC_MSC && (_MSC_VER >= 1400))
 #  define __lzo_restrict        __restrict
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_restrict        __restrict__
 #endif
 #endif
 #if defined(__lzo_restrict)
+#  ifndef __lzo_HAVE_restrict
 #  define __lzo_HAVE_restrict 1
+#  endif
 #else
-#  define __lzo_restrict
+#  define __lzo_restrict        /*empty*/
 #endif
-#if !defined(__lzo_likely) && !defined(__lzo_unlikely)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800))
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
+#if !defined(__lzo_alignof)
+#if (LZO_CC_ARMCC || LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+#  define __lzo_alignof(e)      __alignof__(e)
+#elif (LZO_CC_GHS) && !defined(__cplusplus)
+#  define __lzo_alignof(e)      __alignof__(e)
+#elif (LZO_CC_IBMC >= 600)
+#  define __lzo_alignof(e)      (__lzo_gnuc_extension__ __alignof__(e))
+#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 700))
+#  define __lzo_alignof(e)      __alignof__(e)
+#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_alignof(e)      __alignof(e)
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_alignof(e)      __alignof__(e)
+#endif
+#endif
+#if defined(__lzo_alignof)
+#  ifndef __lzo_HAVE_alignof
+#  define __lzo_HAVE_alignof 1
+#  endif
+#endif
+#if !defined(__lzo_struct_packed)
+#if   (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020700ul))
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_PCC && (LZO_CC_PCC < 0x010100ul))
+#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC < 0x5110)) && !defined(__cplusplus)
+#elif (LZO_CC_GNUC >= 0x030400ul) && !(LZO_CC_PCC_GNUC) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+#  define __lzo_struct_packed(s)        struct s {
+#  define __lzo_struct_packed_end()     } __attribute__((__gcc_struct__,__packed__));
+#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__gcc_struct__,__packed__));
+#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || (LZO_CC_PGI >= 0x0d0a00ul) || (LZO_CC_SUNPROC >= 0x5100))
+#  define __lzo_struct_packed(s)        struct s {
+#  define __lzo_struct_packed_end()     } __attribute__((__packed__));
+#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_struct_packed(s)        __lzo_gnuc_extension__ struct s {
+#  define __lzo_struct_packed_end()     } __attribute__((__packed__));
+#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_struct_packed(s)        __pragma(pack(push,1)) struct s {
+#  define __lzo_struct_packed_end()     } __pragma(pack(pop));
+#elif (LZO_CC_WATCOMC && (__WATCOMC__ >= 900))
+#  define __lzo_struct_packed(s)        _Packed struct s {
+#  define __lzo_struct_packed_end()     };
+#endif
+#endif
+#if defined(__lzo_struct_packed) && !defined(__lzo_struct_packed_ma)
+#  define __lzo_struct_packed_ma(s)     __lzo_struct_packed(s)
+#endif
+#if defined(__lzo_struct_packed_end) && !defined(__lzo_struct_packed_ma_end)
+#  define __lzo_struct_packed_ma_end()  __lzo_struct_packed_end()
+#endif
+#if !defined(__lzo_byte_struct)
+#if defined(__lzo_struct_packed)
+#  define __lzo_byte_struct(s,n)        __lzo_struct_packed(s) unsigned char a[n]; __lzo_struct_packed_end()
+#  define __lzo_byte_struct_ma(s,n)     __lzo_struct_packed_ma(s) unsigned char a[n]; __lzo_struct_packed_ma_end()
+#elif (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_PGI || (LZO_CC_SUNPROC >= 0x5100))
+#  define __lzo_byte_struct(s,n)        struct s { unsigned char a[n]; } __attribute__((__packed__));
+#  define __lzo_byte_struct_ma(s,n)     struct s { unsigned char a[n]; } __lzo_may_alias __attribute__((__packed__));
+#endif
+#endif
+#if defined(__lzo_byte_struct) &&  !defined(__lzo_byte_struct_ma)
+#  define __lzo_byte_struct_ma(s,n)     __lzo_byte_struct(s,n)
+#endif
+#if !defined(__lzo_struct_align16) && (__lzo_HAVE_alignof)
+#if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x030000ul))
+#elif (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_CILLY || LZO_CC_PCC)
+#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_struct_align16(s)       struct __declspec(align(16)) s {
+#  define __lzo_struct_align16_end()    };
+#  define __lzo_struct_align32(s)       struct __declspec(align(32)) s {
+#  define __lzo_struct_align32_end()    };
+#  define __lzo_struct_align64(s)       struct __declspec(align(64)) s {
+#  define __lzo_struct_align64_end()    };
+#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || (LZO_CC_IBMC >= 700) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_struct_align16(s)       struct s {
+#  define __lzo_struct_align16_end()    } __attribute__((__aligned__(16)));
+#  define __lzo_struct_align32(s)       struct s {
+#  define __lzo_struct_align32_end()    } __attribute__((__aligned__(32)));
+#  define __lzo_struct_align64(s)       struct s {
+#  define __lzo_struct_align64_end()    } __attribute__((__aligned__(64)));
+#endif
+#endif
+#if !defined(__lzo_union_um)
+#if   (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020700ul))
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER < 810))
+#elif (LZO_CC_PCC && (LZO_CC_PCC < 0x010100ul))
+#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC < 0x5110)) && !defined(__cplusplus)
+#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || (LZO_CC_PGI >= 0x0d0a00ul) || (LZO_CC_SUNPROC >= 0x5100))
+#  define __lzo_union_am(s)             union s {
+#  define __lzo_union_am_end()          } __lzo_may_alias;
+#  define __lzo_union_um(s)             union s {
+#  define __lzo_union_um_end()          } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_union_am(s)             __lzo_gnuc_extension__ union s {
+#  define __lzo_union_am_end()          } __lzo_may_alias;
+#  define __lzo_union_um(s)             __lzo_gnuc_extension__ union s {
+#  define __lzo_union_um_end()          } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_union_um(s)             __pragma(pack(push,1)) union s {
+#  define __lzo_union_um_end()          } __pragma(pack(pop));
+#elif (LZO_CC_WATCOMC && (__WATCOMC__ >= 900))
+#  define __lzo_union_um(s)             _Packed union s {
+#  define __lzo_union_um_end()          };
+#endif
+#endif
+#if !defined(__lzo_union_am)
+#  define __lzo_union_am(s)             union s {
+#  define __lzo_union_am_end()          };
+#endif
+#if !defined(__lzo_constructor)
+#if (LZO_CC_GNUC >= 0x030400ul)
+#  define __lzo_constructor     __attribute__((__constructor__,__used__))
+#elif (LZO_CC_GNUC >= 0x020700ul)
+#  define __lzo_constructor     __attribute__((__constructor__))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
+#  define __lzo_constructor     __attribute__((__constructor__,__used__))
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_constructor     __attribute__((__constructor__))
+#endif
+#endif
+#if defined(__lzo_constructor)
+#  ifndef __lzo_HAVE_constructor
+#  define __lzo_HAVE_constructor 1
+#  endif
+#endif
+#if !defined(__lzo_destructor)
+#if (LZO_CC_GNUC >= 0x030400ul)
+#  define __lzo_destructor      __attribute__((__destructor__,__used__))
+#elif (LZO_CC_GNUC >= 0x020700ul)
+#  define __lzo_destructor      __attribute__((__destructor__))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
+#  define __lzo_destructor      __attribute__((__destructor__,__used__))
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_destructor      __attribute__((__destructor__))
+#endif
+#endif
+#if defined(__lzo_destructor)
+#  ifndef __lzo_HAVE_destructor
+#  define __lzo_HAVE_destructor 1
+#  endif
+#endif
+#if (__lzo_HAVE_destructor) && !(__lzo_HAVE_constructor)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if !defined(__lzo_likely) && !defined(__lzo_unlikely)
+#if (LZO_CC_GNUC >= 0x030200ul)
+#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
+#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
+#elif (LZO_CC_IBMC >= 1010)
+#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
+#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
+#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800))
+#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
 #  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
 #  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
 #  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
 #endif
 #endif
 #if defined(__lzo_likely)
+#  ifndef __lzo_HAVE_likely
 #  define __lzo_HAVE_likely 1
+#  endif
 #else
 #  define __lzo_likely(e)       (e)
 #endif
 #if defined(__lzo_unlikely)
+#  ifndef __lzo_HAVE_unlikely
 #  define __lzo_HAVE_unlikely 1
+#  endif
 #else
 #  define __lzo_unlikely(e)     (e)
 #endif
-#if !defined(LZO_UNUSED)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED(var)         ((void) &var)
-#  elif (LZO_CC_BORLANDC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PELLESC || LZO_CC_TURBOC)
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#    define LZO_UNUSED(var)         ((void) var)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_KEILC)
-#    define LZO_UNUSED(var)         {extern int __lzo_unused[1-2*!(sizeof(var)>0)];}
-#  elif (LZO_CC_PACIFICC)
-#    define LZO_UNUSED(var)         ((void) sizeof(var))
-#  elif (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED(var)         ((void) var)
+#if !defined(__lzo_static_unused_void_func)
+#  if 1 && (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+#    define __lzo_static_unused_void_func(f)    static void __attribute__((__unused__)) f(void)
 #  else
-#    define LZO_UNUSED(var)         ((void) &var)
+#    define __lzo_static_unused_void_func(f)    static __lzo_inline void f(void)
 #  endif
 #endif
-#if !defined(LZO_UNUSED_FUNC)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
-#  elif (LZO_CC_BORLANDC || LZO_CC_NDPC || LZO_CC_TURBOC)
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_LLVM)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_MSC)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_KEILC || LZO_CC_PELLESC)
-#    define LZO_UNUSED_FUNC(func)   {extern int __lzo_unused[1-2*!(sizeof((int)func)>0)];}
+#if !defined(__lzo_loop_forever)
+#  if (LZO_CC_IBMC)
+#    define __lzo_loop_forever()    LZO_BLOCK_BEGIN for (;;) { ; } LZO_BLOCK_END
 #  else
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
+#    define __lzo_loop_forever()    do { ; } while __lzo_cte(1)
 #  endif
 #endif
-#if !defined(LZO_UNUSED_LABEL)
-#  if (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  elif (LZO_CC_INTELC || LZO_CC_WATCOMC)
-#    define LZO_UNUSED_LABEL(l)     if (0) goto l
-#  else
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  endif
+#if !defined(__lzo_unreachable)
+#if (LZO_CC_CLANG && (LZO_CC_CLANG >= 0x020800ul))
+#  define __lzo_unreachable()       __builtin_unreachable();
+#elif (LZO_CC_GNUC >= 0x040500ul)
+#  define __lzo_unreachable()       __builtin_unreachable();
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 1300)) && 1
+#  define __lzo_unreachable()       __builtin_unreachable();
 #endif
-#if !defined(LZO_DEFINE_UNINITIALIZED_VAR)
+#endif
+#if defined(__lzo_unreachable)
+#  ifndef __lzo_HAVE_unreachable
+#  define __lzo_HAVE_unreachable 1
+#  endif
+#else
 #  if 0
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var
-#  elif 0 && (LZO_CC_GNUC)
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = var
+#  define __lzo_unreachable()       ((void)0);
 #  else
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = init
+#  define __lzo_unreachable()       __lzo_loop_forever();
 #  endif
 #endif
+#ifndef __LZO_CTA_NAME
+#if (LZO_CFG_USE_COUNTER)
+#  define __LZO_CTA_NAME(a)         LZO_PP_ECONCAT2(a,__COUNTER__)
+#else
+#  define __LZO_CTA_NAME(a)         LZO_PP_ECONCAT2(a,__LINE__)
+#endif
+#endif
 #if !defined(LZO_COMPILE_TIME_ASSERT_HEADER)
 #  if (LZO_CC_AZTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-!(e)]; LZO_EXTERN_C_END
 #  elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1u-2*!(e)];
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1u-2*!(e)]; LZO_EXTERN_C_END
 #  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-!(e)]; LZO_EXTERN_C_END
+#  elif (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020900ul)) && defined(__cplusplus)
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN int __LZO_CTA_NAME(lzo_cta_f__)(int [1-2*!(e)]); LZO_EXTERN_C_END
+#  elif (LZO_CC_GNUC) && defined(__CHECKER__) && defined(__SPARSE_CHECKER__)
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN enum {__LZO_CTA_NAME(lzo_cta_e__)=1/!!(e)} __attribute__((__unused__)); LZO_EXTERN_C_END
 #  else
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-2*!(e)];
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-2*!(e)]; LZO_EXTERN_C_END
 #  endif
 #endif
 #if !defined(LZO_COMPILE_TIME_ASSERT)
 #  if (LZO_CC_AZTECC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-!(e)];}
+#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-!(e)];}
 #  elif (LZO_CC_DMC || LZO_CC_PACIFICC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
 #    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
+#  elif (LZO_CC_GNUC) && defined(__CHECKER__) && defined(__SPARSE_CHECKER__)
+#    define LZO_COMPILE_TIME_ASSERT(e)  {(void) (0/!!(e));}
+#  elif (LZO_CC_GNUC >= 0x040700ul) && (LZO_CFG_USE_COUNTER) && defined(__cplusplus)
+#    define LZO_COMPILE_TIME_ASSERT(e)  {enum {__LZO_CTA_NAME(lzo_cta_e__)=1/!!(e)} __attribute__((__unused__));}
+#  elif (LZO_CC_GNUC >= 0x040700ul)
+#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-2*!(e)] __attribute__((__unused__));}
 #  elif (LZO_CC_MSC && (_MSC_VER < 900))
 #    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
 #  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
 #    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
 #  else
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-2*!(e)];}
+#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-2*!(e)];}
 #  endif
 #endif
+LZO_COMPILE_TIME_ASSERT_HEADER(1 == 1)
+#if defined(__cplusplus)
+extern "C" { LZO_COMPILE_TIME_ASSERT_HEADER(2 == 2) }
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(3 == 3)
 #if (LZO_ARCH_I086 || LZO_ARCH_I386) && (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
 #  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC)
 #  elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
 #    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit
+#    define __lzo_cdecl_atexit          /*empty*/
 #    define __lzo_cdecl_main            __cdecl
 #    if (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
 #      define __lzo_cdecl_qsort         __pascal
@@ -1648,24 +1927,25 @@ extern "C" {
 #  define __lzo_cdecl                   cdecl
 #endif
 #if !defined(__lzo_cdecl)
-#  define __lzo_cdecl
+#  define __lzo_cdecl                   /*empty*/
 #endif
 #if !defined(__lzo_cdecl_atexit)
-#  define __lzo_cdecl_atexit
+#  define __lzo_cdecl_atexit            /*empty*/
 #endif
 #if !defined(__lzo_cdecl_main)
-#  define __lzo_cdecl_main
+#  define __lzo_cdecl_main              /*empty*/
 #endif
 #if !defined(__lzo_cdecl_qsort)
-#  define __lzo_cdecl_qsort
+#  define __lzo_cdecl_qsort             /*empty*/
 #endif
 #if !defined(__lzo_cdecl_sighandler)
-#  define __lzo_cdecl_sighandler
+#  define __lzo_cdecl_sighandler        /*empty*/
 #endif
 #if !defined(__lzo_cdecl_va)
 #  define __lzo_cdecl_va                __lzo_cdecl
 #endif
-#if !defined(LZO_CFG_NO_WINDOWS_H)
+#if !(LZO_CFG_NO_WINDOWS_H)
+#if !defined(LZO_HAVE_WINDOWS_H)
 #if (LZO_OS_CYGWIN || (LZO_OS_EMX && defined(__RSXNT__)) || LZO_OS_WIN32 || LZO_OS_WIN64)
 #  if (LZO_CC_WATCOMC && (__WATCOMC__ < 1000))
 #  elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
@@ -1675,133 +1955,1044 @@ extern "C" {
 #  endif
 #endif
 #endif
-#if (LZO_ARCH_ALPHA)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_AMD64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  define LZO_OPT_UNALIGNED64       1
-#elif (LZO_ARCH_ARM && LZO_ARCH_ARM_THUMB)
-#elif (LZO_ARCH_ARM)
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_CRIS)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#elif (LZO_ARCH_I386)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#elif (LZO_ARCH_IA64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_PREFER_POSTINC    1
-#elif (LZO_ARCH_M68K)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if defined(__mc68020__) && !defined(__mcoldfire__)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
-#  endif
-#elif (LZO_ARCH_MIPS)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#elif (LZO_ARCH_POWERPC)
-#  define LZO_OPT_PREFER_PREINC     1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if defined(LZO_ABI_BIG_ENDIAN)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
-#  endif
-#elif (LZO_ARCH_S390)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  if (LZO_SIZEOF_SIZE_T == 8)
-#    define LZO_OPT_UNALIGNED64     1
-#  endif
-#elif (LZO_ARCH_SH)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
 #endif
-#if !defined(LZO_CFG_NO_INLINE_ASM)
-#if defined(LZO_CC_LLVM)
-#  define LZO_CFG_NO_INLINE_ASM 1
+#ifndef LZO_SIZEOF_SHORT
+#if defined(SIZEOF_SHORT)
+#  define LZO_SIZEOF_SHORT          (SIZEOF_SHORT)
+#elif defined(__SIZEOF_SHORT__)
+#  define LZO_SIZEOF_SHORT          (__SIZEOF_SHORT__)
 #endif
 #endif
-#if !defined(LZO_CFG_NO_UNALIGNED)
-#if defined(LZO_ABI_NEUTRAL_ENDIAN) || defined(LZO_ARCH_GENERIC)
-#  define LZO_CFG_NO_UNALIGNED 1
+#ifndef LZO_SIZEOF_INT
+#if defined(SIZEOF_INT)
+#  define LZO_SIZEOF_INT            (SIZEOF_INT)
+#elif defined(__SIZEOF_INT__)
+#  define LZO_SIZEOF_INT            (__SIZEOF_INT__)
 #endif
 #endif
-#if defined(LZO_CFG_NO_UNALIGNED)
-#  undef LZO_OPT_UNALIGNED16
-#  undef LZO_OPT_UNALIGNED32
-#  undef LZO_OPT_UNALIGNED64
+#ifndef LZO_SIZEOF_LONG
+#if defined(SIZEOF_LONG)
+#  define LZO_SIZEOF_LONG           (SIZEOF_LONG)
+#elif defined(__SIZEOF_LONG__)
+#  define LZO_SIZEOF_LONG           (__SIZEOF_LONG__)
 #endif
-#if defined(LZO_CFG_NO_INLINE_ASM)
-#elif (LZO_ARCH_I386 && (LZO_OS_DOS32 || LZO_OS_WIN32) && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#  define LZO_ASM_SYNTAX_MSC 1
-#elif (LZO_OS_WIN64 && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#elif (LZO_ARCH_I386 && (LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#elif (LZO_ARCH_AMD64 && (LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
 #endif
-#if (LZO_ASM_SYNTAX_GNUC)
-#if (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
-#  define __LZO_ASM_CLOBBER         "ax"
-#elif (LZO_CC_INTELC)
-#  define __LZO_ASM_CLOBBER         "memory"
-#else
-#  define __LZO_ASM_CLOBBER         "cc", "memory"
+#ifndef LZO_SIZEOF_LONG_LONG
+#if defined(SIZEOF_LONG_LONG)
+#  define LZO_SIZEOF_LONG_LONG      (SIZEOF_LONG_LONG)
+#elif defined(__SIZEOF_LONG_LONG__)
+#  define LZO_SIZEOF_LONG_LONG      (__SIZEOF_LONG_LONG__)
 #endif
 #endif
-#if defined(__LZO_INFOSTR_MM)
-#elif (LZO_MM_FLAT) && (defined(__LZO_INFOSTR_PM) || defined(LZO_INFO_ABI_PM))
-#  define __LZO_INFOSTR_MM          ""
-#elif defined(LZO_INFO_MM)
-#  define __LZO_INFOSTR_MM          "." LZO_INFO_MM
-#else
-#  define __LZO_INFOSTR_MM          ""
+#ifndef LZO_SIZEOF___INT16
+#if defined(SIZEOF___INT16)
+#  define LZO_SIZEOF___INT16        (SIZEOF___INT16)
 #endif
-#if defined(__LZO_INFOSTR_PM)
-#elif defined(LZO_INFO_ABI_PM)
-#  define __LZO_INFOSTR_PM          "." LZO_INFO_ABI_PM
-#else
-#  define __LZO_INFOSTR_PM          ""
 #endif
-#if defined(__LZO_INFOSTR_ENDIAN)
-#elif defined(LZO_INFO_ABI_ENDIAN)
-#  define __LZO_INFOSTR_ENDIAN      "." LZO_INFO_ABI_ENDIAN
-#else
-#  define __LZO_INFOSTR_ENDIAN      ""
+#ifndef LZO_SIZEOF___INT32
+#if defined(SIZEOF___INT32)
+#  define LZO_SIZEOF___INT32        (SIZEOF___INT32)
 #endif
-#if defined(__LZO_INFOSTR_OSNAME)
-#elif defined(LZO_INFO_OS_CONSOLE)
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_CONSOLE
-#elif defined(LZO_INFO_OS_POSIX)
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_POSIX
-#else
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS
 #endif
-#if defined(__LZO_INFOSTR_LIBC)
-#elif defined(LZO_INFO_LIBC)
-#  define __LZO_INFOSTR_LIBC        "." LZO_INFO_LIBC
-#else
-#  define __LZO_INFOSTR_LIBC        ""
+#ifndef LZO_SIZEOF___INT64
+#if defined(SIZEOF___INT64)
+#  define LZO_SIZEOF___INT64        (SIZEOF___INT64)
+#endif
+#endif
+#ifndef LZO_SIZEOF_VOID_P
+#if defined(SIZEOF_VOID_P)
+#  define LZO_SIZEOF_VOID_P         (SIZEOF_VOID_P)
+#elif defined(__SIZEOF_POINTER__)
+#  define LZO_SIZEOF_VOID_P         (__SIZEOF_POINTER__)
+#endif
+#endif
+#ifndef LZO_SIZEOF_SIZE_T
+#if defined(SIZEOF_SIZE_T)
+#  define LZO_SIZEOF_SIZE_T         (SIZEOF_SIZE_T)
+#elif defined(__SIZEOF_SIZE_T__)
+#  define LZO_SIZEOF_SIZE_T         (__SIZEOF_SIZE_T__)
+#endif
+#endif
+#ifndef LZO_SIZEOF_PTRDIFF_T
+#if defined(SIZEOF_PTRDIFF_T)
+#  define LZO_SIZEOF_PTRDIFF_T      (SIZEOF_PTRDIFF_T)
+#elif defined(__SIZEOF_PTRDIFF_T__)
+#  define LZO_SIZEOF_PTRDIFF_T      (__SIZEOF_PTRDIFF_T__)
+#endif
+#endif
+#define __LZO_LSR(x,b)    (((x)+0ul) >> (b))
+#if !defined(LZO_SIZEOF_SHORT)
+#  if (LZO_ARCH_CRAY_PVP)
+#    define LZO_SIZEOF_SHORT        8
+#  elif (USHRT_MAX == LZO_0xffffL)
+#    define LZO_SIZEOF_SHORT        2
+#  elif (__LZO_LSR(USHRT_MAX,7) == 1)
+#    define LZO_SIZEOF_SHORT        1
+#  elif (__LZO_LSR(USHRT_MAX,15) == 1)
+#    define LZO_SIZEOF_SHORT        2
+#  elif (__LZO_LSR(USHRT_MAX,31) == 1)
+#    define LZO_SIZEOF_SHORT        4
+#  elif (__LZO_LSR(USHRT_MAX,63) == 1)
+#    define LZO_SIZEOF_SHORT        8
+#  elif (__LZO_LSR(USHRT_MAX,127) == 1)
+#    define LZO_SIZEOF_SHORT        16
+#  else
+#    error "LZO_SIZEOF_SHORT"
+#  endif
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_SHORT == sizeof(short))
+#if !defined(LZO_SIZEOF_INT)
+#  if (LZO_ARCH_CRAY_PVP)
+#    define LZO_SIZEOF_INT          8
+#  elif (UINT_MAX == LZO_0xffffL)
+#    define LZO_SIZEOF_INT          2
+#  elif (UINT_MAX == LZO_0xffffffffL)
+#    define LZO_SIZEOF_INT          4
+#  elif (__LZO_LSR(UINT_MAX,7) == 1)
+#    define LZO_SIZEOF_INT          1
+#  elif (__LZO_LSR(UINT_MAX,15) == 1)
+#    define LZO_SIZEOF_INT          2
+#  elif (__LZO_LSR(UINT_MAX,31) == 1)
+#    define LZO_SIZEOF_INT          4
+#  elif (__LZO_LSR(UINT_MAX,63) == 1)
+#    define LZO_SIZEOF_INT          8
+#  elif (__LZO_LSR(UINT_MAX,127) == 1)
+#    define LZO_SIZEOF_INT          16
+#  else
+#    error "LZO_SIZEOF_INT"
+#  endif
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_INT == sizeof(int))
+#if !defined(LZO_SIZEOF_LONG)
+#  if (ULONG_MAX == LZO_0xffffffffL)
+#    define LZO_SIZEOF_LONG         4
+#  elif (__LZO_LSR(ULONG_MAX,7) == 1)
+#    define LZO_SIZEOF_LONG         1
+#  elif (__LZO_LSR(ULONG_MAX,15) == 1)
+#    define LZO_SIZEOF_LONG         2
+#  elif (__LZO_LSR(ULONG_MAX,31) == 1)
+#    define LZO_SIZEOF_LONG         4
+#  elif (__LZO_LSR(ULONG_MAX,39) == 1)
+#    define LZO_SIZEOF_LONG         5
+#  elif (__LZO_LSR(ULONG_MAX,63) == 1)
+#    define LZO_SIZEOF_LONG         8
+#  elif (__LZO_LSR(ULONG_MAX,127) == 1)
+#    define LZO_SIZEOF_LONG         16
+#  else
+#    error "LZO_SIZEOF_LONG"
+#  endif
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_LONG == sizeof(long))
+#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
+#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
+#  if defined(__LONG_MAX__) && defined(__LONG_LONG_MAX__)
+#    if (LZO_CC_GNUC >= 0x030300ul)
+#      if ((__LONG_MAX__-0) == (__LONG_LONG_MAX__-0))
+#        define LZO_SIZEOF_LONG_LONG      LZO_SIZEOF_LONG
+#      elif (__LZO_LSR(__LONG_LONG_MAX__,30) == 1)
+#        define LZO_SIZEOF_LONG_LONG      4
+#      endif
+#    endif
+#  endif
+#endif
+#endif
+#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
+#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
+#if (LZO_ARCH_I086 && LZO_CC_DMC)
+#elif (LZO_CC_CILLY) && defined(__GNUC__)
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif ((LZO_OS_WIN32 || LZO_OS_WIN64 || defined(_WIN32)) && LZO_CC_MSC && (_MSC_VER >= 1400))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_OS_WIN64 || defined(_WIN64))
+#  define LZO_SIZEOF___INT64        8
+#elif (LZO_ARCH_I386 && (LZO_CC_DMC))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_ARCH_I386 && (LZO_CC_SYMANTECC && (__SC__ >= 0x700)))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_ARCH_I386 && (LZO_CC_INTELC && defined(__linux__)))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_ARCH_I386 && (LZO_CC_MWERKS || LZO_CC_PELLESC || LZO_CC_PGI || LZO_CC_SUNPROC))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_ARCH_I386 && (LZO_CC_INTELC || LZO_CC_MSC))
+#  define LZO_SIZEOF___INT64        8
+#elif ((LZO_OS_WIN32 || defined(_WIN32)) && (LZO_CC_MSC))
+#  define LZO_SIZEOF___INT64        8
+#elif (LZO_ARCH_I386 && (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0520)))
+#  define LZO_SIZEOF___INT64        8
+#elif (LZO_ARCH_I386 && (LZO_CC_WATCOMC && (__WATCOMC__ >= 1100)))
+#  define LZO_SIZEOF___INT64        8
+#elif (LZO_CC_GHS && defined(__LLONG_BIT) && ((__LLONG_BIT-0) == 64))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_CC_WATCOMC && defined(_INTEGRAL_MAX_BITS) && ((_INTEGRAL_MAX_BITS-0) == 64))
+#  define LZO_SIZEOF___INT64        8
+#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (defined(__vms) || defined(__VMS)) && ((__INITIAL_POINTER_SIZE-0) == 64)
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_CC_SDCC) && (LZO_SIZEOF_INT == 2)
+#elif 1 && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
+#  define LZO_SIZEOF_LONG_LONG      8
+#endif
+#endif
+#endif
+#if defined(__cplusplus) && (LZO_CC_GNUC)
+#  if (LZO_CC_GNUC < 0x020800ul)
+#    undef LZO_SIZEOF_LONG_LONG
+#  endif
+#endif
+#if (LZO_CFG_NO_LONG_LONG)
+#  undef LZO_SIZEOF_LONG_LONG
+#elif defined(__NO_LONG_LONG)
+#  undef LZO_SIZEOF_LONG_LONG
+#elif defined(_NO_LONGLONG)
+#  undef LZO_SIZEOF_LONG_LONG
+#endif
+#if !defined(LZO_WORDSIZE)
+#if (LZO_ARCH_ALPHA)
+#  define LZO_WORDSIZE              8
+#elif (LZO_ARCH_AMD64)
+#  define LZO_WORDSIZE              8
+#elif (LZO_ARCH_AVR)
+#  define LZO_WORDSIZE              1
+#elif (LZO_ARCH_H8300)
+#  if defined(__NORMAL_MODE__)
+#    define LZO_WORDSIZE            4
+#  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
+#    define LZO_WORDSIZE            4
+#  else
+#    define LZO_WORDSIZE            2
+#  endif
+#elif (LZO_ARCH_I086)
+#  define LZO_WORDSIZE              2
+#elif (LZO_ARCH_IA64)
+#  define LZO_WORDSIZE              8
+#elif (LZO_ARCH_M16C)
+#  define LZO_WORDSIZE              2
+#elif (LZO_ARCH_SPU)
+#  define LZO_WORDSIZE              4
+#elif (LZO_ARCH_Z80)
+#  define LZO_WORDSIZE              1
+#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
+#  define LZO_WORDSIZE              8
+#elif (LZO_OS_OS400 || defined(__OS400__))
+#  define LZO_WORDSIZE              8
+#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
+#  define LZO_WORDSIZE              8
+#endif
+#endif
+#if !defined(LZO_SIZEOF_VOID_P)
+#if defined(__ILP32__) || defined(__ILP32) || defined(_ILP32)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(int)  == 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 4)
+#  define LZO_SIZEOF_VOID_P         4
+#elif defined(__ILP64__) || defined(__ILP64) || defined(_ILP64)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(int)  == 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 8)
+#  define LZO_SIZEOF_VOID_P         8
+#elif defined(__LLP64__) || defined(__LLP64) || defined(_LLP64) || defined(_WIN64)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 4)
+#  define LZO_SIZEOF_VOID_P         8
+#elif defined(__LP64__) || defined(__LP64) || defined(_LP64)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 8)
+#  define LZO_SIZEOF_VOID_P         8
+#elif (LZO_ARCH_AVR)
+#  define LZO_SIZEOF_VOID_P         2
+#elif (LZO_ARCH_C166 || LZO_ARCH_MCS51 || LZO_ARCH_MCS251 || LZO_ARCH_MSP430)
+#  define LZO_SIZEOF_VOID_P         2
+#elif (LZO_ARCH_H8300)
+#  if defined(__NORMAL_MODE__)
+#    define LZO_SIZEOF_VOID_P       2
+#  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
+#    define LZO_SIZEOF_VOID_P       4
+#  else
+#    define LZO_SIZEOF_VOID_P       2
+#  endif
+#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_SIZEOF_INT == 4)
+#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_INT
+#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_INT
+#  endif
+#elif (LZO_ARCH_I086)
+#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
+#    define LZO_SIZEOF_VOID_P       2
+#  elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
+#    define LZO_SIZEOF_VOID_P       4
+#  else
+#    error "invalid LZO_ARCH_I086 memory model"
+#  endif
+#elif (LZO_ARCH_M16C)
+#  if defined(__m32c_cpu__) || defined(__m32cm_cpu__)
+#    define LZO_SIZEOF_VOID_P       4
+#  else
+#    define LZO_SIZEOF_VOID_P       2
+#  endif
+#elif (LZO_ARCH_SPU)
+#  define LZO_SIZEOF_VOID_P         4
+#elif (LZO_ARCH_Z80)
+#  define LZO_SIZEOF_VOID_P         2
+#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
+#  define LZO_SIZEOF_VOID_P         4
+#elif (LZO_OS_OS400 || defined(__OS400__))
+#  if defined(__LLP64_IFC__)
+#    define LZO_SIZEOF_VOID_P       8
+#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_LONG
+#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_LONG
+#  else
+#    define LZO_SIZEOF_VOID_P       16
+#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_LONG
+#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_LONG
+#  endif
+#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
+#  define LZO_SIZEOF_VOID_P         8
+#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
+#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
+#endif
+#endif
+#if !defined(LZO_SIZEOF_VOID_P)
+#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_VOID_P == sizeof(void *))
+#if !defined(LZO_SIZEOF_SIZE_T)
+#if (LZO_ARCH_I086 || LZO_ARCH_M16C)
+#  define LZO_SIZEOF_SIZE_T         2
+#endif
+#endif
+#if !defined(LZO_SIZEOF_SIZE_T)
+#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_VOID_P
+#endif
+#if defined(offsetof)
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_SIZE_T == sizeof(size_t))
+#endif
+#if !defined(LZO_SIZEOF_PTRDIFF_T)
+#if (LZO_ARCH_I086)
+#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM || LZO_MM_HUGE)
+#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_VOID_P
+#  elif (LZO_MM_COMPACT || LZO_MM_LARGE)
+#    if (LZO_CC_BORLANDC || LZO_CC_TURBOC)
+#      define LZO_SIZEOF_PTRDIFF_T  4
+#    else
+#      define LZO_SIZEOF_PTRDIFF_T  2
+#    endif
+#  else
+#    error "invalid LZO_ARCH_I086 memory model"
+#  endif
+#endif
+#endif
+#if !defined(LZO_SIZEOF_PTRDIFF_T)
+#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_SIZE_T
+#endif
+#if defined(offsetof)
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_PTRDIFF_T == sizeof(ptrdiff_t))
+#endif
+#if !defined(LZO_WORDSIZE)
+#  define LZO_WORDSIZE              LZO_SIZEOF_VOID_P
+#endif
+#if (LZO_ABI_NEUTRAL_ENDIAN)
+#  undef LZO_ABI_BIG_ENDIAN
+#  undef LZO_ABI_LITTLE_ENDIAN
+#elif !(LZO_ABI_BIG_ENDIAN) && !(LZO_ABI_LITTLE_ENDIAN)
+#if (LZO_ARCH_ALPHA) && (LZO_ARCH_CRAY_MPP)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif (LZO_ARCH_IA64) && (LZO_OS_POSIX_LINUX || LZO_OS_WIN64)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif (LZO_ARCH_ALPHA || LZO_ARCH_AMD64 || LZO_ARCH_BLACKFIN || LZO_ARCH_CRIS || LZO_ARCH_I086 || LZO_ARCH_I386 || LZO_ARCH_MSP430)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif (LZO_ARCH_AVR32 || LZO_ARCH_M68K || LZO_ARCH_S390 || LZO_ARCH_SPU)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif 1 && defined(__IAR_SYSTEMS_ICC__) && defined(__LITTLE_ENDIAN__)
+#  if (__LITTLE_ENDIAN__ == 1)
+#    define LZO_ABI_LITTLE_ENDIAN   1
+#  else
+#    define LZO_ABI_BIG_ENDIAN      1
+#  endif
+#elif 1 && defined(__BIG_ENDIAN__) && !defined(__LITTLE_ENDIAN__)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif 1 && defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEB__) && !defined(__ARMEL__)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEL__) && !defined(__ARMEB__)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif 1 && (LZO_ARCH_ARM && LZO_CC_ARMCC_ARMCC)
+#  if defined(__BIG_ENDIAN) && defined(__LITTLE_ENDIAN)
+#    error "unexpected configuration - check your compiler defines"
+#  elif defined(__BIG_ENDIAN)
+#    define LZO_ABI_BIG_ENDIAN      1
+#  else
+#    define LZO_ABI_LITTLE_ENDIAN   1
+#  endif
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif 1 && (LZO_ARCH_ARM64) && defined(__AARCH64EB__) && !defined(__AARCH64EL__)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif 1 && (LZO_ARCH_ARM64) && defined(__AARCH64EL__) && !defined(__AARCH64EB__)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEB__) && !defined(__MIPSEL__)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEL__) && !defined(__MIPSEB__)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#endif
+#endif
+#if (LZO_ABI_BIG_ENDIAN) && (LZO_ABI_LITTLE_ENDIAN)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ABI_BIG_ENDIAN)
+#  define LZO_INFO_ABI_ENDIAN       "be"
+#elif (LZO_ABI_LITTLE_ENDIAN)
+#  define LZO_INFO_ABI_ENDIAN       "le"
+#elif (LZO_ABI_NEUTRAL_ENDIAN)
+#  define LZO_INFO_ABI_ENDIAN       "neutral"
+#endif
+#if (LZO_SIZEOF_INT == 1 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
+#  define LZO_ABI_I8LP16         1
+#  define LZO_INFO_ABI_PM       "i8lp16"
+#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
+#  define LZO_ABI_ILP16         1
+#  define LZO_INFO_ABI_PM       "ilp16"
+#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
+#  define LZO_ABI_LP32          1
+#  define LZO_INFO_ABI_PM       "lp32"
+#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
+#  define LZO_ABI_ILP32         1
+#  define LZO_INFO_ABI_PM       "ilp32"
+#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 8 && LZO_SIZEOF_SIZE_T == 8)
+#  define LZO_ABI_LLP64         1
+#  define LZO_INFO_ABI_PM       "llp64"
+#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
+#  define LZO_ABI_LP64          1
+#  define LZO_INFO_ABI_PM       "lp64"
+#elif (LZO_SIZEOF_INT == 8 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
+#  define LZO_ABI_ILP64         1
+#  define LZO_INFO_ABI_PM       "ilp64"
+#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 4)
+#  define LZO_ABI_IP32L64       1
+#  define LZO_INFO_ABI_PM       "ip32l64"
+#endif
+#if 0
+#elif !defined(__LZO_LIBC_OVERRIDE)
+#if (LZO_LIBC_NAKED)
+#  define LZO_INFO_LIBC         "naked"
+#elif (LZO_LIBC_FREESTANDING)
+#  define LZO_INFO_LIBC         "freestanding"
+#elif (LZO_LIBC_MOSTLY_FREESTANDING)
+#  define LZO_INFO_LIBC         "mfreestanding"
+#elif (LZO_LIBC_ISOC90)
+#  define LZO_INFO_LIBC         "isoc90"
+#elif (LZO_LIBC_ISOC99)
+#  define LZO_INFO_LIBC         "isoc99"
+#elif (LZO_CC_ARMCC_ARMCC) && defined(__ARMCLIB_VERSION)
+#  define LZO_LIBC_ISOC90       1
+#  define LZO_INFO_LIBC         "isoc90"
+#elif defined(__dietlibc__)
+#  define LZO_LIBC_DIETLIBC     1
+#  define LZO_INFO_LIBC         "dietlibc"
+#elif defined(_NEWLIB_VERSION)
+#  define LZO_LIBC_NEWLIB       1
+#  define LZO_INFO_LIBC         "newlib"
+#elif defined(__UCLIBC__) && defined(__UCLIBC_MAJOR__) && defined(__UCLIBC_MINOR__)
+#  if defined(__UCLIBC_SUBLEVEL__)
+#    define LZO_LIBC_UCLIBC     (__UCLIBC_MAJOR__ * 0x10000L + (__UCLIBC_MINOR__-0) * 0x100 + (__UCLIBC_SUBLEVEL__-0))
+#  else
+#    define LZO_LIBC_UCLIBC     0x00090bL
+#  endif
+#  define LZO_INFO_LIBC         "uc" "libc"
+#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__)
+#  define LZO_LIBC_GLIBC        (__GLIBC__ * 0x10000L + (__GLIBC_MINOR__-0) * 0x100)
+#  define LZO_INFO_LIBC         "glibc"
+#elif (LZO_CC_MWERKS) && defined(__MSL__)
+#  define LZO_LIBC_MSL          __MSL__
+#  define LZO_INFO_LIBC         "msl"
+#elif 1 && defined(__IAR_SYSTEMS_ICC__)
+#  define LZO_LIBC_ISOC90       1
+#  define LZO_INFO_LIBC         "isoc90"
+#else
+#  define LZO_LIBC_DEFAULT      1
+#  define LZO_INFO_LIBC         "default"
+#endif
+#endif
+#if (LZO_ARCH_I386 && (LZO_OS_DOS32 || LZO_OS_WIN32) && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
+#  define LZO_ASM_SYNTAX_MSC 1
+#elif (LZO_OS_WIN64 && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
+#elif (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC == 0x011f00ul))
+#elif (LZO_ARCH_I386 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
+#  define LZO_ASM_SYNTAX_GNUC 1
+#elif (LZO_ARCH_AMD64 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
+#  define LZO_ASM_SYNTAX_GNUC 1
+#elif (LZO_CC_GNUC)
+#  define LZO_ASM_SYNTAX_GNUC 1
+#endif
+#if (LZO_ASM_SYNTAX_GNUC)
+#if (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
+#  define __LZO_ASM_CLOBBER                     "ax"
+#  define __LZO_ASM_CLOBBER_LIST_CC             /*empty*/
+#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      /*empty*/
+#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
+#elif (LZO_CC_INTELC && (__INTEL_COMPILER < 1000))
+#  define __LZO_ASM_CLOBBER                     "memory"
+#  define __LZO_ASM_CLOBBER_LIST_CC             /*empty*/
+#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      : "memory"
+#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
+#else
+#  define __LZO_ASM_CLOBBER                     "cc", "memory"
+#  define __LZO_ASM_CLOBBER_LIST_CC             : "cc"
+#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      : "cc", "memory"
+#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
+#endif
+#endif
+#if (LZO_ARCH_ALPHA)
+#  define LZO_OPT_AVOID_UINT_INDEX          1
+#elif (LZO_ARCH_AMD64)
+#  define LZO_OPT_AVOID_INT_INDEX           1
+#  define LZO_OPT_AVOID_UINT_INDEX          1
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED64
+#  define LZO_OPT_UNALIGNED64               1
+#  endif
+#elif (LZO_ARCH_ARM)
+#  if defined(__ARM_FEATURE_UNALIGNED)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#  elif defined(__TARGET_ARCH_ARM) && ((__TARGET_ARCH_ARM+0) >= 7)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#  elif defined(__TARGET_ARCH_ARM) && ((__TARGET_ARCH_ARM+0) >= 6) && !defined(__TARGET_PROFILE_M)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#  endif
+#elif (LZO_ARCH_ARM64)
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED64
+#  define LZO_OPT_UNALIGNED64               1
+#  endif
+#elif (LZO_ARCH_CRIS)
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
+#elif (LZO_ARCH_I386)
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
+#elif (LZO_ARCH_IA64)
+#  define LZO_OPT_AVOID_INT_INDEX           1
+#  define LZO_OPT_AVOID_UINT_INDEX          1
+#  define LZO_OPT_PREFER_POSTINC            1
+#elif (LZO_ARCH_M68K)
+#  define LZO_OPT_PREFER_POSTINC            1
+#  define LZO_OPT_PREFER_PREDEC             1
+#  if defined(__mc68020__) && !defined(__mcoldfire__)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#  endif
+#elif (LZO_ARCH_MIPS)
+#  define LZO_OPT_AVOID_UINT_INDEX          1
+#elif (LZO_ARCH_POWERPC)
+#  define LZO_OPT_PREFER_PREINC             1
+#  define LZO_OPT_PREFER_PREDEC             1
+#  if (LZO_ABI_BIG_ENDIAN)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#    if (LZO_WORDSIZE == 8)
+#      ifndef LZO_OPT_UNALIGNED64
+#      define LZO_OPT_UNALIGNED64           1
+#      endif
+#    endif
+#  endif
+#elif (LZO_ARCH_S390)
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
+#  if (LZO_WORDSIZE == 8)
+#    ifndef LZO_OPT_UNALIGNED64
+#    define LZO_OPT_UNALIGNED64             1
+#    endif
+#  endif
+#elif (LZO_ARCH_SH)
+#  define LZO_OPT_PREFER_POSTINC            1
+#  define LZO_OPT_PREFER_PREDEC             1
+#endif
+#ifndef LZO_CFG_NO_INLINE_ASM
+#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
+#  define LZO_CFG_NO_INLINE_ASM 1
+#elif (LZO_CC_LLVM)
+#  define LZO_CFG_NO_INLINE_ASM 1
+#endif
+#endif
+#if (LZO_CFG_NO_INLINE_ASM)
+#  undef LZO_ASM_SYNTAX_MSC
+#  undef LZO_ASM_SYNTAX_GNUC
+#  undef __LZO_ASM_CLOBBER
+#  undef __LZO_ASM_CLOBBER_LIST_CC
+#  undef __LZO_ASM_CLOBBER_LIST_CC_MEMORY
+#  undef __LZO_ASM_CLOBBER_LIST_EMPTY
+#endif
+#ifndef LZO_CFG_NO_UNALIGNED
+#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
+#  define LZO_CFG_NO_UNALIGNED 1
+#endif
+#endif
+#if (LZO_CFG_NO_UNALIGNED)
+#  undef LZO_OPT_UNALIGNED16
+#  undef LZO_OPT_UNALIGNED32
+#  undef LZO_OPT_UNALIGNED64
+#endif
+#if defined(__LZO_INFOSTR_MM)
+#elif (LZO_MM_FLAT) && (defined(__LZO_INFOSTR_PM) || defined(LZO_INFO_ABI_PM))
+#  define __LZO_INFOSTR_MM          ""
+#elif defined(LZO_INFO_MM)
+#  define __LZO_INFOSTR_MM          "." LZO_INFO_MM
+#else
+#  define __LZO_INFOSTR_MM          ""
+#endif
+#if defined(__LZO_INFOSTR_PM)
+#elif defined(LZO_INFO_ABI_PM)
+#  define __LZO_INFOSTR_PM          "." LZO_INFO_ABI_PM
+#else
+#  define __LZO_INFOSTR_PM          ""
+#endif
+#if defined(__LZO_INFOSTR_ENDIAN)
+#elif defined(LZO_INFO_ABI_ENDIAN)
+#  define __LZO_INFOSTR_ENDIAN      "." LZO_INFO_ABI_ENDIAN
+#else
+#  define __LZO_INFOSTR_ENDIAN      ""
+#endif
+#if defined(__LZO_INFOSTR_OSNAME)
+#elif defined(LZO_INFO_OS_CONSOLE)
+#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_CONSOLE
+#elif defined(LZO_INFO_OS_POSIX)
+#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_POSIX
+#else
+#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS
+#endif
+#if defined(__LZO_INFOSTR_LIBC)
+#elif defined(LZO_INFO_LIBC)
+#  define __LZO_INFOSTR_LIBC        "." LZO_INFO_LIBC
+#else
+#  define __LZO_INFOSTR_LIBC        ""
+#endif
+#if defined(__LZO_INFOSTR_CCVER)
+#elif defined(LZO_INFO_CCVER)
+#  define __LZO_INFOSTR_CCVER       " " LZO_INFO_CCVER
+#else
+#  define __LZO_INFOSTR_CCVER       ""
+#endif
+#define LZO_INFO_STRING \
+    LZO_INFO_ARCH __LZO_INFOSTR_MM __LZO_INFOSTR_PM __LZO_INFOSTR_ENDIAN \
+    " " __LZO_INFOSTR_OSNAME __LZO_INFOSTR_LIBC " " LZO_INFO_CC __LZO_INFOSTR_CCVER
+#if !(LZO_CFG_SKIP_LZO_TYPES)
+#if (!(LZO_SIZEOF_SHORT+0 > 0 && LZO_SIZEOF_INT+0 > 0 && LZO_SIZEOF_LONG+0 > 0))
+#  error "missing defines for sizes"
+#endif
+#if (!(LZO_SIZEOF_PTRDIFF_T+0 > 0 && LZO_SIZEOF_SIZE_T+0 > 0 && LZO_SIZEOF_VOID_P+0 > 0))
+#  error "missing defines for sizes"
+#endif
+#if !defined(lzo_llong_t)
+#if (LZO_SIZEOF_LONG_LONG+0 > 0)
+__lzo_gnuc_extension__ typedef long long lzo_llong_t__;
+__lzo_gnuc_extension__ typedef unsigned long long lzo_ullong_t__;
+#  define lzo_llong_t               lzo_llong_t__
+#  define lzo_ullong_t              lzo_ullong_t__
+#endif
+#endif
+#if !defined(lzo_int16e_t)
+#if (LZO_SIZEOF_LONG == 2)
+#  define lzo_int16e_t              long
+#  define lzo_uint16e_t             unsigned long
+#elif (LZO_SIZEOF_INT == 2)
+#  define lzo_int16e_t              int
+#  define lzo_uint16e_t             unsigned int
+#elif (LZO_SIZEOF_SHORT == 2)
+#  define lzo_int16e_t              short int
+#  define lzo_uint16e_t             unsigned short int
+#elif 1 && !(LZO_CFG_TYPE_NO_MODE_HI) && (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x025f00ul) || LZO_CC_LLVM)
+   typedef int lzo_int16e_hi_t__ __attribute__((__mode__(__HI__)));
+   typedef unsigned int lzo_uint16e_hi_t__ __attribute__((__mode__(__HI__)));
+#  define lzo_int16e_t              lzo_int16e_hi_t__
+#  define lzo_uint16e_t             lzo_uint16e_hi_t__
+#elif (LZO_SIZEOF___INT16 == 2)
+#  define lzo_int16e_t              __int16
+#  define lzo_uint16e_t             unsigned __int16
+#else
+#endif
+#endif
+#if defined(lzo_int16e_t)
+#  define LZO_SIZEOF_LZO_INT16E_T   2
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16e_t) == 2)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16e_t) == LZO_SIZEOF_LZO_INT16E_T)
+#endif
+#if !defined(lzo_int32e_t)
+#if (LZO_SIZEOF_LONG == 4)
+#  define lzo_int32e_t              long int
+#  define lzo_uint32e_t             unsigned long int
+#elif (LZO_SIZEOF_INT == 4)
+#  define lzo_int32e_t              int
+#  define lzo_uint32e_t             unsigned int
+#elif (LZO_SIZEOF_SHORT == 4)
+#  define lzo_int32e_t              short int
+#  define lzo_uint32e_t             unsigned short int
+#elif (LZO_SIZEOF_LONG_LONG == 4)
+#  define lzo_int32e_t              lzo_llong_t
+#  define lzo_uint32e_t             lzo_ullong_t
+#elif 1 && !(LZO_CFG_TYPE_NO_MODE_SI) && (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x025f00ul) || LZO_CC_LLVM) && (__INT_MAX__+0 > 2147483647L)
+   typedef int lzo_int32e_si_t__ __attribute__((__mode__(__SI__)));
+   typedef unsigned int lzo_uint32e_si_t__ __attribute__((__mode__(__SI__)));
+#  define lzo_int32e_t              lzo_int32e_si_t__
+#  define lzo_uint32e_t             lzo_uint32e_si_t__
+#elif 1 && !(LZO_CFG_TYPE_NO_MODE_SI) && (LZO_CC_GNUC >= 0x025f00ul) && defined(__AVR__) && (__LONG_MAX__+0 == 32767L)
+   typedef int lzo_int32e_si_t__ __attribute__((__mode__(__SI__)));
+   typedef unsigned int lzo_uint32e_si_t__ __attribute__((__mode__(__SI__)));
+#  define lzo_int32e_t              lzo_int32e_si_t__
+#  define lzo_uint32e_t             lzo_uint32e_si_t__
+#  define LZO_INT32_C(c)            (c##LL)
+#  define LZO_UINT32_C(c)           (c##ULL)
+#elif (LZO_SIZEOF___INT32 == 4)
+#  define lzo_int32e_t              __int32
+#  define lzo_uint32e_t             unsigned __int32
+#else
+#endif
+#endif
+#if defined(lzo_int32e_t)
+#  define LZO_SIZEOF_LZO_INT32E_T   4
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32e_t) == 4)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32e_t) == LZO_SIZEOF_LZO_INT32E_T)
+#endif
+#if !defined(lzo_int64e_t)
+#if (LZO_SIZEOF___INT64 == 8)
+#  if (LZO_CC_BORLANDC) && !(LZO_CFG_TYPE_PREFER___INT64)
+#    define LZO_CFG_TYPE_PREFER___INT64 1
+#  endif
+#endif
+#if (LZO_SIZEOF_INT == 8) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
+#  define lzo_int64e_t              int
+#  define lzo_uint64e_t             unsigned int
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_LONG == 8)
+#  define lzo_int64e_t              long int
+#  define lzo_uint64e_t             unsigned long int
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF_LONG
+#elif (LZO_SIZEOF_LONG_LONG == 8) && !(LZO_CFG_TYPE_PREFER___INT64)
+#  define lzo_int64e_t              lzo_llong_t
+#  define lzo_uint64e_t             lzo_ullong_t
+#  if (LZO_CC_BORLANDC)
+#    define LZO_INT64_C(c)          ((c) + 0ll)
+#    define LZO_UINT64_C(c)         ((c) + 0ull)
+#  elif 0
+#    define LZO_INT64_C(c)          (__lzo_gnuc_extension__ (c##LL))
+#    define LZO_UINT64_C(c)         (__lzo_gnuc_extension__ (c##ULL))
+#  else
+#    define LZO_INT64_C(c)          (c##LL)
+#    define LZO_UINT64_C(c)         (c##ULL)
+#  endif
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF_LONG_LONG
+#elif (LZO_SIZEOF___INT64 == 8)
+#  define lzo_int64e_t              __int64
+#  define lzo_uint64e_t             unsigned __int64
+#  if (LZO_CC_BORLANDC)
+#    define LZO_INT64_C(c)          ((c) + 0i64)
+#    define LZO_UINT64_C(c)         ((c) + 0ui64)
+#  else
+#    define LZO_INT64_C(c)          (c##i64)
+#    define LZO_UINT64_C(c)         (c##ui64)
+#  endif
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF___INT64
+#else
+#endif
+#endif
+#if defined(lzo_int64e_t)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64e_t) == 8)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64e_t) == LZO_SIZEOF_LZO_INT64E_T)
+#endif
+#if !defined(lzo_int32l_t)
+#if defined(lzo_int32e_t)
+#  define lzo_int32l_t              lzo_int32e_t
+#  define lzo_uint32l_t             lzo_uint32e_t
+#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_LZO_INT32E_T
+#elif (LZO_SIZEOF_INT >= 4) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
+#  define lzo_int32l_t              int
+#  define lzo_uint32l_t             unsigned int
+#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_LONG >= 4)
+#  define lzo_int32l_t              long int
+#  define lzo_uint32l_t             unsigned long int
+#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_LONG
+#else
+#  error "lzo_int32l_t"
+#endif
+#endif
+#if 1
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32l_t) >= 4)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32l_t) == LZO_SIZEOF_LZO_INT32L_T)
+#endif
+#if !defined(lzo_int64l_t)
+#if defined(lzo_int64e_t)
+#  define lzo_int64l_t              lzo_int64e_t
+#  define lzo_uint64l_t             lzo_uint64e_t
+#  define LZO_SIZEOF_LZO_INT64L_T   LZO_SIZEOF_LZO_INT64E_T
+#else
+#endif
+#endif
+#if defined(lzo_int64l_t)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64l_t) >= 8)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64l_t) == LZO_SIZEOF_LZO_INT64L_T)
+#endif
+#if !defined(lzo_int32f_t)
+#if (LZO_SIZEOF_SIZE_T >= 8)
+#  define lzo_int32f_t              lzo_int64l_t
+#  define lzo_uint32f_t             lzo_uint64l_t
+#  define LZO_SIZEOF_LZO_INT32F_T   LZO_SIZEOF_LZO_INT64L_T
+#else
+#  define lzo_int32f_t              lzo_int32l_t
+#  define lzo_uint32f_t             lzo_uint32l_t
+#  define LZO_SIZEOF_LZO_INT32F_T   LZO_SIZEOF_LZO_INT32L_T
+#endif
+#endif
+#if 1
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32f_t) >= 4)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32f_t) == LZO_SIZEOF_LZO_INT32F_T)
+#endif
+#if !defined(lzo_int64f_t)
+#if defined(lzo_int64l_t)
+#  define lzo_int64f_t              lzo_int64l_t
+#  define lzo_uint64f_t             lzo_uint64l_t
+#  define LZO_SIZEOF_LZO_INT64F_T   LZO_SIZEOF_LZO_INT64L_T
+#else
+#endif
+#endif
+#if defined(lzo_int64f_t)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64f_t) >= 8)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64f_t) == LZO_SIZEOF_LZO_INT64F_T)
+#endif
+#if !defined(lzo_intptr_t)
+#if 1 && (LZO_OS_OS400 && (LZO_SIZEOF_VOID_P == 16))
+#  define __LZO_INTPTR_T_IS_POINTER 1
+   typedef char*                    lzo_intptr_t;
+   typedef char*                    lzo_uintptr_t;
+#  define lzo_intptr_t              lzo_intptr_t
+#  define lzo_uintptr_t             lzo_uintptr_t
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_VOID_P
+#elif (LZO_CC_MSC && (_MSC_VER >= 1300) && (LZO_SIZEOF_VOID_P == 4) && (LZO_SIZEOF_INT == 4))
+   typedef __w64 int                lzo_intptr_t;
+   typedef __w64 unsigned int       lzo_uintptr_t;
+#  define lzo_intptr_t              lzo_intptr_t
+#  define lzo_uintptr_t             lzo_uintptr_t
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_SHORT == LZO_SIZEOF_VOID_P) && (LZO_SIZEOF_INT > LZO_SIZEOF_VOID_P)
+#  define lzo_intptr_t              short
+#  define lzo_uintptr_t             unsigned short
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_SHORT
+#elif (LZO_SIZEOF_INT >= LZO_SIZEOF_VOID_P) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
+#  define lzo_intptr_t              int
+#  define lzo_uintptr_t             unsigned int
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_LONG >= LZO_SIZEOF_VOID_P)
+#  define lzo_intptr_t              long
+#  define lzo_uintptr_t             unsigned long
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_LONG
+#elif (LZO_SIZEOF_LZO_INT64L_T >= LZO_SIZEOF_VOID_P)
+#  define lzo_intptr_t              lzo_int64l_t
+#  define lzo_uintptr_t             lzo_uint64l_t
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_LZO_INT64L_T
+#else
+#  error "lzo_intptr_t"
+#endif
+#endif
+#if 1
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_intptr_t) >= sizeof(void *))
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_intptr_t) == sizeof(lzo_uintptr_t))
+#endif
+#if !defined(lzo_word_t)
+#if defined(LZO_WORDSIZE) && (LZO_WORDSIZE+0 > 0)
+#if (LZO_WORDSIZE == LZO_SIZEOF_LZO_INTPTR_T) && !(__LZO_INTPTR_T_IS_POINTER)
+#  define lzo_word_t                lzo_uintptr_t
+#  define lzo_sword_t               lzo_intptr_t
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_LZO_INTPTR_T
+#elif (LZO_WORDSIZE == LZO_SIZEOF_LONG)
+#  define lzo_word_t                unsigned long
+#  define lzo_sword_t               long
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_LONG
+#elif (LZO_WORDSIZE == LZO_SIZEOF_INT)
+#  define lzo_word_t                unsigned int
+#  define lzo_sword_t               int
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_INT
+#elif (LZO_WORDSIZE == LZO_SIZEOF_SHORT)
+#  define lzo_word_t                unsigned short
+#  define lzo_sword_t               short
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_SHORT
+#elif (LZO_WORDSIZE == 1)
+#  define lzo_word_t                unsigned char
+#  define lzo_sword_t               signed char
+#  define LZO_SIZEOF_LZO_WORD_T 1
+#elif (LZO_WORDSIZE == LZO_SIZEOF_LZO_INT64L_T)
+#  define lzo_word_t                lzo_uint64l_t
+#  define lzo_sword_t               lzo_int64l_t
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_LZO_INT64L_T
+#elif (LZO_ARCH_SPU) && (LZO_CC_GNUC)
+#if 0
+   typedef unsigned lzo_word_t  __attribute__((__mode__(__V16QI__)));
+   typedef int      lzo_sword_t __attribute__((__mode__(__V16QI__)));
+#  define lzo_word_t                lzo_word_t
+#  define lzo_sword_t               lzo_sword_t
+#  define LZO_SIZEOF_LZO_WORD_T     16
+#endif
+#else
+#  error "lzo_word_t"
+#endif
+#endif
+#endif
+#if 1 && defined(lzo_word_t)
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_word_t)  == LZO_WORDSIZE)
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_sword_t) == LZO_WORDSIZE)
+#endif
+#if 1
+#define lzo_int8_t                  signed char
+#define lzo_uint8_t                 unsigned char
+#define LZO_SIZEOF_LZO_INT8_T       1
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int8_t) == 1)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int8_t) == sizeof(lzo_uint8_t))
+#endif
+#if defined(lzo_int16e_t)
+#define lzo_int16_t                 lzo_int16e_t
+#define lzo_uint16_t                lzo_uint16e_t
+#define LZO_SIZEOF_LZO_INT16_T      LZO_SIZEOF_LZO_INT16E_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16_t) == 2)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16_t) == sizeof(lzo_uint16_t))
+#endif
+#if defined(lzo_int32e_t)
+#define lzo_int32_t                 lzo_int32e_t
+#define lzo_uint32_t                lzo_uint32e_t
+#define LZO_SIZEOF_LZO_INT32_T      LZO_SIZEOF_LZO_INT32E_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32_t) == 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32_t) == sizeof(lzo_uint32_t))
+#endif
+#if defined(lzo_int64e_t)
+#define lzo_int64_t                 lzo_int64e_t
+#define lzo_uint64_t                lzo_uint64e_t
+#define LZO_SIZEOF_LZO_INT64_T      LZO_SIZEOF_LZO_INT64E_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64_t) == 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64_t) == sizeof(lzo_uint64_t))
+#endif
+#if 1
+#define lzo_int_least32_t           lzo_int32l_t
+#define lzo_uint_least32_t          lzo_uint32l_t
+#define LZO_SIZEOF_LZO_INT_LEAST32_T LZO_SIZEOF_LZO_INT32L_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least32_t) >= 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least32_t) == sizeof(lzo_uint_least32_t))
+#endif
+#if defined(lzo_int64l_t)
+#define lzo_int_least64_t           lzo_int64l_t
+#define lzo_uint_least64_t          lzo_uint64l_t
+#define LZO_SIZEOF_LZO_INT_LEAST64_T LZO_SIZEOF_LZO_INT64L_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least64_t) >= 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least64_t) == sizeof(lzo_uint_least64_t))
+#endif
+#if 1
+#define lzo_int_fast32_t           lzo_int32f_t
+#define lzo_uint_fast32_t          lzo_uint32f_t
+#define LZO_SIZEOF_LZO_INT_FAST32_T LZO_SIZEOF_LZO_INT32F_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast32_t) >= 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast32_t) == sizeof(lzo_uint_fast32_t))
+#endif
+#if defined(lzo_int64f_t)
+#define lzo_int_fast64_t           lzo_int64f_t
+#define lzo_uint_fast64_t          lzo_uint64f_t
+#define LZO_SIZEOF_LZO_INT_FAST64_T LZO_SIZEOF_LZO_INT64F_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast64_t) >= 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast64_t) == sizeof(lzo_uint_fast64_t))
+#endif
+#if !defined(LZO_INT16_C)
+#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 2)
+#    define LZO_INT16_C(c)          ((c) + 0)
+#    define LZO_UINT16_C(c)         ((c) + 0U)
+#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 2)
+#    define LZO_INT16_C(c)          ((c) + 0L)
+#    define LZO_UINT16_C(c)         ((c) + 0UL)
+#  elif (LZO_SIZEOF_INT >= 2)
+#    define LZO_INT16_C(c)          (c)
+#    define LZO_UINT16_C(c)         (c##U)
+#  elif (LZO_SIZEOF_LONG >= 2)
+#    define LZO_INT16_C(c)          (c##L)
+#    define LZO_UINT16_C(c)         (c##UL)
+#  else
+#    error "LZO_INT16_C"
+#  endif
+#endif
+#if !defined(LZO_INT32_C)
+#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 4)
+#    define LZO_INT32_C(c)          ((c) + 0)
+#    define LZO_UINT32_C(c)         ((c) + 0U)
+#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 4)
+#    define LZO_INT32_C(c)          ((c) + 0L)
+#    define LZO_UINT32_C(c)         ((c) + 0UL)
+#  elif (LZO_SIZEOF_INT >= 4)
+#    define LZO_INT32_C(c)          (c)
+#    define LZO_UINT32_C(c)         (c##U)
+#  elif (LZO_SIZEOF_LONG >= 4)
+#    define LZO_INT32_C(c)          (c##L)
+#    define LZO_UINT32_C(c)         (c##UL)
+#  elif (LZO_SIZEOF_LONG_LONG >= 4)
+#    define LZO_INT32_C(c)          (c##LL)
+#    define LZO_UINT32_C(c)         (c##ULL)
+#  else
+#    error "LZO_INT32_C"
+#  endif
+#endif
+#if !defined(LZO_INT64_C) && defined(lzo_int64l_t)
+#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 8)
+#    define LZO_INT64_C(c)          ((c) + 0)
+#    define LZO_UINT64_C(c)         ((c) + 0U)
+#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 8)
+#    define LZO_INT64_C(c)          ((c) + 0L)
+#    define LZO_UINT64_C(c)         ((c) + 0UL)
+#  elif (LZO_SIZEOF_INT >= 8)
+#    define LZO_INT64_C(c)          (c)
+#    define LZO_UINT64_C(c)         (c##U)
+#  elif (LZO_SIZEOF_LONG >= 8)
+#    define LZO_INT64_C(c)          (c##L)
+#    define LZO_UINT64_C(c)         (c##UL)
+#  else
+#    error "LZO_INT64_C"
+#  endif
 #endif
-#if defined(__LZO_INFOSTR_CCVER)
-#elif defined(LZO_INFO_CCVER)
-#  define __LZO_INFOSTR_CCVER       " " LZO_INFO_CCVER
-#else
-#  define __LZO_INFOSTR_CCVER       ""
 #endif
-#define LZO_INFO_STRING \
-    LZO_INFO_ARCH __LZO_INFOSTR_MM __LZO_INFOSTR_PM __LZO_INFOSTR_ENDIAN \
-    " " __LZO_INFOSTR_OSNAME __LZO_INFOSTR_LIBC " " LZO_INFO_CC __LZO_INFOSTR_CCVER
 
 #endif /* already included */
 
-/* vim:set ts=4 et: */
+/* vim:set ts=4 sw=4 et: */
diff --git a/mythtv/libs/libmythtv/metadataimagehelper.cpp b/mythtv/libs/libmythtv/metadataimagehelper.cpp
index 1323775..1e0037f 100644
--- a/mythtv/libs/libmythtv/metadataimagehelper.cpp
+++ b/mythtv/libs/libmythtv/metadataimagehelper.cpp
@@ -11,6 +11,9 @@ ArtworkMap GetArtwork(QString inetref,
 {
     ArtworkMap map;
 
+    if (inetref.isEmpty())
+        return map;
+
     MSqlQuery query(MSqlQuery::InitCon());
 
     QString querystring = "SELECT host, coverart, fanart, banner "
diff --git a/mythtv/libs/libmythtv/minilzo.cpp b/mythtv/libs/libmythtv/minilzo.cpp
index d0df7c3..2651317 100644
--- a/mythtv/libs/libmythtv/minilzo.cpp
+++ b/mythtv/libs/libmythtv/minilzo.cpp
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -43,8 +31,7 @@
  *   http://www.oberhumer.com/opensource/lzo/
  */
 
-#define __LZO_IN_MINILZO
-#define LZO_BUILD
+#define __LZO_IN_MINILZO 1
 
 #if defined(LZO_CFG_FREESTANDING)
 #  undef MINILZO_HAVE_CONFIG_H
@@ -65,12 +52,6 @@
 #if defined(__CYGWIN32__) && !defined(__CYGWIN__)
 #  define __CYGWIN__ __CYGWIN32__
 #endif
-#if defined(__IBMCPP__) && !defined(__IBMC__)
-#  define __IBMC__ __IBMCPP__
-#endif
-#if defined(__ICL) && defined(_WIN32) && !defined(__INTEL_COMPILER)
-#  define __INTEL_COMPILER __ICL
-#endif
 #if 1 && defined(__INTERIX) && defined(__GNUC__) && !defined(_ALL_SOURCE)
 #  define _ALL_SOURCE 1
 #endif
@@ -79,19 +60,30 @@
 #    define __LONG_MAX__ 9223372036854775807L
 #  endif
 #endif
-#if defined(__INTEL_COMPILER) && defined(__linux__)
+#if !defined(LZO_CFG_NO_DISABLE_WUNDEF)
+#if defined(__ARMCC_VERSION)
+#  pragma diag_suppress 193
+#elif defined(__clang__) && defined(__clang_minor__)
+#  pragma clang diagnostic ignored "-Wundef"
+#elif defined(__INTEL_COMPILER)
 #  pragma warning(disable: 193)
-#endif
-#if defined(__KEIL__) && defined(__C166__)
-#  pragma warning disable = 322
-#elif 0 && defined(__C251__)
+#elif defined(__KEIL__) && defined(__C166__)
 #  pragma warning disable = 322
-#endif
-#if defined(_MSC_VER) && !defined(__INTEL_COMPILER) && !defined(__MWERKS__)
-#  if (_MSC_VER >= 1300)
+#elif defined(__GNUC__) && defined(__GNUC_MINOR__) && !defined(__PATHSCALE__)
+#  if ((__GNUC__-0) >= 5 || ((__GNUC__-0) == 4 && (__GNUC_MINOR__-0) >= 2))
+#    pragma GCC diagnostic ignored "-Wundef"
+#  endif
+#elif defined(_MSC_VER) && !defined(__clang__) && !defined(__INTEL_COMPILER) && !defined(__MWERKS__)
+#  if ((_MSC_VER-0) >= 1300)
 #    pragma warning(disable: 4668)
 #  endif
 #endif
+#endif
+#if 0 && defined(__POCC__) && defined(_WIN32)
+#  if (__POCC__ >= 400)
+#    pragma warn(disable: 2216)
+#  endif
+#endif
 #if 0 && defined(__WATCOMC__)
 #  if (__WATCOMC__ >= 1050) && (__WATCOMC__ < 1060)
 #    pragma warning 203 9
@@ -100,13 +92,29 @@
 #if defined(__BORLANDC__) && defined(__MSDOS__) && !defined(__FLAT__)
 #  pragma option -h
 #endif
+#if !(LZO_CFG_NO_DISABLE_WCRTNONSTDC)
+#ifndef _CRT_NONSTDC_NO_DEPRECATE
+#define _CRT_NONSTDC_NO_DEPRECATE 1
+#endif
+#ifndef _CRT_NONSTDC_NO_WARNINGS
+#define _CRT_NONSTDC_NO_WARNINGS 1
+#endif
+#ifndef _CRT_SECURE_NO_DEPRECATE
+#define _CRT_SECURE_NO_DEPRECATE 1
+#endif
+#ifndef _CRT_SECURE_NO_WARNINGS
+#define _CRT_SECURE_NO_WARNINGS 1
+#endif
+#endif
 #if 0
-#define LZO_0xffffL             0xfffful
-#define LZO_0xffffffffL         0xfffffffful
+#define LZO_0xffffUL            0xfffful
+#define LZO_0xffffffffUL        0xfffffffful
 #else
-#define LZO_0xffffL             65535ul
-#define LZO_0xffffffffL         4294967295ul
+#define LZO_0xffffUL            65535ul
+#define LZO_0xffffffffUL        4294967295ul
 #endif
+#define LZO_0xffffL             LZO_0xffffUL
+#define LZO_0xffffffffL         LZO_0xffffffffUL
 #if (LZO_0xffffL == LZO_0xffffffffL)
 #  error "your preprocessor is broken 1"
 #endif
@@ -121,6 +129,13 @@
 #  error "your preprocessor is broken 4"
 #endif
 #endif
+#if defined(__COUNTER__)
+#  ifndef LZO_CFG_USE_COUNTER
+#  define LZO_CFG_USE_COUNTER 1
+#  endif
+#else
+#  undef LZO_CFG_USE_COUNTER
+#endif
 #if (UINT_MAX == LZO_0xffffL)
 #if defined(__ZTC__) && defined(__I86__) && !defined(__OS2__)
 #  if !defined(MSDOS)
@@ -142,7 +157,7 @@
 #endif
 #if defined(_MSC_VER) && defined(M_I86HM) && (UINT_MAX == LZO_0xffffL)
 #  define ptrdiff_t long
-#  define _PTRDIFF_T_DEFINED
+#  define _PTRDIFF_T_DEFINED 1
 #endif
 #if (UINT_MAX == LZO_0xffffL)
 #  undef __LZO_RENAME_A
@@ -251,14 +266,31 @@
 #endif
 #define LZO_PP_STRINGIZE(x)             #x
 #define LZO_PP_MACRO_EXPAND(x)          LZO_PP_STRINGIZE(x)
+#define LZO_PP_CONCAT0()                /*empty*/
+#define LZO_PP_CONCAT1(a)               a
 #define LZO_PP_CONCAT2(a,b)             a ## b
 #define LZO_PP_CONCAT3(a,b,c)           a ## b ## c
 #define LZO_PP_CONCAT4(a,b,c,d)         a ## b ## c ## d
 #define LZO_PP_CONCAT5(a,b,c,d,e)       a ## b ## c ## d ## e
+#define LZO_PP_CONCAT6(a,b,c,d,e,f)     a ## b ## c ## d ## e ## f
+#define LZO_PP_CONCAT7(a,b,c,d,e,f,g)   a ## b ## c ## d ## e ## f ## g
+#define LZO_PP_ECONCAT0()               LZO_PP_CONCAT0()
+#define LZO_PP_ECONCAT1(a)              LZO_PP_CONCAT1(a)
 #define LZO_PP_ECONCAT2(a,b)            LZO_PP_CONCAT2(a,b)
 #define LZO_PP_ECONCAT3(a,b,c)          LZO_PP_CONCAT3(a,b,c)
 #define LZO_PP_ECONCAT4(a,b,c,d)        LZO_PP_CONCAT4(a,b,c,d)
 #define LZO_PP_ECONCAT5(a,b,c,d,e)      LZO_PP_CONCAT5(a,b,c,d,e)
+#define LZO_PP_ECONCAT6(a,b,c,d,e,f)    LZO_PP_CONCAT6(a,b,c,d,e,f)
+#define LZO_PP_ECONCAT7(a,b,c,d,e,f,g)  LZO_PP_CONCAT7(a,b,c,d,e,f,g)
+#define LZO_PP_EMPTY                    /*empty*/
+#define LZO_PP_EMPTY0()                 /*empty*/
+#define LZO_PP_EMPTY1(a)                /*empty*/
+#define LZO_PP_EMPTY2(a,b)              /*empty*/
+#define LZO_PP_EMPTY3(a,b,c)            /*empty*/
+#define LZO_PP_EMPTY4(a,b,c,d)          /*empty*/
+#define LZO_PP_EMPTY5(a,b,c,d,e)        /*empty*/
+#define LZO_PP_EMPTY6(a,b,c,d,e,f)      /*empty*/
+#define LZO_PP_EMPTY7(a,b,c,d,e,f,g)    /*empty*/
 #if 1
 #define LZO_CPP_STRINGIZE(x)            #x
 #define LZO_CPP_MACRO_EXPAND(x)         LZO_CPP_STRINGIZE(x)
@@ -266,12 +298,16 @@
 #define LZO_CPP_CONCAT3(a,b,c)          a ## b ## c
 #define LZO_CPP_CONCAT4(a,b,c,d)        a ## b ## c ## d
 #define LZO_CPP_CONCAT5(a,b,c,d,e)      a ## b ## c ## d ## e
+#define LZO_CPP_CONCAT6(a,b,c,d,e,f)    a ## b ## c ## d ## e ## f
+#define LZO_CPP_CONCAT7(a,b,c,d,e,f,g)  a ## b ## c ## d ## e ## f ## g
 #define LZO_CPP_ECONCAT2(a,b)           LZO_CPP_CONCAT2(a,b)
 #define LZO_CPP_ECONCAT3(a,b,c)         LZO_CPP_CONCAT3(a,b,c)
 #define LZO_CPP_ECONCAT4(a,b,c,d)       LZO_CPP_CONCAT4(a,b,c,d)
 #define LZO_CPP_ECONCAT5(a,b,c,d,e)     LZO_CPP_CONCAT5(a,b,c,d,e)
+#define LZO_CPP_ECONCAT6(a,b,c,d,e,f)   LZO_CPP_CONCAT6(a,b,c,d,e,f)
+#define LZO_CPP_ECONCAT7(a,b,c,d,e,f,g) LZO_CPP_CONCAT7(a,b,c,d,e,f,g)
 #endif
-#define __LZO_MASK_GEN(o,b)     (((((o) << ((b)-1)) - (o)) << 1) + (o))
+#define __LZO_MASK_GEN(o,b)     (((((o) << ((b)-!!(b))) - (o)) << 1) + (o)*!!(b))
 #if 1 && defined(__cplusplus)
 #  if !defined(__STDC_CONSTANT_MACROS)
 #    define __STDC_CONSTANT_MACROS 1
@@ -281,14 +317,18 @@
 #  endif
 #endif
 #if defined(__cplusplus)
-#  define LZO_EXTERN_C extern "C"
+#  define LZO_EXTERN_C          extern "C"
+#  define LZO_EXTERN_C_BEGIN    extern "C" {
+#  define LZO_EXTERN_C_END      }
 #else
-#  define LZO_EXTERN_C extern
+#  define LZO_EXTERN_C          extern
+#  define LZO_EXTERN_C_BEGIN    /*empty*/
+#  define LZO_EXTERN_C_END      /*empty*/
 #endif
 #if !defined(__LZO_OS_OVERRIDE)
-#if defined(LZO_OS_FREESTANDING)
+#if (LZO_OS_FREESTANDING)
 #  define LZO_INFO_OS           "freestanding"
-#elif defined(LZO_OS_EMBEDDED)
+#elif (LZO_OS_EMBEDDED)
 #  define LZO_INFO_OS           "embedded"
 #elif 1 && defined(__IAR_SYSTEMS_ICC__)
 #  define LZO_OS_EMBEDDED       1
@@ -384,12 +424,12 @@
 #elif defined(__VMS)
 #  define LZO_OS_VMS            1
 #  define LZO_INFO_OS           "vms"
-#elif ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
+#elif (defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__)
 #  define LZO_OS_CONSOLE        1
 #  define LZO_OS_CONSOLE_PS2    1
 #  define LZO_INFO_OS           "console"
 #  define LZO_INFO_OS_CONSOLE   "ps2"
-#elif (defined(__mips__) && defined(__psp__))
+#elif defined(__mips__) && defined(__psp__)
 #  define LZO_OS_CONSOLE        1
 #  define LZO_OS_CONSOLE_PSP    1
 #  define LZO_INFO_OS           "console"
@@ -417,9 +457,18 @@
 #  elif defined(__linux__) || defined(__linux) || defined(__LINUX__)
 #    define LZO_OS_POSIX_LINUX      1
 #    define LZO_INFO_OS_POSIX       "linux"
-#  elif defined(__APPLE__) || defined(__MACOS__)
-#    define LZO_OS_POSIX_MACOSX     1
-#    define LZO_INFO_OS_POSIX       "macosx"
+#  elif defined(__APPLE__) && defined(__MACH__)
+#    if ((__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__-0) >= 20000)
+#      define LZO_OS_POSIX_DARWIN     1040
+#      define LZO_INFO_OS_POSIX       "darwin_iphone"
+#    elif ((__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__-0) >= 1040)
+#      define LZO_OS_POSIX_DARWIN     __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
+#      define LZO_INFO_OS_POSIX       "darwin"
+#    else
+#      define LZO_OS_POSIX_DARWIN     1
+#      define LZO_INFO_OS_POSIX       "darwin"
+#    endif
+#    define LZO_OS_POSIX_MACOSX     LZO_OS_POSIX_DARWIN
 #  elif defined(__minix__) || defined(__minix)
 #    define LZO_OS_POSIX_MINIX      1
 #    define LZO_INFO_OS_POSIX       "minix"
@@ -454,18 +503,18 @@
 #endif
 #if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
 #  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #if (LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_WIN32 || LZO_OS_WIN64)
 #  if (UINT_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #if defined(CIL) && defined(_GNUCC) && defined(__GNUC__)
@@ -481,48 +530,73 @@
 #  define LZO_INFO_CC           "sdcc"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(SDCC)
 #elif defined(__PATHSCALE__) && defined(__PATHCC_PATCHLEVEL__)
-#  define LZO_CC_PATHSCALE      (__PATHCC__ * 0x10000L + __PATHCC_MINOR__ * 0x100 + __PATHCC_PATCHLEVEL__)
+#  define LZO_CC_PATHSCALE      (__PATHCC__ * 0x10000L + (__PATHCC_MINOR__-0) * 0x100 + (__PATHCC_PATCHLEVEL__-0))
 #  define LZO_INFO_CC           "Pathscale C"
 #  define LZO_INFO_CCVER        __PATHSCALE__
-#elif defined(__INTEL_COMPILER)
-#  define LZO_CC_INTELC         1
+#  if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_PATHSCALE_GNUC (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  endif
+#elif defined(__INTEL_COMPILER) && ((__INTEL_COMPILER-0) > 0)
+#  define LZO_CC_INTELC         __INTEL_COMPILER
 #  define LZO_INFO_CC           "Intel C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__INTEL_COMPILER)
-#  if defined(_WIN32) || defined(_WIN64)
-#    define LZO_CC_SYNTAX_MSC 1
-#  else
-#    define LZO_CC_SYNTAX_GNUC 1
+#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#    define LZO_CC_INTELC_MSC   _MSC_VER
+#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_INTELC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
 #  endif
 #elif defined(__POCC__) && defined(_WIN32)
 #  define LZO_CC_PELLESC        1
 #  define LZO_INFO_CC           "Pelles C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__POCC__)
-#elif defined(__llvm__) && defined(__GNUC__) && defined(__VERSION__)
-#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_LLVM         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
+#elif defined(__ARMCC_VERSION) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#  if defined(__GNUC_PATCHLEVEL__)
+#    define LZO_CC_ARMCC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
 #  else
-#    define LZO_CC_LLVM         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
+#    define LZO_CC_ARMCC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
 #  endif
-#  define LZO_INFO_CC           "llvm-gcc"
+#  define LZO_CC_ARMCC          __ARMCC_VERSION
+#  define LZO_INFO_CC           "ARM C Compiler"
 #  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__GNUC__) && defined(__VERSION__)
-#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  elif defined(__GNUC_MINOR__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
+#elif defined(__clang__) && defined(__llvm__) && defined(__VERSION__)
+#  if defined(__clang_major__) && defined(__clang_minor__) && defined(__clang_patchlevel__)
+#    define LZO_CC_CLANG        (__clang_major__ * 0x10000L + (__clang_minor__-0) * 0x100 + (__clang_patchlevel__-0))
 #  else
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L)
+#    define LZO_CC_CLANG        0x010000L
 #  endif
-#  define LZO_INFO_CC           "gcc"
+#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#    define LZO_CC_CLANG_MSC    _MSC_VER
+#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  endif
+#  define LZO_INFO_CC           "clang"
+#  define LZO_INFO_CCVER        __VERSION__
+#elif defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#  if defined(__GNUC_PATCHLEVEL__)
+#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  else
+#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
+#  endif
+#  define LZO_CC_LLVM           LZO_CC_LLVM_GNUC
+#  define LZO_INFO_CC           "llvm-gcc"
 #  define LZO_INFO_CCVER        __VERSION__
 #elif defined(__ACK__) && defined(_ACK)
 #  define LZO_CC_ACK            1
 #  define LZO_INFO_CC           "Amsterdam Compiler Kit C"
 #  define LZO_INFO_CCVER        "unknown"
+#elif defined(__ARMCC_VERSION) && !defined(__GNUC__)
+#  define LZO_CC_ARMCC          __ARMCC_VERSION
+#  define LZO_CC_ARMCC_ARMCC    __ARMCC_VERSION
+#  define LZO_INFO_CC           "ARM C Compiler"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__ARMCC_VERSION)
 #elif defined(__AZTEC_C__)
 #  define LZO_CC_AZTECC         1
 #  define LZO_INFO_CC           "Aztec C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__AZTEC_C__)
+#elif defined(__CODEGEARC__)
+#  define LZO_CC_CODEGEARC      1
+#  define LZO_INFO_CC           "CodeGear C"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__CODEGEARC__)
 #elif defined(__BORLANDC__)
 #  define LZO_CC_BORLANDC       1
 #  define LZO_INFO_CC           "Borland C"
@@ -539,10 +613,23 @@
 #  define LZO_CC_DECC           1
 #  define LZO_INFO_CC           "DEC C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DECC)
+#elif (defined(__ghs) || defined(__ghs__)) && defined(__GHS_VERSION_NUMBER) && ((__GHS_VERSION_NUMBER-0) > 0)
+#  define LZO_CC_GHS            1
+#  define LZO_INFO_CC           "Green Hills C"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__GHS_VERSION_NUMBER)
+#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#    define LZO_CC_GHS_MSC      _MSC_VER
+#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_GHS_GNUC     (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  endif
 #elif defined(__HIGHC__)
 #  define LZO_CC_HIGHC          1
 #  define LZO_INFO_CC           "MetaWare High C"
 #  define LZO_INFO_CCVER        "unknown"
+#elif defined(__HP_aCC) && ((__HP_aCC-0) > 0)
+#  define LZO_CC_HPACC          __HP_aCC
+#  define LZO_INFO_CC           "HP aCC"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__HP_aCC)
 #elif defined(__IAR_SYSTEMS_ICC__)
 #  define LZO_CC_IARC           1
 #  define LZO_INFO_CC           "IAR C"
@@ -551,10 +638,14 @@
 #  else
 #    define LZO_INFO_CCVER      "unknown"
 #  endif
-#elif defined(__IBMC__)
-#  define LZO_CC_IBMC           1
+#elif defined(__IBMC__) && ((__IBMC__-0) > 0)
+#  define LZO_CC_IBMC           __IBMC__
 #  define LZO_INFO_CC           "IBM C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMC__)
+#elif defined(__IBMCPP__) && ((__IBMCPP__-0) > 0)
+#  define LZO_CC_IBMC           __IBMCPP__
+#  define LZO_INFO_CC           "IBM C"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMCPP__)
 #elif defined(__KEIL__) && defined(__C166__)
 #  define LZO_CC_KEILC          1
 #  define LZO_INFO_CC           "Keil C"
@@ -571,16 +662,8 @@
 #  else
 #    define LZO_INFO_CCVER      "unknown"
 #  endif
-#elif defined(_MSC_VER)
-#  define LZO_CC_MSC            1
-#  define LZO_INFO_CC           "Microsoft C"
-#  if defined(_MSC_FULL_VER)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER) "." LZO_PP_MACRO_EXPAND(_MSC_FULL_VER)
-#  else
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER)
-#  endif
-#elif defined(__MWERKS__)
-#  define LZO_CC_MWERKS         1
+#elif defined(__MWERKS__) && ((__MWERKS__-0) > 0)
+#  define LZO_CC_MWERKS         __MWERKS__
 #  define LZO_INFO_CC           "Metrowerks C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__MWERKS__)
 #elif (defined(__NDPC__) || defined(__NDPX__)) && defined(__i386)
@@ -591,6 +674,15 @@
 #  define LZO_CC_PACIFICC       1
 #  define LZO_INFO_CC           "Pacific C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PACIFIC__)
+#elif defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__)
+#  if defined(__PGIC_PATCHLEVEL__)
+#    define LZO_CC_PGI          (__PGIC__ * 0x10000L + (__PGIC_MINOR__-0) * 0x100 + (__PGIC_PATCHLEVEL__-0))
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__PGIC__) "." LZO_PP_MACRO_EXPAND(__PGIC_MINOR__) "." LZO_PP_MACRO_EXPAND(__PGIC_PATCHLEVEL__)
+#  else
+#    define LZO_CC_PGI          (__PGIC__ * 0x10000L + (__PGIC_MINOR__-0) * 0x100)
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__PGIC__) "." LZO_PP_MACRO_EXPAND(__PGIC_MINOR__) ".0"
+#  endif
+#  define LZO_INFO_CC           "Portland Group PGI C"
 #elif defined(__PGI) && (defined(__linux__) || defined(__WIN32__))
 #  define LZO_CC_PGI            1
 #  define LZO_INFO_CC           "Portland Group PGI C"
@@ -605,7 +697,7 @@
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__SC__)
 #elif defined(__SUNPRO_C)
 #  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_C)+0 > 0)
+#  if ((__SUNPRO_C-0) > 0)
 #    define LZO_CC_SUNPROC      __SUNPRO_C
 #    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_C)
 #  else
@@ -614,7 +706,7 @@
 #  endif
 #elif defined(__SUNPRO_CC)
 #  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_CC)+0 > 0)
+#  if ((__SUNPRO_CC-0) > 0)
 #    define LZO_CC_SUNPROC      __SUNPRO_CC
 #    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_CC)
 #  else
@@ -640,20 +732,50 @@
 #elif defined(__ZTC__)
 #  define LZO_CC_ZORTECHC       1
 #  define LZO_INFO_CC           "Zortech C"
-#  if (__ZTC__ == 0x310)
+#  if ((__ZTC__-0) == 0x310)
 #    define LZO_INFO_CCVER      "0x310"
 #  else
 #    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__ZTC__)
 #  endif
+#elif defined(__GNUC__) && defined(__VERSION__)
+#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
+#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  elif defined(__GNUC_MINOR__)
+#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
+#  else
+#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L)
+#  endif
+#  define LZO_INFO_CC           "gcc"
+#  define LZO_INFO_CCVER        __VERSION__
+#elif defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#  define LZO_CC_MSC            _MSC_VER
+#  define LZO_INFO_CC           "Microsoft C"
+#  if defined(_MSC_FULL_VER)
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER) "." LZO_PP_MACRO_EXPAND(_MSC_FULL_VER)
+#  else
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER)
+#  endif
 #else
 #  define LZO_CC_UNKNOWN        1
 #  define LZO_INFO_CC           "unknown"
 #  define LZO_INFO_CCVER        "unknown"
 #endif
+#if (LZO_CC_GNUC) && defined(__OPEN64__)
+#  if defined(__OPENCC__) && defined(__OPENCC_MINOR__) && defined(__OPENCC_PATCHLEVEL__)
+#    define LZO_CC_OPEN64       (__OPENCC__ * 0x10000L + (__OPENCC_MINOR__-0) * 0x100 + (__OPENCC_PATCHLEVEL__-0))
+#    define LZO_CC_OPEN64_GNUC  LZO_CC_GNUC
+#  endif
+#endif
+#if (LZO_CC_GNUC) && defined(__PCC__)
+#  if defined(__PCC__) && defined(__PCC_MINOR__) && defined(__PCC_MINORMINOR__)
+#    define LZO_CC_PCC          (__PCC__ * 0x10000L + (__PCC_MINOR__-0) * 0x100 + (__PCC_MINORMINOR__-0))
+#    define LZO_CC_PCC_GNUC     LZO_CC_GNUC
+#  endif
+#endif
 #if 0 && (LZO_CC_MSC && (_MSC_VER >= 1200)) && !defined(_MSC_FULL_VER)
 #  error "LZO_CC_MSC: _MSC_FULL_VER is not defined"
 #endif
-#if !defined(__LZO_ARCH_OVERRIDE) && !defined(LZO_ARCH_GENERIC) && defined(_CRAY)
+#if !defined(__LZO_ARCH_OVERRIDE) && !(LZO_ARCH_GENERIC) && defined(_CRAY)
 #  if (UINT_MAX > LZO_0xffffffffL) && defined(_CRAY)
 #    if defined(_CRAYMPP) || defined(_CRAYT3D) || defined(_CRAYT3E)
 #      define LZO_ARCH_CRAY_MPP     1
@@ -663,12 +785,14 @@
 #  endif
 #endif
 #if !defined(__LZO_ARCH_OVERRIDE)
-#if defined(LZO_ARCH_GENERIC)
+#if (LZO_ARCH_GENERIC)
 #  define LZO_INFO_ARCH             "generic"
 #elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
 #  define LZO_ARCH_I086             1
-#  define LZO_ARCH_IA16             1
 #  define LZO_INFO_ARCH             "i086"
+#elif defined(__aarch64__)
+#  define LZO_ARCH_ARM64            1
+#  define LZO_INFO_ARCH             "arm64"
 #elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
 #  define LZO_ARCH_ALPHA            1
 #  define LZO_INFO_ARCH             "alpha"
@@ -684,10 +808,10 @@
 #  define LZO_INFO_ARCH             "arm_thumb"
 #elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCARM__)
 #  define LZO_ARCH_ARM              1
-#  if defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 1)
+#  if defined(__CPU_MODE__) && ((__CPU_MODE__-0) == 1)
 #    define LZO_ARCH_ARM_THUMB      1
 #    define LZO_INFO_ARCH           "arm_thumb"
-#  elif defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 2)
+#  elif defined(__CPU_MODE__) && ((__CPU_MODE__-0) == 2)
 #    define LZO_INFO_ARCH           "arm"
 #  else
 #    define LZO_INFO_ARCH           "arm"
@@ -698,6 +822,9 @@
 #elif (UINT_MAX <= LZO_0xffffL) && defined(__AVR__)
 #  define LZO_ARCH_AVR              1
 #  define LZO_INFO_ARCH             "avr"
+#elif defined(__avr32__) || defined(__AVR32__)
+#  define LZO_ARCH_AVR32            1
+#  define LZO_INFO_ARCH             "avr32"
 #elif defined(__bfin__)
 #  define LZO_ARCH_BLACKFIN         1
 #  define LZO_INFO_ARCH             "blackfin"
@@ -802,53 +929,147 @@
 #  error "FIXME - missing define for CPU architecture"
 #endif
 #if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN32)
-#  error "FIXME - missing WIN32 define for CPU architecture"
+#  error "FIXME - missing LZO_OS_WIN32 define for CPU architecture"
 #endif
 #if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN64)
-#  error "FIXME - missing WIN64 define for CPU architecture"
+#  error "FIXME - missing LZO_OS_WIN64 define for CPU architecture"
 #endif
 #if (LZO_OS_OS216 || LZO_OS_WIN16)
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #elif 1 && (LZO_OS_DOS16 && defined(BLX286))
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #elif 1 && (LZO_OS_DOS16 && defined(DOSX286))
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #elif 1 && (LZO_OS_DOS16 && LZO_CC_BORLANDC && defined(__DPMI16__))
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #endif
-#if defined(LZO_ARCH_ARM_THUMB) && !defined(LZO_ARCH_ARM)
-#  error "this should not happen"
+#if (LZO_ARCH_AMD64 && !LZO_ARCH_X64)
+#  define LZO_ARCH_X64              1
+#elif (!LZO_ARCH_AMD64 && LZO_ARCH_X64) && defined(__LZO_ARCH_OVERRIDE)
+#  define LZO_ARCH_AMD64            1
+#endif
+#if (LZO_ARCH_ARM64 && !LZO_ARCH_AARCH64)
+#  define LZO_ARCH_AARCH64          1
+#elif (!LZO_ARCH_ARM64 && LZO_ARCH_AARCH64) && defined(__LZO_ARCH_OVERRIDE)
+#  define LZO_ARCH_ARM64            1
+#endif
+#if (LZO_ARCH_I386 && !LZO_ARCH_X86)
+#  define LZO_ARCH_X86              1
+#elif (!LZO_ARCH_I386 && LZO_ARCH_X86) && defined(__LZO_ARCH_OVERRIDE)
+#  define LZO_ARCH_I386            1
+#endif
+#if (LZO_ARCH_AMD64 && !LZO_ARCH_X64) || (!LZO_ARCH_AMD64 && LZO_ARCH_X64)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM64 && !LZO_ARCH_AARCH64) || (!LZO_ARCH_ARM64 && LZO_ARCH_AARCH64)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_I386 && !LZO_ARCH_X86) || (!LZO_ARCH_I386 && LZO_ARCH_X86)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM_THUMB && !LZO_ARCH_ARM)
+#  error "unexpected configuration - check your compiler defines"
 #endif
-#if defined(LZO_ARCH_I086PM) && !defined(LZO_ARCH_I086)
-#  error "this should not happen"
+#if (LZO_ARCH_ARM_THUMB1 && !LZO_ARCH_ARM_THUMB)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM_THUMB2 && !LZO_ARCH_ARM_THUMB)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM_THUMB1 && LZO_ARCH_ARM_THUMB2)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_I086PM && !LZO_ARCH_I086)
+#  error "unexpected configuration - check your compiler defines"
 #endif
 #if (LZO_ARCH_I086)
 #  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #if (LZO_ARCH_I386)
 #  if (UINT_MAX != LZO_0xffffL) && defined(__i386_int16__)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (UINT_MAX != LZO_0xffffffffL) && !defined(__i386_int16__)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
+#  endif
+#endif
+#if (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+#  if !defined(LZO_TARGET_FEATURE_SSE2)
+#    if defined(__SSE2__)
+#      define LZO_TARGET_FEATURE_SSE2       1
+#    elif defined(_MSC_VER) && ((defined(_M_IX86_FP) && ((_M_IX86_FP)+0 >= 2)) || defined(_M_AMD64))
+#      define LZO_TARGET_FEATURE_SSE2       1
+#    endif
+#  endif
+#  if !defined(LZO_TARGET_FEATURE_SSSE3)
+#  if (LZO_TARGET_FEATURE_SSE2)
+#    if defined(__SSSE3__)
+#      define LZO_TARGET_FEATURE_SSSE3      1
+#    elif defined(_MSC_VER) && defined(__AVX__)
+#      define LZO_TARGET_FEATURE_SSSE3      1
+#    endif
+#  endif
+#  endif
+#  if !defined(LZO_TARGET_FEATURE_SSE4_2)
+#  if (LZO_TARGET_FEATURE_SSSE3)
+#    if defined(__SSE4_2__)
+#      define LZO_TARGET_FEATURE_SSE4_2     1
+#    endif
+#  endif
+#  endif
+#  if !defined(LZO_TARGET_FEATURE_AVX)
+#  if (LZO_TARGET_FEATURE_SSSE3)
+#    if defined(__AVX__)
+#      define LZO_TARGET_FEATURE_AVX        1
+#    endif
+#  endif
+#  endif
+#  if !defined(LZO_TARGET_FEATURE_AVX2)
+#  if (LZO_TARGET_FEATURE_AVX)
+#    if defined(__AVX2__)
+#      define LZO_TARGET_FEATURE_AVX2       1
+#    endif
+#  endif
+#  endif
+#endif
+#if (LZO_TARGET_FEATURE_SSSE3 && !(LZO_TARGET_FEATURE_SSE2))
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_TARGET_FEATURE_SSE4_2 && !(LZO_TARGET_FEATURE_SSSE3))
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_TARGET_FEATURE_AVX && !(LZO_TARGET_FEATURE_SSSE3))
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_TARGET_FEATURE_AVX2 && !(LZO_TARGET_FEATURE_AVX))
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM)
+#  if !defined(LZO_TARGET_FEATURE_NEON)
+#    if defined(__ARM_NEON__)
+#      define LZO_TARGET_FEATURE_NEON       1
+#    endif
+#  endif
+#elif (LZO_ARCH_ARM64)
+#  if !defined(LZO_TARGET_FEATURE_NEON)
+#    if 1
+#      define LZO_TARGET_FEATURE_NEON       1
+#    endif
 #  endif
 #endif
-#if !defined(__LZO_MM_OVERRIDE)
+#if 0
+#elif !defined(__LZO_MM_OVERRIDE)
 #if (LZO_ARCH_I086)
 #if (UINT_MAX != LZO_0xffffL)
-#  error "this should not happen"
+#  error "unexpected configuration - check your compiler defines"
 #endif
 #if defined(__TINY__) || defined(M_I86TM) || defined(_M_I86TM)
 #  define LZO_MM_TINY           1
@@ -875,7 +1096,7 @@
 #elif (LZO_CC_ZORTECHC && defined(__VCM__))
 #  define LZO_MM_LARGE          1
 #else
-#  error "unknown memory model"
+#  error "unknown LZO_ARCH_I086 memory model"
 #endif
 #if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
 #define LZO_HAVE_MM_HUGE_PTR        1
@@ -896,12 +1117,12 @@
 #elif (LZO_CC_TURBOC && (__TURBOC__ < 0x0295))
 #  undef LZO_HAVE_MM_HUGE_ARRAY
 #endif
-#if (LZO_ARCH_I086PM) && !defined(LZO_HAVE_MM_HUGE_PTR)
+#if (LZO_ARCH_I086PM) && !(LZO_HAVE_MM_HUGE_PTR)
 #  if (LZO_OS_DOS16)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  elif (LZO_CC_ZORTECHC)
 #  else
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #ifdef __cplusplus
@@ -933,7 +1154,7 @@ extern "C" {
 #endif
 #elif (LZO_ARCH_C166)
 #if !defined(__MODEL__)
-#  error "FIXME - C166 __MODEL__"
+#  error "FIXME - LZO_ARCH_C166 __MODEL__"
 #elif ((__MODEL__) == 0)
 #  define LZO_MM_SMALL          1
 #elif ((__MODEL__) == 1)
@@ -947,11 +1168,11 @@ extern "C" {
 #elif ((__MODEL__) == 5)
 #  define LZO_MM_XSMALL         1
 #else
-#  error "FIXME - C166 __MODEL__"
+#  error "FIXME - LZO_ARCH_C166 __MODEL__"
 #endif
 #elif (LZO_ARCH_MCS251)
 #if !defined(__MODEL__)
-#  error "FIXME - MCS251 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS251 __MODEL__"
 #elif ((__MODEL__) == 0)
 #  define LZO_MM_SMALL          1
 #elif ((__MODEL__) == 2)
@@ -963,11 +1184,11 @@ extern "C" {
 #elif ((__MODEL__) == 5)
 #  define LZO_MM_XSMALL         1
 #else
-#  error "FIXME - MCS251 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS251 __MODEL__"
 #endif
 #elif (LZO_ARCH_MCS51)
 #if !defined(__MODEL__)
-#  error "FIXME - MCS51 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS51 __MODEL__"
 #elif ((__MODEL__) == 1)
 #  define LZO_MM_SMALL          1
 #elif ((__MODEL__) == 2)
@@ -979,7 +1200,7 @@ extern "C" {
 #elif ((__MODEL__) == 5)
 #  define LZO_MM_XSMALL         1
 #else
-#  error "FIXME - MCS51 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS51 __MODEL__"
 #endif
 #elif (LZO_ARCH_CRAY_PVP)
 #  define LZO_MM_PVP            1
@@ -1006,454 +1227,270 @@ extern "C" {
 #  error "unknown memory model"
 #endif
 #endif
-#if defined(SIZEOF_SHORT)
-#  define LZO_SIZEOF_SHORT          (SIZEOF_SHORT)
+#if !defined(__lzo_gnuc_extension__)
+#if (LZO_CC_GNUC >= 0x020800ul)
+#  define __lzo_gnuc_extension__    __extension__
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_gnuc_extension__    __extension__
+#elif (LZO_CC_IBMC >= 600)
+#  define __lzo_gnuc_extension__    __extension__
+#else
 #endif
-#if defined(SIZEOF_INT)
-#  define LZO_SIZEOF_INT            (SIZEOF_INT)
 #endif
-#if defined(SIZEOF_LONG)
-#  define LZO_SIZEOF_LONG           (SIZEOF_LONG)
+#if !defined(__lzo_gnuc_extension__)
+#  define __lzo_gnuc_extension__    /*empty*/
 #endif
-#if defined(SIZEOF_LONG_LONG)
-#  define LZO_SIZEOF_LONG_LONG      (SIZEOF_LONG_LONG)
+#if !defined(LZO_CFG_USE_NEW_STYLE_CASTS) && defined(__cplusplus) && 0
+#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul))
+#    define LZO_CFG_USE_NEW_STYLE_CASTS 0
+#  elif (LZO_CC_INTELC && (__INTEL_COMPILER < 1200))
+#    define LZO_CFG_USE_NEW_STYLE_CASTS 0
+#  else
+#    define LZO_CFG_USE_NEW_STYLE_CASTS 1
+#  endif
 #endif
-#if defined(SIZEOF___INT16)
-#  define LZO_SIZEOF___INT16        (SIZEOF___INT16)
+#if !defined(LZO_CFG_USE_NEW_STYLE_CASTS)
+#  define LZO_CFG_USE_NEW_STYLE_CASTS 0
 #endif
-#if defined(SIZEOF___INT32)
-#  define LZO_SIZEOF___INT32        (SIZEOF___INT32)
+#if !defined(__cplusplus)
+#  if defined(LZO_CFG_USE_NEW_STYLE_CASTS)
+#    undef LZO_CFG_USE_NEW_STYLE_CASTS
+#  endif
+#  define LZO_CFG_USE_NEW_STYLE_CASTS 0
 #endif
-#if defined(SIZEOF___INT64)
-#  define LZO_SIZEOF___INT64        (SIZEOF___INT64)
+#if !defined(LZO_REINTERPRET_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_REINTERPRET_CAST(t,e)       (reinterpret_cast<t> (e))
+#  endif
 #endif
-#if defined(SIZEOF_VOID_P)
-#  define LZO_SIZEOF_VOID_P         (SIZEOF_VOID_P)
+#if !defined(LZO_REINTERPRET_CAST)
+#  define LZO_REINTERPRET_CAST(t,e)         ((t) (e))
 #endif
-#if defined(SIZEOF_SIZE_T)
-#  define LZO_SIZEOF_SIZE_T         (SIZEOF_SIZE_T)
+#if !defined(LZO_STATIC_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_STATIC_CAST(t,e)            (static_cast<t> (e))
+#  endif
 #endif
-#if defined(SIZEOF_PTRDIFF_T)
-#  define LZO_SIZEOF_PTRDIFF_T      (SIZEOF_PTRDIFF_T)
+#if !defined(LZO_STATIC_CAST)
+#  define LZO_STATIC_CAST(t,e)              ((t) (e))
 #endif
-#define __LZO_LSR(x,b)    (((x)+0ul) >> (b))
-#if !defined(LZO_SIZEOF_SHORT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (USHRT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,7) == 1)
-#    define LZO_SIZEOF_SHORT        1
-#  elif (__LZO_LSR(USHRT_MAX,15) == 1)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,31) == 1)
-#    define LZO_SIZEOF_SHORT        4
-#  elif (__LZO_LSR(USHRT_MAX,63) == 1)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (__LZO_LSR(USHRT_MAX,127) == 1)
-#    define LZO_SIZEOF_SHORT        16
-#  else
-#    error "LZO_SIZEOF_SHORT"
-#  endif
+#if !defined(LZO_STATIC_CAST2)
+#  define LZO_STATIC_CAST2(t1,t2,e)         LZO_STATIC_CAST(t1, LZO_STATIC_CAST(t2, e))
 #endif
-#if !defined(LZO_SIZEOF_INT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_INT          8
-#  elif (UINT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_INT          2
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,7) == 1)
-#    define LZO_SIZEOF_INT          1
-#  elif (__LZO_LSR(UINT_MAX,15) == 1)
-#    define LZO_SIZEOF_INT          2
-#  elif (__LZO_LSR(UINT_MAX,31) == 1)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,63) == 1)
-#    define LZO_SIZEOF_INT          8
-#  elif (__LZO_LSR(UINT_MAX,127) == 1)
-#    define LZO_SIZEOF_INT          16
-#  else
-#    error "LZO_SIZEOF_INT"
+#if !defined(LZO_UNCONST_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNCONST_CAST(t,e)           (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNCONST_CAST(t,e)           ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNCONST_CAST(t,e)           ((t) ((void *) ((lzo_uintptr_t) ((const void *) (e)))))
 #  endif
 #endif
-#if !defined(LZO_SIZEOF_LONG)
-#  if (ULONG_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,7) == 1)
-#    define LZO_SIZEOF_LONG         1
-#  elif (__LZO_LSR(ULONG_MAX,15) == 1)
-#    define LZO_SIZEOF_LONG         2
-#  elif (__LZO_LSR(ULONG_MAX,31) == 1)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,63) == 1)
-#    define LZO_SIZEOF_LONG         8
-#  elif (__LZO_LSR(ULONG_MAX,127) == 1)
-#    define LZO_SIZEOF_LONG         16
-#  else
-#    error "LZO_SIZEOF_LONG"
+#if !defined(LZO_UNCONST_CAST)
+#  define LZO_UNCONST_CAST(t,e)             ((t) ((void *) ((const void *) (e))))
+#endif
+#if !defined(LZO_UNCONST_VOLATILE_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNCONST_VOLATILE_CAST(t,e)  (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNCONST_VOLATILE_CAST(t,e)  ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNCONST_VOLATILE_CAST(t,e)  ((t) ((volatile void *) ((lzo_uintptr_t) ((volatile const void *) (e)))))
 #  endif
 #endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#  if defined(__LONG_MAX__) && defined(__LONG_LONG_MAX__)
-#    if (LZO_CC_GNUC >= 0x030300ul)
-#      if ((__LONG_MAX__)+0 == (__LONG_LONG_MAX__)+0)
-#        define LZO_SIZEOF_LONG_LONG      LZO_SIZEOF_LONG
-#      elif (__LZO_LSR(__LONG_LONG_MAX__,30) == 1)
-#        define LZO_SIZEOF_LONG_LONG      4
-#      endif
-#    endif
+#if !defined(LZO_UNCONST_VOLATILE_CAST)
+#  define LZO_UNCONST_VOLATILE_CAST(t,e)    ((t) ((volatile void *) ((volatile const void *) (e))))
+#endif
+#if !defined(LZO_UNVOLATILE_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNVOLATILE_CAST(t,e)        (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNVOLATILE_CAST(t,e)        ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNVOLATILE_CAST(t,e)        ((t) ((void *) ((lzo_uintptr_t) ((volatile void *) (e)))))
 #  endif
 #endif
+#if !defined(LZO_UNVOLATILE_CAST)
+#  define LZO_UNVOLATILE_CAST(t,e)          ((t) ((void *) ((volatile void *) (e))))
 #endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#if (LZO_ARCH_I086 && LZO_CC_DMC)
-#elif (LZO_CC_CILLY) && defined(__GNUC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif ((LZO_OS_WIN32 || LZO_OS_WIN64 || defined(_WIN32)) && LZO_CC_MSC && (_MSC_VER >= 1400))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_OS_WIN64 || defined(_WIN64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_DMC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_SYMANTECC && (__SC__ >= 0x700)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC && defined(__linux__)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_MWERKS || LZO_CC_PELLESC || LZO_CC_PGI || LZO_CC_SUNPROC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC || LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif ((LZO_OS_WIN32 || defined(_WIN32)) && (LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0520)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_WATCOMC && (__WATCOMC__ >= 1100)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_CC_WATCOMC && defined(_INTEGRAL_MAX_BITS) && (_INTEGRAL_MAX_BITS == 64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_SDCC) && (LZO_SIZEOF_INT == 2)
-#elif 1 && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define LZO_SIZEOF_LONG_LONG      8
+#if !defined(LZO_UNVOLATILE_CONST_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNVOLATILE_CONST_CAST(t,e)  (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNVOLATILE_CONST_CAST(t,e)  ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNVOLATILE_CONST_CAST(t,e)  ((t) ((const void *) ((lzo_uintptr_t) ((volatile const void *) (e)))))
+#  endif
 #endif
+#if !defined(LZO_UNVOLATILE_CONST_CAST)
+#  define LZO_UNVOLATILE_CONST_CAST(t,e)    ((t) ((const void *) ((volatile const void *) (e))))
 #endif
+#if !defined(LZO_PCAST)
+#  if (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_PCAST(t,e)                  ((t) (e))
+#  endif
 #endif
-#if defined(__cplusplus) && defined(LZO_CC_GNUC)
-#  if (LZO_CC_GNUC < 0x020800ul)
-#    undef LZO_SIZEOF_LONG_LONG
+#if !defined(LZO_PCAST)
+#  define LZO_PCAST(t,e)                    LZO_STATIC_CAST(t, LZO_STATIC_CAST(void *, e))
+#endif
+#if !defined(LZO_CCAST)
+#  if (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_CCAST(t,e)                  ((t) (e))
 #  endif
 #endif
-#if defined(LZO_CFG_NO_LONG_LONG) || defined(__NO_LONG_LONG)
-#  undef LZO_SIZEOF_LONG_LONG
+#if !defined(LZO_CCAST)
+#  define LZO_CCAST(t,e)                    LZO_STATIC_CAST(t, LZO_STATIC_CAST(const void *, e))
 #endif
-#if !defined(LZO_SIZEOF_VOID_P)
-#if (LZO_ARCH_I086)
-#  define __LZO_WORDSIZE            2
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
-#    define LZO_SIZEOF_VOID_P       2
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    error "LZO_MM"
+#if !defined(LZO_ICONV)
+#  define LZO_ICONV(t,e)                    LZO_STATIC_CAST(t, e)
+#endif
+#if !defined(LZO_ICAST)
+#  define LZO_ICAST(t,e)                    LZO_STATIC_CAST(t, e)
+#endif
+#if !defined(LZO_ITRUNC)
+#  define LZO_ITRUNC(t,e)                   LZO_STATIC_CAST(t, e)
+#endif
+#if !defined(__lzo_cte)
+#  if (LZO_CC_MSC || LZO_CC_WATCOMC)
+#    define __lzo_cte(e)            ((void)0,(e))
+#  elif 1
+#    define __lzo_cte(e)            ((void)0,(e))
 #  endif
-#elif (LZO_ARCH_AVR || LZO_ARCH_Z80)
-#  define __LZO_WORDSIZE            1
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_C166 || LZO_ARCH_MCS51 || LZO_ARCH_MCS251 || LZO_ARCH_MSP430)
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_H8300)
-#  if defined(__NORMAL_MODE__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       2
-#  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define __LZO_WORDSIZE          2
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_SIZEOF_INT == 4)
-#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_INT
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_INT
-#  endif
-#elif (LZO_ARCH_M16C)
-#  define __LZO_WORDSIZE            2
-#  if defined(__m32c_cpu__) || defined(__m32cm_cpu__)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         4
-#elif defined(__LLP64__) || defined(__LLP64) || defined(_LLP64) || defined(_WIN64)
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_OS_OS400 || defined(__OS400__))
-#  define __LZO_WORDSIZE            LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_VOID_P         16
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_VOID_P         8
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_ARCH_SPU)
-# if 0
-#  define __LZO_WORDSIZE            16
-# endif
-#  define LZO_SIZEOF_VOID_P         4
-#else
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
 #endif
+#if !defined(__lzo_cte)
+#  define __lzo_cte(e)              (e)
 #endif
-#if !defined(LZO_WORDSIZE)
-#  if defined(__LZO_WORDSIZE)
-#    define LZO_WORDSIZE            __LZO_WORDSIZE
+#if !defined(LZO_BLOCK_BEGIN)
+#  define LZO_BLOCK_BEGIN           do {
+#  define LZO_BLOCK_END             } while __lzo_cte(0)
+#endif
+#if !defined(LZO_UNUSED)
+#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
+#    define LZO_UNUSED(var)         ((void) &var)
+#  elif (LZO_CC_BORLANDC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PELLESC || LZO_CC_TURBOC)
+#    define LZO_UNUSED(var)         if (&var) ; else
+#  elif (LZO_CC_CLANG && (LZO_CC_CLANG >= 0x030200ul))
+#    define LZO_UNUSED(var)         ((void) &var)
+#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNUSED(var)         ((void) var)
+#  elif (LZO_CC_MSC && (_MSC_VER < 900))
+#    define LZO_UNUSED(var)         if (&var) ; else
+#  elif (LZO_CC_KEILC)
+#    define LZO_UNUSED(var)         {LZO_EXTERN_C int lzo_unused__[1-2*!(sizeof(var)>0)];}
+#  elif (LZO_CC_PACIFICC)
+#    define LZO_UNUSED(var)         ((void) sizeof(var))
+#  elif (LZO_CC_WATCOMC) && defined(__cplusplus)
+#    define LZO_UNUSED(var)         ((void) var)
 #  else
-#    define LZO_WORDSIZE            LZO_SIZEOF_VOID_P
+#    define LZO_UNUSED(var)         ((void) &var)
 #  endif
 #endif
-#if !defined(LZO_SIZEOF_SIZE_T)
-#if (LZO_ARCH_I086 || LZO_ARCH_M16C)
-#  define LZO_SIZEOF_SIZE_T         2
-#else
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_VOID_P
-#endif
-#endif
-#if !defined(LZO_SIZEOF_PTRDIFF_T)
-#if (LZO_ARCH_I086)
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM || LZO_MM_HUGE)
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_VOID_P
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE)
-#    if (LZO_CC_BORLANDC || LZO_CC_TURBOC)
-#      define LZO_SIZEOF_PTRDIFF_T  4
-#    else
-#      define LZO_SIZEOF_PTRDIFF_T  2
-#    endif
+#if !defined(LZO_UNUSED_FUNC)
+#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
+#    define LZO_UNUSED_FUNC(func)   ((void) func)
+#  elif (LZO_CC_BORLANDC || LZO_CC_NDPC || LZO_CC_TURBOC)
+#    define LZO_UNUSED_FUNC(func)   if (func) ; else
+#  elif (LZO_CC_CLANG || LZO_CC_LLVM)
+#    define LZO_UNUSED_FUNC(func)   ((void) &func)
+#  elif (LZO_CC_MSC && (_MSC_VER < 900))
+#    define LZO_UNUSED_FUNC(func)   if (func) ; else
+#  elif (LZO_CC_MSC)
+#    define LZO_UNUSED_FUNC(func)   ((void) &func)
+#  elif (LZO_CC_KEILC || LZO_CC_PELLESC)
+#    define LZO_UNUSED_FUNC(func)   {LZO_EXTERN_C int lzo_unused_func__[1-2*!(sizeof((int)func)>0)];}
 #  else
-#    error "LZO_MM"
+#    define LZO_UNUSED_FUNC(func)   ((void) func)
 #  endif
-#else
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_SIZE_T
-#endif
 #endif
-#if defined(LZO_ABI_NEUTRAL_ENDIAN)
-#  undef LZO_ABI_BIG_ENDIAN
-#  undef LZO_ABI_LITTLE_ENDIAN
-#elif !defined(LZO_ABI_BIG_ENDIAN) && !defined(LZO_ABI_LITTLE_ENDIAN)
-#if (LZO_ARCH_ALPHA) && (LZO_ARCH_CRAY_MPP)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif (LZO_ARCH_ALPHA || LZO_ARCH_AMD64 || LZO_ARCH_BLACKFIN || LZO_ARCH_CRIS || LZO_ARCH_I086 || LZO_ARCH_I386 || LZO_ARCH_MSP430)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif (LZO_ARCH_M68K || LZO_ARCH_S390)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__IAR_SYSTEMS_ICC__) && defined(__LITTLE_ENDIAN__)
-#  if (__LITTLE_ENDIAN__ == 1)
-#    define LZO_ABI_LITTLE_ENDIAN   1
+#if !defined(LZO_UNUSED_LABEL)
+#  if (LZO_CC_CLANG >= 0x020800ul)
+#    define LZO_UNUSED_LABEL(l)     (__lzo_gnuc_extension__ ((void) ((const void *) &&l)))
+#  elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_INTELC || LZO_CC_WATCOMC)
+#    define LZO_UNUSED_LABEL(l)     if __lzo_cte(0) goto l
 #  else
-#    define LZO_ABI_BIG_ENDIAN      1
+#    define LZO_UNUSED_LABEL(l)     switch (0) case 1:goto l
 #  endif
-#elif 1 && defined(__BIG_ENDIAN__) && !defined(__LITTLE_ENDIAN__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEB__) && !defined(__ARMEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEL__) && !defined(__ARMEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEB__) && !defined(__MIPSEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEL__) && !defined(__MIPSEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#endif
-#endif
-#if defined(LZO_ABI_BIG_ENDIAN) && defined(LZO_ABI_LITTLE_ENDIAN)
-#  error "this should not happen"
-#endif
-#if defined(LZO_ABI_BIG_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "be"
-#elif defined(LZO_ABI_LITTLE_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "le"
-#elif defined(LZO_ABI_NEUTRAL_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "neutral"
-#endif
-#if (LZO_SIZEOF_INT == 1 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_I8LP16         1
-#  define LZO_INFO_ABI_PM       "i8lp16"
-#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_ILP16         1
-#  define LZO_INFO_ABI_PM       "ilp16"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_ILP32         1
-#  define LZO_INFO_ABI_PM       "ilp32"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 8 && LZO_SIZEOF_SIZE_T == 8)
-#  define LZO_ABI_LLP64         1
-#  define LZO_INFO_ABI_PM       "llp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_LP64          1
-#  define LZO_INFO_ABI_PM       "lp64"
-#elif (LZO_SIZEOF_INT == 8 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_ILP64         1
-#  define LZO_INFO_ABI_PM       "ilp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_IP32L64       1
-#  define LZO_INFO_ABI_PM       "ip32l64"
 #endif
-#if !defined(__LZO_LIBC_OVERRIDE)
-#if defined(LZO_LIBC_NAKED)
-#  define LZO_INFO_LIBC         "naked"
-#elif defined(LZO_LIBC_FREESTANDING)
-#  define LZO_INFO_LIBC         "freestanding"
-#elif defined(LZO_LIBC_MOSTLY_FREESTANDING)
-#  define LZO_INFO_LIBC         "mfreestanding"
-#elif defined(LZO_LIBC_ISOC90)
-#  define LZO_INFO_LIBC         "isoc90"
-#elif defined(LZO_LIBC_ISOC99)
-#  define LZO_INFO_LIBC         "isoc99"
-#elif defined(__dietlibc__)
-#  define LZO_LIBC_DIETLIBC     1
-#  define LZO_INFO_LIBC         "dietlibc"
-#elif defined(_NEWLIB_VERSION)
-#  define LZO_LIBC_NEWLIB       1
-#  define LZO_INFO_LIBC         "newlib"
-#elif defined(__UCLIBC__) && defined(__UCLIBC_MAJOR__) && defined(__UCLIBC_MINOR__)
-#  if defined(__UCLIBC_SUBLEVEL__)
-#    define LZO_LIBC_UCLIBC     (__UCLIBC_MAJOR__ * 0x10000L + __UCLIBC_MINOR__ * 0x100 + __UCLIBC_SUBLEVEL__)
+#if !defined(LZO_DEFINE_UNINITIALIZED_VAR)
+#  if 0
+#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var
+#  elif 0 && (LZO_CC_GNUC)
+#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = var
 #  else
-#    define LZO_LIBC_UCLIBC     0x00090bL
+#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = init
 #  endif
-#  define LZO_INFO_LIBC         "uclibc"
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__)
-#  define LZO_LIBC_GLIBC        (__GLIBC__ * 0x10000L + __GLIBC_MINOR__ * 0x100)
-#  define LZO_INFO_LIBC         "glibc"
-#elif (LZO_CC_MWERKS) && defined(__MSL__)
-#  define LZO_LIBC_MSL          __MSL__
-#  define LZO_INFO_LIBC         "msl"
-#elif 1 && defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_LIBC_ISOC90       1
-#  define LZO_INFO_LIBC         "isoc90"
-#else
-#  define LZO_LIBC_DEFAULT      1
-#  define LZO_INFO_LIBC         "default"
-#endif
-#endif
-#if !defined(__lzo_gnuc_extension__)
-#if (LZO_CC_GNUC >= 0x020800ul)
-#  define __lzo_gnuc_extension__    __extension__
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_gnuc_extension__    __extension__
-#else
-#  define __lzo_gnuc_extension__
-#endif
-#endif
-#if !defined(__lzo_ua_volatile)
-#  define __lzo_ua_volatile     volatile
-#endif
-#if !defined(__lzo_alignof)
-#if (LZO_CC_CILLY || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 700))
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_alignof(e)      __alignof(e)
-#endif
-#endif
-#if defined(__lzo_alignof)
-#  define __lzo_HAVE_alignof 1
-#endif
-#if !defined(__lzo_constructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_constructor     __attribute__((__constructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#endif
-#endif
-#if defined(__lzo_constructor)
-#  define __lzo_HAVE_constructor 1
-#endif
-#if !defined(__lzo_destructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_destructor      __attribute__((__destructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#endif
-#endif
-#if defined(__lzo_destructor)
-#  define __lzo_HAVE_destructor 1
-#endif
-#if defined(__lzo_HAVE_destructor) && !defined(__lzo_HAVE_constructor)
-#  error "this should not happen"
 #endif
 #if !defined(__lzo_inline)
 #if (LZO_CC_TURBOC && (__TURBOC__ <= 0x0295))
 #elif defined(__cplusplus)
 #  define __lzo_inline          inline
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__-0 >= 199901L)
+#  define __lzo_inline          inline
 #elif (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0550))
 #  define __lzo_inline          __inline
-#elif (LZO_CC_CILLY || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
 #  define __lzo_inline          __inline__
 #elif (LZO_CC_DMC)
 #  define __lzo_inline          __inline
+#elif (LZO_CC_GHS)
+#  define __lzo_inline          __inline__
+#elif (LZO_CC_IBMC >= 600)
+#  define __lzo_inline          __inline__
 #elif (LZO_CC_INTELC)
 #  define __lzo_inline          __inline
 #elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x2405))
 #  define __lzo_inline          __inline
 #elif (LZO_CC_MSC && (_MSC_VER >= 900))
 #  define __lzo_inline          __inline
-#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define __lzo_inline          inline
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_inline          __inline__
 #endif
 #endif
 #if defined(__lzo_inline)
+#  ifndef __lzo_HAVE_inline
 #  define __lzo_HAVE_inline 1
+#  endif
 #else
-#  define __lzo_inline
+#  define __lzo_inline          /*empty*/
 #endif
 #if !defined(__lzo_forceinline)
 #if (LZO_CC_GNUC >= 0x030200ul)
 #  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450))
 #  define __lzo_forceinline     __forceinline
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
 #  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
 #  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
 #elif (LZO_CC_MSC && (_MSC_VER >= 1200))
 #  define __lzo_forceinline     __forceinline
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
 #endif
 #endif
 #if defined(__lzo_forceinline)
+#  ifndef __lzo_HAVE_forceinline
 #  define __lzo_HAVE_forceinline 1
+#  endif
 #else
-#  define __lzo_forceinline
+#  define __lzo_forceinline     __lzo_inline
 #endif
 #if !defined(__lzo_noinline)
 #if 1 && (LZO_ARCH_I386) && (LZO_CC_GNUC >= 0x040000ul) && (LZO_CC_GNUC < 0x040003ul)
 #  define __lzo_noinline        __attribute__((__noinline__,__used__))
 #elif (LZO_CC_GNUC >= 0x030200ul)
 #  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_MSC)
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_noinline        __attribute__((__noinline__))
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 600))
 #  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
 #  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
 #  define __lzo_noinline        __attribute__((__noinline__))
 #elif (LZO_CC_MSC && (_MSC_VER >= 1300))
 #  define __lzo_noinline        __declspec(noinline)
@@ -1462,173 +1499,414 @@ extern "C" {
 #  else
 #    define __lzo_noinline      __declspec(noinline)
 #  endif
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_noinline        __attribute__((__noinline__))
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_noinline        __attribute__((__noinline__))
 #endif
 #endif
 #if defined(__lzo_noinline)
+#  ifndef __lzo_HAVE_noinline
 #  define __lzo_HAVE_noinline 1
+#  endif
+#else
+#  define __lzo_noinline        /*empty*/
+#endif
+#if (__lzo_HAVE_forceinline || __lzo_HAVE_noinline) && !(__lzo_HAVE_inline)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if !defined(__lzo_static_inline)
+#if (LZO_CC_IBMC)
+#  define __lzo_static_inline       __lzo_gnuc_extension__ static __lzo_inline
+#endif
+#endif
+#if !defined(__lzo_static_inline)
+#  define __lzo_static_inline       static __lzo_inline
+#endif
+#if !defined(__lzo_static_forceinline)
+#if (LZO_CC_IBMC)
+#  define __lzo_static_forceinline  __lzo_gnuc_extension__ static __lzo_forceinline
+#endif
+#endif
+#if !defined(__lzo_static_forceinline)
+#  define __lzo_static_forceinline  static __lzo_forceinline
+#endif
+#if !defined(__lzo_static_noinline)
+#if (LZO_CC_IBMC)
+#  define __lzo_static_noinline     __lzo_gnuc_extension__ static __lzo_noinline
+#endif
+#endif
+#if !defined(__lzo_static_noinline)
+#  define __lzo_static_noinline     static __lzo_noinline
+#endif
+#if !defined(__lzo_c99_extern_inline)
+#if defined(__GNUC_GNU_INLINE__)
+#  define __lzo_c99_extern_inline   __lzo_inline
+#elif defined(__GNUC_STDC_INLINE__)
+#  define __lzo_c99_extern_inline   extern __lzo_inline
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__-0 >= 199901L)
+#  define __lzo_c99_extern_inline   extern __lzo_inline
+#endif
+#if !defined(__lzo_c99_extern_inline) && (__lzo_HAVE_inline)
+#  define __lzo_c99_extern_inline   __lzo_inline
+#endif
+#endif
+#if defined(__lzo_c99_extern_inline)
+#  ifndef __lzo_HAVE_c99_extern_inline
+#  define __lzo_HAVE_c99_extern_inline 1
+#  endif
 #else
-#  define __lzo_noinline
+#  define __lzo_c99_extern_inline   /*empty*/
 #endif
-#if (defined(__lzo_HAVE_forceinline) || defined(__lzo_HAVE_noinline)) && !defined(__lzo_HAVE_inline)
-#  error "this should not happen"
+#if !defined(__lzo_may_alias)
+#if (LZO_CC_GNUC >= 0x030400ul)
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#elif (LZO_CC_CLANG >= 0x020900ul)
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 1210)) && 0
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#elif (LZO_CC_PGI >= 0x0d0a00ul) && 0
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#endif
+#endif
+#if defined(__lzo_may_alias)
+#  ifndef __lzo_HAVE_may_alias
+#  define __lzo_HAVE_may_alias 1
+#  endif
+#else
+#  define __lzo_may_alias       /*empty*/
 #endif
 #if !defined(__lzo_noreturn)
 #if (LZO_CC_GNUC >= 0x020700ul)
 #  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_noreturn        __attribute__((__noreturn__))
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450))
 #  define __lzo_noreturn        __declspec(noreturn)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 600))
 #  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
 #  define __lzo_noreturn        __attribute__((__noreturn__))
 #elif (LZO_CC_MSC && (_MSC_VER >= 1200))
 #  define __lzo_noreturn        __declspec(noreturn)
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_noreturn        __attribute__((__noreturn__))
 #endif
 #endif
 #if defined(__lzo_noreturn)
+#  ifndef __lzo_HAVE_noreturn
 #  define __lzo_HAVE_noreturn 1
+#  endif
 #else
-#  define __lzo_noreturn
+#  define __lzo_noreturn        /*empty*/
 #endif
 #if !defined(__lzo_nothrow)
 #if (LZO_CC_GNUC >= 0x030300ul)
 #  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC) && defined(__cplusplus)
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450)) && defined(__cplusplus)
 #  define __lzo_nothrow         __declspec(nothrow)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 900))
 #  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
 #  define __lzo_nothrow         __attribute__((__nothrow__))
 #elif (LZO_CC_MSC && (_MSC_VER >= 1200)) && defined(__cplusplus)
 #  define __lzo_nothrow         __declspec(nothrow)
 #endif
 #endif
 #if defined(__lzo_nothrow)
+#  ifndef __lzo_HAVE_nothrow
 #  define __lzo_HAVE_nothrow 1
+#  endif
 #else
-#  define __lzo_nothrow
+#  define __lzo_nothrow         /*empty*/
 #endif
 #if !defined(__lzo_restrict)
 #if (LZO_CC_GNUC >= 0x030400ul)
 #  define __lzo_restrict        __restrict__
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
+#elif (LZO_CC_IBMC >= 800) && !defined(__cplusplus)
 #  define __lzo_restrict        __restrict__
-#elif (LZO_CC_LLVM)
+#elif (LZO_CC_IBMC >= 1210)
+#  define __lzo_restrict        __restrict__
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 600))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 600))
+#  define __lzo_restrict        __restrict__
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM)
 #  define __lzo_restrict        __restrict__
 #elif (LZO_CC_MSC && (_MSC_VER >= 1400))
 #  define __lzo_restrict        __restrict
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_restrict        __restrict__
 #endif
 #endif
 #if defined(__lzo_restrict)
+#  ifndef __lzo_HAVE_restrict
 #  define __lzo_HAVE_restrict 1
+#  endif
 #else
-#  define __lzo_restrict
+#  define __lzo_restrict        /*empty*/
 #endif
-#if !defined(__lzo_likely) && !defined(__lzo_unlikely)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800))
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
+#if !defined(__lzo_alignof)
+#if (LZO_CC_ARMCC || LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+#  define __lzo_alignof(e)      __alignof__(e)
+#elif (LZO_CC_GHS) && !defined(__cplusplus)
+#  define __lzo_alignof(e)      __alignof__(e)
+#elif (LZO_CC_IBMC >= 600)
+#  define __lzo_alignof(e)      (__lzo_gnuc_extension__ __alignof__(e))
+#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 700))
+#  define __lzo_alignof(e)      __alignof__(e)
+#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_alignof(e)      __alignof(e)
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_alignof(e)      __alignof__(e)
+#endif
+#endif
+#if defined(__lzo_alignof)
+#  ifndef __lzo_HAVE_alignof
+#  define __lzo_HAVE_alignof 1
+#  endif
+#endif
+#if !defined(__lzo_struct_packed)
+#if   (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020700ul))
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_PCC && (LZO_CC_PCC < 0x010100ul))
+#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC < 0x5110)) && !defined(__cplusplus)
+#elif (LZO_CC_GNUC >= 0x030400ul) && !(LZO_CC_PCC_GNUC) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+#  define __lzo_struct_packed(s)        struct s {
+#  define __lzo_struct_packed_end()     } __attribute__((__gcc_struct__,__packed__));
+#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__gcc_struct__,__packed__));
+#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || (LZO_CC_PGI >= 0x0d0a00ul) || (LZO_CC_SUNPROC >= 0x5100))
+#  define __lzo_struct_packed(s)        struct s {
+#  define __lzo_struct_packed_end()     } __attribute__((__packed__));
+#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_struct_packed(s)        __lzo_gnuc_extension__ struct s {
+#  define __lzo_struct_packed_end()     } __attribute__((__packed__));
+#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_struct_packed(s)        __pragma(pack(push,1)) struct s {
+#  define __lzo_struct_packed_end()     } __pragma(pack(pop));
+#elif (LZO_CC_WATCOMC && (__WATCOMC__ >= 900))
+#  define __lzo_struct_packed(s)        _Packed struct s {
+#  define __lzo_struct_packed_end()     };
+#endif
+#endif
+#if defined(__lzo_struct_packed) && !defined(__lzo_struct_packed_ma)
+#  define __lzo_struct_packed_ma(s)     __lzo_struct_packed(s)
+#endif
+#if defined(__lzo_struct_packed_end) && !defined(__lzo_struct_packed_ma_end)
+#  define __lzo_struct_packed_ma_end()  __lzo_struct_packed_end()
+#endif
+#if !defined(__lzo_byte_struct)
+#if defined(__lzo_struct_packed)
+#  define __lzo_byte_struct(s,n)        __lzo_struct_packed(s) unsigned char a[n]; __lzo_struct_packed_end()
+#  define __lzo_byte_struct_ma(s,n)     __lzo_struct_packed_ma(s) unsigned char a[n]; __lzo_struct_packed_ma_end()
+#elif (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_PGI || (LZO_CC_SUNPROC >= 0x5100))
+#  define __lzo_byte_struct(s,n)        struct s { unsigned char a[n]; } __attribute__((__packed__));
+#  define __lzo_byte_struct_ma(s,n)     struct s { unsigned char a[n]; } __lzo_may_alias __attribute__((__packed__));
+#endif
+#endif
+#if defined(__lzo_byte_struct) &&  !defined(__lzo_byte_struct_ma)
+#  define __lzo_byte_struct_ma(s,n)     __lzo_byte_struct(s,n)
+#endif
+#if !defined(__lzo_struct_align16) && (__lzo_HAVE_alignof)
+#if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x030000ul))
+#elif (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_CILLY || LZO_CC_PCC)
+#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_struct_align16(s)       struct __declspec(align(16)) s {
+#  define __lzo_struct_align16_end()    };
+#  define __lzo_struct_align32(s)       struct __declspec(align(32)) s {
+#  define __lzo_struct_align32_end()    };
+#  define __lzo_struct_align64(s)       struct __declspec(align(64)) s {
+#  define __lzo_struct_align64_end()    };
+#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || (LZO_CC_IBMC >= 700) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_struct_align16(s)       struct s {
+#  define __lzo_struct_align16_end()    } __attribute__((__aligned__(16)));
+#  define __lzo_struct_align32(s)       struct s {
+#  define __lzo_struct_align32_end()    } __attribute__((__aligned__(32)));
+#  define __lzo_struct_align64(s)       struct s {
+#  define __lzo_struct_align64_end()    } __attribute__((__aligned__(64)));
+#endif
+#endif
+#if !defined(__lzo_union_um)
+#if   (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020700ul))
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER < 810))
+#elif (LZO_CC_PCC && (LZO_CC_PCC < 0x010100ul))
+#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC < 0x5110)) && !defined(__cplusplus)
+#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || (LZO_CC_PGI >= 0x0d0a00ul) || (LZO_CC_SUNPROC >= 0x5100))
+#  define __lzo_union_am(s)             union s {
+#  define __lzo_union_am_end()          } __lzo_may_alias;
+#  define __lzo_union_um(s)             union s {
+#  define __lzo_union_um_end()          } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_union_am(s)             __lzo_gnuc_extension__ union s {
+#  define __lzo_union_am_end()          } __lzo_may_alias;
+#  define __lzo_union_um(s)             __lzo_gnuc_extension__ union s {
+#  define __lzo_union_um_end()          } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_union_um(s)             __pragma(pack(push,1)) union s {
+#  define __lzo_union_um_end()          } __pragma(pack(pop));
+#elif (LZO_CC_WATCOMC && (__WATCOMC__ >= 900))
+#  define __lzo_union_um(s)             _Packed union s {
+#  define __lzo_union_um_end()          };
+#endif
+#endif
+#if !defined(__lzo_union_am)
+#  define __lzo_union_am(s)             union s {
+#  define __lzo_union_am_end()          };
+#endif
+#if !defined(__lzo_constructor)
+#if (LZO_CC_GNUC >= 0x030400ul)
+#  define __lzo_constructor     __attribute__((__constructor__,__used__))
+#elif (LZO_CC_GNUC >= 0x020700ul)
+#  define __lzo_constructor     __attribute__((__constructor__))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
+#  define __lzo_constructor     __attribute__((__constructor__,__used__))
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_constructor     __attribute__((__constructor__))
+#endif
+#endif
+#if defined(__lzo_constructor)
+#  ifndef __lzo_HAVE_constructor
+#  define __lzo_HAVE_constructor 1
+#  endif
+#endif
+#if !defined(__lzo_destructor)
+#if (LZO_CC_GNUC >= 0x030400ul)
+#  define __lzo_destructor      __attribute__((__destructor__,__used__))
+#elif (LZO_CC_GNUC >= 0x020700ul)
+#  define __lzo_destructor      __attribute__((__destructor__))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
+#  define __lzo_destructor      __attribute__((__destructor__,__used__))
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_destructor      __attribute__((__destructor__))
+#endif
+#endif
+#if defined(__lzo_destructor)
+#  ifndef __lzo_HAVE_destructor
+#  define __lzo_HAVE_destructor 1
+#  endif
+#endif
+#if (__lzo_HAVE_destructor) && !(__lzo_HAVE_constructor)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if !defined(__lzo_likely) && !defined(__lzo_unlikely)
+#if (LZO_CC_GNUC >= 0x030200ul)
+#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
+#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
+#elif (LZO_CC_IBMC >= 1010)
+#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
+#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
+#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800))
+#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
 #  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
 #  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
 #  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
 #endif
 #endif
 #if defined(__lzo_likely)
+#  ifndef __lzo_HAVE_likely
 #  define __lzo_HAVE_likely 1
+#  endif
 #else
 #  define __lzo_likely(e)       (e)
 #endif
 #if defined(__lzo_unlikely)
+#  ifndef __lzo_HAVE_unlikely
 #  define __lzo_HAVE_unlikely 1
+#  endif
 #else
 #  define __lzo_unlikely(e)     (e)
 #endif
-#if !defined(LZO_UNUSED)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED(var)         ((void) &var)
-#  elif (LZO_CC_BORLANDC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PELLESC || LZO_CC_TURBOC)
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#    define LZO_UNUSED(var)         ((void) var)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_KEILC)
-#    define LZO_UNUSED(var)         {extern int __lzo_unused[1-2*!(sizeof(var)>0)];}
-#  elif (LZO_CC_PACIFICC)
-#    define LZO_UNUSED(var)         ((void) sizeof(var))
-#  elif (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED(var)         ((void) var)
+#if !defined(__lzo_static_unused_void_func)
+#  if 1 && (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+#    define __lzo_static_unused_void_func(f)    static void __attribute__((__unused__)) f(void)
 #  else
-#    define LZO_UNUSED(var)         ((void) &var)
+#    define __lzo_static_unused_void_func(f)    static __lzo_inline void f(void)
 #  endif
 #endif
-#if !defined(LZO_UNUSED_FUNC)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
-#  elif (LZO_CC_BORLANDC || LZO_CC_NDPC || LZO_CC_TURBOC)
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_LLVM)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_MSC)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_KEILC || LZO_CC_PELLESC)
-#    define LZO_UNUSED_FUNC(func)   {extern int __lzo_unused[1-2*!(sizeof((int)func)>0)];}
+#if !defined(__lzo_loop_forever)
+#  if (LZO_CC_IBMC)
+#    define __lzo_loop_forever()    LZO_BLOCK_BEGIN for (;;) { ; } LZO_BLOCK_END
 #  else
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
+#    define __lzo_loop_forever()    do { ; } while __lzo_cte(1)
 #  endif
 #endif
-#if !defined(LZO_UNUSED_LABEL)
-#  if (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  elif (LZO_CC_INTELC || LZO_CC_WATCOMC)
-#    define LZO_UNUSED_LABEL(l)     if (0) goto l
-#  else
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  endif
+#if !defined(__lzo_unreachable)
+#if (LZO_CC_CLANG && (LZO_CC_CLANG >= 0x020800ul))
+#  define __lzo_unreachable()       __builtin_unreachable();
+#elif (LZO_CC_GNUC >= 0x040500ul)
+#  define __lzo_unreachable()       __builtin_unreachable();
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 1300)) && 1
+#  define __lzo_unreachable()       __builtin_unreachable();
 #endif
-#if !defined(LZO_DEFINE_UNINITIALIZED_VAR)
+#endif
+#if defined(__lzo_unreachable)
+#  ifndef __lzo_HAVE_unreachable
+#  define __lzo_HAVE_unreachable 1
+#  endif
+#else
 #  if 0
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var
-#  elif 0 && (LZO_CC_GNUC)
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = var
+#  define __lzo_unreachable()       ((void)0);
 #  else
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = init
+#  define __lzo_unreachable()       __lzo_loop_forever();
 #  endif
 #endif
+#ifndef __LZO_CTA_NAME
+#if (LZO_CFG_USE_COUNTER)
+#  define __LZO_CTA_NAME(a)         LZO_PP_ECONCAT2(a,__COUNTER__)
+#else
+#  define __LZO_CTA_NAME(a)         LZO_PP_ECONCAT2(a,__LINE__)
+#endif
+#endif
 #if !defined(LZO_COMPILE_TIME_ASSERT_HEADER)
 #  if (LZO_CC_AZTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-!(e)]; LZO_EXTERN_C_END
 #  elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1u-2*!(e)];
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1u-2*!(e)]; LZO_EXTERN_C_END
 #  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-!(e)]; LZO_EXTERN_C_END
+#  elif (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020900ul)) && defined(__cplusplus)
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN int __LZO_CTA_NAME(lzo_cta_f__)(int [1-2*!(e)]); LZO_EXTERN_C_END
+#  elif (LZO_CC_GNUC) && defined(__CHECKER__) && defined(__SPARSE_CHECKER__)
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN enum {__LZO_CTA_NAME(lzo_cta_e__)=1/!!(e)} __attribute__((__unused__)); LZO_EXTERN_C_END
 #  else
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-2*!(e)];
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-2*!(e)]; LZO_EXTERN_C_END
 #  endif
 #endif
 #if !defined(LZO_COMPILE_TIME_ASSERT)
 #  if (LZO_CC_AZTECC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-!(e)];}
+#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-!(e)];}
 #  elif (LZO_CC_DMC || LZO_CC_PACIFICC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
 #    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
+#  elif (LZO_CC_GNUC) && defined(__CHECKER__) && defined(__SPARSE_CHECKER__)
+#    define LZO_COMPILE_TIME_ASSERT(e)  {(void) (0/!!(e));}
+#  elif (LZO_CC_GNUC >= 0x040700ul) && (LZO_CFG_USE_COUNTER) && defined(__cplusplus)
+#    define LZO_COMPILE_TIME_ASSERT(e)  {enum {__LZO_CTA_NAME(lzo_cta_e__)=1/!!(e)} __attribute__((__unused__));}
+#  elif (LZO_CC_GNUC >= 0x040700ul)
+#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-2*!(e)] __attribute__((__unused__));}
 #  elif (LZO_CC_MSC && (_MSC_VER < 900))
 #    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
 #  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
 #    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
 #  else
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-2*!(e)];}
+#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-2*!(e)];}
 #  endif
 #endif
+LZO_COMPILE_TIME_ASSERT_HEADER(1 == 1)
+#if defined(__cplusplus)
+extern "C" { LZO_COMPILE_TIME_ASSERT_HEADER(2 == 2) }
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(3 == 3)
 #if (LZO_ARCH_I086 || LZO_ARCH_I386) && (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
 #  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC)
 #  elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
 #    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit
+#    define __lzo_cdecl_atexit          /*empty*/
 #    define __lzo_cdecl_main            __cdecl
 #    if (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
 #      define __lzo_cdecl_qsort         __pascal
@@ -1669,116 +1947,653 @@ extern "C" {
 #  define __lzo_cdecl                   cdecl
 #endif
 #if !defined(__lzo_cdecl)
-#  define __lzo_cdecl
+#  define __lzo_cdecl                   /*empty*/
 #endif
 #if !defined(__lzo_cdecl_atexit)
-#  define __lzo_cdecl_atexit
+#  define __lzo_cdecl_atexit            /*empty*/
 #endif
 #if !defined(__lzo_cdecl_main)
-#  define __lzo_cdecl_main
+#  define __lzo_cdecl_main              /*empty*/
 #endif
 #if !defined(__lzo_cdecl_qsort)
-#  define __lzo_cdecl_qsort
+#  define __lzo_cdecl_qsort             /*empty*/
+#endif
+#if !defined(__lzo_cdecl_sighandler)
+#  define __lzo_cdecl_sighandler        /*empty*/
+#endif
+#if !defined(__lzo_cdecl_va)
+#  define __lzo_cdecl_va                __lzo_cdecl
+#endif
+#if !(LZO_CFG_NO_WINDOWS_H)
+#if !defined(LZO_HAVE_WINDOWS_H)
+#if (LZO_OS_CYGWIN || (LZO_OS_EMX && defined(__RSXNT__)) || LZO_OS_WIN32 || LZO_OS_WIN64)
+#  if (LZO_CC_WATCOMC && (__WATCOMC__ < 1000))
+#  elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
+#  elif ((LZO_OS_CYGWIN || defined(__MINGW32__)) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x025f00ul)))
+#  else
+#    define LZO_HAVE_WINDOWS_H 1
+#  endif
+#endif
+#endif
+#endif
+#ifndef LZO_SIZEOF_SHORT
+#if defined(SIZEOF_SHORT)
+#  define LZO_SIZEOF_SHORT          (SIZEOF_SHORT)
+#elif defined(__SIZEOF_SHORT__)
+#  define LZO_SIZEOF_SHORT          (__SIZEOF_SHORT__)
+#endif
+#endif
+#ifndef LZO_SIZEOF_INT
+#if defined(SIZEOF_INT)
+#  define LZO_SIZEOF_INT            (SIZEOF_INT)
+#elif defined(__SIZEOF_INT__)
+#  define LZO_SIZEOF_INT            (__SIZEOF_INT__)
+#endif
+#endif
+#ifndef LZO_SIZEOF_LONG
+#if defined(SIZEOF_LONG)
+#  define LZO_SIZEOF_LONG           (SIZEOF_LONG)
+#elif defined(__SIZEOF_LONG__)
+#  define LZO_SIZEOF_LONG           (__SIZEOF_LONG__)
+#endif
+#endif
+#ifndef LZO_SIZEOF_LONG_LONG
+#if defined(SIZEOF_LONG_LONG)
+#  define LZO_SIZEOF_LONG_LONG      (SIZEOF_LONG_LONG)
+#elif defined(__SIZEOF_LONG_LONG__)
+#  define LZO_SIZEOF_LONG_LONG      (__SIZEOF_LONG_LONG__)
+#endif
+#endif
+#ifndef LZO_SIZEOF___INT16
+#if defined(SIZEOF___INT16)
+#  define LZO_SIZEOF___INT16        (SIZEOF___INT16)
+#endif
+#endif
+#ifndef LZO_SIZEOF___INT32
+#if defined(SIZEOF___INT32)
+#  define LZO_SIZEOF___INT32        (SIZEOF___INT32)
+#endif
+#endif
+#ifndef LZO_SIZEOF___INT64
+#if defined(SIZEOF___INT64)
+#  define LZO_SIZEOF___INT64        (SIZEOF___INT64)
+#endif
+#endif
+#ifndef LZO_SIZEOF_VOID_P
+#if defined(SIZEOF_VOID_P)
+#  define LZO_SIZEOF_VOID_P         (SIZEOF_VOID_P)
+#elif defined(__SIZEOF_POINTER__)
+#  define LZO_SIZEOF_VOID_P         (__SIZEOF_POINTER__)
+#endif
+#endif
+#ifndef LZO_SIZEOF_SIZE_T
+#if defined(SIZEOF_SIZE_T)
+#  define LZO_SIZEOF_SIZE_T         (SIZEOF_SIZE_T)
+#elif defined(__SIZEOF_SIZE_T__)
+#  define LZO_SIZEOF_SIZE_T         (__SIZEOF_SIZE_T__)
+#endif
+#endif
+#ifndef LZO_SIZEOF_PTRDIFF_T
+#if defined(SIZEOF_PTRDIFF_T)
+#  define LZO_SIZEOF_PTRDIFF_T      (SIZEOF_PTRDIFF_T)
+#elif defined(__SIZEOF_PTRDIFF_T__)
+#  define LZO_SIZEOF_PTRDIFF_T      (__SIZEOF_PTRDIFF_T__)
+#endif
+#endif
+#define __LZO_LSR(x,b)    (((x)+0ul) >> (b))
+#if !defined(LZO_SIZEOF_SHORT)
+#  if (LZO_ARCH_CRAY_PVP)
+#    define LZO_SIZEOF_SHORT        8
+#  elif (USHRT_MAX == LZO_0xffffL)
+#    define LZO_SIZEOF_SHORT        2
+#  elif (__LZO_LSR(USHRT_MAX,7) == 1)
+#    define LZO_SIZEOF_SHORT        1
+#  elif (__LZO_LSR(USHRT_MAX,15) == 1)
+#    define LZO_SIZEOF_SHORT        2
+#  elif (__LZO_LSR(USHRT_MAX,31) == 1)
+#    define LZO_SIZEOF_SHORT        4
+#  elif (__LZO_LSR(USHRT_MAX,63) == 1)
+#    define LZO_SIZEOF_SHORT        8
+#  elif (__LZO_LSR(USHRT_MAX,127) == 1)
+#    define LZO_SIZEOF_SHORT        16
+#  else
+#    error "LZO_SIZEOF_SHORT"
+#  endif
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_SHORT == sizeof(short))
+#if !defined(LZO_SIZEOF_INT)
+#  if (LZO_ARCH_CRAY_PVP)
+#    define LZO_SIZEOF_INT          8
+#  elif (UINT_MAX == LZO_0xffffL)
+#    define LZO_SIZEOF_INT          2
+#  elif (UINT_MAX == LZO_0xffffffffL)
+#    define LZO_SIZEOF_INT          4
+#  elif (__LZO_LSR(UINT_MAX,7) == 1)
+#    define LZO_SIZEOF_INT          1
+#  elif (__LZO_LSR(UINT_MAX,15) == 1)
+#    define LZO_SIZEOF_INT          2
+#  elif (__LZO_LSR(UINT_MAX,31) == 1)
+#    define LZO_SIZEOF_INT          4
+#  elif (__LZO_LSR(UINT_MAX,63) == 1)
+#    define LZO_SIZEOF_INT          8
+#  elif (__LZO_LSR(UINT_MAX,127) == 1)
+#    define LZO_SIZEOF_INT          16
+#  else
+#    error "LZO_SIZEOF_INT"
+#  endif
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_INT == sizeof(int))
+#if !defined(LZO_SIZEOF_LONG)
+#  if (ULONG_MAX == LZO_0xffffffffL)
+#    define LZO_SIZEOF_LONG         4
+#  elif (__LZO_LSR(ULONG_MAX,7) == 1)
+#    define LZO_SIZEOF_LONG         1
+#  elif (__LZO_LSR(ULONG_MAX,15) == 1)
+#    define LZO_SIZEOF_LONG         2
+#  elif (__LZO_LSR(ULONG_MAX,31) == 1)
+#    define LZO_SIZEOF_LONG         4
+#  elif (__LZO_LSR(ULONG_MAX,39) == 1)
+#    define LZO_SIZEOF_LONG         5
+#  elif (__LZO_LSR(ULONG_MAX,63) == 1)
+#    define LZO_SIZEOF_LONG         8
+#  elif (__LZO_LSR(ULONG_MAX,127) == 1)
+#    define LZO_SIZEOF_LONG         16
+#  else
+#    error "LZO_SIZEOF_LONG"
+#  endif
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_LONG == sizeof(long))
+#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
+#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
+#  if defined(__LONG_MAX__) && defined(__LONG_LONG_MAX__)
+#    if (LZO_CC_GNUC >= 0x030300ul)
+#      if ((__LONG_MAX__-0) == (__LONG_LONG_MAX__-0))
+#        define LZO_SIZEOF_LONG_LONG      LZO_SIZEOF_LONG
+#      elif (__LZO_LSR(__LONG_LONG_MAX__,30) == 1)
+#        define LZO_SIZEOF_LONG_LONG      4
+#      endif
+#    endif
+#  endif
+#endif
+#endif
+#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
+#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
+#if (LZO_ARCH_I086 && LZO_CC_DMC)
+#elif (LZO_CC_CILLY) && defined(__GNUC__)
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif ((LZO_OS_WIN32 || LZO_OS_WIN64 || defined(_WIN32)) && LZO_CC_MSC && (_MSC_VER >= 1400))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_OS_WIN64 || defined(_WIN64))
+#  define LZO_SIZEOF___INT64        8
+#elif (LZO_ARCH_I386 && (LZO_CC_DMC))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_ARCH_I386 && (LZO_CC_SYMANTECC && (__SC__ >= 0x700)))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_ARCH_I386 && (LZO_CC_INTELC && defined(__linux__)))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_ARCH_I386 && (LZO_CC_MWERKS || LZO_CC_PELLESC || LZO_CC_PGI || LZO_CC_SUNPROC))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_ARCH_I386 && (LZO_CC_INTELC || LZO_CC_MSC))
+#  define LZO_SIZEOF___INT64        8
+#elif ((LZO_OS_WIN32 || defined(_WIN32)) && (LZO_CC_MSC))
+#  define LZO_SIZEOF___INT64        8
+#elif (LZO_ARCH_I386 && (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0520)))
+#  define LZO_SIZEOF___INT64        8
+#elif (LZO_ARCH_I386 && (LZO_CC_WATCOMC && (__WATCOMC__ >= 1100)))
+#  define LZO_SIZEOF___INT64        8
+#elif (LZO_CC_GHS && defined(__LLONG_BIT) && ((__LLONG_BIT-0) == 64))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_CC_WATCOMC && defined(_INTEGRAL_MAX_BITS) && ((_INTEGRAL_MAX_BITS-0) == 64))
+#  define LZO_SIZEOF___INT64        8
+#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (defined(__vms) || defined(__VMS)) && ((__INITIAL_POINTER_SIZE-0) == 64)
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_CC_SDCC) && (LZO_SIZEOF_INT == 2)
+#elif 1 && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
+#  define LZO_SIZEOF_LONG_LONG      8
+#endif
+#endif
+#endif
+#if defined(__cplusplus) && (LZO_CC_GNUC)
+#  if (LZO_CC_GNUC < 0x020800ul)
+#    undef LZO_SIZEOF_LONG_LONG
+#  endif
+#endif
+#if (LZO_CFG_NO_LONG_LONG)
+#  undef LZO_SIZEOF_LONG_LONG
+#elif defined(__NO_LONG_LONG)
+#  undef LZO_SIZEOF_LONG_LONG
+#elif defined(_NO_LONGLONG)
+#  undef LZO_SIZEOF_LONG_LONG
+#endif
+#if !defined(LZO_WORDSIZE)
+#if (LZO_ARCH_ALPHA)
+#  define LZO_WORDSIZE              8
+#elif (LZO_ARCH_AMD64)
+#  define LZO_WORDSIZE              8
+#elif (LZO_ARCH_AVR)
+#  define LZO_WORDSIZE              1
+#elif (LZO_ARCH_H8300)
+#  if defined(__NORMAL_MODE__)
+#    define LZO_WORDSIZE            4
+#  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
+#    define LZO_WORDSIZE            4
+#  else
+#    define LZO_WORDSIZE            2
+#  endif
+#elif (LZO_ARCH_I086)
+#  define LZO_WORDSIZE              2
+#elif (LZO_ARCH_IA64)
+#  define LZO_WORDSIZE              8
+#elif (LZO_ARCH_M16C)
+#  define LZO_WORDSIZE              2
+#elif (LZO_ARCH_SPU)
+#  define LZO_WORDSIZE              4
+#elif (LZO_ARCH_Z80)
+#  define LZO_WORDSIZE              1
+#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
+#  define LZO_WORDSIZE              8
+#elif (LZO_OS_OS400 || defined(__OS400__))
+#  define LZO_WORDSIZE              8
+#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
+#  define LZO_WORDSIZE              8
+#endif
+#endif
+#if !defined(LZO_SIZEOF_VOID_P)
+#if defined(__ILP32__) || defined(__ILP32) || defined(_ILP32)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(int)  == 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 4)
+#  define LZO_SIZEOF_VOID_P         4
+#elif defined(__ILP64__) || defined(__ILP64) || defined(_ILP64)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(int)  == 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 8)
+#  define LZO_SIZEOF_VOID_P         8
+#elif defined(__LLP64__) || defined(__LLP64) || defined(_LLP64) || defined(_WIN64)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 4)
+#  define LZO_SIZEOF_VOID_P         8
+#elif defined(__LP64__) || defined(__LP64) || defined(_LP64)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 8)
+#  define LZO_SIZEOF_VOID_P         8
+#elif (LZO_ARCH_AVR)
+#  define LZO_SIZEOF_VOID_P         2
+#elif (LZO_ARCH_C166 || LZO_ARCH_MCS51 || LZO_ARCH_MCS251 || LZO_ARCH_MSP430)
+#  define LZO_SIZEOF_VOID_P         2
+#elif (LZO_ARCH_H8300)
+#  if defined(__NORMAL_MODE__)
+#    define LZO_SIZEOF_VOID_P       2
+#  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
+#    define LZO_SIZEOF_VOID_P       4
+#  else
+#    define LZO_SIZEOF_VOID_P       2
+#  endif
+#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_SIZEOF_INT == 4)
+#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_INT
+#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_INT
+#  endif
+#elif (LZO_ARCH_I086)
+#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
+#    define LZO_SIZEOF_VOID_P       2
+#  elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
+#    define LZO_SIZEOF_VOID_P       4
+#  else
+#    error "invalid LZO_ARCH_I086 memory model"
+#  endif
+#elif (LZO_ARCH_M16C)
+#  if defined(__m32c_cpu__) || defined(__m32cm_cpu__)
+#    define LZO_SIZEOF_VOID_P       4
+#  else
+#    define LZO_SIZEOF_VOID_P       2
+#  endif
+#elif (LZO_ARCH_SPU)
+#  define LZO_SIZEOF_VOID_P         4
+#elif (LZO_ARCH_Z80)
+#  define LZO_SIZEOF_VOID_P         2
+#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
+#  define LZO_SIZEOF_VOID_P         4
+#elif (LZO_OS_OS400 || defined(__OS400__))
+#  if defined(__LLP64_IFC__)
+#    define LZO_SIZEOF_VOID_P       8
+#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_LONG
+#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_LONG
+#  else
+#    define LZO_SIZEOF_VOID_P       16
+#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_LONG
+#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_LONG
+#  endif
+#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
+#  define LZO_SIZEOF_VOID_P         8
+#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
+#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
+#endif
+#endif
+#if !defined(LZO_SIZEOF_VOID_P)
+#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_VOID_P == sizeof(void *))
+#if !defined(LZO_SIZEOF_SIZE_T)
+#if (LZO_ARCH_I086 || LZO_ARCH_M16C)
+#  define LZO_SIZEOF_SIZE_T         2
+#endif
+#endif
+#if !defined(LZO_SIZEOF_SIZE_T)
+#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_VOID_P
+#endif
+#if defined(offsetof)
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_SIZE_T == sizeof(size_t))
+#endif
+#if !defined(LZO_SIZEOF_PTRDIFF_T)
+#if (LZO_ARCH_I086)
+#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM || LZO_MM_HUGE)
+#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_VOID_P
+#  elif (LZO_MM_COMPACT || LZO_MM_LARGE)
+#    if (LZO_CC_BORLANDC || LZO_CC_TURBOC)
+#      define LZO_SIZEOF_PTRDIFF_T  4
+#    else
+#      define LZO_SIZEOF_PTRDIFF_T  2
+#    endif
+#  else
+#    error "invalid LZO_ARCH_I086 memory model"
+#  endif
+#endif
+#endif
+#if !defined(LZO_SIZEOF_PTRDIFF_T)
+#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_SIZE_T
+#endif
+#if defined(offsetof)
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_PTRDIFF_T == sizeof(ptrdiff_t))
+#endif
+#if !defined(LZO_WORDSIZE)
+#  define LZO_WORDSIZE              LZO_SIZEOF_VOID_P
+#endif
+#if (LZO_ABI_NEUTRAL_ENDIAN)
+#  undef LZO_ABI_BIG_ENDIAN
+#  undef LZO_ABI_LITTLE_ENDIAN
+#elif !(LZO_ABI_BIG_ENDIAN) && !(LZO_ABI_LITTLE_ENDIAN)
+#if (LZO_ARCH_ALPHA) && (LZO_ARCH_CRAY_MPP)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif (LZO_ARCH_IA64) && (LZO_OS_POSIX_LINUX || LZO_OS_WIN64)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif (LZO_ARCH_ALPHA || LZO_ARCH_AMD64 || LZO_ARCH_BLACKFIN || LZO_ARCH_CRIS || LZO_ARCH_I086 || LZO_ARCH_I386 || LZO_ARCH_MSP430)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif (LZO_ARCH_AVR32 || LZO_ARCH_M68K || LZO_ARCH_S390 || LZO_ARCH_SPU)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif 1 && defined(__IAR_SYSTEMS_ICC__) && defined(__LITTLE_ENDIAN__)
+#  if (__LITTLE_ENDIAN__ == 1)
+#    define LZO_ABI_LITTLE_ENDIAN   1
+#  else
+#    define LZO_ABI_BIG_ENDIAN      1
+#  endif
+#elif 1 && defined(__BIG_ENDIAN__) && !defined(__LITTLE_ENDIAN__)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif 1 && defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEB__) && !defined(__ARMEL__)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEL__) && !defined(__ARMEB__)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif 1 && (LZO_ARCH_ARM && LZO_CC_ARMCC_ARMCC)
+#  if defined(__BIG_ENDIAN) && defined(__LITTLE_ENDIAN)
+#    error "unexpected configuration - check your compiler defines"
+#  elif defined(__BIG_ENDIAN)
+#    define LZO_ABI_BIG_ENDIAN      1
+#  else
+#    define LZO_ABI_LITTLE_ENDIAN   1
+#  endif
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif 1 && (LZO_ARCH_ARM64) && defined(__AARCH64EB__) && !defined(__AARCH64EL__)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif 1 && (LZO_ARCH_ARM64) && defined(__AARCH64EL__) && !defined(__AARCH64EB__)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEB__) && !defined(__MIPSEL__)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEL__) && !defined(__MIPSEB__)
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#endif
+#endif
+#if (LZO_ABI_BIG_ENDIAN) && (LZO_ABI_LITTLE_ENDIAN)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ABI_BIG_ENDIAN)
+#  define LZO_INFO_ABI_ENDIAN       "be"
+#elif (LZO_ABI_LITTLE_ENDIAN)
+#  define LZO_INFO_ABI_ENDIAN       "le"
+#elif (LZO_ABI_NEUTRAL_ENDIAN)
+#  define LZO_INFO_ABI_ENDIAN       "neutral"
+#endif
+#if (LZO_SIZEOF_INT == 1 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
+#  define LZO_ABI_I8LP16         1
+#  define LZO_INFO_ABI_PM       "i8lp16"
+#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
+#  define LZO_ABI_ILP16         1
+#  define LZO_INFO_ABI_PM       "ilp16"
+#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
+#  define LZO_ABI_LP32          1
+#  define LZO_INFO_ABI_PM       "lp32"
+#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
+#  define LZO_ABI_ILP32         1
+#  define LZO_INFO_ABI_PM       "ilp32"
+#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 8 && LZO_SIZEOF_SIZE_T == 8)
+#  define LZO_ABI_LLP64         1
+#  define LZO_INFO_ABI_PM       "llp64"
+#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
+#  define LZO_ABI_LP64          1
+#  define LZO_INFO_ABI_PM       "lp64"
+#elif (LZO_SIZEOF_INT == 8 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
+#  define LZO_ABI_ILP64         1
+#  define LZO_INFO_ABI_PM       "ilp64"
+#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 4)
+#  define LZO_ABI_IP32L64       1
+#  define LZO_INFO_ABI_PM       "ip32l64"
+#endif
+#if 0
+#elif !defined(__LZO_LIBC_OVERRIDE)
+#if (LZO_LIBC_NAKED)
+#  define LZO_INFO_LIBC         "naked"
+#elif (LZO_LIBC_FREESTANDING)
+#  define LZO_INFO_LIBC         "freestanding"
+#elif (LZO_LIBC_MOSTLY_FREESTANDING)
+#  define LZO_INFO_LIBC         "mfreestanding"
+#elif (LZO_LIBC_ISOC90)
+#  define LZO_INFO_LIBC         "isoc90"
+#elif (LZO_LIBC_ISOC99)
+#  define LZO_INFO_LIBC         "isoc99"
+#elif (LZO_CC_ARMCC_ARMCC) && defined(__ARMCLIB_VERSION)
+#  define LZO_LIBC_ISOC90       1
+#  define LZO_INFO_LIBC         "isoc90"
+#elif defined(__dietlibc__)
+#  define LZO_LIBC_DIETLIBC     1
+#  define LZO_INFO_LIBC         "dietlibc"
+#elif defined(_NEWLIB_VERSION)
+#  define LZO_LIBC_NEWLIB       1
+#  define LZO_INFO_LIBC         "newlib"
+#elif defined(__UCLIBC__) && defined(__UCLIBC_MAJOR__) && defined(__UCLIBC_MINOR__)
+#  if defined(__UCLIBC_SUBLEVEL__)
+#    define LZO_LIBC_UCLIBC     (__UCLIBC_MAJOR__ * 0x10000L + (__UCLIBC_MINOR__-0) * 0x100 + (__UCLIBC_SUBLEVEL__-0))
+#  else
+#    define LZO_LIBC_UCLIBC     0x00090bL
+#  endif
+#  define LZO_INFO_LIBC         "uc" "libc"
+#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__)
+#  define LZO_LIBC_GLIBC        (__GLIBC__ * 0x10000L + (__GLIBC_MINOR__-0) * 0x100)
+#  define LZO_INFO_LIBC         "glibc"
+#elif (LZO_CC_MWERKS) && defined(__MSL__)
+#  define LZO_LIBC_MSL          __MSL__
+#  define LZO_INFO_LIBC         "msl"
+#elif 1 && defined(__IAR_SYSTEMS_ICC__)
+#  define LZO_LIBC_ISOC90       1
+#  define LZO_INFO_LIBC         "isoc90"
+#else
+#  define LZO_LIBC_DEFAULT      1
+#  define LZO_INFO_LIBC         "default"
 #endif
-#if !defined(__lzo_cdecl_sighandler)
-#  define __lzo_cdecl_sighandler
 #endif
-#if !defined(__lzo_cdecl_va)
-#  define __lzo_cdecl_va                __lzo_cdecl
+#if (LZO_ARCH_I386 && (LZO_OS_DOS32 || LZO_OS_WIN32) && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
+#  define LZO_ASM_SYNTAX_MSC 1
+#elif (LZO_OS_WIN64 && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
+#elif (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC == 0x011f00ul))
+#elif (LZO_ARCH_I386 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
+#  define LZO_ASM_SYNTAX_GNUC 1
+#elif (LZO_ARCH_AMD64 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
+#  define LZO_ASM_SYNTAX_GNUC 1
+#elif (LZO_CC_GNUC)
+#  define LZO_ASM_SYNTAX_GNUC 1
 #endif
-#if !defined(LZO_CFG_NO_WINDOWS_H)
-#if (LZO_OS_CYGWIN || (LZO_OS_EMX && defined(__RSXNT__)) || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (LZO_CC_WATCOMC && (__WATCOMC__ < 1000))
-#  elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
-#  elif ((LZO_OS_CYGWIN || defined(__MINGW32__)) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x025f00ul)))
-#  else
-#    define LZO_HAVE_WINDOWS_H 1
-#  endif
+#if (LZO_ASM_SYNTAX_GNUC)
+#if (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
+#  define __LZO_ASM_CLOBBER                     "ax"
+#  define __LZO_ASM_CLOBBER_LIST_CC             /*empty*/
+#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      /*empty*/
+#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
+#elif (LZO_CC_INTELC && (__INTEL_COMPILER < 1000))
+#  define __LZO_ASM_CLOBBER                     "memory"
+#  define __LZO_ASM_CLOBBER_LIST_CC             /*empty*/
+#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      : "memory"
+#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
+#else
+#  define __LZO_ASM_CLOBBER                     "cc", "memory"
+#  define __LZO_ASM_CLOBBER_LIST_CC             : "cc"
+#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      : "cc", "memory"
+#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
 #endif
 #endif
 #if (LZO_ARCH_ALPHA)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
+#  define LZO_OPT_AVOID_UINT_INDEX          1
 #elif (LZO_ARCH_AMD64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  define LZO_OPT_UNALIGNED64       1
-#elif (LZO_ARCH_ARM && LZO_ARCH_ARM_THUMB)
+#  define LZO_OPT_AVOID_INT_INDEX           1
+#  define LZO_OPT_AVOID_UINT_INDEX          1
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED64
+#  define LZO_OPT_UNALIGNED64               1
+#  endif
 #elif (LZO_ARCH_ARM)
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
+#  if defined(__ARM_FEATURE_UNALIGNED)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#  elif defined(__TARGET_ARCH_ARM) && ((__TARGET_ARCH_ARM+0) >= 7)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#  elif defined(__TARGET_ARCH_ARM) && ((__TARGET_ARCH_ARM+0) >= 6) && !defined(__TARGET_PROFILE_M)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#  endif
+#elif (LZO_ARCH_ARM64)
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED64
+#  define LZO_OPT_UNALIGNED64               1
+#  endif
 #elif (LZO_ARCH_CRIS)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
 #elif (LZO_ARCH_I386)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
 #elif (LZO_ARCH_IA64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_PREFER_POSTINC    1
+#  define LZO_OPT_AVOID_INT_INDEX           1
+#  define LZO_OPT_AVOID_UINT_INDEX          1
+#  define LZO_OPT_PREFER_POSTINC            1
 #elif (LZO_ARCH_M68K)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
+#  define LZO_OPT_PREFER_POSTINC            1
+#  define LZO_OPT_PREFER_PREDEC             1
 #  if defined(__mc68020__) && !defined(__mcoldfire__)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
 #  endif
 #elif (LZO_ARCH_MIPS)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
+#  define LZO_OPT_AVOID_UINT_INDEX          1
 #elif (LZO_ARCH_POWERPC)
-#  define LZO_OPT_PREFER_PREINC     1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if defined(LZO_ABI_BIG_ENDIAN)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
+#  define LZO_OPT_PREFER_PREINC             1
+#  define LZO_OPT_PREFER_PREDEC             1
+#  if (LZO_ABI_BIG_ENDIAN)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#    if (LZO_WORDSIZE == 8)
+#      ifndef LZO_OPT_UNALIGNED64
+#      define LZO_OPT_UNALIGNED64           1
+#      endif
+#    endif
 #  endif
 #elif (LZO_ARCH_S390)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  if (LZO_SIZEOF_SIZE_T == 8)
-#    define LZO_OPT_UNALIGNED64     1
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
+#  if (LZO_WORDSIZE == 8)
+#    ifndef LZO_OPT_UNALIGNED64
+#    define LZO_OPT_UNALIGNED64             1
+#    endif
 #  endif
 #elif (LZO_ARCH_SH)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
+#  define LZO_OPT_PREFER_POSTINC            1
+#  define LZO_OPT_PREFER_PREDEC             1
 #endif
-#if !defined(LZO_CFG_NO_INLINE_ASM)
-#if defined(LZO_CC_LLVM)
+#ifndef LZO_CFG_NO_INLINE_ASM
+#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
+#  define LZO_CFG_NO_INLINE_ASM 1
+#elif (LZO_CC_LLVM)
 #  define LZO_CFG_NO_INLINE_ASM 1
 #endif
 #endif
-#if !defined(LZO_CFG_NO_UNALIGNED)
-#if defined(LZO_ABI_NEUTRAL_ENDIAN) || defined(LZO_ARCH_GENERIC)
+#if (LZO_CFG_NO_INLINE_ASM)
+#  undef LZO_ASM_SYNTAX_MSC
+#  undef LZO_ASM_SYNTAX_GNUC
+#  undef __LZO_ASM_CLOBBER
+#  undef __LZO_ASM_CLOBBER_LIST_CC
+#  undef __LZO_ASM_CLOBBER_LIST_CC_MEMORY
+#  undef __LZO_ASM_CLOBBER_LIST_EMPTY
+#endif
+#ifndef LZO_CFG_NO_UNALIGNED
+#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
 #  define LZO_CFG_NO_UNALIGNED 1
 #endif
 #endif
-#if defined(LZO_CFG_NO_UNALIGNED)
+#if (LZO_CFG_NO_UNALIGNED)
 #  undef LZO_OPT_UNALIGNED16
 #  undef LZO_OPT_UNALIGNED32
 #  undef LZO_OPT_UNALIGNED64
 #endif
-#if defined(LZO_CFG_NO_INLINE_ASM)
-#elif (LZO_ARCH_I386 && (LZO_OS_DOS32 || LZO_OS_WIN32) && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#  define LZO_ASM_SYNTAX_MSC 1
-#elif (LZO_OS_WIN64 && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#elif (LZO_ARCH_I386 && (LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#elif (LZO_ARCH_AMD64 && (LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#endif
-#if (LZO_ASM_SYNTAX_GNUC)
-#if (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
-#  define __LZO_ASM_CLOBBER         "ax"
-#elif (LZO_CC_INTELC)
-#  define __LZO_ASM_CLOBBER         "memory"
-#else
-#  define __LZO_ASM_CLOBBER         "cc", "memory"
-#endif
-#endif
 #if defined(__LZO_INFOSTR_MM)
 #elif (LZO_MM_FLAT) && (defined(__LZO_INFOSTR_PM) || defined(LZO_INFO_ABI_PM))
 #  define __LZO_INFOSTR_MM          ""
@@ -1822,6 +2637,381 @@ extern "C" {
 #define LZO_INFO_STRING \
     LZO_INFO_ARCH __LZO_INFOSTR_MM __LZO_INFOSTR_PM __LZO_INFOSTR_ENDIAN \
     " " __LZO_INFOSTR_OSNAME __LZO_INFOSTR_LIBC " " LZO_INFO_CC __LZO_INFOSTR_CCVER
+#if !(LZO_CFG_SKIP_LZO_TYPES)
+#if (!(LZO_SIZEOF_SHORT+0 > 0 && LZO_SIZEOF_INT+0 > 0 && LZO_SIZEOF_LONG+0 > 0))
+#  error "missing defines for sizes"
+#endif
+#if (!(LZO_SIZEOF_PTRDIFF_T+0 > 0 && LZO_SIZEOF_SIZE_T+0 > 0 && LZO_SIZEOF_VOID_P+0 > 0))
+#  error "missing defines for sizes"
+#endif
+#if !defined(lzo_llong_t)
+#if (LZO_SIZEOF_LONG_LONG+0 > 0)
+__lzo_gnuc_extension__ typedef long long lzo_llong_t__;
+__lzo_gnuc_extension__ typedef unsigned long long lzo_ullong_t__;
+#  define lzo_llong_t               lzo_llong_t__
+#  define lzo_ullong_t              lzo_ullong_t__
+#endif
+#endif
+#if !defined(lzo_int16e_t)
+#if (LZO_SIZEOF_LONG == 2)
+#  define lzo_int16e_t              long
+#  define lzo_uint16e_t             unsigned long
+#elif (LZO_SIZEOF_INT == 2)
+#  define lzo_int16e_t              int
+#  define lzo_uint16e_t             unsigned int
+#elif (LZO_SIZEOF_SHORT == 2)
+#  define lzo_int16e_t              short int
+#  define lzo_uint16e_t             unsigned short int
+#elif 1 && !(LZO_CFG_TYPE_NO_MODE_HI) && (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x025f00ul) || LZO_CC_LLVM)
+   typedef int lzo_int16e_hi_t__ __attribute__((__mode__(__HI__)));
+   typedef unsigned int lzo_uint16e_hi_t__ __attribute__((__mode__(__HI__)));
+#  define lzo_int16e_t              lzo_int16e_hi_t__
+#  define lzo_uint16e_t             lzo_uint16e_hi_t__
+#elif (LZO_SIZEOF___INT16 == 2)
+#  define lzo_int16e_t              __int16
+#  define lzo_uint16e_t             unsigned __int16
+#else
+#endif
+#endif
+#if defined(lzo_int16e_t)
+#  define LZO_SIZEOF_LZO_INT16E_T   2
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16e_t) == 2)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16e_t) == LZO_SIZEOF_LZO_INT16E_T)
+#endif
+#if !defined(lzo_int32e_t)
+#if (LZO_SIZEOF_LONG == 4)
+#  define lzo_int32e_t              long int
+#  define lzo_uint32e_t             unsigned long int
+#elif (LZO_SIZEOF_INT == 4)
+#  define lzo_int32e_t              int
+#  define lzo_uint32e_t             unsigned int
+#elif (LZO_SIZEOF_SHORT == 4)
+#  define lzo_int32e_t              short int
+#  define lzo_uint32e_t             unsigned short int
+#elif (LZO_SIZEOF_LONG_LONG == 4)
+#  define lzo_int32e_t              lzo_llong_t
+#  define lzo_uint32e_t             lzo_ullong_t
+#elif 1 && !(LZO_CFG_TYPE_NO_MODE_SI) && (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x025f00ul) || LZO_CC_LLVM) && (__INT_MAX__+0 > 2147483647L)
+   typedef int lzo_int32e_si_t__ __attribute__((__mode__(__SI__)));
+   typedef unsigned int lzo_uint32e_si_t__ __attribute__((__mode__(__SI__)));
+#  define lzo_int32e_t              lzo_int32e_si_t__
+#  define lzo_uint32e_t             lzo_uint32e_si_t__
+#elif 1 && !(LZO_CFG_TYPE_NO_MODE_SI) && (LZO_CC_GNUC >= 0x025f00ul) && defined(__AVR__) && (__LONG_MAX__+0 == 32767L)
+   typedef int lzo_int32e_si_t__ __attribute__((__mode__(__SI__)));
+   typedef unsigned int lzo_uint32e_si_t__ __attribute__((__mode__(__SI__)));
+#  define lzo_int32e_t              lzo_int32e_si_t__
+#  define lzo_uint32e_t             lzo_uint32e_si_t__
+#  define LZO_INT32_C(c)            (c##LL)
+#  define LZO_UINT32_C(c)           (c##ULL)
+#elif (LZO_SIZEOF___INT32 == 4)
+#  define lzo_int32e_t              __int32
+#  define lzo_uint32e_t             unsigned __int32
+#else
+#endif
+#endif
+#if defined(lzo_int32e_t)
+#  define LZO_SIZEOF_LZO_INT32E_T   4
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32e_t) == 4)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32e_t) == LZO_SIZEOF_LZO_INT32E_T)
+#endif
+#if !defined(lzo_int64e_t)
+#if (LZO_SIZEOF___INT64 == 8)
+#  if (LZO_CC_BORLANDC) && !(LZO_CFG_TYPE_PREFER___INT64)
+#    define LZO_CFG_TYPE_PREFER___INT64 1
+#  endif
+#endif
+#if (LZO_SIZEOF_INT == 8) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
+#  define lzo_int64e_t              int
+#  define lzo_uint64e_t             unsigned int
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_LONG == 8)
+#  define lzo_int64e_t              long int
+#  define lzo_uint64e_t             unsigned long int
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF_LONG
+#elif (LZO_SIZEOF_LONG_LONG == 8) && !(LZO_CFG_TYPE_PREFER___INT64)
+#  define lzo_int64e_t              lzo_llong_t
+#  define lzo_uint64e_t             lzo_ullong_t
+#  if (LZO_CC_BORLANDC)
+#    define LZO_INT64_C(c)          ((c) + 0ll)
+#    define LZO_UINT64_C(c)         ((c) + 0ull)
+#  elif 0
+#    define LZO_INT64_C(c)          (__lzo_gnuc_extension__ (c##LL))
+#    define LZO_UINT64_C(c)         (__lzo_gnuc_extension__ (c##ULL))
+#  else
+#    define LZO_INT64_C(c)          (c##LL)
+#    define LZO_UINT64_C(c)         (c##ULL)
+#  endif
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF_LONG_LONG
+#elif (LZO_SIZEOF___INT64 == 8)
+#  define lzo_int64e_t              __int64
+#  define lzo_uint64e_t             unsigned __int64
+#  if (LZO_CC_BORLANDC)
+#    define LZO_INT64_C(c)          ((c) + 0i64)
+#    define LZO_UINT64_C(c)         ((c) + 0ui64)
+#  else
+#    define LZO_INT64_C(c)          (c##i64)
+#    define LZO_UINT64_C(c)         (c##ui64)
+#  endif
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF___INT64
+#else
+#endif
+#endif
+#if defined(lzo_int64e_t)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64e_t) == 8)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64e_t) == LZO_SIZEOF_LZO_INT64E_T)
+#endif
+#if !defined(lzo_int32l_t)
+#if defined(lzo_int32e_t)
+#  define lzo_int32l_t              lzo_int32e_t
+#  define lzo_uint32l_t             lzo_uint32e_t
+#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_LZO_INT32E_T
+#elif (LZO_SIZEOF_INT >= 4) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
+#  define lzo_int32l_t              int
+#  define lzo_uint32l_t             unsigned int
+#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_LONG >= 4)
+#  define lzo_int32l_t              long int
+#  define lzo_uint32l_t             unsigned long int
+#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_LONG
+#else
+#  error "lzo_int32l_t"
+#endif
+#endif
+#if 1
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32l_t) >= 4)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32l_t) == LZO_SIZEOF_LZO_INT32L_T)
+#endif
+#if !defined(lzo_int64l_t)
+#if defined(lzo_int64e_t)
+#  define lzo_int64l_t              lzo_int64e_t
+#  define lzo_uint64l_t             lzo_uint64e_t
+#  define LZO_SIZEOF_LZO_INT64L_T   LZO_SIZEOF_LZO_INT64E_T
+#else
+#endif
+#endif
+#if defined(lzo_int64l_t)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64l_t) >= 8)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64l_t) == LZO_SIZEOF_LZO_INT64L_T)
+#endif
+#if !defined(lzo_int32f_t)
+#if (LZO_SIZEOF_SIZE_T >= 8)
+#  define lzo_int32f_t              lzo_int64l_t
+#  define lzo_uint32f_t             lzo_uint64l_t
+#  define LZO_SIZEOF_LZO_INT32F_T   LZO_SIZEOF_LZO_INT64L_T
+#else
+#  define lzo_int32f_t              lzo_int32l_t
+#  define lzo_uint32f_t             lzo_uint32l_t
+#  define LZO_SIZEOF_LZO_INT32F_T   LZO_SIZEOF_LZO_INT32L_T
+#endif
+#endif
+#if 1
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32f_t) >= 4)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32f_t) == LZO_SIZEOF_LZO_INT32F_T)
+#endif
+#if !defined(lzo_int64f_t)
+#if defined(lzo_int64l_t)
+#  define lzo_int64f_t              lzo_int64l_t
+#  define lzo_uint64f_t             lzo_uint64l_t
+#  define LZO_SIZEOF_LZO_INT64F_T   LZO_SIZEOF_LZO_INT64L_T
+#else
+#endif
+#endif
+#if defined(lzo_int64f_t)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64f_t) >= 8)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64f_t) == LZO_SIZEOF_LZO_INT64F_T)
+#endif
+#if !defined(lzo_intptr_t)
+#if 1 && (LZO_OS_OS400 && (LZO_SIZEOF_VOID_P == 16))
+#  define __LZO_INTPTR_T_IS_POINTER 1
+   typedef char*                    lzo_intptr_t;
+   typedef char*                    lzo_uintptr_t;
+#  define lzo_intptr_t              lzo_intptr_t
+#  define lzo_uintptr_t             lzo_uintptr_t
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_VOID_P
+#elif (LZO_CC_MSC && (_MSC_VER >= 1300) && (LZO_SIZEOF_VOID_P == 4) && (LZO_SIZEOF_INT == 4))
+   typedef __w64 int                lzo_intptr_t;
+   typedef __w64 unsigned int       lzo_uintptr_t;
+#  define lzo_intptr_t              lzo_intptr_t
+#  define lzo_uintptr_t             lzo_uintptr_t
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_SHORT == LZO_SIZEOF_VOID_P) && (LZO_SIZEOF_INT > LZO_SIZEOF_VOID_P)
+#  define lzo_intptr_t              short
+#  define lzo_uintptr_t             unsigned short
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_SHORT
+#elif (LZO_SIZEOF_INT >= LZO_SIZEOF_VOID_P) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
+#  define lzo_intptr_t              int
+#  define lzo_uintptr_t             unsigned int
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_LONG >= LZO_SIZEOF_VOID_P)
+#  define lzo_intptr_t              long
+#  define lzo_uintptr_t             unsigned long
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_LONG
+#elif (LZO_SIZEOF_LZO_INT64L_T >= LZO_SIZEOF_VOID_P)
+#  define lzo_intptr_t              lzo_int64l_t
+#  define lzo_uintptr_t             lzo_uint64l_t
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_LZO_INT64L_T
+#else
+#  error "lzo_intptr_t"
+#endif
+#endif
+#if 1
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_intptr_t) >= sizeof(void *))
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_intptr_t) == sizeof(lzo_uintptr_t))
+#endif
+#if !defined(lzo_word_t)
+#if defined(LZO_WORDSIZE) && (LZO_WORDSIZE+0 > 0)
+#if (LZO_WORDSIZE == LZO_SIZEOF_LZO_INTPTR_T) && !(__LZO_INTPTR_T_IS_POINTER)
+#  define lzo_word_t                lzo_uintptr_t
+#  define lzo_sword_t               lzo_intptr_t
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_LZO_INTPTR_T
+#elif (LZO_WORDSIZE == LZO_SIZEOF_LONG)
+#  define lzo_word_t                unsigned long
+#  define lzo_sword_t               long
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_LONG
+#elif (LZO_WORDSIZE == LZO_SIZEOF_INT)
+#  define lzo_word_t                unsigned int
+#  define lzo_sword_t               int
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_INT
+#elif (LZO_WORDSIZE == LZO_SIZEOF_SHORT)
+#  define lzo_word_t                unsigned short
+#  define lzo_sword_t               short
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_SHORT
+#elif (LZO_WORDSIZE == 1)
+#  define lzo_word_t                unsigned char
+#  define lzo_sword_t               signed char
+#  define LZO_SIZEOF_LZO_WORD_T 1
+#elif (LZO_WORDSIZE == LZO_SIZEOF_LZO_INT64L_T)
+#  define lzo_word_t                lzo_uint64l_t
+#  define lzo_sword_t               lzo_int64l_t
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_LZO_INT64L_T
+#elif (LZO_ARCH_SPU) && (LZO_CC_GNUC)
+#if 0
+   typedef unsigned lzo_word_t  __attribute__((__mode__(__V16QI__)));
+   typedef int      lzo_sword_t __attribute__((__mode__(__V16QI__)));
+#  define lzo_word_t                lzo_word_t
+#  define lzo_sword_t               lzo_sword_t
+#  define LZO_SIZEOF_LZO_WORD_T     16
+#endif
+#else
+#  error "lzo_word_t"
+#endif
+#endif
+#endif
+#if 1 && defined(lzo_word_t)
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_word_t)  == LZO_WORDSIZE)
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_sword_t) == LZO_WORDSIZE)
+#endif
+#if 1
+#define lzo_int8_t                  signed char
+#define lzo_uint8_t                 unsigned char
+#define LZO_SIZEOF_LZO_INT8_T       1
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int8_t) == 1)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int8_t) == sizeof(lzo_uint8_t))
+#endif
+#if defined(lzo_int16e_t)
+#define lzo_int16_t                 lzo_int16e_t
+#define lzo_uint16_t                lzo_uint16e_t
+#define LZO_SIZEOF_LZO_INT16_T      LZO_SIZEOF_LZO_INT16E_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16_t) == 2)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16_t) == sizeof(lzo_uint16_t))
+#endif
+#if defined(lzo_int32e_t)
+#define lzo_int32_t                 lzo_int32e_t
+#define lzo_uint32_t                lzo_uint32e_t
+#define LZO_SIZEOF_LZO_INT32_T      LZO_SIZEOF_LZO_INT32E_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32_t) == 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32_t) == sizeof(lzo_uint32_t))
+#endif
+#if defined(lzo_int64e_t)
+#define lzo_int64_t                 lzo_int64e_t
+#define lzo_uint64_t                lzo_uint64e_t
+#define LZO_SIZEOF_LZO_INT64_T      LZO_SIZEOF_LZO_INT64E_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64_t) == 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64_t) == sizeof(lzo_uint64_t))
+#endif
+#if 1
+#define lzo_int_least32_t           lzo_int32l_t
+#define lzo_uint_least32_t          lzo_uint32l_t
+#define LZO_SIZEOF_LZO_INT_LEAST32_T LZO_SIZEOF_LZO_INT32L_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least32_t) >= 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least32_t) == sizeof(lzo_uint_least32_t))
+#endif
+#if defined(lzo_int64l_t)
+#define lzo_int_least64_t           lzo_int64l_t
+#define lzo_uint_least64_t          lzo_uint64l_t
+#define LZO_SIZEOF_LZO_INT_LEAST64_T LZO_SIZEOF_LZO_INT64L_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least64_t) >= 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least64_t) == sizeof(lzo_uint_least64_t))
+#endif
+#if 1
+#define lzo_int_fast32_t           lzo_int32f_t
+#define lzo_uint_fast32_t          lzo_uint32f_t
+#define LZO_SIZEOF_LZO_INT_FAST32_T LZO_SIZEOF_LZO_INT32F_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast32_t) >= 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast32_t) == sizeof(lzo_uint_fast32_t))
+#endif
+#if defined(lzo_int64f_t)
+#define lzo_int_fast64_t           lzo_int64f_t
+#define lzo_uint_fast64_t          lzo_uint64f_t
+#define LZO_SIZEOF_LZO_INT_FAST64_T LZO_SIZEOF_LZO_INT64F_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast64_t) >= 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast64_t) == sizeof(lzo_uint_fast64_t))
+#endif
+#if !defined(LZO_INT16_C)
+#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 2)
+#    define LZO_INT16_C(c)          ((c) + 0)
+#    define LZO_UINT16_C(c)         ((c) + 0U)
+#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 2)
+#    define LZO_INT16_C(c)          ((c) + 0L)
+#    define LZO_UINT16_C(c)         ((c) + 0UL)
+#  elif (LZO_SIZEOF_INT >= 2)
+#    define LZO_INT16_C(c)          (c)
+#    define LZO_UINT16_C(c)         (c##U)
+#  elif (LZO_SIZEOF_LONG >= 2)
+#    define LZO_INT16_C(c)          (c##L)
+#    define LZO_UINT16_C(c)         (c##UL)
+#  else
+#    error "LZO_INT16_C"
+#  endif
+#endif
+#if !defined(LZO_INT32_C)
+#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 4)
+#    define LZO_INT32_C(c)          ((c) + 0)
+#    define LZO_UINT32_C(c)         ((c) + 0U)
+#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 4)
+#    define LZO_INT32_C(c)          ((c) + 0L)
+#    define LZO_UINT32_C(c)         ((c) + 0UL)
+#  elif (LZO_SIZEOF_INT >= 4)
+#    define LZO_INT32_C(c)          (c)
+#    define LZO_UINT32_C(c)         (c##U)
+#  elif (LZO_SIZEOF_LONG >= 4)
+#    define LZO_INT32_C(c)          (c##L)
+#    define LZO_UINT32_C(c)         (c##UL)
+#  elif (LZO_SIZEOF_LONG_LONG >= 4)
+#    define LZO_INT32_C(c)          (c##LL)
+#    define LZO_UINT32_C(c)         (c##ULL)
+#  else
+#    error "LZO_INT32_C"
+#  endif
+#endif
+#if !defined(LZO_INT64_C) && defined(lzo_int64l_t)
+#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 8)
+#    define LZO_INT64_C(c)          ((c) + 0)
+#    define LZO_UINT64_C(c)         ((c) + 0U)
+#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 8)
+#    define LZO_INT64_C(c)          ((c) + 0L)
+#    define LZO_UINT64_C(c)         ((c) + 0UL)
+#  elif (LZO_SIZEOF_INT >= 8)
+#    define LZO_INT64_C(c)          (c)
+#    define LZO_UINT64_C(c)         (c##U)
+#  elif (LZO_SIZEOF_LONG >= 8)
+#    define LZO_INT64_C(c)          (c##L)
+#    define LZO_UINT64_C(c)         (c##UL)
+#  else
+#    error "LZO_INT64_C"
+#  endif
+#endif
+#endif
 
 #endif
 
@@ -1830,35 +3020,21 @@ extern "C" {
 #undef LZO_HAVE_CONFIG_H
 #include "minilzo.h"
 
-#if !defined(MINILZO_VERSION) || (MINILZO_VERSION != 0x2030)
+#if !defined(MINILZO_VERSION) || (MINILZO_VERSION != 0x2070)
 #  error "version mismatch in miniLZO source files"
 #endif
 
 #ifdef MINILZO_HAVE_CONFIG_H
-#  define LZO_HAVE_CONFIG_H
+#  define LZO_HAVE_CONFIG_H 1
 #endif
 
 #ifndef __LZO_CONF_H
-#define __LZO_CONF_H
+#define __LZO_CONF_H 1
 
 #if !defined(__LZO_IN_MINILZO)
-#if defined(LZO_CFG_FREESTANDING)
+#if defined(LZO_CFG_FREESTANDING) && (LZO_CFG_FREESTANDING)
 #  define LZO_LIBC_FREESTANDING 1
 #  define LZO_OS_FREESTANDING 1
-#  define ACC_LIBC_FREESTANDING 1
-#  define ACC_OS_FREESTANDING 1
-#endif
-#if defined(LZO_CFG_NO_UNALIGNED)
-#  define ACC_CFG_NO_UNALIGNED 1
-#endif
-#if defined(LZO_ARCH_GENERIC)
-#  define ACC_ARCH_GENERIC 1
-#endif
-#if defined(LZO_ABI_NEUTRAL_ENDIAN)
-#  define ACC_ABI_NEUTRAL_ENDIAN 1
-#endif
-#if defined(LZO_HAVE_CONFIG_H)
-#  define ACC_CONFIG_NO_HEADER 1
 #endif
 #if defined(LZO_CFG_EXTRA_CONFIG_HEADER)
 #  include LZO_CFG_EXTRA_CONFIG_HEADER
@@ -1867,71 +3043,46 @@ extern "C" {
 #  error "include this file first"
 #endif
 #include "lzo/lzoconf.h"
+#if defined(LZO_CFG_EXTRA_CONFIG_HEADER2)
+#  include LZO_CFG_EXTRA_CONFIG_HEADER2
+#endif
 #endif
 
-#if (LZO_VERSION < 0x02000) || !defined(__LZOCONF_H_INCLUDED)
+#if (LZO_VERSION < 0x2070) || !defined(__LZOCONF_H_INCLUDED)
 #  error "version mismatch"
 #endif
 
-#if (LZO_CC_BORLANDC && LZO_ARCH_I086)
-#  pragma option -h
+#if (LZO_CC_MSC && (_MSC_VER >= 1000 && _MSC_VER < 1100))
+#  pragma warning(disable: 4702)
 #endif
-
 #if (LZO_CC_MSC && (_MSC_VER >= 1000))
 #  pragma warning(disable: 4127 4701)
+#  pragma warning(disable: 4514 4710 4711)
 #endif
 #if (LZO_CC_MSC && (_MSC_VER >= 1300))
 #  pragma warning(disable: 4820)
-#  pragma warning(disable: 4514 4710 4711)
+#endif
+#if (LZO_CC_MSC && (_MSC_VER >= 1800))
+#  pragma warning(disable: 4746)
 #endif
 
 #if (LZO_CC_SUNPROC)
+#if !defined(__cplusplus)
 #  pragma error_messages(off,E_END_OF_LOOP_CODE_NOT_REACHED)
 #  pragma error_messages(off,E_LOOP_NOT_ENTERED_AT_TOP)
+#  pragma error_messages(off,E_STATEMENT_NOT_REACHED)
 #endif
-
-#if defined(__LZO_MMODEL_HUGE) && (!LZO_HAVE_MM_HUGE_PTR)
-#  error "this should not happen - check defines for __huge"
 #endif
 
-#if defined(__LZO_IN_MINILZO) || defined(LZO_CFG_FREESTANDING)
-#elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  define ACC_WANT_ACC_INCD_H 1
-#  define ACC_WANT_ACC_INCE_H 1
-#  define ACC_WANT_ACC_INCI_H 1
+#if defined(__LZO_IN_MINILZO) || (LZO_CFG_FREESTANDING)
 #elif 1
 #  include <string.h>
 #else
-#  define ACC_WANT_ACC_INCD_H 1
+#  define LZO_WANT_ACC_INCD_H 1
 #endif
-
-#if (LZO_ARCH_I086)
-#  define ACC_MM_AHSHIFT        LZO_MM_AHSHIFT
-#  define ACC_PTR_FP_OFF(x)     (((const unsigned __far*)&(x))[0])
-#  define ACC_PTR_FP_SEG(x)     (((const unsigned __far*)&(x))[1])
-#  define ACC_PTR_MK_FP(s,o)    ((void __far*)(((unsigned long)(s)<<16)+(unsigned)(o)))
-#endif
-
-#if !defined(lzo_uintptr_t)
-#  if defined(__LZO_MMODEL_HUGE)
-#    define lzo_uintptr_t       unsigned long
-#  elif 1 && defined(LZO_OS_OS400) && (LZO_SIZEOF_VOID_P == 16)
-#    define __LZO_UINTPTR_T_IS_POINTER 1
-     typedef char*              lzo_uintptr_t;
-#    define lzo_uintptr_t       lzo_uintptr_t
-#  elif (LZO_SIZEOF_SIZE_T == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       size_t
-#  elif (LZO_SIZEOF_LONG == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       unsigned long
-#  elif (LZO_SIZEOF_INT == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       unsigned int
-#  elif (LZO_SIZEOF_LONG_LONG == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       unsigned long long
-#  else
-#    define lzo_uintptr_t       size_t
-#  endif
+#if defined(LZO_HAVE_CONFIG_H)
+#  define LZO_CFG_NO_CONFIG_HEADER 1
 #endif
-LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
 
 #if 1 && !defined(LZO_CFG_FREESTANDING)
 #if 1 && !defined(HAVE_STRING_H)
@@ -1955,40 +3106,61 @@ LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
 #include <string.h>
 #endif
 
-#if defined(LZO_CFG_FREESTANDING)
+#if 1 || defined(lzo_int8_t) || defined(lzo_uint8_t)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int8_t)  == 1)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint8_t) == 1)
+#endif
+#if 1 || defined(lzo_int16_t) || defined(lzo_uint16_t)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16_t)  == 2)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint16_t) == 2)
+#endif
+#if 1 || defined(lzo_int32_t) || defined(lzo_uint32_t)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32_t)  == 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint32_t) == 4)
+#endif
+#if defined(lzo_int64_t) || defined(lzo_uint64_t)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64_t)  == 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint64_t) == 8)
+#endif
+
+#if (LZO_CFG_FREESTANDING)
 #  undef HAVE_MEMCMP
 #  undef HAVE_MEMCPY
 #  undef HAVE_MEMMOVE
 #  undef HAVE_MEMSET
 #endif
 
-#if !defined(HAVE_MEMCMP)
+#if !(HAVE_MEMCMP)
 #  undef memcmp
 #  define memcmp(a,b,c)         lzo_memcmp(a,b,c)
-#elif !defined(__LZO_MMODEL_HUGE)
+#else
+#  undef lzo_memcmp
 #  define lzo_memcmp(a,b,c)     memcmp(a,b,c)
 #endif
-#if !defined(HAVE_MEMCPY)
+#if !(HAVE_MEMCPY)
 #  undef memcpy
 #  define memcpy(a,b,c)         lzo_memcpy(a,b,c)
-#elif !defined(__LZO_MMODEL_HUGE)
+#else
+#  undef lzo_memcpy
 #  define lzo_memcpy(a,b,c)     memcpy(a,b,c)
 #endif
-#if !defined(HAVE_MEMMOVE)
+#if !(HAVE_MEMMOVE)
 #  undef memmove
 #  define memmove(a,b,c)        lzo_memmove(a,b,c)
-#elif !defined(__LZO_MMODEL_HUGE)
+#else
+#  undef lzo_memmove
 #  define lzo_memmove(a,b,c)    memmove(a,b,c)
 #endif
-#if !defined(HAVE_MEMSET)
+#if !(HAVE_MEMSET)
 #  undef memset
 #  define memset(a,b,c)         lzo_memset(a,b,c)
-#elif !defined(__LZO_MMODEL_HUGE)
+#else
+#  undef lzo_memset
 #  define lzo_memset(a,b,c)     memset(a,b,c)
 #endif
 
 #undef NDEBUG
-#if defined(LZO_CFG_FREESTANDING)
+#if (LZO_CFG_FREESTANDING)
 #  undef LZO_DEBUG
 #  define NDEBUG 1
 #  undef assert
@@ -2007,16 +3179,29 @@ LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
 #  define BOUNDS_CHECKING_OFF_IN_EXPR(expr)     (expr)
 #endif
 
-#if !defined(__lzo_inline)
-#  define __lzo_inline
-#endif
-#if !defined(__lzo_forceinline)
-#  define __lzo_forceinline
-#endif
-#if !defined(__lzo_noinline)
-#  define __lzo_noinline
+#if (LZO_CFG_PGO)
+#  undef __lzo_likely
+#  undef __lzo_unlikely
+#  define __lzo_likely(e)       (e)
+#  define __lzo_unlikely(e)     (e)
 #endif
 
+#undef _
+#undef __
+#undef ___
+#undef ____
+#undef _p0
+#undef _p1
+#undef _p2
+#undef _p3
+#undef _p4
+#undef _s0
+#undef _s1
+#undef _s2
+#undef _s3
+#undef _s4
+#undef _ww
+
 #if 1
 #  define LZO_BYTE(x)       ((unsigned char) (x))
 #else
@@ -2035,39 +3220,548 @@ LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
 #define LZO_SIZE(bits)      (1u << (bits))
 #define LZO_MASK(bits)      (LZO_SIZE(bits) - 1)
 
-#define LZO_LSIZE(bits)     (1ul << (bits))
-#define LZO_LMASK(bits)     (LZO_LSIZE(bits) - 1)
+#define LZO_USIZE(bits)     ((lzo_uint) 1 << (bits))
+#define LZO_UMASK(bits)     (LZO_USIZE(bits) - 1)
+
+#if !defined(DMUL)
+#if 0
+
+#  define DMUL(a,b) ((lzo_xint) ((lzo_uint32_t)(a) * (lzo_uint32_t)(b)))
+#else
+#  define DMUL(a,b) ((lzo_xint) ((a) * (b)))
+#endif
+#endif
+
+#ifndef __LZO_FUNC_H
+#define __LZO_FUNC_H 1
+
+#if !defined(LZO_BITOPS_USE_ASM_BITSCAN) && !defined(LZO_BITOPS_USE_GNUC_BITSCAN) && !defined(LZO_BITOPS_USE_MSC_BITSCAN)
+#if 1 && (LZO_ARCH_AMD64) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_ASM_SYNTAX_GNUC)
+#define LZO_BITOPS_USE_ASM_BITSCAN 1
+#elif (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x030400ul) || (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 1000)) || (LZO_CC_LLVM && (!defined(__llvm_tools_version__) || (__llvm_tools_version__+0 >= 0x010500ul))))
+#define LZO_BITOPS_USE_GNUC_BITSCAN 1
+#elif (LZO_OS_WIN32 || LZO_OS_WIN64) && ((LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 1010)) || (LZO_CC_MSC && (_MSC_VER >= 1400)))
+#define LZO_BITOPS_USE_MSC_BITSCAN 1
+#if (LZO_CC_MSC) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+#include <intrin.h>
+#endif
+#if (LZO_CC_MSC) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+#pragma intrinsic(_BitScanReverse)
+#pragma intrinsic(_BitScanForward)
+#endif
+#if (LZO_CC_MSC) && (LZO_ARCH_AMD64)
+#pragma intrinsic(_BitScanReverse64)
+#pragma intrinsic(_BitScanForward64)
+#endif
+#endif
+#endif
+
+__lzo_static_forceinline unsigned lzo_bitops_ctlz32_func(lzo_uint32_t v)
+{
+#if (LZO_BITOPS_USE_MSC_BITSCAN) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+    unsigned long r; (void) _BitScanReverse(&r, v); return (unsigned) r ^ 31;
+#define lzo_bitops_ctlz32(v)    lzo_bitops_ctlz32_func(v)
+#elif (LZO_BITOPS_USE_ASM_BITSCAN) && (LZO_ARCH_AMD64 || LZO_ARCH_I386) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_uint32_t r;
+    __asm__("bsr %1,%0" : "=r" (r) : "rm" (v) __LZO_ASM_CLOBBER_LIST_CC);
+    return (unsigned) r ^ 31;
+#define lzo_bitops_ctlz32(v)    lzo_bitops_ctlz32_func(v)
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_INT == 4)
+    unsigned r; r = (unsigned) __builtin_clz(v); return r;
+#define lzo_bitops_ctlz32(v)    ((unsigned) __builtin_clz(v))
+#else
+    LZO_UNUSED(v); return 0;
+#endif
+}
+
+#if defined(lzo_uint64_t)
+__lzo_static_forceinline unsigned lzo_bitops_ctlz64_func(lzo_uint64_t v)
+{
+#if (LZO_BITOPS_USE_MSC_BITSCAN) && (LZO_ARCH_AMD64)
+    unsigned long r; (void) _BitScanReverse64(&r, v); return (unsigned) r ^ 63;
+#define lzo_bitops_ctlz64(v)    lzo_bitops_ctlz64_func(v)
+#elif (LZO_BITOPS_USE_ASM_BITSCAN) && (LZO_ARCH_AMD64) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_uint64_t r;
+    __asm__("bsr %1,%0" : "=r" (r) : "rm" (v) __LZO_ASM_CLOBBER_LIST_CC);
+    return (unsigned) r ^ 63;
+#define lzo_bitops_ctlz64(v)    lzo_bitops_ctlz64_func(v)
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_LONG == 8) && (LZO_WORDSIZE >= 8)
+    unsigned r; r = (unsigned) __builtin_clzl(v); return r;
+#define lzo_bitops_ctlz64(v)    ((unsigned) __builtin_clzl(v))
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_LONG_LONG == 8) && (LZO_WORDSIZE >= 8)
+    unsigned r; r = (unsigned) __builtin_clzll(v); return r;
+#define lzo_bitops_ctlz64(v)    ((unsigned) __builtin_clzll(v))
+#else
+    LZO_UNUSED(v); return 0;
+#endif
+}
+#endif
+
+__lzo_static_forceinline unsigned lzo_bitops_cttz32_func(lzo_uint32_t v)
+{
+#if (LZO_BITOPS_USE_MSC_BITSCAN) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+    unsigned long r; (void) _BitScanForward(&r, v); return (unsigned) r;
+#define lzo_bitops_cttz32(v)    lzo_bitops_cttz32_func(v)
+#elif (LZO_BITOPS_USE_ASM_BITSCAN) && (LZO_ARCH_AMD64 || LZO_ARCH_I386) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_uint32_t r;
+    __asm__("bsf %1,%0" : "=r" (r) : "rm" (v) __LZO_ASM_CLOBBER_LIST_CC);
+    return (unsigned) r;
+#define lzo_bitops_cttz32(v)    lzo_bitops_cttz32_func(v)
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_INT >= 4)
+    unsigned r; r = (unsigned) __builtin_ctz(v); return r;
+#define lzo_bitops_cttz32(v)    ((unsigned) __builtin_ctz(v))
+#else
+    LZO_UNUSED(v); return 0;
+#endif
+}
+
+#if defined(lzo_uint64_t)
+__lzo_static_forceinline unsigned lzo_bitops_cttz64_func(lzo_uint64_t v)
+{
+#if (LZO_BITOPS_USE_MSC_BITSCAN) && (LZO_ARCH_AMD64)
+    unsigned long r; (void) _BitScanForward64(&r, v); return (unsigned) r;
+#define lzo_bitops_cttz64(v)    lzo_bitops_cttz64_func(v)
+#elif (LZO_BITOPS_USE_ASM_BITSCAN) && (LZO_ARCH_AMD64) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_uint64_t r;
+    __asm__("bsf %1,%0" : "=r" (r) : "rm" (v) __LZO_ASM_CLOBBER_LIST_CC);
+    return (unsigned) r;
+#define lzo_bitops_cttz64(v)    lzo_bitops_cttz64_func(v)
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_LONG >= 8) && (LZO_WORDSIZE >= 8)
+    unsigned r; r = (unsigned) __builtin_ctzl(v); return r;
+#define lzo_bitops_cttz64(v)    ((unsigned) __builtin_ctzl(v))
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_LONG_LONG >= 8) && (LZO_WORDSIZE >= 8)
+    unsigned r; r = (unsigned) __builtin_ctzll(v); return r;
+#define lzo_bitops_cttz64(v)    ((unsigned) __builtin_ctzll(v))
+#else
+    LZO_UNUSED(v); return 0;
+#endif
+}
+#endif
+
+#if 1 && (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+static void __attribute__((__unused__))
+#else
+__lzo_static_forceinline void
+#endif
+lzo_bitops_unused_funcs(void)
+{
+    LZO_UNUSED_FUNC(lzo_bitops_ctlz32_func);
+    LZO_UNUSED_FUNC(lzo_bitops_cttz32_func);
+#if defined(lzo_uint64_t)
+    LZO_UNUSED_FUNC(lzo_bitops_ctlz64_func);
+    LZO_UNUSED_FUNC(lzo_bitops_cttz64_func);
+#endif
+    LZO_UNUSED_FUNC(lzo_bitops_unused_funcs);
+}
+
+#if defined(__lzo_alignof) && !(LZO_CFG_NO_UNALIGNED)
+#ifndef __lzo_memops_tcheck
+#define __lzo_memops_tcheck(t,a,b) ((void)0, sizeof(t) == (a) && __lzo_alignof(t) == (b))
+#endif
+#endif
+#ifndef lzo_memops_TU0p
+#define lzo_memops_TU0p void __LZO_MMODEL *
+#endif
+#ifndef lzo_memops_TU1p
+#define lzo_memops_TU1p unsigned char __LZO_MMODEL *
+#endif
+#ifndef lzo_memops_TU2p
+#if (LZO_OPT_UNALIGNED16)
+typedef lzo_uint16_t __lzo_may_alias lzo_memops_TU2;
+#define lzo_memops_TU2p volatile lzo_memops_TU2 *
+#elif defined(__lzo_byte_struct)
+__lzo_byte_struct(lzo_memops_TU2_struct,2)
+typedef struct lzo_memops_TU2_struct lzo_memops_TU2;
+#else
+struct lzo_memops_TU2_struct { unsigned char a[2]; } __lzo_may_alias;
+typedef struct lzo_memops_TU2_struct lzo_memops_TU2;
+#endif
+#ifndef lzo_memops_TU2p
+#define lzo_memops_TU2p lzo_memops_TU2 *
+#endif
+#endif
+#ifndef lzo_memops_TU4p
+#if (LZO_OPT_UNALIGNED32)
+typedef lzo_uint32_t __lzo_may_alias lzo_memops_TU4;
+#define lzo_memops_TU4p volatile lzo_memops_TU4 __LZO_MMODEL *
+#elif defined(__lzo_byte_struct)
+__lzo_byte_struct(lzo_memops_TU4_struct,4)
+typedef struct lzo_memops_TU4_struct lzo_memops_TU4;
+#else
+struct lzo_memops_TU4_struct { unsigned char a[4]; } __lzo_may_alias;
+typedef struct lzo_memops_TU4_struct lzo_memops_TU4;
+#endif
+#ifndef lzo_memops_TU4p
+#define lzo_memops_TU4p lzo_memops_TU4 __LZO_MMODEL *
+#endif
+#endif
+#ifndef lzo_memops_TU8p
+#if (LZO_OPT_UNALIGNED64)
+typedef lzo_uint64_t __lzo_may_alias lzo_memops_TU8;
+#define lzo_memops_TU8p volatile lzo_memops_TU8 __LZO_MMODEL *
+#elif defined(__lzo_byte_struct)
+__lzo_byte_struct(lzo_memops_TU8_struct,8)
+typedef struct lzo_memops_TU8_struct lzo_memops_TU8;
+#else
+struct lzo_memops_TU8_struct { unsigned char a[8]; } __lzo_may_alias;
+typedef struct lzo_memops_TU8_struct lzo_memops_TU8;
+#endif
+#ifndef lzo_memops_TU8p
+#define lzo_memops_TU8p lzo_memops_TU8 __LZO_MMODEL *
+#endif
+#endif
+#ifndef lzo_memops_set_TU1p
+#define lzo_memops_set_TU1p     volatile lzo_memops_TU1p
+#endif
+#ifndef lzo_memops_move_TU1p
+#define lzo_memops_move_TU1p    lzo_memops_TU1p
+#endif
+#define LZO_MEMOPS_SET1(dd,cc) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_set_TU1p d__1 = (lzo_memops_set_TU1p) (lzo_memops_TU0p) (dd); \
+    d__1[0] = LZO_BYTE(cc); \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_SET2(dd,cc) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_set_TU1p d__2 = (lzo_memops_set_TU1p) (lzo_memops_TU0p) (dd); \
+    d__2[0] = LZO_BYTE(cc); d__2[1] = LZO_BYTE(cc); \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_SET3(dd,cc) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_set_TU1p d__3 = (lzo_memops_set_TU1p) (lzo_memops_TU0p) (dd); \
+    d__3[0] = LZO_BYTE(cc); d__3[1] = LZO_BYTE(cc); d__3[2] = LZO_BYTE(cc); \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_SET4(dd,cc) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_set_TU1p d__4 = (lzo_memops_set_TU1p) (lzo_memops_TU0p) (dd); \
+    d__4[0] = LZO_BYTE(cc); d__4[1] = LZO_BYTE(cc); d__4[2] = LZO_BYTE(cc); d__4[3] = LZO_BYTE(cc); \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_MOVE1(dd,ss) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_move_TU1p d__1 = (lzo_memops_move_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_move_TU1p s__1 = (const lzo_memops_move_TU1p) (const lzo_memops_TU0p) (ss); \
+    d__1[0] = s__1[0]; \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_MOVE2(dd,ss) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_move_TU1p d__2 = (lzo_memops_move_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_move_TU1p s__2 = (const lzo_memops_move_TU1p) (const lzo_memops_TU0p) (ss); \
+    d__2[0] = s__2[0]; d__2[1] = s__2[1]; \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_MOVE3(dd,ss) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_move_TU1p d__3 = (lzo_memops_move_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_move_TU1p s__3 = (const lzo_memops_move_TU1p) (const lzo_memops_TU0p) (ss); \
+    d__3[0] = s__3[0]; d__3[1] = s__3[1]; d__3[2] = s__3[2]; \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_MOVE4(dd,ss) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_move_TU1p d__4 = (lzo_memops_move_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_move_TU1p s__4 = (const lzo_memops_move_TU1p) (const lzo_memops_TU0p) (ss); \
+    d__4[0] = s__4[0]; d__4[1] = s__4[1]; d__4[2] = s__4[2]; d__4[3] = s__4[3]; \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_MOVE8(dd,ss) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_move_TU1p d__8 = (lzo_memops_move_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_move_TU1p s__8 = (const lzo_memops_move_TU1p) (const lzo_memops_TU0p) (ss); \
+    d__8[0] = s__8[0]; d__8[1] = s__8[1]; d__8[2] = s__8[2]; d__8[3] = s__8[3]; \
+    d__8[4] = s__8[4]; d__8[5] = s__8[5]; d__8[6] = s__8[6]; d__8[7] = s__8[7]; \
+    LZO_BLOCK_END
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(*(lzo_memops_TU1p)0)==1)
+#define LZO_MEMOPS_COPY1(dd,ss) LZO_MEMOPS_MOVE1(dd,ss)
+#if (LZO_OPT_UNALIGNED16)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(*(lzo_memops_TU2p)0)==2)
+#define LZO_MEMOPS_COPY2(dd,ss) \
+    * (lzo_memops_TU2p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU2p) (const lzo_memops_TU0p) (ss)
+#elif defined(__lzo_memops_tcheck)
+#define LZO_MEMOPS_COPY2(dd,ss) \
+    LZO_BLOCK_BEGIN if (__lzo_memops_tcheck(lzo_memops_TU2,2,1)) { \
+        * (lzo_memops_TU2p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU2p) (const lzo_memops_TU0p) (ss); \
+    } else { LZO_MEMOPS_MOVE2(dd,ss); } LZO_BLOCK_END
+#else
+#define LZO_MEMOPS_COPY2(dd,ss) LZO_MEMOPS_MOVE2(dd,ss)
+#endif
+#if (LZO_OPT_UNALIGNED32)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(*(lzo_memops_TU4p)0)==4)
+#define LZO_MEMOPS_COPY4(dd,ss) \
+    * (lzo_memops_TU4p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU4p) (const lzo_memops_TU0p) (ss)
+#elif defined(__lzo_memops_tcheck)
+#define LZO_MEMOPS_COPY4(dd,ss) \
+    LZO_BLOCK_BEGIN if (__lzo_memops_tcheck(lzo_memops_TU4,4,1)) { \
+        * (lzo_memops_TU4p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU4p) (const lzo_memops_TU0p) (ss); \
+    } else { LZO_MEMOPS_MOVE4(dd,ss); } LZO_BLOCK_END
+#else
+#define LZO_MEMOPS_COPY4(dd,ss) LZO_MEMOPS_MOVE4(dd,ss)
+#endif
+#if (LZO_WORDSIZE != 8)
+#define LZO_MEMOPS_COPY8(dd,ss) \
+    LZO_BLOCK_BEGIN LZO_MEMOPS_COPY4(dd,ss); LZO_MEMOPS_COPY4((lzo_memops_TU1p)(lzo_memops_TU0p)(dd)+4,(const lzo_memops_TU1p)(const lzo_memops_TU0p)(ss)+4); LZO_BLOCK_END
+#else
+#if (LZO_OPT_UNALIGNED64)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(*(lzo_memops_TU8p)0)==8)
+#define LZO_MEMOPS_COPY8(dd,ss) \
+    * (lzo_memops_TU8p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU8p) (const lzo_memops_TU0p) (ss)
+#elif (LZO_OPT_UNALIGNED32)
+#define LZO_MEMOPS_COPY8(dd,ss) \
+    LZO_BLOCK_BEGIN LZO_MEMOPS_COPY4(dd,ss); LZO_MEMOPS_COPY4((lzo_memops_TU1p)(lzo_memops_TU0p)(dd)+4,(const lzo_memops_TU1p)(const lzo_memops_TU0p)(ss)+4); LZO_BLOCK_END
+#elif defined(__lzo_memops_tcheck)
+#define LZO_MEMOPS_COPY8(dd,ss) \
+    LZO_BLOCK_BEGIN if (__lzo_memops_tcheck(lzo_memops_TU8,8,1)) { \
+        * (lzo_memops_TU8p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU8p) (const lzo_memops_TU0p) (ss); \
+    } else { LZO_MEMOPS_MOVE8(dd,ss); } LZO_BLOCK_END
+#else
+#define LZO_MEMOPS_COPY8(dd,ss) LZO_MEMOPS_MOVE8(dd,ss)
+#endif
+#endif
+#define LZO_MEMOPS_COPYN(dd,ss,nn) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_TU1p d__n = (lzo_memops_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_TU1p s__n = (const lzo_memops_TU1p) (const lzo_memops_TU0p) (ss); \
+    lzo_uint n__n = (nn); \
+    while ((void)0, n__n >= 8) { LZO_MEMOPS_COPY8(d__n, s__n); d__n += 8; s__n += 8; n__n -= 8; } \
+    if ((void)0, n__n >= 4) { LZO_MEMOPS_COPY4(d__n, s__n); d__n += 4; s__n += 4; n__n -= 4; } \
+    if ((void)0, n__n > 0) do { *d__n++ = *s__n++; } while (--n__n > 0); \
+    LZO_BLOCK_END
+
+__lzo_static_forceinline lzo_uint16_t lzo_memops_get_le16(const lzo_voidp ss)
+{
+    lzo_uint16_t v;
+#if (LZO_ABI_LITTLE_ENDIAN)
+    LZO_MEMOPS_COPY2(&v, ss);
+#elif (LZO_OPT_UNALIGNED16 && LZO_ARCH_POWERPC && LZO_ABI_BIG_ENDIAN) && (LZO_ASM_SYNTAX_GNUC)
+    const lzo_memops_TU2p s = (const lzo_memops_TU2p) ss;
+    unsigned long vv;
+    __asm__("lhbrx %0,0,%1" : "=r" (vv) : "r" (s), "m" (*s));
+    v = (lzo_uint16_t) vv;
+#else
+    const lzo_memops_TU1p s = (const lzo_memops_TU1p) ss;
+    v = (lzo_uint16_t) (((lzo_uint16_t)s[0]) | ((lzo_uint16_t)s[1] << 8));
+#endif
+    return v;
+}
+#if (LZO_OPT_UNALIGNED16) && (LZO_ABI_LITTLE_ENDIAN)
+#define LZO_MEMOPS_GET_LE16(ss)    * (const lzo_memops_TU2p) (const lzo_memops_TU0p) (ss)
+#else
+#define LZO_MEMOPS_GET_LE16(ss)    lzo_memops_get_le16(ss)
+#endif
+
+__lzo_static_forceinline lzo_uint32_t lzo_memops_get_le32(const lzo_voidp ss)
+{
+    lzo_uint32_t v;
+#if (LZO_ABI_LITTLE_ENDIAN)
+    LZO_MEMOPS_COPY4(&v, ss);
+#elif (LZO_OPT_UNALIGNED32 && LZO_ARCH_POWERPC && LZO_ABI_BIG_ENDIAN) && (LZO_ASM_SYNTAX_GNUC)
+    const lzo_memops_TU4p s = (const lzo_memops_TU4p) ss;
+    unsigned long vv;
+    __asm__("lwbrx %0,0,%1" : "=r" (vv) : "r" (s), "m" (*s));
+    v = (lzo_uint32_t) vv;
+#else
+    const lzo_memops_TU1p s = (const lzo_memops_TU1p) ss;
+    v = (lzo_uint32_t) (((lzo_uint32_t)s[0] << 24) | ((lzo_uint32_t)s[1] << 16) | ((lzo_uint32_t)s[2] << 8) | ((lzo_uint32_t)s[3]));
+#endif
+    return v;
+}
+#if (LZO_OPT_UNALIGNED32) && (LZO_ABI_LITTLE_ENDIAN)
+#define LZO_MEMOPS_GET_LE32(ss)    * (const lzo_memops_TU4p) (const lzo_memops_TU0p) (ss)
+#else
+#define LZO_MEMOPS_GET_LE32(ss)    lzo_memops_get_le32(ss)
+#endif
+
+#if (LZO_OPT_UNALIGNED64) && (LZO_ABI_LITTLE_ENDIAN)
+#define LZO_MEMOPS_GET_LE64(ss)    * (const lzo_memops_TU8p) (const lzo_memops_TU0p) (ss)
+#endif
+
+__lzo_static_forceinline lzo_uint16_t lzo_memops_get_ne16(const lzo_voidp ss)
+{
+    lzo_uint16_t v;
+    LZO_MEMOPS_COPY2(&v, ss);
+    return v;
+}
+#if (LZO_OPT_UNALIGNED16)
+#define LZO_MEMOPS_GET_NE16(ss)    * (const lzo_memops_TU2p) (const lzo_memops_TU0p) (ss)
+#else
+#define LZO_MEMOPS_GET_NE16(ss)    lzo_memops_get_ne16(ss)
+#endif
+
+__lzo_static_forceinline lzo_uint32_t lzo_memops_get_ne32(const lzo_voidp ss)
+{
+    lzo_uint32_t v;
+    LZO_MEMOPS_COPY4(&v, ss);
+    return v;
+}
+#if (LZO_OPT_UNALIGNED32)
+#define LZO_MEMOPS_GET_NE32(ss)    * (const lzo_memops_TU4p) (const lzo_memops_TU0p) (ss)
+#else
+#define LZO_MEMOPS_GET_NE32(ss)    lzo_memops_get_ne32(ss)
+#endif
+
+#if (LZO_OPT_UNALIGNED64)
+#define LZO_MEMOPS_GET_NE64(ss)    * (const lzo_memops_TU8p) (const lzo_memops_TU0p) (ss)
+#endif
+
+__lzo_static_forceinline void lzo_memops_put_le16(lzo_voidp dd, lzo_uint16_t vv)
+{
+#if (LZO_ABI_LITTLE_ENDIAN)
+    LZO_MEMOPS_COPY2(dd, &vv);
+#elif (LZO_OPT_UNALIGNED16 && LZO_ARCH_POWERPC && LZO_ABI_BIG_ENDIAN) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_memops_TU2p d = (lzo_memops_TU2p) dd;
+    unsigned long v = vv;
+    __asm__("sthbrx %2,0,%1" : "=m" (*d) : "r" (d), "r" (v));
+#else
+    lzo_memops_TU1p d = (lzo_memops_TU1p) dd;
+    d[0] = LZO_BYTE((vv      ) & 0xff);
+    d[1] = LZO_BYTE((vv >>  8) & 0xff);
+#endif
+}
+#if (LZO_OPT_UNALIGNED16) && (LZO_ABI_LITTLE_ENDIAN)
+#define LZO_MEMOPS_PUT_LE16(dd,vv) (* (lzo_memops_TU2p) (lzo_memops_TU0p) (dd) = (vv))
+#else
+#define LZO_MEMOPS_PUT_LE16(dd,vv) lzo_memops_put_le16(dd,vv)
+#endif
+
+__lzo_static_forceinline void lzo_memops_put_le32(lzo_voidp dd, lzo_uint32_t vv)
+{
+#if (LZO_ABI_LITTLE_ENDIAN)
+    LZO_MEMOPS_COPY4(dd, &vv);
+#elif (LZO_OPT_UNALIGNED32 && LZO_ARCH_POWERPC && LZO_ABI_BIG_ENDIAN) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_memops_TU4p d = (lzo_memops_TU4p) dd;
+    unsigned long v = vv;
+    __asm__("stwbrx %2,0,%1" : "=m" (*d) : "r" (d), "r" (v));
+#else
+    lzo_memops_TU1p d = (lzo_memops_TU1p) dd;
+    d[0] = LZO_BYTE((vv      ) & 0xff);
+    d[1] = LZO_BYTE((vv >>  8) & 0xff);
+    d[2] = LZO_BYTE((vv >> 16) & 0xff);
+    d[3] = LZO_BYTE((vv >> 24) & 0xff);
+#endif
+}
+#if (LZO_OPT_UNALIGNED32) && (LZO_ABI_LITTLE_ENDIAN)
+#define LZO_MEMOPS_PUT_LE32(dd,vv) (* (lzo_memops_TU4p) (lzo_memops_TU0p) (dd) = (vv))
+#else
+#define LZO_MEMOPS_PUT_LE32(dd,vv) lzo_memops_put_le32(dd,vv)
+#endif
 
-#define LZO_USIZE(bits)     ((lzo_uint) 1 << (bits))
-#define LZO_UMASK(bits)     (LZO_USIZE(bits) - 1)
+__lzo_static_forceinline void lzo_memops_put_ne16(lzo_voidp dd, lzo_uint16_t vv)
+{
+    LZO_MEMOPS_COPY2(dd, &vv);
+}
+#if (LZO_OPT_UNALIGNED16)
+#define LZO_MEMOPS_PUT_NE16(dd,vv) (* (lzo_memops_TU2p) (lzo_memops_TU0p) (dd) = (vv))
+#else
+#define LZO_MEMOPS_PUT_NE16(dd,vv) lzo_memops_put_ne16(dd,vv)
+#endif
 
-#if !defined(DMUL)
-#if 0
+__lzo_static_forceinline void lzo_memops_put_ne32(lzo_voidp dd, lzo_uint32_t vv)
+{
+    LZO_MEMOPS_COPY4(dd, &vv);
+}
+#if (LZO_OPT_UNALIGNED32)
+#define LZO_MEMOPS_PUT_NE32(dd,vv) (* (lzo_memops_TU4p) (lzo_memops_TU0p) (dd) = (vv))
+#else
+#define LZO_MEMOPS_PUT_NE32(dd,vv) lzo_memops_put_ne32(dd,vv)
+#endif
 
-#  define DMUL(a,b) ((lzo_xint) ((lzo_uint32)(a) * (lzo_uint32)(b)))
+#if 1 && (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+static void __attribute__((__unused__))
 #else
-#  define DMUL(a,b) ((lzo_xint) ((a) * (b)))
+__lzo_static_forceinline void
 #endif
+lzo_memops_unused_funcs(void)
+{
+    LZO_UNUSED_FUNC(lzo_memops_get_le16);
+    LZO_UNUSED_FUNC(lzo_memops_get_le32);
+    LZO_UNUSED_FUNC(lzo_memops_get_ne16);
+    LZO_UNUSED_FUNC(lzo_memops_get_ne32);
+    LZO_UNUSED_FUNC(lzo_memops_put_le16);
+    LZO_UNUSED_FUNC(lzo_memops_put_le32);
+    LZO_UNUSED_FUNC(lzo_memops_put_ne16);
+    LZO_UNUSED_FUNC(lzo_memops_put_ne32);
+    LZO_UNUSED_FUNC(lzo_memops_unused_funcs);
+}
+
 #endif
 
-#if 1 && !defined(LZO_CFG_NO_UNALIGNED)
-#if 1 && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
-#  if (LZO_SIZEOF_SHORT == 2)
-#    define LZO_UNALIGNED_OK_2
-#  endif
-#  if (LZO_SIZEOF_INT == 4)
-#    define LZO_UNALIGNED_OK_4
-#  endif
+#ifndef UA_SET1
+#define UA_SET1             LZO_MEMOPS_SET1
 #endif
+#ifndef UA_SET2
+#define UA_SET2             LZO_MEMOPS_SET2
 #endif
-
-#if defined(LZO_UNALIGNED_OK_2)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(short) == 2)
+#ifndef UA_SET3
+#define UA_SET3             LZO_MEMOPS_SET3
+#endif
+#ifndef UA_SET4
+#define UA_SET4             LZO_MEMOPS_SET4
+#endif
+#ifndef UA_MOVE1
+#define UA_MOVE1            LZO_MEMOPS_MOVE1
+#endif
+#ifndef UA_MOVE2
+#define UA_MOVE2            LZO_MEMOPS_MOVE2
+#endif
+#ifndef UA_MOVE3
+#define UA_MOVE3            LZO_MEMOPS_MOVE3
+#endif
+#ifndef UA_MOVE4
+#define UA_MOVE4            LZO_MEMOPS_MOVE4
 #endif
-#if defined(LZO_UNALIGNED_OK_4)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint32) == 4)
-#elif defined(LZO_ALIGNED_OK_4)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint32) == 4)
+#ifndef UA_MOVE8
+#define UA_MOVE8            LZO_MEMOPS_MOVE8
+#endif
+#ifndef UA_COPY1
+#define UA_COPY1            LZO_MEMOPS_COPY1
+#endif
+#ifndef UA_COPY2
+#define UA_COPY2            LZO_MEMOPS_COPY2
+#endif
+#ifndef UA_COPY3
+#define UA_COPY3            LZO_MEMOPS_COPY3
+#endif
+#ifndef UA_COPY4
+#define UA_COPY4            LZO_MEMOPS_COPY4
+#endif
+#ifndef UA_COPY8
+#define UA_COPY8            LZO_MEMOPS_COPY8
+#endif
+#ifndef UA_COPYN
+#define UA_COPYN            LZO_MEMOPS_COPYN
+#endif
+#ifndef UA_COPYN_X
+#define UA_COPYN_X          LZO_MEMOPS_COPYN
+#endif
+#ifndef UA_GET_LE16
+#define UA_GET_LE16         LZO_MEMOPS_GET_LE16
+#endif
+#ifndef UA_GET_LE32
+#define UA_GET_LE32         LZO_MEMOPS_GET_LE32
+#endif
+#ifdef LZO_MEMOPS_GET_LE64
+#ifndef UA_GET_LE64
+#define UA_GET_LE64         LZO_MEMOPS_GET_LE64
+#endif
+#endif
+#ifndef UA_GET_NE16
+#define UA_GET_NE16         LZO_MEMOPS_GET_NE16
+#endif
+#ifndef UA_GET_NE32
+#define UA_GET_NE32         LZO_MEMOPS_GET_NE32
+#endif
+#ifdef LZO_MEMOPS_GET_NE64
+#ifndef UA_GET_NE64
+#define UA_GET_NE64         LZO_MEMOPS_GET_NE64
+#endif
+#endif
+#ifndef UA_PUT_LE16
+#define UA_PUT_LE16         LZO_MEMOPS_PUT_LE16
+#endif
+#ifndef UA_PUT_LE32
+#define UA_PUT_LE32         LZO_MEMOPS_PUT_LE32
+#endif
+#ifndef UA_PUT_NE16
+#define UA_PUT_NE16         LZO_MEMOPS_PUT_NE16
+#endif
+#ifndef UA_PUT_NE32
+#define UA_PUT_NE32         LZO_MEMOPS_PUT_NE32
 #endif
 
 #define MEMCPY8_DS(dest,src,len) \
@@ -2079,36 +3773,19 @@ LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
 #define MEMCPY_DS(dest,src,len) \
     do *dest++ = *src++; while (--len > 0)
 
-__LZO_EXTERN_C int __lzo_init_done;
-__LZO_EXTERN_C const char __lzo_copyright[];
 LZO_EXTERN(const lzo_bytep) lzo_copyright(void);
 
 #ifndef __LZO_PTR_H
-#define __LZO_PTR_H
+#define __LZO_PTR_H 1
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#if !defined(lzo_uintptr_t)
-#  if defined(__LZO_MMODEL_HUGE)
-#    define lzo_uintptr_t   unsigned long
-#  else
-#    define lzo_uintptr_t   acc_uintptr_t
-#    ifdef __ACC_INTPTR_T_IS_POINTER
-#      define __LZO_UINTPTR_T_IS_POINTER 1
-#    endif
-#  endif
-#endif
-
 #if (LZO_ARCH_I086)
-#define PTR(a)              ((lzo_bytep) (a))
-#define PTR_ALIGNED_4(a)    ((ACC_PTR_FP_OFF(a) & 3) == 0)
-#define PTR_ALIGNED2_4(a,b) (((ACC_PTR_FP_OFF(a) | ACC_PTR_FP_OFF(b)) & 3) == 0)
+#error "LZO_ARCH_I086 is unsupported"
 #elif (LZO_MM_PVP)
-#define PTR(a)              ((lzo_bytep) (a))
-#define PTR_ALIGNED_8(a)    ((((lzo_uintptr_t)(a)) >> 61) == 0)
-#define PTR_ALIGNED2_8(a,b) ((((lzo_uintptr_t)(a)|(lzo_uintptr_t)(b)) >> 61) == 0)
+#error "LZO_MM_PVP is unsupported"
 #else
 #define PTR(a)              ((lzo_uintptr_t) (a))
 #define PTR_LINEAR(a)       PTR(a)
@@ -2138,20 +3815,28 @@ typedef union
     unsigned long   a_ulong;
     lzo_int         a_lzo_int;
     lzo_uint        a_lzo_uint;
-    lzo_int32       a_lzo_int32;
-    lzo_uint32      a_lzo_uint32;
+    lzo_xint        a_lzo_xint;
+    lzo_int16_t     a_lzo_int16_t;
+    lzo_uint16_t    a_lzo_uint16_t;
+    lzo_int32_t     a_lzo_int32_t;
+    lzo_uint32_t    a_lzo_uint32_t;
+#if defined(lzo_uint64_t)
+    lzo_int64_t     a_lzo_int64_t;
+    lzo_uint64_t    a_lzo_uint64_t;
+#endif
+    size_t          a_size_t;
     ptrdiff_t       a_ptrdiff_t;
     lzo_uintptr_t   a_lzo_uintptr_t;
-    lzo_voidp       a_lzo_voidp;
     void *          a_void_p;
-    lzo_bytep       a_lzo_bytep;
-    lzo_bytepp      a_lzo_bytepp;
-    lzo_uintp       a_lzo_uintp;
-    lzo_uint *      a_lzo_uint_p;
-    lzo_uint32p     a_lzo_uint32p;
-    lzo_uint32 *    a_lzo_uint32_p;
-    unsigned char * a_uchar_p;
     char *          a_char_p;
+    unsigned char * a_uchar_p;
+    const void *          a_c_void_p;
+    const char *          a_c_char_p;
+    const unsigned char * a_c_uchar_p;
+    lzo_voidp       a_lzo_voidp;
+    lzo_bytep       a_lzo_bytep;
+    const lzo_voidp a_c_lzo_voidp;
+    const lzo_bytep a_c_lzo_bytep;
 }
 lzo_full_align_t;
 
@@ -2161,19 +3846,20 @@ lzo_full_align_t;
 
 #endif
 
-#define LZO_DETERMINISTIC
+#ifndef LZO_DETERMINISTIC
+#define LZO_DETERMINISTIC 1
+#endif
 
-#define LZO_DICT_USE_PTR
-#if 0 && (LZO_ARCH_I086)
-#  undef LZO_DICT_USE_PTR
+#ifndef LZO_DICT_USE_PTR
+#define LZO_DICT_USE_PTR 1
 #endif
 
-#if defined(LZO_DICT_USE_PTR)
+#if (LZO_DICT_USE_PTR)
 #  define lzo_dict_t    const lzo_bytep
-#  define lzo_dict_p    lzo_dict_t __LZO_MMODEL *
+#  define lzo_dict_p    lzo_dict_t *
 #else
 #  define lzo_dict_t    lzo_uint
-#  define lzo_dict_p    lzo_dict_t __LZO_MMODEL *
+#  define lzo_dict_p    lzo_dict_t *
 #endif
 
 #endif
@@ -2186,10 +3872,9 @@ __lzo_ptr_linear(const lzo_voidp ptr)
     lzo_uintptr_t p;
 
 #if (LZO_ARCH_I086)
-    p = (((lzo_uintptr_t)(ACC_PTR_FP_SEG(ptr))) << (16 - ACC_MM_AHSHIFT)) + (ACC_PTR_FP_OFF(ptr));
+#error "LZO_ARCH_I086 is unsupported"
 #elif (LZO_MM_PVP)
-    p = (lzo_uintptr_t) (ptr);
-    p = (p << 3) | (p >> 61);
+#error "LZO_MM_PVP is unsupported"
 #else
     p = (lzo_uintptr_t) PTR_LINEAR(ptr);
 #endif
@@ -2200,9 +3885,8 @@ __lzo_ptr_linear(const lzo_voidp ptr)
 LZO_PUBLIC(unsigned)
 __lzo_align_gap(const lzo_voidp ptr, lzo_uint size)
 {
-#if defined(__LZO_UINTPTR_T_IS_POINTER)
-    size_t n = (size_t) ptr;
-    n = (((n + size - 1) / size) * size) - n;
+#if (__LZO_UINTPTR_T_IS_POINTER)
+#error "__LZO_UINTPTR_T_IS_POINTER is unsupported"
 #else
     lzo_uintptr_t p, n;
     p = __lzo_ptr_linear(ptr);
@@ -2216,33 +3900,29 @@ __lzo_align_gap(const lzo_voidp ptr, lzo_uint size)
 }
 
 #endif
+#if !defined(MINILZO_CFG_SKIP_LZO_UTIL)
 
 /* If you use the LZO library in a product, I would appreciate that you
  * keep this copyright string in the executable of your product.
  */
 
-const char __lzo_copyright[] =
+static const char __lzo_copyright[] =
 #if !defined(__LZO_IN_MINLZO)
     LZO_VERSION_STRING;
 #else
     "\r\n\n"
     "LZO data compression library.\n"
-    "$Copyright: LZO (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Markus Franz Xaver Johannes Oberhumer\n"
+    "$Copyright: LZO Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer\n"
     "<markus@oberhumer.com>\n"
     "http://www.oberhumer.com $\n\n"
-    "$Id$\n"
-    "$Built: " __DATE__ " " __TIME__ " $\n"
+    "$Id: LZO version: v" LZO_VERSION_STRING ", " LZO_VERSION_DATE " $\n"
     "$Info: " LZO_INFO_STRING " $\n";
 #endif
 
 LZO_PUBLIC(const lzo_bytep)
 lzo_copyright(void)
 {
-#if (LZO_OS_DOS16 && LZO_CC_TURBOC)
-    return (lzo_voidp) __lzo_copyright;
-#else
     return (const lzo_bytep) __lzo_copyright;
-#endif
 }
 
 LZO_PUBLIC(unsigned)
@@ -2284,11 +3964,11 @@ _lzo_version_date(void)
 #define LZO_DO8(buf,i)  LZO_DO4(buf,i); LZO_DO4(buf,i+4);
 #define LZO_DO16(buf,i) LZO_DO8(buf,i); LZO_DO8(buf,i+8);
 
-LZO_PUBLIC(lzo_uint32)
-lzo_adler32(lzo_uint32 adler, const lzo_bytep buf, lzo_uint len)
+LZO_PUBLIC(lzo_uint32_t)
+lzo_adler32(lzo_uint32_t adler, const lzo_bytep buf, lzo_uint len)
 {
-    lzo_uint32 s1 = adler & 0xffff;
-    lzo_uint32 s2 = (adler >> 16) & 0xffff;
+    lzo_uint32_t s1 = adler & 0xffff;
+    lzo_uint32_t s2 = (adler >> 16) & 0xffff;
     unsigned k;
 
     if (buf == NULL)
@@ -2321,6 +4001,7 @@ lzo_adler32(lzo_uint32 adler, const lzo_bytep buf, lzo_uint len)
 #undef LZO_DO8
 #undef LZO_DO16
 
+#endif
 #if !defined(MINILZO_CFG_SKIP_LZO_STRING)
 #undef lzo_memcmp
 #undef lzo_memcpy
@@ -2343,9 +4024,9 @@ lzo_adler32(lzo_uint32 adler, const lzo_bytep buf, lzo_uint len)
 #endif
 LZOLIB_PUBLIC(int, lzo_hmemcmp) (const lzo_hvoid_p s1, const lzo_hvoid_p s2, lzo_hsize_t len)
 {
-#if (LZO_HAVE_MM_HUGE_PTR) || !defined(HAVE_MEMCMP)
-    const lzo_hbyte_p p1 = (const lzo_hbyte_p) s1;
-    const lzo_hbyte_p p2 = (const lzo_hbyte_p) s2;
+#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMCMP)
+    const lzo_hbyte_p p1 = LZO_STATIC_CAST(const lzo_hbyte_p, s1);
+    const lzo_hbyte_p p2 = LZO_STATIC_CAST(const lzo_hbyte_p, s2);
     if __lzo_likely(len > 0) do
     {
         int d = *p1 - *p2;
@@ -2360,9 +4041,9 @@ LZOLIB_PUBLIC(int, lzo_hmemcmp) (const lzo_hvoid_p s1, const lzo_hvoid_p s2, lzo
 }
 LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemcpy) (lzo_hvoid_p dest, const lzo_hvoid_p src, lzo_hsize_t len)
 {
-#if (LZO_HAVE_MM_HUGE_PTR) || !defined(HAVE_MEMCPY)
-    lzo_hbyte_p p1 = (lzo_hbyte_p) dest;
-    const lzo_hbyte_p p2 = (const lzo_hbyte_p) src;
+#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMCPY)
+    lzo_hbyte_p p1 = LZO_STATIC_CAST(lzo_hbyte_p, dest);
+    const lzo_hbyte_p p2 = LZO_STATIC_CAST(const lzo_hbyte_p, src);
     if (!(len > 0) || p1 == p2)
         return dest;
     do
@@ -2375,9 +4056,9 @@ LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemcpy) (lzo_hvoid_p dest, const lzo_hvoid_p src
 }
 LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemmove) (lzo_hvoid_p dest, const lzo_hvoid_p src, lzo_hsize_t len)
 {
-#if (LZO_HAVE_MM_HUGE_PTR) || !defined(HAVE_MEMMOVE)
-    lzo_hbyte_p p1 = (lzo_hbyte_p) dest;
-    const lzo_hbyte_p p2 = (const lzo_hbyte_p) src;
+#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMMOVE)
+    lzo_hbyte_p p1 = LZO_STATIC_CAST(lzo_hbyte_p, dest);
+    const lzo_hbyte_p p2 = LZO_STATIC_CAST(const lzo_hbyte_p, src);
     if (!(len > 0) || p1 == p2)
         return dest;
     if (p1 < p2)
@@ -2399,81 +4080,143 @@ LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemmove) (lzo_hvoid_p dest, const lzo_hvoid_p sr
     return memmove(dest, src, len);
 #endif
 }
-LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemset) (lzo_hvoid_p s, int c, lzo_hsize_t len)
+LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemset) (lzo_hvoid_p s, int cc, lzo_hsize_t len)
 {
-#if (LZO_HAVE_MM_HUGE_PTR) || !defined(HAVE_MEMSET)
-    lzo_hbyte_p p = (lzo_hbyte_p) s;
+#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMSET)
+    lzo_hbyte_p p = LZO_STATIC_CAST(lzo_hbyte_p, s);
+    unsigned char c = LZO_ITRUNC(unsigned char, cc);
     if __lzo_likely(len > 0) do
-        *p++ = (unsigned char) c;
+        *p++ = c;
     while __lzo_likely(--len > 0);
     return s;
 #else
-    return memset(s, c, len);
+    return memset(s, cc, len);
 #endif
 }
 #undef LZOLIB_PUBLIC
 #endif
+#if !defined(MINILZO_CFG_SKIP_LZO_INIT)
 
 #if !defined(__LZO_IN_MINILZO)
 
-#define ACC_WANT_ACC_CHK_CH 1
-#undef ACCCHK_ASSERT
+#define LZO_WANT_ACC_CHK_CH 1
+#undef LZOCHK_ASSERT
 
-    ACCCHK_ASSERT_IS_SIGNED_T(lzo_int)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uint)
-
-    ACCCHK_ASSERT_IS_SIGNED_T(lzo_int32)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uint32)
-    ACCCHK_ASSERT((LZO_UINT32_C(1) << (int)(8*sizeof(LZO_UINT32_C(1))-1)) > 0)
-    ACCCHK_ASSERT(sizeof(lzo_uint32) >= 4)
+    LZOCHK_ASSERT((LZO_UINT32_C(1) << (int)(8*sizeof(LZO_UINT32_C(1))-1)) > 0)
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_int)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uint)
+#if !(__LZO_UINTPTR_T_IS_POINTER)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uintptr_t)
+#endif
+    LZOCHK_ASSERT(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_xint)
 
-#if !defined(__LZO_UINTPTR_T_IS_POINTER)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uintptr_t)
 #endif
-    ACCCHK_ASSERT(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
+#undef LZOCHK_ASSERT
 
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_xint)
-    ACCCHK_ASSERT(sizeof(lzo_xint) >= sizeof(lzo_uint32))
-    ACCCHK_ASSERT(sizeof(lzo_xint) >= sizeof(lzo_uint))
-    ACCCHK_ASSERT(sizeof(lzo_xint) == sizeof(lzo_uint32) || sizeof(lzo_xint) == sizeof(lzo_uint))
+union lzo_config_check_union {
+    lzo_uint a[2];
+    unsigned char b[2*LZO_MAX(8,sizeof(lzo_uint))];
+#if defined(lzo_uint64_t)
+    lzo_uint64_t c[2];
+#endif
+};
 
+#if 0
+#define u2p(ptr,off) ((lzo_voidp) (((lzo_bytep)(lzo_voidp)(ptr)) + (off)))
+#else
+static __lzo_noinline lzo_voidp u2p(lzo_voidp ptr, lzo_uint off)
+{
+    return (lzo_voidp) ((lzo_bytep) ptr + off);
+}
 #endif
-#undef ACCCHK_ASSERT
 
 LZO_PUBLIC(int)
 _lzo_config_check(void)
 {
-    lzo_bool r = 1;
-    union { unsigned char c[2*sizeof(lzo_xint)]; lzo_xint l[2]; } u;
-    lzo_uintptr_t p;
-
-#if !defined(LZO_CFG_NO_CONFIG_CHECK)
-#if defined(LZO_ABI_BIG_ENDIAN)
-    u.l[0] = u.l[1] = 0; u.c[sizeof(lzo_xint) - 1] = 128;
-    r &= (u.l[0] == 128);
-#endif
-#if defined(LZO_ABI_LITTLE_ENDIAN)
-    u.l[0] = u.l[1] = 0; u.c[0] = 128;
-    r &= (u.l[0] == 128);
-#endif
-#if defined(LZO_UNALIGNED_OK_2)
-    p = (lzo_uintptr_t) (const lzo_voidp) &u.c[0];
-    u.l[0] = u.l[1] = 0;
-    r &= ((* (const lzo_ushortp) (p+1)) == 0);
-#endif
-#if defined(LZO_UNALIGNED_OK_4)
-    p = (lzo_uintptr_t) (const lzo_voidp) &u.c[0];
-    u.l[0] = u.l[1] = 0;
-    r &= ((* (const lzo_uint32p) (p+1)) == 0);
-#endif
+#if (LZO_CC_CLANG && (LZO_CC_CLANG >= 0x030100ul && LZO_CC_CLANG < 0x030300ul))
+# if 0
+    volatile
+# endif
 #endif
+    union lzo_config_check_union u;
+    lzo_voidp p;
+    unsigned r = 1;
+
+    u.a[0] = u.a[1] = 0;
+    p = u2p(&u, 0);
+    r &= ((* (lzo_bytep) p) == 0);
+#if !(LZO_CFG_NO_CONFIG_CHECK)
+#if (LZO_ABI_BIG_ENDIAN)
+    u.a[0] = u.a[1] = 0; u.b[sizeof(lzo_uint) - 1] = 128;
+    p = u2p(&u, 0);
+    r &= ((* (lzo_uintp) p) == 128);
+#endif
+#if (LZO_ABI_LITTLE_ENDIAN)
+    u.a[0] = u.a[1] = 0; u.b[0] = 128;
+    p = u2p(&u, 0);
+    r &= ((* (lzo_uintp) p) == 128);
+#endif
+    u.a[0] = u.a[1] = 0;
+    u.b[0] = 1; u.b[3] = 2;
+    p = u2p(&u, 1);
+    r &= UA_GET_NE16(p) == 0;
+    r &= UA_GET_LE16(p) == 0;
+    u.b[1] = 128;
+    r &= UA_GET_LE16(p) == 128;
+    u.a[0] = u.a[1] = 0;
+    u.b[0] = 3; u.b[5] = 4;
+    p = u2p(&u, 1);
+    r &= UA_GET_NE32(p) == 0;
+    r &= UA_GET_LE32(p) == 0;
+    u.b[1] = 128;
+    r &= UA_GET_LE32(p) == 128;
+#if defined(UA_GET_NE64)
+    u.c[0] = u.c[1] = 0;
+    u.b[0] = 5; u.b[9] = 6;
+    p = u2p(&u, 1);
+    u.c[0] = u.c[1] = 0;
+    r &= UA_GET_NE64(p) == 0;
+#if defined(UA_GET_LE64)
+    r &= UA_GET_LE64(p) == 0;
+    u.b[1] = 128;
+    r &= UA_GET_LE64(p) == 128;
+#endif
+#endif
+#if defined(lzo_bitops_ctlz32)
+    { unsigned i = 0; lzo_uint32_t v;
+    for (v = 1; v != 0 && r == 1; v <<= 1, i++) {
+        r &= lzo_bitops_ctlz32(v) == 31 - i;
+        r &= lzo_bitops_ctlz32_func(v) == 31 - i;
+    }}
+#endif
+#if defined(lzo_bitops_ctlz64)
+    { unsigned i = 0; lzo_uint64_t v;
+    for (v = 1; v != 0 && r == 1; v <<= 1, i++) {
+        r &= lzo_bitops_ctlz64(v) == 63 - i;
+        r &= lzo_bitops_ctlz64_func(v) == 63 - i;
+    }}
+#endif
+#if defined(lzo_bitops_cttz32)
+    { unsigned i = 0; lzo_uint32_t v;
+    for (v = 1; v != 0 && r == 1; v <<= 1, i++) {
+        r &= lzo_bitops_cttz32(v) == i;
+        r &= lzo_bitops_cttz32_func(v) == i;
+    }}
+#endif
+#if defined(lzo_bitops_cttz64)
+    { unsigned i = 0; lzo_uint64_t v;
+    for (v = 1; v != 0 && r == 1; v <<= 1, i++) {
+        r &= lzo_bitops_cttz64(v) == i;
+        r &= lzo_bitops_cttz64_func(v) == i;
+    }}
+#endif
+#endif
+    LZO_UNUSED_FUNC(lzo_bitops_unused_funcs);
 
-    LZO_UNUSED(u); LZO_UNUSED(p);
     return r == 1 ? LZO_E_OK : LZO_E_ERROR;
 }
 
-int __lzo_init_done = 0;
-
 LZO_PUBLIC(int)
 __lzo_init_v2(unsigned v, int s1, int s2, int s3, int s4, int s5,
                           int s6, int s7, int s8, int s9)
@@ -2483,13 +4226,11 @@ __lzo_init_v2(unsigned v, int s1, int s2, int s3, int s4, int s5,
 #if defined(__LZO_IN_MINILZO)
 #elif (LZO_CC_MSC && ((_MSC_VER) < 700))
 #else
-#define ACC_WANT_ACC_CHK_CH 1
-#undef ACCCHK_ASSERT
-#define ACCCHK_ASSERT(expr)  LZO_COMPILE_TIME_ASSERT(expr)
+#define LZO_WANT_ACC_CHK_CH 1
+#undef LZOCHK_ASSERT
+#define LZOCHK_ASSERT(expr)  LZO_COMPILE_TIME_ASSERT(expr)
 #endif
-#undef ACCCHK_ASSERT
-
-    __lzo_init_done = 1;
+#undef LZOCHK_ASSERT
 
     if (v == 0)
         return LZO_E_ERROR;
@@ -2497,7 +4238,7 @@ __lzo_init_v2(unsigned v, int s1, int s2, int s3, int s4, int s5,
     r = (s1 == -1 || s1 == (int) sizeof(short)) &&
         (s2 == -1 || s2 == (int) sizeof(int)) &&
         (s3 == -1 || s3 == (int) sizeof(long)) &&
-        (s4 == -1 || s4 == (int) sizeof(lzo_uint32)) &&
+        (s4 == -1 || s4 == (int) sizeof(lzo_uint32_t)) &&
         (s5 == -1 || s5 == (int) sizeof(lzo_uint)) &&
         (s6 == -1 || s6 == (int) lzo_sizeof_dict_t) &&
         (s7 == -1 || s7 == (int) sizeof(char *)) &&
@@ -2532,27 +4273,47 @@ int __far __pascal LibMain ( int a, short b, short c, long d )
 
 #endif
 
-#define do_compress         _lzo1x_1_do_compress
+#endif
+
+#define LZO1X           1
+#define LZO_EOF_CODE    1
+#define M2_MAX_OFFSET   0x0800
 
 #if !defined(MINILZO_CFG_SKIP_LZO1X_1_COMPRESS)
 
-#define LZO_NEED_DICT_H
+#if 1 && defined(UA_GET_LE32)
+#undef  LZO_DICT_USE_PTR
+#define LZO_DICT_USE_PTR 0
+#undef  lzo_dict_t
+#define lzo_dict_t lzo_uint16_t
+#endif
+
+#define LZO_NEED_DICT_H 1
+#ifndef D_BITS
 #define D_BITS          14
+#endif
 #define D_INDEX1(d,p)       d = DM(DMUL(0x21,DX3(p,5,5,6)) >> 5)
 #define D_INDEX2(d,p)       d = (d & (D_MASK & 0x7ff)) ^ (D_HIGH | 0x1f)
+#if 1
+#define DINDEX(dv,p)        DM(((DMUL(0x1824429d,dv)) >> (32-D_BITS)))
+#else
+#define DINDEX(dv,p)        DM((dv) + ((dv) >> (32-D_BITS)))
+#endif
 
 #ifndef __LZO_CONFIG1X_H
-#define __LZO_CONFIG1X_H
+#define __LZO_CONFIG1X_H 1
 
 #if !defined(LZO1X) && !defined(LZO1Y) && !defined(LZO1Z)
-#  define LZO1X
+#  define LZO1X 1
 #endif
 
 #if !defined(__LZO_IN_MINILZO)
 #include "lzo/lzo1x.h"
 #endif
 
-#define LZO_EOF_CODE
+#ifndef LZO_EOF_CODE
+#define LZO_EOF_CODE 1
+#endif
 #undef LZO_DETERMINISTIC
 
 #define M1_MAX_OFFSET   0x0400
@@ -2592,7 +4353,7 @@ int __far __pascal LibMain ( int a, short b, short c, long d )
 #define DL_MIN_LEN          M2_MIN_LEN
 
 #ifndef __LZO_DICT_H
-#define __LZO_DICT_H
+#define __LZO_DICT_H 1
 
 #ifdef __cplusplus
 extern "C" {
@@ -2633,10 +4394,10 @@ extern "C" {
 #if (D_BITS != DL_BITS + DD_BITS)
 #  error "D_BITS does not match"
 #endif
-#if (D_BITS < 8 || D_BITS > 18)
+#if (D_BITS < 6 || D_BITS > 18)
 #  error "invalid D_BITS"
 #endif
-#if (DL_BITS < 8 || DL_BITS > 20)
+#if (DL_BITS < 6 || DL_BITS > 20)
 #  error "invalid DL_BITS"
 #endif
 #if (DD_BITS < 0 || DD_BITS > 6)
@@ -2695,14 +4456,14 @@ extern "C" {
 #  define _DINDEX(dv,p)     (_DV_A((p),DL_SHIFT))
 
 #elif (LZO_HASH == LZO_HASH_GZIP_INCREMENTAL)
-#  define __LZO_HASH_INCREMENTAL
+#  define __LZO_HASH_INCREMENTAL 1
 #  define DVAL_FIRST(dv,p)  dv = _DV_A((p),DL_SHIFT)
 #  define DVAL_NEXT(dv,p)   dv = (((dv) << DL_SHIFT) ^ p[2])
 #  define _DINDEX(dv,p)     (dv)
 #  define DVAL_LOOKAHEAD    DL_MIN_LEN
 
 #elif (LZO_HASH == LZO_HASH_LZO_INCREMENTAL_A)
-#  define __LZO_HASH_INCREMENTAL
+#  define __LZO_HASH_INCREMENTAL 1
 #  define DVAL_FIRST(dv,p)  dv = _DV_A((p),5)
 #  define DVAL_NEXT(dv,p) \
                 dv ^= (lzo_xint)(p[-1]) << (2*5); dv = (((dv) << 5) ^ p[2])
@@ -2710,7 +4471,7 @@ extern "C" {
 #  define DVAL_LOOKAHEAD    DL_MIN_LEN
 
 #elif (LZO_HASH == LZO_HASH_LZO_INCREMENTAL_B)
-#  define __LZO_HASH_INCREMENTAL
+#  define __LZO_HASH_INCREMENTAL 1
 #  define DVAL_FIRST(dv,p)  dv = _DV_B((p),5)
 #  define DVAL_NEXT(dv,p) \
                 dv ^= p[-1]; dv = (((dv) >> 5) ^ ((lzo_xint)(p[2]) << (2*5)))
@@ -2739,7 +4500,12 @@ extern "C" {
 
 #if !defined(DVAL_ASSERT)
 #if defined(__LZO_HASH_INCREMENTAL) && !defined(NDEBUG)
-static void DVAL_ASSERT(lzo_xint dv, const lzo_bytep p)
+#if (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_LLVM)
+static void __attribute__((__unused__))
+#else
+static void
+#endif
+DVAL_ASSERT(lzo_xint dv, const lzo_bytep p)
 {
     lzo_xint df;
     DVAL_FIRST(df,(p));
@@ -2750,11 +4516,11 @@ static void DVAL_ASSERT(lzo_xint dv, const lzo_bytep p)
 #endif
 #endif
 
-#if defined(LZO_DICT_USE_PTR)
+#if (LZO_DICT_USE_PTR)
 #  define DENTRY(p,in)                          (p)
 #  define GINDEX(m_pos,m_off,dict,dindex,in)    m_pos = dict[dindex]
 #else
-#  define DENTRY(p,in)                          ((lzo_uint) ((p)-(in)))
+#  define DENTRY(p,in)                          ((lzo_dict_t) pd(p, in))
 #  define GINDEX(m_pos,m_off,dict,dindex,in)    m_off = dict[dindex]
 #endif
 
@@ -2775,7 +4541,7 @@ static void DVAL_ASSERT(lzo_xint dv, const lzo_bytep p)
 
 #endif
 
-#if defined(LZO_DICT_USE_PTR)
+#if (LZO_DICT_USE_PTR)
 
 #define LZO_CHECK_MPOS_DET(m_pos,m_off,in,ip,max_offset) \
         (m_pos == NULL || (m_off = pd(ip, m_pos)) > max_offset)
@@ -2784,7 +4550,7 @@ static void DVAL_ASSERT(lzo_xint dv, const lzo_bytep p)
     (BOUNDS_CHECKING_OFF_IN_EXPR(( \
         m_pos = ip - (lzo_uint) PTR_DIFF(ip,m_pos), \
         PTR_LT(m_pos,in) || \
-        (m_off = (lzo_uint) PTR_DIFF(ip,m_pos)) <= 0 || \
+        (m_off = (lzo_uint) PTR_DIFF(ip,m_pos)) == 0 || \
          m_off > max_offset )))
 
 #else
@@ -2801,7 +4567,7 @@ static void DVAL_ASSERT(lzo_xint dv, const lzo_bytep p)
 
 #endif
 
-#if defined(LZO_DETERMINISTIC)
+#if (LZO_DETERMINISTIC)
 #  define LZO_CHECK_MPOS    LZO_CHECK_MPOS_DET
 #else
 #  define LZO_CHECK_MPOS    LZO_CHECK_MPOS_NON_DET
@@ -2817,17 +4583,25 @@ static void DVAL_ASSERT(lzo_xint dv, const lzo_bytep p)
 
 #endif
 
+#define LZO_DETERMINISTIC !(LZO_DICT_USE_PTR)
+
+#ifndef DO_COMPRESS
 #define DO_COMPRESS     lzo1x_1_compress
+#endif
+
+#if 1 && defined(DO_COMPRESS) && !defined(do_compress)
+#  define do_compress       LZO_PP_ECONCAT2(DO_COMPRESS,_core)
+#endif
 
 static __lzo_noinline lzo_uint
 do_compress ( const lzo_bytep in , lzo_uint  in_len,
                     lzo_bytep out, lzo_uintp out_len,
-                    lzo_voidp wrkmem )
+                    lzo_uint  ti,  lzo_voidp wrkmem)
 {
-    register const lzo_bytep ip;
+    const lzo_bytep ip;
     lzo_bytep op;
     const lzo_bytep const in_end = in + in_len;
-    const lzo_bytep const ip_end = in + in_len - M2_MAX_LEN - 5;
+    const lzo_bytep const ip_end = in + in_len - 20;
     const lzo_bytep ii;
     lzo_dict_p const dict = (lzo_dict_p) wrkmem;
 
@@ -2835,14 +4609,17 @@ do_compress ( const lzo_bytep in , lzo_uint  in_len,
     ip = in;
     ii = ip;
 
-    ip += 4;
+    ip += ti < 4 ? 4 - ti : 0;
     for (;;)
     {
-        register const lzo_bytep m_pos;
-        lzo_uint m_off;
+        const lzo_bytep m_pos;
+#if !(LZO_DETERMINISTIC)
+        LZO_DEFINE_UNINITIALIZED_VAR(lzo_uint, m_off, 0);
         lzo_uint m_len;
         lzo_uint dindex;
-
+next:
+        if __lzo_unlikely(ip >= ip_end)
+            break;
         DINDEX1(dindex,ip);
         GINDEX(m_pos,m_off,dict,dindex,in);
         if (LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,M4_MAX_OFFSET))
@@ -2860,200 +4637,247 @@ do_compress ( const lzo_bytep in , lzo_uint  in_len,
         goto literal;
 
 try_match:
-#if 1 && defined(LZO_UNALIGNED_OK_2)
-        if (* (const lzo_ushortp) m_pos != * (const lzo_ushortp) ip)
+#if (LZO_OPT_UNALIGNED32)
+        if (UA_GET_NE32(m_pos) != UA_GET_NE32(ip))
 #else
-        if (m_pos[0] != ip[0] || m_pos[1] != ip[1])
+        if (m_pos[0] != ip[0] || m_pos[1] != ip[1] || m_pos[2] != ip[2] || m_pos[3] != ip[3])
 #endif
         {
+literal:
+            UPDATE_I(dict,0,dindex,ip,in);
+            ip += 1 + ((ip - ii) >> 5);
+            continue;
         }
-        else
-        {
-            if __lzo_likely(m_pos[2] == ip[2])
-            {
-#if 0
-                if (m_off <= M2_MAX_OFFSET)
-                    goto match;
-                if (lit <= 3)
-                    goto match;
-                if (lit == 3)
-                {
-                    assert(op - 2 > out); op[-2] |= LZO_BYTE(3);
-                    *op++ = *ii++; *op++ = *ii++; *op++ = *ii++;
-                    goto code_match;
-                }
-                if (m_pos[3] == ip[3])
-#endif
-                    goto match;
-            }
-            else
-            {
-#if 0
-#if 0
-                if (m_off <= M1_MAX_OFFSET && lit > 0 && lit <= 3)
+        UPDATE_I(dict,0,dindex,ip,in);
 #else
-                if (m_off <= M1_MAX_OFFSET && lit == 3)
-#endif
-                {
-                    register lzo_uint t;
-
-                    t = lit;
-                    assert(op - 2 > out); op[-2] |= LZO_BYTE(t);
-                    do *op++ = *ii++; while (--t > 0);
-                    assert(ii == ip);
-                    m_off -= 1;
-                    *op++ = LZO_BYTE(M1_MARKER | ((m_off & 3) << 2));
-                    *op++ = LZO_BYTE(m_off >> 2);
-                    ip += 2;
-                    goto match_done;
-                }
-#endif
-            }
-        }
-
+        lzo_uint m_off;
+        lzo_uint m_len;
+        {
+        lzo_uint32_t dv;
+        lzo_uint dindex;
 literal:
-        UPDATE_I(dict,0,dindex,ip,in);
-        ++ip;
+        ip += 1 + ((ip - ii) >> 5);
+next:
         if __lzo_unlikely(ip >= ip_end)
             break;
-        continue;
-
-match:
+        dv = UA_GET_LE32(ip);
+        dindex = DINDEX(dv,ip);
+        GINDEX(m_off,m_pos,in+dict,dindex,in);
         UPDATE_I(dict,0,dindex,ip,in);
-        if (pd(ip,ii) > 0)
-        {
-            register lzo_uint t = pd(ip,ii);
+        if __lzo_unlikely(dv != UA_GET_LE32(m_pos))
+            goto literal;
+        }
+#endif
 
+        ii -= ti; ti = 0;
+        {
+        lzo_uint t = pd(ip,ii);
+        if (t != 0)
+        {
             if (t <= 3)
             {
-                assert(op - 2 > out);
-                op[-2] |= LZO_BYTE(t);
+                op[-2] = LZO_BYTE(op[-2] | t);
+#if (LZO_OPT_UNALIGNED32)
+                UA_COPY4(op, ii);
+                op += t;
+#else
+                { do *op++ = *ii++; while (--t > 0); }
+#endif
             }
-            else if (t <= 18)
+#if (LZO_OPT_UNALIGNED32) || (LZO_OPT_UNALIGNED64)
+            else if (t <= 16)
+            {
                 *op++ = LZO_BYTE(t - 3);
+                UA_COPY8(op, ii);
+                UA_COPY8(op+8, ii+8);
+                op += t;
+            }
+#endif
             else
             {
-                register lzo_uint tt = t - 18;
-
-                *op++ = 0;
-                while (tt > 255)
+                if (t <= 18)
+                    *op++ = LZO_BYTE(t - 3);
+                else
                 {
-                    tt -= 255;
+                    lzo_uint tt = t - 18;
                     *op++ = 0;
+                    while __lzo_unlikely(tt > 255)
+                    {
+                        tt -= 255;
+                        UA_SET1(op, 0);
+                        op++;
+                    }
+                    assert(tt > 0);
+                    *op++ = LZO_BYTE(tt);
                 }
-                assert(tt > 0);
-                *op++ = LZO_BYTE(tt);
+#if (LZO_OPT_UNALIGNED32) || (LZO_OPT_UNALIGNED64)
+                do {
+                    UA_COPY8(op, ii);
+                    UA_COPY8(op+8, ii+8);
+                    op += 16; ii += 16; t -= 16;
+                } while (t >= 16); if (t > 0)
+#endif
+                { do *op++ = *ii++; while (--t > 0); }
             }
-            do *op++ = *ii++; while (--t > 0);
         }
-
-        assert(ii == ip);
-        ip += 3;
-        if (m_pos[3] != *ip++ || m_pos[4] != *ip++ || m_pos[5] != *ip++ ||
-            m_pos[6] != *ip++ || m_pos[7] != *ip++ || m_pos[8] != *ip++
-#ifdef LZO1Y
-            || m_pos[ 9] != *ip++ || m_pos[10] != *ip++ || m_pos[11] != *ip++
-            || m_pos[12] != *ip++ || m_pos[13] != *ip++ || m_pos[14] != *ip++
+        }
+        m_len = 4;
+        {
+#if (LZO_OPT_UNALIGNED64)
+        lzo_uint64_t v;
+        v = UA_GET_NE64(ip + m_len) ^ UA_GET_NE64(m_pos + m_len);
+        if __lzo_unlikely(v == 0) {
+            do {
+                m_len += 8;
+                v = UA_GET_NE64(ip + m_len) ^ UA_GET_NE64(m_pos + m_len);
+                if __lzo_unlikely(ip + m_len >= ip_end)
+                    goto m_len_done;
+            } while (v == 0);
+        }
+#if (LZO_ABI_BIG_ENDIAN) && defined(lzo_bitops_ctlz64)
+        m_len += lzo_bitops_ctlz64(v) / CHAR_BIT;
+#elif (LZO_ABI_BIG_ENDIAN)
+        if ((v >> (64 - CHAR_BIT)) == 0) do {
+            v <<= CHAR_BIT;
+            m_len += 1;
+        } while ((v >> (64 - CHAR_BIT)) == 0);
+#elif (LZO_ABI_LITTLE_ENDIAN) && defined(lzo_bitops_cttz64)
+        m_len += lzo_bitops_cttz64(v) / CHAR_BIT;
+#elif (LZO_ABI_LITTLE_ENDIAN)
+        if ((v & UCHAR_MAX) == 0) do {
+            v >>= CHAR_BIT;
+            m_len += 1;
+        } while ((v & UCHAR_MAX) == 0);
+#else
+        if (ip[m_len] == m_pos[m_len]) do {
+            m_len += 1;
+        } while (ip[m_len] == m_pos[m_len]);
+#endif
+#elif (LZO_OPT_UNALIGNED32)
+        lzo_uint32_t v;
+        v = UA_GET_NE32(ip + m_len) ^ UA_GET_NE32(m_pos + m_len);
+        if __lzo_unlikely(v == 0) {
+            do {
+                m_len += 4;
+                v = UA_GET_NE32(ip + m_len) ^ UA_GET_NE32(m_pos + m_len);
+                if (v != 0)
+                    break;
+                m_len += 4;
+                v = UA_GET_NE32(ip + m_len) ^ UA_GET_NE32(m_pos + m_len);
+                if __lzo_unlikely(ip + m_len >= ip_end)
+                    goto m_len_done;
+            } while (v == 0);
+        }
+#if (LZO_ABI_BIG_ENDIAN) && defined(lzo_bitops_ctlz32)
+        m_len += lzo_bitops_ctlz32(v) / CHAR_BIT;
+#elif (LZO_ABI_BIG_ENDIAN)
+        if ((v >> (32 - CHAR_BIT)) == 0) do {
+            v <<= CHAR_BIT;
+            m_len += 1;
+        } while ((v >> (32 - CHAR_BIT)) == 0);
+#elif (LZO_ABI_LITTLE_ENDIAN) && defined(lzo_bitops_cttz32)
+        m_len += lzo_bitops_cttz32(v) / CHAR_BIT;
+#elif (LZO_ABI_LITTLE_ENDIAN)
+        if ((v & UCHAR_MAX) == 0) do {
+            v >>= CHAR_BIT;
+            m_len += 1;
+        } while ((v & UCHAR_MAX) == 0);
+#else
+        if (ip[m_len] == m_pos[m_len]) do {
+            m_len += 1;
+        } while (ip[m_len] == m_pos[m_len]);
+#endif
+#else
+        if __lzo_unlikely(ip[m_len] == m_pos[m_len]) {
+            do {
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if __lzo_unlikely(ip + m_len >= ip_end)
+                    goto m_len_done;
+            } while (ip[m_len] == m_pos[m_len]);
+        }
 #endif
-           )
+        }
+m_len_done:
+        m_off = pd(ip,m_pos);
+        ip += m_len;
+        ii = ip;
+        if (m_len <= M2_MAX_LEN && m_off <= M2_MAX_OFFSET)
         {
-            --ip;
-            m_len = pd(ip, ii);
-            assert(m_len >= 3); assert(m_len <= M2_MAX_LEN);
-
-            if (m_off <= M2_MAX_OFFSET)
-            {
-                m_off -= 1;
+            m_off -= 1;
 #if defined(LZO1X)
-                *op++ = LZO_BYTE(((m_len - 1) << 5) | ((m_off & 7) << 2));
-                *op++ = LZO_BYTE(m_off >> 3);
+            *op++ = LZO_BYTE(((m_len - 1) << 5) | ((m_off & 7) << 2));
+            *op++ = LZO_BYTE(m_off >> 3);
 #elif defined(LZO1Y)
-                *op++ = LZO_BYTE(((m_len + 1) << 4) | ((m_off & 3) << 2));
-                *op++ = LZO_BYTE(m_off >> 2);
+            *op++ = LZO_BYTE(((m_len + 1) << 4) | ((m_off & 3) << 2));
+            *op++ = LZO_BYTE(m_off >> 2);
 #endif
-            }
-            else if (m_off <= M3_MAX_OFFSET)
-            {
-                m_off -= 1;
+        }
+        else if (m_off <= M3_MAX_OFFSET)
+        {
+            m_off -= 1;
+            if (m_len <= M3_MAX_LEN)
                 *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));
-                goto m3_m4_offset;
-            }
             else
-#if defined(LZO1X)
             {
-                m_off -= 0x4000;
-                assert(m_off > 0); assert(m_off <= 0x7fff);
-                *op++ = LZO_BYTE(M4_MARKER |
-                                 ((m_off & 0x4000) >> 11) | (m_len - 2));
-                goto m3_m4_offset;
+                m_len -= M3_MAX_LEN;
+                *op++ = M3_MARKER | 0;
+                while __lzo_unlikely(m_len > 255)
+                {
+                    m_len -= 255;
+                    UA_SET1(op, 0);
+                    op++;
+                }
+                *op++ = LZO_BYTE(m_len);
             }
-#elif defined(LZO1Y)
-                goto m4_match;
-#endif
+            *op++ = LZO_BYTE(m_off << 2);
+            *op++ = LZO_BYTE(m_off >> 6);
         }
         else
         {
-            {
-                const lzo_bytep end = in_end;
-                const lzo_bytep m = m_pos + M2_MAX_LEN + 1;
-                while (ip < end && *m == *ip)
-                    m++, ip++;
-                m_len = pd(ip, ii);
-            }
-            assert(m_len > M2_MAX_LEN);
-
-            if (m_off <= M3_MAX_OFFSET)
-            {
-                m_off -= 1;
-                if (m_len <= 33)
-                    *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));
-                else
-                {
-                    m_len -= 33;
-                    *op++ = M3_MARKER | 0;
-                    goto m3_m4_len;
-                }
-            }
+            m_off -= 0x4000;
+            if (m_len <= M4_MAX_LEN)
+                *op++ = LZO_BYTE(M4_MARKER | ((m_off >> 11) & 8) | (m_len - 2));
             else
             {
-#if defined(LZO1Y)
-m4_match:
-#endif
-                m_off -= 0x4000;
-                assert(m_off > 0); assert(m_off <= 0x7fff);
-                if (m_len <= M4_MAX_LEN)
-                    *op++ = LZO_BYTE(M4_MARKER |
-                                     ((m_off & 0x4000) >> 11) | (m_len - 2));
-                else
+                m_len -= M4_MAX_LEN;
+                *op++ = LZO_BYTE(M4_MARKER | ((m_off >> 11) & 8));
+                while __lzo_unlikely(m_len > 255)
                 {
-                    m_len -= M4_MAX_LEN;
-                    *op++ = LZO_BYTE(M4_MARKER | ((m_off & 0x4000) >> 11));
-m3_m4_len:
-                    while (m_len > 255)
-                    {
-                        m_len -= 255;
-                        *op++ = 0;
-                    }
-                    assert(m_len > 0);
-                    *op++ = LZO_BYTE(m_len);
+                    m_len -= 255;
+                    UA_SET1(op, 0);
+                    op++;
                 }
+                *op++ = LZO_BYTE(m_len);
             }
-
-m3_m4_offset:
-            *op++ = LZO_BYTE((m_off & 63) << 2);
+            *op++ = LZO_BYTE(m_off << 2);
             *op++ = LZO_BYTE(m_off >> 6);
         }
-
-#if 0
-match_done:
-#endif
-        ii = ip;
-        if __lzo_unlikely(ip >= ip_end)
-            break;
+        goto next;
     }
 
     *out_len = pd(op, out);
-    return pd(in_end,ii);
+    return pd(in_end,ii-ti);
 }
 
 LZO_PUBLIC(int)
@@ -3061,16 +4885,30 @@ DO_COMPRESS      ( const lzo_bytep in , lzo_uint  in_len,
                          lzo_bytep out, lzo_uintp out_len,
                          lzo_voidp wrkmem )
 {
+    const lzo_bytep ip = in;
     lzo_bytep op = out;
-    lzo_uint t;
+    lzo_uint l = in_len;
+    lzo_uint t = 0;
 
-    if __lzo_unlikely(in_len <= M2_MAX_LEN + 5)
-        t = in_len;
-    else
+    while (l > 20)
     {
-        t = do_compress(in,in_len,op,out_len,wrkmem);
+        lzo_uint ll = l;
+        lzo_uintptr_t ll_end;
+#if 0 || (LZO_DETERMINISTIC)
+        ll = LZO_MIN(ll, 49152);
+#endif
+        ll_end = (lzo_uintptr_t)ip + ll;
+        if ((ll_end + ((t + ll) >> 5)) <= ll_end || (const lzo_bytep)(ll_end + ((t + ll) >> 5)) <= ip + ll)
+            break;
+#if (LZO_DETERMINISTIC)
+        lzo_memset(wrkmem, 0, ((lzo_uint)1 << D_BITS) * sizeof(lzo_dict_t));
+#endif
+        t = do_compress(ip,ll,op,out_len,t,wrkmem);
+        ip += ll;
         op += *out_len;
+        l  -= ll;
     }
+    t += l;
 
     if (t > 0)
     {
@@ -3079,7 +4917,7 @@ DO_COMPRESS      ( const lzo_bytep in , lzo_uint  in_len,
         if (op == out && t <= 238)
             *op++ = LZO_BYTE(17 + t);
         else if (t <= 3)
-            op[-2] |= LZO_BYTE(t);
+            op[-2] = LZO_BYTE(op[-2] | t);
         else if (t <= 18)
             *op++ = LZO_BYTE(t - 3);
         else
@@ -3090,12 +4928,14 @@ DO_COMPRESS      ( const lzo_bytep in , lzo_uint  in_len,
             while (tt > 255)
             {
                 tt -= 255;
-                *op++ = 0;
+                UA_SET1(op, 0);
+                op++;
             }
             assert(tt > 0);
             *op++ = LZO_BYTE(tt);
         }
-        do *op++ = *ii++; while (--t > 0);
+        UA_COPYN(op, ii, t);
+        op += t;
     }
 
     *op++ = M4_MARKER | 1;
@@ -3126,16 +4966,19 @@ DO_COMPRESS      ( const lzo_bytep in , lzo_uint  in_len,
 #    define LZO_TEST_OVERRUN_OUTPUT      2
 #  endif
 #  if !defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#    define LZO_TEST_OVERRUN_LOOKBEHIND
+#    define LZO_TEST_OVERRUN_LOOKBEHIND  1
 #  endif
 #endif
 
 #undef TEST_IP
 #undef TEST_OP
+#undef TEST_IP_AND_TEST_OP
 #undef TEST_LB
 #undef TEST_LBO
 #undef NEED_IP
 #undef NEED_OP
+#undef TEST_IV
+#undef TEST_OV
 #undef HAVE_TEST_IP
 #undef HAVE_TEST_OP
 #undef HAVE_NEED_IP
@@ -3150,6 +4993,7 @@ DO_COMPRESS      ( const lzo_bytep in , lzo_uint  in_len,
 #  if (LZO_TEST_OVERRUN_INPUT >= 2)
 #    define NEED_IP(x) \
             if ((lzo_uint)(ip_end - ip) < (lzo_uint)(x))  goto input_overrun
+#    define TEST_IV(x)          if ((x) >  (lzo_uint)0 - (511)) goto input_overrun
 #  endif
 #endif
 
@@ -3161,12 +5005,13 @@ DO_COMPRESS      ( const lzo_bytep in , lzo_uint  in_len,
 #    undef TEST_OP
 #    define NEED_OP(x) \
             if ((lzo_uint)(op_end - op) < (lzo_uint)(x))  goto output_overrun
+#    define TEST_OV(x)          if ((x) >  (lzo_uint)0 - (511)) goto output_overrun
 #  endif
 #endif
 
 #if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#  define TEST_LB(m_pos)        if (m_pos < out || m_pos >= op) goto lookbehind_overrun
-#  define TEST_LBO(m_pos,o)     if (m_pos < out || m_pos >= op - (o)) goto lookbehind_overrun
+#  define TEST_LB(m_pos)        if (PTR_LT(m_pos,out) || PTR_GE(m_pos,op)) goto lookbehind_overrun
+#  define TEST_LBO(m_pos,o)     if (PTR_LT(m_pos,out) || PTR_GE(m_pos,op-(o))) goto lookbehind_overrun
 #else
 #  define TEST_LB(m_pos)        ((void) 0)
 #  define TEST_LBO(m_pos,o)     ((void) 0)
@@ -3177,42 +5022,44 @@ DO_COMPRESS      ( const lzo_bytep in , lzo_uint  in_len,
 #endif
 
 #if defined(TEST_IP)
-#  define HAVE_TEST_IP
+#  define HAVE_TEST_IP 1
 #else
 #  define TEST_IP               1
 #endif
 #if defined(TEST_OP)
-#  define HAVE_TEST_OP
+#  define HAVE_TEST_OP 1
 #else
 #  define TEST_OP               1
 #endif
 
+#if defined(HAVE_TEST_IP) && defined(HAVE_TEST_OP)
+#  define TEST_IP_AND_TEST_OP   (TEST_IP && TEST_OP)
+#elif defined(HAVE_TEST_IP)
+#  define TEST_IP_AND_TEST_OP   TEST_IP
+#elif defined(HAVE_TEST_OP)
+#  define TEST_IP_AND_TEST_OP   TEST_OP
+#else
+#  define TEST_IP_AND_TEST_OP   1
+#endif
+
 #if defined(NEED_IP)
-#  define HAVE_NEED_IP
+#  define HAVE_NEED_IP 1
 #else
 #  define NEED_IP(x)            ((void) 0)
+#  define TEST_IV(x)            ((void) 0)
 #endif
 #if defined(NEED_OP)
-#  define HAVE_NEED_OP
+#  define HAVE_NEED_OP 1
 #else
 #  define NEED_OP(x)            ((void) 0)
+#  define TEST_OV(x)            ((void) 0)
 #endif
 
 #if defined(HAVE_TEST_IP) || defined(HAVE_NEED_IP)
-#  define HAVE_ANY_IP
+#  define HAVE_ANY_IP 1
 #endif
 #if defined(HAVE_TEST_OP) || defined(HAVE_NEED_OP)
-#  define HAVE_ANY_OP
-#endif
-
-#undef __COPY4
-#define __COPY4(dst,src)    * (lzo_uint32p)(dst) = * (const lzo_uint32p)(src)
-
-#undef COPY4
-#if defined(LZO_UNALIGNED_OK_4)
-#  define COPY4(dst,src)    __COPY4(dst,src)
-#elif defined(LZO_ALIGNED_OK_4)
-#  define COPY4(dst,src)    __COPY4((lzo_uintptr_t)(dst),(lzo_uintptr_t)(src))
+#  define HAVE_ANY_OP 1
 #endif
 
 #if defined(DO_DECOMPRESS)
@@ -3222,14 +5069,14 @@ DO_DECOMPRESS  ( const lzo_bytep in , lzo_uint  in_len,
                        lzo_voidp wrkmem )
 #endif
 {
-    register lzo_bytep op;
-    register const lzo_bytep ip;
-    register lzo_uint t;
+    lzo_bytep op;
+    const lzo_bytep ip;
+    lzo_uint t;
 #if defined(COPY_DICT)
     lzo_uint m_off;
     const lzo_bytep dict_end;
 #else
-    register const lzo_bytep m_pos;
+    const lzo_bytep m_pos;
 #endif
 
     const lzo_bytep const ip_end = in + in_len;
@@ -3264,46 +5111,65 @@ DO_DECOMPRESS  ( const lzo_bytep in , lzo_uint  in_len,
     op = out;
     ip = in;
 
+    NEED_IP(1);
     if (*ip > 17)
     {
         t = *ip++ - 17;
         if (t < 4)
             goto match_next;
-        assert(t > 0); NEED_OP(t); NEED_IP(t+1);
+        assert(t > 0); NEED_OP(t); NEED_IP(t+3);
         do *op++ = *ip++; while (--t > 0);
         goto first_literal_run;
     }
 
-    while (TEST_IP && TEST_OP)
+    for (;;)
     {
+        NEED_IP(3);
         t = *ip++;
         if (t >= 16)
             goto match;
         if (t == 0)
         {
-            NEED_IP(1);
             while (*ip == 0)
             {
                 t += 255;
                 ip++;
+                TEST_IV(t);
                 NEED_IP(1);
             }
             t += 15 + *ip++;
         }
-        assert(t > 0); NEED_OP(t+3); NEED_IP(t+4);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
+        assert(t > 0); NEED_OP(t+3); NEED_IP(t+6);
+#if (LZO_OPT_UNALIGNED64) && (LZO_OPT_UNALIGNED32)
+        t += 3;
+        if (t >= 8) do
+        {
+            UA_COPY8(op,ip);
+            op += 8; ip += 8; t -= 8;
+        } while (t >= 8);
+        if (t >= 4)
+        {
+            UA_COPY4(op,ip);
+            op += 4; ip += 4; t -= 4;
+        }
+        if (t > 0)
+        {
+            *op++ = *ip++;
+            if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }
+        }
+#elif (LZO_OPT_UNALIGNED32) || (LZO_ALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
         if (PTR_ALIGNED2_4(op,ip))
         {
 #endif
-        COPY4(op,ip);
+        UA_COPY4(op,ip);
         op += 4; ip += 4;
         if (--t > 0)
         {
             if (t >= 4)
             {
                 do {
-                    COPY4(op,ip);
+                    UA_COPY4(op,ip);
                     op += 4; ip += 4; t -= 4;
                 } while (t >= 4);
                 if (t > 0) do *op++ = *ip++; while (--t > 0);
@@ -3311,12 +5177,12 @@ DO_DECOMPRESS  ( const lzo_bytep in , lzo_uint  in_len,
             else
                 do *op++ = *ip++; while (--t > 0);
         }
-#if !defined(LZO_UNALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
         }
         else
 #endif
 #endif
-#if !defined(LZO_UNALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
         {
             *op++ = *ip++; *op++ = *ip++; *op++ = *ip++;
             do *op++ = *ip++; while (--t > 0);
@@ -3352,7 +5218,7 @@ first_literal_run:
 #endif
         goto match_done;
 
-        do {
+        for (;;) {
 match:
             if (t >= 64)
             {
@@ -3412,14 +5278,15 @@ match:
                 t &= 31;
                 if (t == 0)
                 {
-                    NEED_IP(1);
                     while (*ip == 0)
                     {
                         t += 255;
                         ip++;
+                        TEST_OV(t);
                         NEED_IP(1);
                     }
                     t += 31 + *ip++;
+                    NEED_IP(2);
                 }
 #if defined(COPY_DICT)
 #if defined(LZO1Z)
@@ -3435,9 +5302,9 @@ match:
                     m_pos = op - off;
                     last_m_off = off;
                 }
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
+#elif (LZO_OPT_UNALIGNED16) && (LZO_ABI_LITTLE_ENDIAN)
                 m_pos = op - 1;
-                m_pos -= (* (const lzo_ushortp) ip) >> 2;
+                m_pos -= UA_GET_LE16(ip) >> 2;
 #else
                 m_pos = op - 1;
                 m_pos -= (ip[0] >> 2) + (ip[1] << 6);
@@ -3456,14 +5323,15 @@ match:
                 t &= 7;
                 if (t == 0)
                 {
-                    NEED_IP(1);
                     while (*ip == 0)
                     {
                         t += 255;
                         ip++;
+                        TEST_OV(t);
                         NEED_IP(1);
                     }
                     t += 7 + *ip++;
+                    NEED_IP(2);
                 }
 #if defined(COPY_DICT)
 #if defined(LZO1Z)
@@ -3481,8 +5349,8 @@ match:
 #else
 #if defined(LZO1Z)
                 m_pos -= (ip[0] << 6) + (ip[1] >> 2);
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
-                m_pos -= (* (const lzo_ushortp) ip) >> 2;
+#elif (LZO_OPT_UNALIGNED16) && (LZO_ABI_LITTLE_ENDIAN)
+                m_pos -= UA_GET_LE16(ip) >> 2;
 #else
                 m_pos -= (ip[0] >> 2) + (ip[1] << 6);
 #endif
@@ -3530,8 +5398,29 @@ match:
 #else
 
             TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
+#if (LZO_OPT_UNALIGNED64) && (LZO_OPT_UNALIGNED32)
+            if (op - m_pos >= 8)
+            {
+                t += (3 - 1);
+                if (t >= 8) do
+                {
+                    UA_COPY8(op,m_pos);
+                    op += 8; m_pos += 8; t -= 8;
+                } while (t >= 8);
+                if (t >= 4)
+                {
+                    UA_COPY4(op,m_pos);
+                    op += 4; m_pos += 4; t -= 4;
+                }
+                if (t > 0)
+                {
+                    *op++ = m_pos[0];
+                    if (t > 1) { *op++ = m_pos[1]; if (t > 2) { *op++ = m_pos[2]; } }
+                }
+            }
+            else
+#elif (LZO_OPT_UNALIGNED32) || (LZO_ALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
             if (t >= 2 * 4 - (3 - 1) && PTR_ALIGNED2_4(op,m_pos))
             {
                 assert((op - m_pos) >= 4);
@@ -3539,10 +5428,10 @@ match:
             if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4)
             {
 #endif
-                COPY4(op,m_pos);
+                UA_COPY4(op,m_pos);
                 op += 4; m_pos += 4; t -= 4 - (3 - 1);
                 do {
-                    COPY4(op,m_pos);
+                    UA_COPY4(op,m_pos);
                     op += 4; m_pos += 4; t -= 4;
                 } while (t >= 4);
                 if (t > 0) do *op++ = *m_pos++; while (--t > 0);
@@ -3567,7 +5456,7 @@ match_done:
                 break;
 
 match_next:
-            assert(t > 0); assert(t < 4); NEED_OP(t); NEED_IP(t+1);
+            assert(t > 0); assert(t < 4); NEED_OP(t); NEED_IP(t+3);
 #if 0
             do *op++ = *ip++; while (--t > 0);
 #else
@@ -3575,16 +5464,10 @@ match_next:
             if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }
 #endif
             t = *ip++;
-        } while (TEST_IP && TEST_OP);
+        }
     }
 
-#if defined(HAVE_TEST_IP) || defined(HAVE_TEST_OP)
-    *out_len = pd(op, out);
-    return LZO_E_EOF_NOT_FOUND;
-#endif
-
 eof_found:
-    assert(t == 1);
     *out_len = pd(op, out);
     return (ip == ip_end ? LZO_E_OK :
            (ip < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));
@@ -3610,7 +5493,7 @@ lookbehind_overrun:
 
 #endif
 
-#define LZO_TEST_OVERRUN
+#define LZO_TEST_OVERRUN 1
 #undef DO_DECOMPRESS
 #define DO_DECOMPRESS       lzo1x_decompress_safe
 
@@ -3624,16 +5507,19 @@ lookbehind_overrun:
 #    define LZO_TEST_OVERRUN_OUTPUT      2
 #  endif
 #  if !defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#    define LZO_TEST_OVERRUN_LOOKBEHIND
+#    define LZO_TEST_OVERRUN_LOOKBEHIND  1
 #  endif
 #endif
 
 #undef TEST_IP
 #undef TEST_OP
+#undef TEST_IP_AND_TEST_OP
 #undef TEST_LB
 #undef TEST_LBO
 #undef NEED_IP
 #undef NEED_OP
+#undef TEST_IV
+#undef TEST_OV
 #undef HAVE_TEST_IP
 #undef HAVE_TEST_OP
 #undef HAVE_NEED_IP
@@ -3648,6 +5534,7 @@ lookbehind_overrun:
 #  if (LZO_TEST_OVERRUN_INPUT >= 2)
 #    define NEED_IP(x) \
             if ((lzo_uint)(ip_end - ip) < (lzo_uint)(x))  goto input_overrun
+#    define TEST_IV(x)          if ((x) >  (lzo_uint)0 - (511)) goto input_overrun
 #  endif
 #endif
 
@@ -3659,12 +5546,13 @@ lookbehind_overrun:
 #    undef TEST_OP
 #    define NEED_OP(x) \
             if ((lzo_uint)(op_end - op) < (lzo_uint)(x))  goto output_overrun
+#    define TEST_OV(x)          if ((x) >  (lzo_uint)0 - (511)) goto output_overrun
 #  endif
 #endif
 
 #if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#  define TEST_LB(m_pos)        if (m_pos < out || m_pos >= op) goto lookbehind_overrun
-#  define TEST_LBO(m_pos,o)     if (m_pos < out || m_pos >= op - (o)) goto lookbehind_overrun
+#  define TEST_LB(m_pos)        if (PTR_LT(m_pos,out) || PTR_GE(m_pos,op)) goto lookbehind_overrun
+#  define TEST_LBO(m_pos,o)     if (PTR_LT(m_pos,out) || PTR_GE(m_pos,op-(o))) goto lookbehind_overrun
 #else
 #  define TEST_LB(m_pos)        ((void) 0)
 #  define TEST_LBO(m_pos,o)     ((void) 0)
@@ -3675,42 +5563,44 @@ lookbehind_overrun:
 #endif
 
 #if defined(TEST_IP)
-#  define HAVE_TEST_IP
+#  define HAVE_TEST_IP 1
 #else
 #  define TEST_IP               1
 #endif
 #if defined(TEST_OP)
-#  define HAVE_TEST_OP
+#  define HAVE_TEST_OP 1
 #else
 #  define TEST_OP               1
 #endif
 
+#if defined(HAVE_TEST_IP) && defined(HAVE_TEST_OP)
+#  define TEST_IP_AND_TEST_OP   (TEST_IP && TEST_OP)
+#elif defined(HAVE_TEST_IP)
+#  define TEST_IP_AND_TEST_OP   TEST_IP
+#elif defined(HAVE_TEST_OP)
+#  define TEST_IP_AND_TEST_OP   TEST_OP
+#else
+#  define TEST_IP_AND_TEST_OP   1
+#endif
+
 #if defined(NEED_IP)
-#  define HAVE_NEED_IP
+#  define HAVE_NEED_IP 1
 #else
 #  define NEED_IP(x)            ((void) 0)
+#  define TEST_IV(x)            ((void) 0)
 #endif
 #if defined(NEED_OP)
-#  define HAVE_NEED_OP
+#  define HAVE_NEED_OP 1
 #else
 #  define NEED_OP(x)            ((void) 0)
+#  define TEST_OV(x)            ((void) 0)
 #endif
 
 #if defined(HAVE_TEST_IP) || defined(HAVE_NEED_IP)
-#  define HAVE_ANY_IP
+#  define HAVE_ANY_IP 1
 #endif
 #if defined(HAVE_TEST_OP) || defined(HAVE_NEED_OP)
-#  define HAVE_ANY_OP
-#endif
-
-#undef __COPY4
-#define __COPY4(dst,src)    * (lzo_uint32p)(dst) = * (const lzo_uint32p)(src)
-
-#undef COPY4
-#if defined(LZO_UNALIGNED_OK_4)
-#  define COPY4(dst,src)    __COPY4(dst,src)
-#elif defined(LZO_ALIGNED_OK_4)
-#  define COPY4(dst,src)    __COPY4((lzo_uintptr_t)(dst),(lzo_uintptr_t)(src))
+#  define HAVE_ANY_OP 1
 #endif
 
 #if defined(DO_DECOMPRESS)
@@ -3720,14 +5610,14 @@ DO_DECOMPRESS  ( const lzo_bytep in , lzo_uint  in_len,
                        lzo_voidp wrkmem )
 #endif
 {
-    register lzo_bytep op;
-    register const lzo_bytep ip;
-    register lzo_uint t;
+    lzo_bytep op;
+    const lzo_bytep ip;
+    lzo_uint t;
 #if defined(COPY_DICT)
     lzo_uint m_off;
     const lzo_bytep dict_end;
 #else
-    register const lzo_bytep m_pos;
+    const lzo_bytep m_pos;
 #endif
 
     const lzo_bytep const ip_end = in + in_len;
@@ -3762,46 +5652,65 @@ DO_DECOMPRESS  ( const lzo_bytep in , lzo_uint  in_len,
     op = out;
     ip = in;
 
+    NEED_IP(1);
     if (*ip > 17)
     {
         t = *ip++ - 17;
         if (t < 4)
             goto match_next;
-        assert(t > 0); NEED_OP(t); NEED_IP(t+1);
+        assert(t > 0); NEED_OP(t); NEED_IP(t+3);
         do *op++ = *ip++; while (--t > 0);
         goto first_literal_run;
     }
 
-    while (TEST_IP && TEST_OP)
+    for (;;)
     {
+        NEED_IP(3);
         t = *ip++;
         if (t >= 16)
             goto match;
         if (t == 0)
         {
-            NEED_IP(1);
             while (*ip == 0)
             {
                 t += 255;
                 ip++;
+                TEST_IV(t);
                 NEED_IP(1);
             }
             t += 15 + *ip++;
         }
-        assert(t > 0); NEED_OP(t+3); NEED_IP(t+4);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
+        assert(t > 0); NEED_OP(t+3); NEED_IP(t+6);
+#if (LZO_OPT_UNALIGNED64) && (LZO_OPT_UNALIGNED32)
+        t += 3;
+        if (t >= 8) do
+        {
+            UA_COPY8(op,ip);
+            op += 8; ip += 8; t -= 8;
+        } while (t >= 8);
+        if (t >= 4)
+        {
+            UA_COPY4(op,ip);
+            op += 4; ip += 4; t -= 4;
+        }
+        if (t > 0)
+        {
+            *op++ = *ip++;
+            if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }
+        }
+#elif (LZO_OPT_UNALIGNED32) || (LZO_ALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
         if (PTR_ALIGNED2_4(op,ip))
         {
 #endif
-        COPY4(op,ip);
+        UA_COPY4(op,ip);
         op += 4; ip += 4;
         if (--t > 0)
         {
             if (t >= 4)
             {
                 do {
-                    COPY4(op,ip);
+                    UA_COPY4(op,ip);
                     op += 4; ip += 4; t -= 4;
                 } while (t >= 4);
                 if (t > 0) do *op++ = *ip++; while (--t > 0);
@@ -3809,12 +5718,12 @@ DO_DECOMPRESS  ( const lzo_bytep in , lzo_uint  in_len,
             else
                 do *op++ = *ip++; while (--t > 0);
         }
-#if !defined(LZO_UNALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
         }
         else
 #endif
 #endif
-#if !defined(LZO_UNALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
         {
             *op++ = *ip++; *op++ = *ip++; *op++ = *ip++;
             do *op++ = *ip++; while (--t > 0);
@@ -3850,7 +5759,7 @@ first_literal_run:
 #endif
         goto match_done;
 
-        do {
+        for (;;) {
 match:
             if (t >= 64)
             {
@@ -3910,14 +5819,15 @@ match:
                 t &= 31;
                 if (t == 0)
                 {
-                    NEED_IP(1);
                     while (*ip == 0)
                     {
                         t += 255;
                         ip++;
+                        TEST_OV(t);
                         NEED_IP(1);
                     }
                     t += 31 + *ip++;
+                    NEED_IP(2);
                 }
 #if defined(COPY_DICT)
 #if defined(LZO1Z)
@@ -3933,9 +5843,9 @@ match:
                     m_pos = op - off;
                     last_m_off = off;
                 }
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
+#elif (LZO_OPT_UNALIGNED16) && (LZO_ABI_LITTLE_ENDIAN)
                 m_pos = op - 1;
-                m_pos -= (* (const lzo_ushortp) ip) >> 2;
+                m_pos -= UA_GET_LE16(ip) >> 2;
 #else
                 m_pos = op - 1;
                 m_pos -= (ip[0] >> 2) + (ip[1] << 6);
@@ -3954,14 +5864,15 @@ match:
                 t &= 7;
                 if (t == 0)
                 {
-                    NEED_IP(1);
                     while (*ip == 0)
                     {
                         t += 255;
                         ip++;
+                        TEST_OV(t);
                         NEED_IP(1);
                     }
                     t += 7 + *ip++;
+                    NEED_IP(2);
                 }
 #if defined(COPY_DICT)
 #if defined(LZO1Z)
@@ -3979,8 +5890,8 @@ match:
 #else
 #if defined(LZO1Z)
                 m_pos -= (ip[0] << 6) + (ip[1] >> 2);
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
-                m_pos -= (* (const lzo_ushortp) ip) >> 2;
+#elif (LZO_OPT_UNALIGNED16) && (LZO_ABI_LITTLE_ENDIAN)
+                m_pos -= UA_GET_LE16(ip) >> 2;
 #else
                 m_pos -= (ip[0] >> 2) + (ip[1] << 6);
 #endif
@@ -4028,8 +5939,29 @@ match:
 #else
 
             TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
+#if (LZO_OPT_UNALIGNED64) && (LZO_OPT_UNALIGNED32)
+            if (op - m_pos >= 8)
+            {
+                t += (3 - 1);
+                if (t >= 8) do
+                {
+                    UA_COPY8(op,m_pos);
+                    op += 8; m_pos += 8; t -= 8;
+                } while (t >= 8);
+                if (t >= 4)
+                {
+                    UA_COPY4(op,m_pos);
+                    op += 4; m_pos += 4; t -= 4;
+                }
+                if (t > 0)
+                {
+                    *op++ = m_pos[0];
+                    if (t > 1) { *op++ = m_pos[1]; if (t > 2) { *op++ = m_pos[2]; } }
+                }
+            }
+            else
+#elif (LZO_OPT_UNALIGNED32) || (LZO_ALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
             if (t >= 2 * 4 - (3 - 1) && PTR_ALIGNED2_4(op,m_pos))
             {
                 assert((op - m_pos) >= 4);
@@ -4037,10 +5969,10 @@ match:
             if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4)
             {
 #endif
-                COPY4(op,m_pos);
+                UA_COPY4(op,m_pos);
                 op += 4; m_pos += 4; t -= 4 - (3 - 1);
                 do {
-                    COPY4(op,m_pos);
+                    UA_COPY4(op,m_pos);
                     op += 4; m_pos += 4; t -= 4;
                 } while (t >= 4);
                 if (t > 0) do *op++ = *m_pos++; while (--t > 0);
@@ -4065,7 +5997,7 @@ match_done:
                 break;
 
 match_next:
-            assert(t > 0); assert(t < 4); NEED_OP(t); NEED_IP(t+1);
+            assert(t > 0); assert(t < 4); NEED_OP(t); NEED_IP(t+3);
 #if 0
             do *op++ = *ip++; while (--t > 0);
 #else
@@ -4073,16 +6005,10 @@ match_next:
             if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }
 #endif
             t = *ip++;
-        } while (TEST_IP && TEST_OP);
+        }
     }
 
-#if defined(HAVE_TEST_IP) || defined(HAVE_TEST_OP)
-    *out_len = pd(op, out);
-    return LZO_E_EOF_NOT_FOUND;
-#endif
-
 eof_found:
-    assert(t == 1);
     *out_len = pd(op, out);
     return (ip == ip_end ? LZO_E_OK :
            (ip < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));
@@ -4109,4 +6035,3 @@ lookbehind_overrun:
 #endif
 
 /***** End of minilzo.c *****/
-
diff --git a/mythtv/libs/libmythtv/minilzo.h b/mythtv/libs/libmythtv/minilzo.h
index 0aff50e..fd2fb32 100644
--- a/mythtv/libs/libmythtv/minilzo.h
+++ b/mythtv/libs/libmythtv/minilzo.h
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -45,9 +33,9 @@
 
 
 #ifndef __MINILZO_H
-#define __MINILZO_H
+#define __MINILZO_H 1
 
-#define MINILZO_VERSION         0x2030
+#define MINILZO_VERSION         0x2070
 
 #ifdef __LZOCONF_H
 #  error "you cannot use both LZO and miniLZO"
@@ -75,7 +63,7 @@ extern "C" {
  */
 
 #define LZO1X_MEM_COMPRESS      LZO1X_1_MEM_COMPRESS
-#define LZO1X_1_MEM_COMPRESS    ((lzo_uint32) (16384L * lzo_sizeof_dict_t))
+#define LZO1X_1_MEM_COMPRESS    ((lzo_uint32_t) (16384L * lzo_sizeof_dict_t))
 #define LZO1X_MEM_DECOMPRESS    (0)
 
 
diff --git a/mythtv/libs/libmythtv/mpeg/dvbstreamdata.cpp b/mythtv/libs/libmythtv/mpeg/dvbstreamdata.cpp
index 40d056d..5ecc052 100644
--- a/mythtv/libs/libmythtv/mpeg/dvbstreamdata.cpp
+++ b/mythtv/libs/libmythtv/mpeg/dvbstreamdata.cpp
@@ -436,7 +436,15 @@ void DVBStreamData::ProcessSDT(uint tsid, const ServiceDescriptionTable *sdt)
 
     for (uint i = 0; i < sdt->ServiceCount(); i++)
     {
+        /*
+         * FIXME always signal EIT presence. We filter later. To many
+         * networks set these flags wrong.
+         * This allows the user to simply set useonairguide on a
+         * channel manually.
+         */
+#if 0
         if (sdt->HasEITSchedule(i) || sdt->HasEITPresentFollowing(i))
+#endif
             _dvb_has_eit[sdt->ServiceID(i)] = true;
     }
 
diff --git a/mythtv/libs/libmythtv/mythplayer.cpp b/mythtv/libs/libmythtv/mythplayer.cpp
index 5dbcac0..33d4f9d 100644
--- a/mythtv/libs/libmythtv/mythplayer.cpp
+++ b/mythtv/libs/libmythtv/mythplayer.cpp
@@ -372,6 +372,8 @@ bool MythPlayer::Pause(void)
     audio.Pause(true);
     PauseDecoder();
     PauseBuffer();
+    if (!decoderPaused)
+        PauseDecoder(); // Retry in case audio only stream
     allpaused = decoderPaused && videoPaused && bufferPaused;
     {
         if (FlagIsSet(kVideoIsNull) && decoder)
@@ -385,7 +387,7 @@ bool MythPlayer::Pause(void)
 
 bool MythPlayer::Play(float speed, bool normal, bool unpauseaudio)
 {
-    pauseLock.lock();
+    QMutexLocker locker(&pauseLock);
     LOG(VB_PLAYBACK, LOG_INFO, LOC +
         QString("Play(%1, normal %2, unpause audio %3)")
             .arg(speed,5,'f',1).arg(normal).arg(unpauseaudio));
@@ -393,10 +395,10 @@ bool MythPlayer::Play(float speed, bool normal, bool unpauseaudio)
     if (deleteMap.IsEditing())
     {
         LOG(VB_GENERAL, LOG_ERR, LOC + "Ignoring Play(), in edit mode.");
-        pauseLock.unlock();
         return false;
     }
 
+    SetEof(kEofStateNone);
     UnpauseBuffer();
     UnpauseDecoder();
     if (unpauseaudio)
@@ -405,7 +407,6 @@ bool MythPlayer::Play(float speed, bool normal, bool unpauseaudio)
     allpaused = false;
     next_play_speed   = speed;
     next_normal_speed = normal;
-    pauseLock.unlock();
     return true;
 }
 
@@ -928,7 +929,7 @@ int MythPlayer::OpenFile(uint retries)
     int testreadsize = 2048;
 
     MythTimer bigTimer; bigTimer.start();
-    int timeout = (retries + 1) * 600;
+    int timeout = max((retries + 1) * 500, 15000U);
     while (testreadsize <= kDecoderProbeBufferSize)
     {
         MythTimer peekTimer; peekTimer.start();
@@ -945,7 +946,7 @@ int MythPlayer::OpenFile(uint retries)
                 return -1;
             }
             LOG(VB_GENERAL, LOG_WARNING, LOC + "OpenFile() waiting on data");
-            usleep(50 * 1000);
+            usleep(150 * 1000);
         }
 
         player_ctx->LockPlayingInfo(__FILE__, __LINE__);
@@ -2189,8 +2190,15 @@ void MythPlayer::DisplayNormalFrame(bool check_prebuffer)
     // clear the buffering state
     SetBuffering(false);
 
+    // If PiP then release the last shown frame to the decoding queue
+    if (player_ctx->IsPIP())
+        videoOutput->DoneDisplayingFrame(videoOutput->GetLastShownFrame());
+
     // retrieve the next frame
-    videoOutput->StartDisplayingFrame();
+    bool const bDisplayFrame = videoOutput->ValidVideoFrames() > 0;
+    if (bDisplayFrame)
+        videoOutput->StartDisplayingFrame();
+
     VideoFrame *frame = videoOutput->GetLastShownFrame();
 
     // Check aspect ratio
@@ -2199,9 +2207,12 @@ void MythPlayer::DisplayNormalFrame(bool check_prebuffer)
     // Player specific processing (dvd, bd, mheg etc)
     PreProcessNormalFrame();
 
-    // handle scan type changes
-    AutoDeint(frame);
-    detect_letter_box->SwitchTo(frame);
+    if (GetTrackCount(kTrackTypeVideo))
+    {
+        // handle scan type changes
+        AutoDeint(frame);
+        detect_letter_box->SwitchTo(frame);
+    }
 
     FrameScanType ps = m_scan;
     if (kScan_Detect == m_scan || kScan_Ignore == m_scan)
@@ -2214,7 +2225,11 @@ void MythPlayer::DisplayNormalFrame(bool check_prebuffer)
     osdLock.unlock();
 
     AVSync(frame, 0);
-    videoOutput->DoneDisplayingFrame(frame);
+    // If PiP then keep this frame for MythPlayer::GetCurrentFrame
+    if (player_ctx->IsPIP())
+        return;
+    if (bDisplayFrame)
+        videoOutput->DoneDisplayingFrame(frame);
 }
 
 void MythPlayer::PreProcessNormalFrame(void)
@@ -2223,10 +2238,12 @@ void MythPlayer::PreProcessNormalFrame(void)
     // handle Interactive TV
     if (GetInteractiveTV())
     {
-        osdLock.lock();
-        itvLock.lock();
+        QMutexLocker lk1(&osdLock);
+
         if (osd && videoOutput->GetOSDPainter())
         {
+            QMutexLocker lk2(&itvLock);
+
             InteractiveScreen *window =
                 (InteractiveScreen*)osd->GetWindow(OSD_WIN_INTERACT);
             if ((interactiveTV->ImageHasChanged() || !itvVisible) && window)
@@ -2235,8 +2252,6 @@ void MythPlayer::PreProcessNormalFrame(void)
                 itvVisible = true;
             }
         }
-        itvLock.unlock();
-        osdLock.unlock();
     }
 #endif // USING_MHEG
 }
@@ -2404,7 +2419,7 @@ bool MythPlayer::VideoLoop(void)
         DisplayPauseFrame();
     }
     else
-        DisplayNormalFrame();
+        DisplayNormalFrame(GetTrackCount(kTrackTypeVideo));
 
     if (FlagIsSet(kVideoIsNull) && decoder)
         decoder->UpdateFramesPlayed();
@@ -2534,7 +2549,10 @@ void MythPlayer::SwitchToProgram(void)
     ProgramInfo *pginfo = player_ctx->tvchain->GetSwitchProgram(
         discontinuity, newtype, newid);
     if (!pginfo)
+    {
+        LOG(VB_GENERAL, LOG_ERR, LOC + "SwitchToProgram - No ProgramInfo");
         return;
+    }
 
     bool newIsDummy = player_ctx->tvchain->GetCardType(newid) == "DUMMY";
 
@@ -2669,7 +2687,10 @@ void MythPlayer::JumpToProgram(void)
     ProgramInfo *pginfo = player_ctx->tvchain->GetSwitchProgram(
         discontinuity, newtype, newid);
     if (!pginfo)
+    {
+        LOG(VB_GENERAL, LOG_ERR, LOC + "JumpToProgram - No ProgramInfo");
         return;
+    }
 
     inJumpToProgramPause = true;
 
@@ -2677,7 +2698,6 @@ void MythPlayer::JumpToProgram(void)
     SetPlayingInfo(*pginfo);
 
     Pause();
-    ChangeSpeed();
     ResetCaptions();
     player_ctx->tvchain->SetProgram(*pginfo);
     player_ctx->buffer->Reset(true);
@@ -2915,12 +2935,11 @@ void MythPlayer::EventLoop(void)
         JumpToProgram();
     }
     else if ((!allpaused || GetEof() != kEofStateNone) &&
-             player_ctx->tvchain &&
-             (decoder && !decoder->GetWaitForChange()))
+             decoder && !decoder->GetWaitForChange() &&
+             player_ctx->tvchain && player_ctx->tvchain->NeedsToSwitch())
     {
         // Switch to the next program in livetv
-        if (player_ctx->tvchain->NeedsToSwitch())
-            SwitchToProgram();
+        SwitchToProgram();
     }
 
     // Jump to the next program in livetv
@@ -3114,36 +3133,35 @@ void MythPlayer::AudioEnd(void)
 
 bool MythPlayer::PauseDecoder(void)
 {
-    decoderPauseLock.lock();
+    QMutexLocker locker(&decoderPauseLock);
     if (is_current_thread(decoderThread))
     {
+        pauseDecoder = false;
         decoderPaused = true;
         decoderThreadPause.wakeAll();
-        decoderPauseLock.unlock();
-        return decoderPaused;
+        return true;
     }
 
-    int tries = 0;
     pauseDecoder = true;
-    while (decoderThread && !killdecoder && (tries++ < 100) &&
-           !decoderThreadPause.wait(&decoderPauseLock, 100))
+    int tries = 0;
+    while (!decoderPaused && decoderThread && !killdecoder && (tries++ < 10) &&
+          !decoderThreadPause.wait(locker.mutex(), 100))
     {
         LOG(VB_GENERAL, LOG_WARNING, LOC + "Waited 100ms for decoder to pause");
     }
     pauseDecoder = false;
-    decoderPauseLock.unlock();
     return decoderPaused;
-}
+ }
 
 void MythPlayer::UnpauseDecoder(void)
 {
-    decoderPauseLock.lock();
+    QMutexLocker locker(&decoderPauseLock);
 
     if (is_current_thread(decoderThread))
     {
+        unpauseDecoder = false;
         decoderPaused = false;
         decoderThreadUnpause.wakeAll();
-        decoderPauseLock.unlock();
         return;
     }
 
@@ -3151,15 +3169,14 @@ void MythPlayer::UnpauseDecoder(void)
     {
         int tries = 0;
         unpauseDecoder = true;
-        while (decoderThread && !killdecoder && (tries++ < 100) &&
-              !decoderThreadUnpause.wait(&decoderPauseLock, 100))
+        while (decoderPaused && decoderThread && !killdecoder && (tries++ < 10) &&
+              !decoderThreadUnpause.wait(locker.mutex(), 100))
         {
             LOG(VB_GENERAL, LOG_WARNING, LOC +
                 "Waited 100ms for decoder to unpause");
         }
         unpauseDecoder = false;
     }
-    decoderPauseLock.unlock();
 }
 
 void MythPlayer::DecoderStart(bool start_paused)
@@ -3185,7 +3202,7 @@ void MythPlayer::DecoderEnd(void)
     SetPlaying(false);
     killdecoder = true;
     int tries = 0;
-    while (decoderThread && !decoderThread->wait(100) && (tries++ < 50))
+    while (decoderThread && !decoderThread->wait(100) && (tries++ < 20))
         LOG(VB_PLAYBACK, LOG_INFO, LOC +
             "Waited 100ms for decoder loop to stop");
 
@@ -3198,12 +3215,23 @@ void MythPlayer::DecoderEnd(void)
 
 void MythPlayer::DecoderPauseCheck(void)
 {
-    if (is_current_thread(decoderThread))
+    if (!is_current_thread(decoderThread))
+        return;
+
+    QMutexLocker locker(&decoderPauseLock);
+
+    if (pauseDecoder)
+    {
+        pauseDecoder = false;
+        decoderPaused = true;
+        decoderThreadPause.wakeAll();
+    }
+
+    if (unpauseDecoder)
     {
-        if (pauseDecoder)
-            PauseDecoder();
-        if (unpauseDecoder)
-            UnpauseDecoder();
+        unpauseDecoder = false;
+        decoderPaused = false;
+        decoderThreadUnpause.wakeAll();
     }
 }
 
@@ -3760,19 +3788,21 @@ long long MythPlayer::CalcMaxFFTime(long long ffframes, bool setjump) const
         if (behind < maxtime * 3)
             limitKeyRepeat = true;
     }
+    else if (IsPaused())
+    {
+        uint64_t lastFrame  = deleteMap.IsEmpty() ? totalFrames
+                                                 : deleteMap.GetLastFrame();
+        if (framesPlayed + ffframes >= lastFrame)
+            ret = lastFrame - 1 - framesPlayed;
+    }
     else
     {
-        if (totalFrames > 0)
-        {
-            float behind = secsWritten - secsPlayed;
-            if (behind < maxtime)
-                ret = 0;
-            else if (behind - ff <= maxtime * 2)
-            {
-                uint64_t ms = 1000 * (secsWritten - maxtime * 2);
-                ret = TranslatePositionMsToFrame(ms, true) - framesPlayed;
-            }
-        }
+        float secsMax = secsWritten - 2.f * maxtime;
+        if (secsMax <= 0.f)
+            ret = 0;
+        else if (secsMax < secsPlayed + ff)
+            ret = TranslatePositionMsToFrame(1000 * secsMax, true)
+                    - framesPlayed;
     }
 
     return ret;
@@ -4072,7 +4102,9 @@ bool MythPlayer::HandleProgramEditorActions(QStringList &actions)
             if (seekamount == 0) // 1 frame
                 DoRewind(1, kInaccuracyNone);
             else if (seekamount > 0)
-                DoRewindSecs(seekamount, kInaccuracyEditor, false);
+                // Use fully-accurate seeks for less than 1 second.
+                DoRewindSecs(seekamount, seekamount < 1.0 ? kInaccuracyNone :
+                             kInaccuracyEditor, false);
             else
                 HandleArbSeek(false);
         }
@@ -4081,7 +4113,9 @@ bool MythPlayer::HandleProgramEditorActions(QStringList &actions)
             if (seekamount == 0) // 1 frame
                 DoFastForward(1, kInaccuracyNone);
             else if (seekamount > 0)
-                DoFastForwardSecs(seekamount, kInaccuracyEditor, false);
+                // Use fully-accurate seeks for less than 1 second.
+                DoFastForwardSecs(seekamount, seekamount < 1.0 ? kInaccuracyNone :
+                             kInaccuracyEditor, false);
             else
                 HandleArbSeek(true);
         }
@@ -4650,7 +4684,10 @@ bool MythPlayer::TranscodeGetNextFrame(
                 QString("Fast-Forwarding from %1 to %2")
                     .arg(lastDecodedFrameNumber).arg(jumpto));
             if (jumpto >= totalFrames)
+            {
+                SetEof(kEofStateDelayed);
                 return false;
+            }
 
             // For 0.25, move this to DoJumpToFrame(jumpto)
             WaitForSeek(jumpto, 0);
diff --git a/mythtv/libs/libmythtv/openglvideo.cpp b/mythtv/libs/libmythtv/openglvideo.cpp
index dbd39e2..2de7d4c 100644
--- a/mythtv/libs/libmythtv/openglvideo.cpp
+++ b/mythtv/libs/libmythtv/openglvideo.cpp
@@ -141,7 +141,7 @@ bool OpenGLVideo::Init(MythRenderOpenGL *glcontext, VideoColourSpace *colourspac
     display_visible_rect  = displayVisibleRect;
     display_video_rect    = displayVideoRect;
     video_rect            = videoRect;
-    masterViewportSize    = QSize(1920, 1080);
+    masterViewportSize    = display_visible_rect.size();
     frameBufferRect       = QRect(QPoint(0,0), video_disp_dim);
     softwareDeinterlacer  = "";
     hardwareDeinterlacing = false;
diff --git a/mythtv/libs/libmythtv/programdata.cpp b/mythtv/libs/libmythtv/programdata.cpp
index b182d1e..9368517 100644
--- a/mythtv/libs/libmythtv/programdata.cpp
+++ b/mythtv/libs/libmythtv/programdata.cpp
@@ -28,6 +28,11 @@ static QString denullify(const QString &str)
     return str.isNull() ? "" : str;
 }
 
+static QVariant denullify(const QDateTime &dt)
+{
+    return dt.isNull() ? QVariant("0000-00-00 00:00:00") : QVariant(dt);
+}
+
 DBPerson::DBPerson(const DBPerson &other) :
     role(other.role), name(other.name)
 {
@@ -858,7 +863,7 @@ uint ProgInfo::InsertDB(MSqlQuery &query, uint chanid) const
     query.bindValue(":CATEGORY",    denullify(category));
     query.bindValue(":CATTYPE",     cattype);
     query.bindValue(":STARTTIME",   starttime);
-    query.bindValue(":ENDTIME",     endtime);
+    query.bindValue(":ENDTIME",     denullify(endtime));
     query.bindValue(":CC",
                     subtitleType & SUB_HARDHEAR ? true : false);
     query.bindValue(":STEREO",
@@ -998,25 +1003,9 @@ void ProgramData::FixProgramList(QList<ProgInfo*> &fixlist)
                 (*cur)->endts   = (*it)->startts;
                 (*cur)->endtime = (*it)->starttime;
             }
-            else
-            {
-                (*cur)->endtime = (*cur)->starttime;
-                if ((*cur)->endtime < QDateTime(
-                        (*cur)->endtime.date(), QTime(6, 0), Qt::UTC))
-                {
-                    (*cur)->endtime = QDateTime(
-                        (*cur)->endtime.date(), QTime(6, 0), Qt::UTC);
-                }
-                else
-                {
-                    (*cur)->endtime = QDateTime(
-                        (*cur)->endtime.date().addDays(1),
-                        QTime(0, 0), Qt::UTC);
-                }
-
-                (*cur)->endts =
-                    MythDate::toString((*cur)->endtime, MythDate::kFilename);
-            }
+            /* if its the last programme in the file then leave its
+               endtime as 0000-00-00 00:00:00 so we can find it easily in
+               fix_end_times() */
         }
 
         if (it == fixlist.end())
@@ -1153,7 +1142,7 @@ int ProgramData::fix_end_times(void)
     MSqlQuery query1(MSqlQuery::InitCon()), query2(MSqlQuery::InitCon());
 
     querystr = "SELECT chanid, starttime, endtime FROM program "
-               "WHERE (DATE_FORMAT(endtime,'%H%i') = '0000') "
+               "WHERE endtime = '0000-00-00 00:00:00' "
                "ORDER BY chanid, starttime;";
 
     if (!query1.exec(querystr))
@@ -1170,11 +1159,10 @@ int ProgramData::fix_end_times(void)
         endtime = query1.value(2).toString();
 
         querystr = QString("SELECT chanid, starttime, endtime FROM program "
-                           "WHERE starttime BETWEEN '%1 00:00:00'"
-                           "AND '%2 23:59:59' AND chanid = '%3' "
+                           "WHERE starttime > '%1' "
+                           "AND chanid = '%2' "
                            "ORDER BY starttime LIMIT 1;")
-                           .arg(endtime.left(10))
-                           .arg(endtime.left(10))
+                           .arg(starttime)
                            .arg(chanid);
 
         if (!query2.exec(querystr))
@@ -1188,10 +1176,9 @@ int ProgramData::fix_end_times(void)
         {
             count++;
             endtime = query2.value(1).toString();
-            querystr = QString("UPDATE program SET starttime = '%1', "
+            querystr = QString("UPDATE program SET "
                                "endtime = '%2' WHERE (chanid = '%3' AND "
                                "starttime = '%4');")
-                               .arg(starttime)
                                .arg(endtime)
                                .arg(chanid)
                                .arg(starttime);
diff --git a/mythtv/libs/libmythtv/ringbuffer.cpp b/mythtv/libs/libmythtv/ringbuffer.cpp
index 3a11b26..5e0e775 100644
--- a/mythtv/libs/libmythtv/ringbuffer.cpp
+++ b/mythtv/libs/libmythtv/ringbuffer.cpp
@@ -312,6 +312,12 @@ void RingBuffer::UpdateRawBitrate(uint raw_bitrate)
             QString("Bitrate too low - setting to 64Kb"));
         raw_bitrate = 64;
     }
+    else if (raw_bitrate > 100000)
+    {
+        LOG(VB_FILE, LOG_INFO, LOC +
+            QString("Bitrate too high - setting to 100Mb"));
+        raw_bitrate = 100000;
+    }
 
     rwlock.lockForWrite();
     rawbitrate = raw_bitrate;
@@ -407,6 +413,7 @@ void RingBuffer::CalcReadAheadThresh(void)
         }
         low_buffers = false;
         fill_min = ((fill_min / CHUNK) + 1) * CHUNK;
+        fill_min = min((uint)fill_min, bufferSize / 2);
     }
     else
     {
@@ -532,6 +539,8 @@ long long RingBuffer::Seek(long long pos, int whence, bool has_lock)
         ret = SeekInternal(pos, whence);
     }
 
+    generalWait.wakeAll();
+
     if (!has_lock)
     {
         rwlock.unlock();
@@ -666,7 +675,7 @@ void RingBuffer::Start(void)
 
     MThread::start();
 
-    while (readaheadrunning && !reallyrunning)
+    while (!readaheadrunning && !reallyrunning)
         generalWait.wait(&rwlock);
 
     rwlock.unlock();
@@ -927,7 +936,7 @@ void RingBuffer::run(void)
 
         // These are conditions where we want to sleep to allow
         // other threads to do stuff.
-        if (setswitchtonext || (ateof && readsallowed))
+        if (setswitchtonext || (ateof && readsdesired))
         {
             ignore_for_read_timing = true;
             generalWait.wait(&rwlock, 1000);
@@ -1236,7 +1245,7 @@ bool RingBuffer::WaitForReadsAllowed(void)
            !request_pause && !commserror && readaheadrunning)
     {
         generalWait.wait(&rwlock, clamp(timeout_ms - t.elapsed(), 10, 100));
-        if (!readsallowed && t.elapsed() > 1000 && (count % 10) == 0)
+        if (!check && t.elapsed() > 1000 && (count % 10) == 0)
         {
             LOG(VB_GENERAL, LOG_WARNING, LOC +
                 "Taking too long to be allowed to read..");
@@ -1383,8 +1392,7 @@ int RingBuffer::ReadPriv(void *buf, int count, bool peek)
         return -1;
     }
 
-    if (!readInternalMode &&
-        (request_pause || stopreads || !readaheadrunning || (ignorereadpos>=0)))
+    if (request_pause || stopreads || !readaheadrunning || (ignorereadpos>=0))
     {
         rwlock.unlock();
         rwlock.lockForWrite();
@@ -1472,6 +1480,7 @@ int RingBuffer::ReadPriv(void *buf, int count, bool peek)
         rwlock.lockForWrite();
         ateof = true;
         wanttoread = 0;
+        generalWait.wakeAll();
         rwlock.unlock();
         return count;
     }
diff --git a/mythtv/libs/libmythtv/subtitlescreen.cpp b/mythtv/libs/libmythtv/subtitlescreen.cpp
index 893724c..a3863f6 100644
--- a/mythtv/libs/libmythtv/subtitlescreen.cpp
+++ b/mythtv/libs/libmythtv/subtitlescreen.cpp
@@ -1985,38 +1985,44 @@ bool FormattedTextSubtitle::Draw(const QString &base,
             // Don't draw a background behind leading spaces.
             if (first)
                 bgrect.setLeft(bgrect.left() + x_adjust);
-            MythUIShape *bgshape =
-                parent->m_format->
-                GetBackground(parent,
-                              QString("subbg%1x%2@%3,%4")
-                              .arg(chunk_sz.width()).arg(height)
-                              .arg(x).arg(y),
-                              base, (*chunk).format);
-            bgshape->SetArea(MythRect(bgrect));
-            if (imageCache)
-                imageCache->append(bgshape);
-            if (duration > 0)
-                parent->RegisterExpiration(bgshape, start + duration);
-            result = true;
+            if (bgrect.width() > 0)
+            {
+                MythUIShape *bgshape =
+                    parent->m_format->
+                    GetBackground(parent,
+                                  QString("subbg%1x%2@%3,%4")
+                                  .arg(chunk_sz.width()).arg(height)
+                                  .arg(x).arg(y),
+                                  base, (*chunk).format);
+                bgshape->SetArea(MythRect(bgrect));
+                if (imageCache)
+                    imageCache->append(bgshape);
+                if (duration > 0)
+                    parent->RegisterExpiration(bgshape, start + duration);
+                result = true;
+            }
             // Shift to the right to account for leading spaces that
             // are removed by the MythUISimpleText constructor.  Also
             // add in padding at the end to avoid clipping.
             QRect rect(x + x_adjust, y,
                        chunk_sz.width() - x_adjust + rightPadding, height);
 
-            MythUISimpleText *text =
-                new MythUISimpleText((*chunk).text, *mythfont, rect,
-                                     Qt::AlignLeft, (MythUIType*)parent,
-                                     QString("subtxt%1x%2@%3,%4")
-                                     .arg(chunk_sz.width())
-                                     .arg(height)
-                                     .arg(x).arg(y));
-            bringToFront.append(text);
-            if (imageCache)
-                imageCache->append(text);
-            if (duration > 0)
-                parent->RegisterExpiration(text, start + duration);
-            result = true;
+            if (rect.width() > 0)
+            {
+                MythUISimpleText *text =
+                    new MythUISimpleText((*chunk).text, *mythfont, rect,
+                                         Qt::AlignLeft, (MythUIType*)parent,
+                                         QString("subtxt%1x%2@%3,%4")
+                                         .arg(chunk_sz.width())
+                                         .arg(height)
+                                         .arg(x).arg(y));
+                bringToFront.append(text);
+                if (imageCache)
+                    imageCache->append(text);
+                if (duration > 0)
+                    parent->RegisterExpiration(text, start + duration);
+                result = true;
+            }
 
             LOG(VB_VBI, LOG_INFO,
                 QString("Drawing chunk at (%1,%2): %3")
diff --git a/mythtv/libs/libmythtv/tv_play.cpp b/mythtv/libs/libmythtv/tv_play.cpp
index e193a53..33cf6ac 100644
--- a/mythtv/libs/libmythtv/tv_play.cpp
+++ b/mythtv/libs/libmythtv/tv_play.cpp
@@ -438,6 +438,7 @@ bool TV::StartTV(ProgramInfo *tvrec, uint flags,
             mctx->UnlockDeletePlayer(__FILE__, __LINE__);
         }
         tv->ReturnPlayerLock(mctx);
+        quitAll |= !playerError.isEmpty();
     }
 
     LOG(VB_PLAYBACK, LOG_INFO, LOC + "StartTV -- process events 2 begin");
@@ -5854,7 +5855,8 @@ void TV::PxPToggleType(PlayerContext *mctx, bool wantPBP)
     if (wantPBP)
     {
         GetPlayer(mctx, 0)->SetPIPState(kPBPLeft);
-        GetPlayer(mctx, 1)->SetPIPState(kPBPRight);
+        if (player.size() > 1)
+            GetPlayer(mctx, 1)->SetPIPState(kPBPRight);
     }
     else
     {
@@ -7750,7 +7752,8 @@ void TV::ChangeChannel(PlayerContext *ctx, uint chanid, const QString &chan)
     if (ctx->prevChan.empty())
         ctx->PushPreviousChannel();
 
-    PauseAudioUntilBuffered(ctx);
+    if (ctx->player)
+        ctx->player->GetAudio()->Pause(true);
     PauseLiveTV(ctx);
 
     ctx->LockDeletePlayer(__FILE__, __LINE__);
@@ -7767,6 +7770,7 @@ void TV::ChangeChannel(PlayerContext *ctx, uint chanid, const QString &chan)
         ctx->player->GetAudio()->Reset();
 
     UnpauseLiveTV(ctx, chanid && GetQueuedChanID());
+    PauseAudioUntilBuffered(ctx);
 
     if (oldinputname != ctx->recorder->GetInput())
         UpdateOSDInput(ctx);
diff --git a/mythtv/libs/libmythtv/videobuffers.cpp b/mythtv/libs/libmythtv/videobuffers.cpp
index 3987de0..34bd0df 100644
--- a/mythtv/libs/libmythtv/videobuffers.cpp
+++ b/mythtv/libs/libmythtv/videobuffers.cpp
@@ -775,6 +775,12 @@ uint VideoBuffers::AddBuffer(int width, int height, void* data,
     buffers[num].interlaced_frame = -1;
     buffers[num].top_field_first  = 1;
     vbufferMap[At(num)] = num;
+    if (!data)
+    {
+        int size = buffersize(fmt, width, height);
+        data = av_malloc(size);
+        allocated_arrays.push_back((unsigned char*)data);
+    }
     init(&buffers[num], fmt, (unsigned char*)data, width, height, 0);
     buffers[num].priv[0] = ffmpeg_hack;
     buffers[num].priv[1] = ffmpeg_hack;
diff --git a/mythtv/libs/libmythtv/videoout_nullvdpau.cpp b/mythtv/libs/libmythtv/videoout_nullvdpau.cpp
index 30f55c1..4906545 100644
--- a/mythtv/libs/libmythtv/videoout_nullvdpau.cpp
+++ b/mythtv/libs/libmythtv/videoout_nullvdpau.cpp
@@ -318,11 +318,9 @@ void VideoOutputNullVDPAU::DrawSlice(VideoFrame *frame, int x, int y, int w, int
                                                FMT_VDPAU))
                         {
                             created++;
-                            int size = (m_surfaceSize.width() *
-                                        m_surfaceSize.height() * 3) / 2;
                             m_shadowBuffers->AddBuffer(m_surfaceSize.width(),
                                                        m_surfaceSize.height(),
-                                                       new unsigned char[size],
+                                                       NULL,
                                                        FMT_YV12);
                         }
                     }
diff --git a/mythtv/libs/libmythtv/videoout_opengl.cpp b/mythtv/libs/libmythtv/videoout_opengl.cpp
index a65427a..794cf25 100644
--- a/mythtv/libs/libmythtv/videoout_opengl.cpp
+++ b/mythtv/libs/libmythtv/videoout_opengl.cpp
@@ -872,8 +872,7 @@ void VideoOutputOpenGL::ShowPIP(VideoFrame  *frame,
                      dvr, position,
                      QRect(0, 0, pipVideoWidth, pipVideoHeight),
                      false, options, false);
-        QSize viewport = gl_videochain ? gl_videochain->GetViewPort() :
-                                         window.GetDisplayVisibleRect().size();
+        QSize viewport = window.GetDisplayVisibleRect().size();
         gl_pipchain->SetMasterViewport(viewport);
         if (!success)
         {
@@ -898,8 +897,7 @@ void VideoOutputOpenGL::ShowPIP(VideoFrame  *frame,
             QRect(0, 0, pipVideoWidth, pipVideoHeight),
             false, options, false);
 
-        QSize viewport = gl_videochain ? gl_videochain->GetViewPort() :
-                                         window.GetDisplayVisibleRect().size();
+        QSize viewport = window.GetDisplayVisibleRect().size();
         gl_pipchain->SetMasterViewport(viewport);
 
         if (!success)
diff --git a/mythtv/libs/libmythui/mythuiwebbrowser.cpp b/mythtv/libs/libmythui/mythuiwebbrowser.cpp
index 2db65a7..3c16815 100644
--- a/mythtv/libs/libmythui/mythuiwebbrowser.cpp
+++ b/mythtv/libs/libmythui/mythuiwebbrowser.cpp
@@ -957,7 +957,7 @@ void MythUIWebBrowser::Init(void)
         parentObject = parentObject->parent();
     }
 
-    if (!m_parentScreen)
+    if (!m_parentScreen && parent() != GetGlobalObjectStore())
         LOG(VB_GENERAL, LOG_ERR,
             "MythUIWebBrowser: failed to find our parent screen");
 
diff --git a/mythtv/libs/libmythupnp/upnpcds.h b/mythtv/libs/libmythupnp/upnpcds.h
index 4182cd6..83d1d5c 100644
--- a/mythtv/libs/libmythupnp/upnpcds.h
+++ b/mythtv/libs/libmythupnp/upnpcds.h
@@ -268,7 +268,7 @@ class UPNP_PUBLIC UPnpCDS : public Eventing
         // Implement UPnpServiceImpl methods that we can
 
         virtual QString GetServiceType      () { return "urn:schemas-upnp-org:service:ContentDirectory:1"; }
-        virtual QString GetServiceId        () { return "urn:upnp-org:serviceId:CDS_1-0"; }
+        virtual QString GetServiceId        () { return "urn:upnp-org:serviceId:ContentDirectory"; }
         virtual QString GetServiceControlURL() { return m_sControlUrl.mid( 1 ); }
         virtual QString GetServiceDescURL   () { return m_sControlUrl.mid( 1 ) + "/GetServDesc"; }
 
diff --git a/mythtv/libs/libmythupnp/upnpcmgr.h b/mythtv/libs/libmythupnp/upnpcmgr.h
index d7077b2..4bf5a66 100644
--- a/mythtv/libs/libmythupnp/upnpcmgr.h
+++ b/mythtv/libs/libmythupnp/upnpcmgr.h
@@ -64,7 +64,7 @@ class UPNP_PUBLIC UPnpCMGR : public Eventing
         // Implement UPnpServiceImpl methods that we can
 
         virtual QString GetServiceType      () { return "urn:schemas-upnp-org:service:ConnectionManager:1"; }
-        virtual QString GetServiceId        () { return "urn:upnp-org:serviceId:CMGR_1-0"; }
+        virtual QString GetServiceId        () { return "urn:upnp-org:serviceId:ConnectionManager"; }
         virtual QString GetServiceControlURL() { return m_sControlUrl.mid( 1 ); }
         virtual QString GetServiceDescURL   () { return m_sControlUrl.mid( 1 ) + "/GetServDesc"; }
 
diff --git a/mythtv/programs/mythbackend/main_helpers.cpp b/mythtv/programs/mythbackend/main_helpers.cpp
index abe2ced..53cdc54 100644
--- a/mythtv/programs/mythbackend/main_helpers.cpp
+++ b/mythtv/programs/mythbackend/main_helpers.cpp
@@ -219,13 +219,14 @@ bool setupTVs(bool ismaster, bool &error)
 
 void cleanup(void)
 {
-    if (gCoreContext)
+    if (mainServer)
     {
-        gCoreContext->SetExiting();
+        mainServer->Stop();
+        qApp->processEvents();
     }
 
-    if (mainServer)
-        mainServer->Stop();
+    if (gCoreContext)
+        gCoreContext->SetExiting();
 
     delete housekeeping;
     housekeeping = NULL;
diff --git a/mythtv/programs/mythbackend/mainserver.cpp b/mythtv/programs/mythbackend/mainserver.cpp
index 2b8dd39..7227f52 100644
--- a/mythtv/programs/mythbackend/mainserver.cpp
+++ b/mythtv/programs/mythbackend/mainserver.cpp
@@ -3102,7 +3102,8 @@ void MainServer::HandleQueryFileHash(QStringList &slist, PlaybackSock *pbs)
 
     QString hash = "";
 
-    if (hostname == gCoreContext->GetHostName())
+    if (hostname == gCoreContext->GetHostName() ||
+        gCoreContext->IsThisHost(hostname))
     {
         StorageGroup sgroup(storageGroup, gCoreContext->GetHostName());
         QString fullname = sgroup.FindFile(filename);
@@ -3366,9 +3367,12 @@ void MainServer::HandleSGGetFileList(QStringList &sList,
                                    " path = %3 wanthost = %4")
             .arg(groupname).arg(host).arg(path).arg(wantHost));
 
+    QString addr4 = gCoreContext->GetBackendServerIP4();
+    QString addr6 = gCoreContext->GetBackendServerIP6();
+
     if ((host.toLower() == wantHost.toLower()) ||
-        (gCoreContext->GetBackendServerIP4() == wantHostaddr.toString()) ||
-        (gCoreContext->GetBackendServerIP6() == wantHostaddr.toString()))
+        (!addr4.isEmpty() && addr4 == wantHostaddr.toString()) ||
+        (!addr6.isEmpty() && addr6 == wantHostaddr.toString()))
     {
         StorageGroup sg(groupname, host);
         LOG(VB_FILE, LOG_INFO, "HandleSGGetFileList: Getting local info");
@@ -3423,6 +3427,7 @@ void MainServer::HandleSGFileQuery(QStringList &sList,
         return;
     }
 
+    QString host = gCoreContext->GetHostName();
     QString wantHost = sList.at(1);
     QHostAddress wantHostaddr(wantHost);
     QString groupname = sList.at(2);
@@ -3433,9 +3438,12 @@ void MainServer::HandleSGFileQuery(QStringList &sList,
     LOG(VB_FILE, LOG_INFO, QString("HandleSGFileQuery: %1")
             .arg(gCoreContext->GenMythURL(wantHost, 0, filename, groupname)));
 
-    if ((wantHost.toLower() == gCoreContext->GetHostName().toLower()) ||
-        (wantHostaddr.toString() == gCoreContext->GetBackendServerIP4()) ||
-        (wantHostaddr.toString() == gCoreContext->GetBackendServerIP6()))
+    QString addr4 = gCoreContext->GetBackendServerIP4();
+    QString addr6 = gCoreContext->GetBackendServerIP6();
+
+    if ((host.toLower() == wantHost.toLower()) ||
+        (!addr4.isEmpty() && addr4 == wantHostaddr.toString()) ||
+        (!addr6.isEmpty() && addr6 == wantHostaddr.toString()))
     {
         LOG(VB_FILE, LOG_INFO, "HandleSGFileQuery: Getting local info");
         StorageGroup sg(groupname, gCoreContext->GetHostName());
diff --git a/mythtv/programs/mythbackend/upnpcdstv.cpp b/mythtv/programs/mythbackend/upnpcdstv.cpp
index 7b72969..6bf753f 100644
--- a/mythtv/programs/mythbackend/upnpcdstv.cpp
+++ b/mythtv/programs/mythbackend/upnpcdstv.cpp
@@ -72,15 +72,15 @@ UPnpCDSRootInfo UPnpCDSTv::g_RootNodes[] =
         "WHERE category=:KEY", "category" },
 
     {   "By Date",
-        "DATE_FORMAT(starttime, '%Y-%m-%d')",
-        "SELECT  DATE_FORMAT(starttime, '%Y-%m-%d') as id, "
-          "DATE_FORMAT(starttime, '%Y-%m-%d %W') as name, "
-          "count( DATE_FORMAT(starttime, '%Y-%m-%d %W') ) as children "
+        "DATE_FORMAT(CONVERT_TZ(starttime, 'UTC', 'SYSTEM'), '%Y-%m-%d')",
+        "SELECT  DATE_FORMAT(CONVERT_TZ(starttime, 'UTC', 'SYSTEM'), '%Y-%m-%d') as id, "
+          "DATE_FORMAT(CONVERT_TZ(starttime, 'UTC', 'SYSTEM'), '%Y-%m-%d %W') as name, "
+          "count( starttime ) as children "
             "FROM recorded "
             "%1 "
             "GROUP BY name "
             "ORDER BY starttime DESC",
-        "WHERE DATE_FORMAT(starttime, '%Y-%m-%d') =:KEY", "starttime DESC" },
+        "WHERE DATE_FORMAT(CONVERT_TZ(starttime, 'UTC', 'SYSTEM'), '%Y-%m-%d') =:KEY", "starttime DESC" },
 
     {   "By Channel",
         "chanid",
@@ -367,7 +367,7 @@ void UPnpCDSTv::AddItem( const UPnpCDSRequest    *pRequest,
     pItem->SetPropValue( "artist"        , "[Unknown Author]" );
     pItem->SetPropValue( "album"         , "[Unknown Series]" );
     pItem->SetPropValue( "actor"         , "[Unknown Author]" );
-    pItem->SetPropValue( "date"          , dtStartTime.toString(Qt::ISODate));
+    pItem->SetPropValue( "date"          , dtStartTime.toLocalTime().toString(Qt::ISODate));
 
     pResults->Add( pItem );
 
@@ -401,18 +401,17 @@ void UPnpCDSTv::AddItem( const UPnpCDSRequest    *pRequest,
         sMimeType = "video/avi";
     }
 
-
-    // DLNA string below is temp fix for ps3 seeking.
-    QString sProtocol = QString( "http-get:*:%1:DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=01500000000000000000000000000000" ).arg( sMimeType  );
-    QString sURI      = QString( "%1GetRecording%2").arg( sURIBase   )
-                                                    .arg( sURIParams );
-
-    // Sony BDPS370 requires a DLNA Profile Name
+    // NOTE: Sony BDPS370 requires a DLNA Profile Name
+    // NOTE: DLNA string below is temp fix for ps3 seeking.
     // FIXME: detection to determine the correct DLNA Profile Name
+    QString sFourthField = "*";
     if (sMimeType == "video/mpeg")
     {
-        sProtocol += ";DLNA.ORG_PN=MPEG_TS_SD_NA_ISO";
+        sFourthField = "DLNA.ORG_PN=MPEG_TS_SD_NA_ISO;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=01500000000000000000000000000000";
     }
+    QString sProtocol = QString( "http-get:*:%1:%2" ).arg( sMimeType ).arg( sFourthField );
+    QString sURI      = QString( "%1GetRecording%2").arg( sURIBase   )
+                                                    .arg( sURIParams );
 
     Resource *pRes = pItem->AddResource( sProtocol, sURI );
 
diff --git a/mythtv/programs/mythbackend/upnpcdsvideo.cpp b/mythtv/programs/mythbackend/upnpcdsvideo.cpp
index a80b9b9..b986e56 100644
--- a/mythtv/programs/mythbackend/upnpcdsvideo.cpp
+++ b/mythtv/programs/mythbackend/upnpcdsvideo.cpp
@@ -358,7 +358,7 @@ void UPnpCDSVideo::AddItem( const UPnpCDSRequest    *pRequest,
     }
     QFileInfo fInfo( sFullFileName );
 
-    pItem->SetPropValue( "date", dtInsertDate.toString("yyyy-MM-dd"));
+    pItem->SetPropValue( "date", dtInsertDate.toLocalTime().toString(Qt::ISODate));
     pResults->Add( pItem );
 
     // ----------------------------------------------------------------------
diff --git a/mythtv/programs/mythfrontend/editvideometadata.cpp b/mythtv/programs/mythfrontend/editvideometadata.cpp
index 7d93190..8aa4ce0 100644
--- a/mythtv/programs/mythfrontend/editvideometadata.cpp
+++ b/mythtv/programs/mythfrontend/editvideometadata.cpp
@@ -26,6 +26,7 @@
 #include "videoutils.h"
 
 #include "editvideometadata.h"
+#include "metadatafactory.h"
 
 static const QString _Location = QObject::tr("Metadata Editor");
 
@@ -682,13 +683,8 @@ void EditMetadataDialog::OnSearchListSelection(ArtworkInfo info, VideoArtworkTyp
 
     MetadataLookup *lookup = new MetadataLookup();
     lookup->SetType(kMetadataVideo);
-    if (m_workingMetadata->GetSeason() > 0 ||
-            m_workingMetadata->GetEpisode() > 0)
-        lookup->SetSubtype(kProbableTelevision);
-    else if (m_workingMetadata->GetSubtitle().isEmpty())
-        lookup->SetSubtype(kProbableMovie);
-    else
-        lookup->SetSubtype(kUnknownVideo);
+
+    lookup->SetSubtype(GuessLookupType(m_workingMetadata));
     lookup->SetHost(m_workingMetadata->GetHost());
     lookup->SetAutomatic(true);
     lookup->SetData(qVariantFromValue<VideoArtworkType>(type));
diff --git a/mythtv/programs/mythfrontend/grabbersettings.cpp b/mythtv/programs/mythfrontend/grabbersettings.cpp
index 146c32f..e43c91e 100644
--- a/mythtv/programs/mythfrontend/grabbersettings.cpp
+++ b/mythtv/programs/mythfrontend/grabbersettings.cpp
@@ -85,145 +85,54 @@ GrabberSettings::~GrabberSettings()
 
 void GrabberSettings::Load(void)
 {
-    QDir TVScriptPath = QString("%1metadata/Television/").arg(GetShareDir());
-    QStringList TVScripts = TVScriptPath.entryList(QDir::Files);
-    QDir MovieScriptPath = QString("%1metadata/Movie/").arg(GetShareDir());
-    QStringList MovieScripts = MovieScriptPath.entryList(QDir::Files);
-    QDir GameScriptPath = QString("%1metadata/Game/").arg(GetShareDir());
-    QStringList GameScripts = GameScriptPath.entryList(QDir::Files);
-
-    if (MovieScripts.count())
-    {
-        for (QStringList::const_iterator i = MovieScripts.begin();
-             i != MovieScripts.end(); ++i)
-        {
-            QString commandline = QString("%1/%2")
-                                      .arg(MovieScriptPath.path()).arg(*i);
-            MythSystemLegacy grabber(commandline, QStringList() << "-v", kMSRunShell | kMSStdOut);
-            grabber.Run();
-            grabber.Wait();
-            QByteArray result = grabber.ReadAll();
-
-            if (!result.isEmpty())
-            {
-                QDomDocument doc;
-                doc.setContent(result, true);
-                QDomElement root = doc.documentElement();
-                if (!root.isNull())
-                {
-                    MetaGrabberScript *script = ParseGrabberVersion(root);
-                    if (!script->GetName().isEmpty())
-                        m_movieGrabberList.append(script);
-                }
-            }
-        }
-    }
-
-    if (TVScripts.count())
-    {
-        for (QStringList::const_iterator i = TVScripts.end() - 1;
-                i != TVScripts.begin() - 1; --i)
-        {
-            QString commandline = QString("%1/%2")
-                                      .arg(TVScriptPath.path()).arg(*i);
-            MythSystemLegacy grabber(commandline, QStringList() << "-v", kMSRunShell | kMSStdOut);
-            grabber.Run();
-            grabber.Wait();
-            QByteArray result = grabber.ReadAll();
-
-            if (!result.isEmpty())
-            {
-                QDomDocument doc;
-                doc.setContent(result, true);
-                QDomElement root = doc.documentElement();
-                if (!root.isNull())
-                {
-                    MetaGrabberScript *script = ParseGrabberVersion(root);
-                    if (!script->GetName().isEmpty())
-                        m_tvGrabberList.append(script);
-
-                }
-            }
-        }
-    }
-
-    if (GameScripts.count())
-    {
-        for (QStringList::const_iterator i = GameScripts.end() - 1;
-                i != GameScripts.begin() - 1; --i)
-        {
-            QString commandline = QString("%1/%2")
-                                      .arg(GameScriptPath.path()).arg(*i);
-            MythSystemLegacy grabber(commandline, QStringList() << "-v", kMSRunShell | kMSStdOut);
-            grabber.Run();
-            grabber.Wait();
-            QByteArray result = grabber.ReadAll();
-
-            if (!result.isEmpty())
-            {
-                QDomDocument doc;
-                doc.setContent(result, true);
-                QDomElement root = doc.documentElement();
-                if (!root.isNull())
-                {
-                    MetaGrabberScript *script = ParseGrabberVersion(root);
-                    if (!script->GetName().isEmpty())
-                        m_gameGrabberList.append(script);
-                }
-            }
-        }
-    }
+    m_movieGrabberList = MetaGrabberScript::GetList(kGrabberMovie, true);
+    m_tvGrabberList = MetaGrabberScript::GetList(kGrabberTelevision);
+    m_gameGrabberList = MetaGrabberScript::GetList(kGrabberGame);
 }
 
 void GrabberSettings::Init(void)
 {
-    for (QList<MetaGrabberScript*>::const_iterator it =
-             m_movieGrabberList.begin();
+    for (GrabberList::const_iterator it = m_movieGrabberList.begin();
          it != m_movieGrabberList.end(); ++it)
     {
-        QString commandline = QString("metadata/Movie/%1")
-                    .arg((*it)->GetCommand());
         InfoMap map;
-        (*it)->toMap(map);
+        it->toMap(map);
         MythUIButtonListItem *item =
-                    new MythUIButtonListItem(m_movieGrabberButtonList, (*it)->GetName());
-        item->SetData(commandline);
+                    new MythUIButtonListItem(m_movieGrabberButtonList, it->GetName());
+        item->SetData(it->GetRelPath());
         item->SetTextFromMap(map);
     }
 
     m_movieGrabberList.clear();
 
-    for (QList<MetaGrabberScript*>::const_iterator it = m_tvGrabberList.begin();
+    for (GrabberList::const_iterator it = m_tvGrabberList.begin();
          it != m_tvGrabberList.end(); ++it)
     {
-        QString commandline = QString("metadata/Television/%1")
-                    .arg((*it)->GetCommand());
         InfoMap map;
-        (*it)->toMap(map);
+        it->toMap(map);
         MythUIButtonListItem *item =
-                    new MythUIButtonListItem(m_tvGrabberButtonList, (*it)->GetName());
-        item->SetData(commandline);
+                    new MythUIButtonListItem(m_tvGrabberButtonList, it->GetName());
+        item->SetData(it->GetRelPath());
         item->SetTextFromMap(map);
     }
 
     m_tvGrabberList.clear();
 
-    for (QList<MetaGrabberScript*>::const_iterator it =
-             m_gameGrabberList.begin();
+    for (GrabberList::const_iterator it = m_gameGrabberList.begin();
          it != m_gameGrabberList.end(); ++it)
     {
-        QString commandline = QString("metadata/Game/%1")
-                    .arg((*it)->GetCommand());
         InfoMap map;
-        (*it)->toMap(map);
+        it->toMap(map);
         MythUIButtonListItem *item =
-                    new MythUIButtonListItem(m_gameGrabberButtonList, (*it)->GetName());
-        item->SetData(commandline);
+                    new MythUIButtonListItem(m_gameGrabberButtonList, it->GetName());
+        item->SetData(it->GetRelPath());
         item->SetTextFromMap(map);
     }
 
     m_gameGrabberList.clear();
 
+    // TODO
+    // pull these values from MetaGrabberScript so we're not defining them in multiple locations
     QString currentTVGrabber = gCoreContext->GetSetting("TelevisionGrabber",
                                          "metadata/Television/ttvdb.py");
     QString currentMovieGrabber = gCoreContext->GetSetting("MovieGrabber",
diff --git a/mythtv/programs/mythfrontend/grabbersettings.h b/mythtv/programs/mythfrontend/grabbersettings.h
index a908b96..06b9e5d 100644
--- a/mythtv/programs/mythfrontend/grabbersettings.h
+++ b/mythtv/programs/mythfrontend/grabbersettings.h
@@ -11,6 +11,7 @@
 #include "mythuicheckbox.h"
 #include "mythscreentype.h"
 #include "mythdialogbox.h"
+#include "metadatagrabber.h"
 
 class MetaGrabberScript;
 class GrabberSettings : public MythScreenType
@@ -29,9 +30,9 @@ class GrabberSettings : public MythScreenType
     virtual void Load(void);
     virtual void Init(void);
 
-    QList<MetaGrabberScript*> m_movieGrabberList;
-    QList<MetaGrabberScript*> m_tvGrabberList;
-    QList<MetaGrabberScript*> m_gameGrabberList;
+    GrabberList m_movieGrabberList;
+    GrabberList m_tvGrabberList;
+    GrabberList m_gameGrabberList;
 
     MythUIButtonList   *m_movieGrabberButtonList;
     MythUIButtonList   *m_tvGrabberButtonList;
diff --git a/mythtv/programs/mythfrontend/playbackbox.cpp b/mythtv/programs/mythfrontend/playbackbox.cpp
index 709cf37..d01293f 100644
--- a/mythtv/programs/mythfrontend/playbackbox.cpp
+++ b/mythtv/programs/mythfrontend/playbackbox.cpp
@@ -20,6 +20,8 @@
 #include "mythuitextedit.h"
 #include "mythuispinbox.h"
 #include "mythdialogbox.h"
+#include "mythprogressdialog.h"
+#include "mythuimetadataresults.h"
 #include "recordinginfo.h"
 #include "recordingrule.h"
 #include "mythuihelper.h"
@@ -5251,11 +5253,14 @@ void PasswordChange::SendResult()
 ////////////////////////////////////////////////////////
 
 RecMetadataEdit::RecMetadataEdit(MythScreenStack *lparent, ProgramInfo *pginfo)
-                : MythScreenType(lparent, "recmetadataedit"),
-                    m_progInfo(pginfo)
+  : MythScreenType(lparent, "recmetadataedit"),
+    m_titleEdit(NULL),      m_subtitleEdit(NULL),   m_descriptionEdit(NULL),
+    m_inetrefEdit(NULL),    m_seasonSpin(NULL),     m_episodeSpin(NULL),
+    m_busyPopup(NULL),      m_queryButton(NULL),
+    m_progInfo(pginfo)
 {
-    m_titleEdit = m_subtitleEdit = m_descriptionEdit = m_inetrefEdit = NULL;
-    m_seasonSpin = m_episodeSpin = NULL;
+    m_popupStack = GetMythMainWindow()->GetStack("popup stack");
+    m_metadataFactory = new MetadataFactory(this);
 }
 
 bool RecMetadataEdit::Create()
@@ -5270,6 +5275,7 @@ bool RecMetadataEdit::Create()
     m_seasonSpin = dynamic_cast<MythUISpinBox*>(GetChild("season"));
     m_episodeSpin = dynamic_cast<MythUISpinBox*>(GetChild("episode"));
     MythUIButton *okButton = dynamic_cast<MythUIButton*>(GetChild("ok"));
+    m_queryButton = dynamic_cast<MythUIButton*>(GetChild("query_button"));
 
     if (!m_titleEdit || !m_subtitleEdit || !m_inetrefEdit || !m_seasonSpin ||
         !m_episodeSpin || !okButton)
@@ -5296,6 +5302,10 @@ bool RecMetadataEdit::Create()
     m_episodeSpin->SetValue(m_progInfo->GetEpisode());
 
     connect(okButton, SIGNAL(Clicked()), SLOT(SaveChanges()));
+    if (m_queryButton)
+    {
+        connect(m_queryButton, SIGNAL(Clicked()), SLOT(PerformQuery()));
+    }
 
     BuildFocusList();
 
@@ -5323,6 +5333,146 @@ void RecMetadataEdit::SaveChanges()
     Close();
 }
 
+void RecMetadataEdit::PerformQuery()
+{
+    if (m_busyPopup)
+        return;
+
+    m_busyPopup = new MythUIBusyDialog(tr("Trying to manually find this "
+                                          "recording online..."),
+                                       m_popupStack,
+                                       "metaoptsdialog");
+
+    if (m_busyPopup->Create())
+        m_popupStack->AddScreen(m_busyPopup);
+
+    MetadataLookup *lookup = new MetadataLookup();
+    lookup->SetStep(kLookupSearch);
+    lookup->SetType(kMetadataRecording);
+    LookupType type = GuessLookupType(m_inetrefEdit->GetText());
+
+    if (type == kUnknownVideo)
+    {
+        if (m_seasonSpin->GetIntValue() == 0 &&
+            m_episodeSpin->GetIntValue() == 0 &&
+            m_subtitleEdit->GetText().isEmpty())
+        {
+            lookup->SetSubtype(kProbableMovie);
+        }
+        else
+        {
+            lookup->SetSubtype(kProbableTelevision);
+        }
+    }
+    else
+    {
+        // we could determine the type from the inetref
+        lookup->SetSubtype(type);
+    }
+    lookup->SetAllowGeneric(true);
+    lookup->SetHandleImages(false);
+    lookup->SetHost(gCoreContext->GetMasterHostName());
+    lookup->SetTitle(m_titleEdit->GetText());
+    lookup->SetSubtitle(m_subtitleEdit->GetText());
+    lookup->SetInetref(m_inetrefEdit->GetText());
+    lookup->SetCollectionref(m_inetrefEdit->GetText());
+    lookup->SetSeason(m_seasonSpin->GetIntValue());
+    lookup->SetEpisode(m_episodeSpin->GetIntValue());
+    lookup->SetAutomatic(false);
+
+    m_metadataFactory->Lookup(lookup);
+}
+
+void RecMetadataEdit::QueryComplete(MetadataLookup *lookup)
+{
+    if (!lookup)
+        return;
+
+    m_inetrefEdit->SetText(lookup->GetInetref());
+    m_seasonSpin->SetValue(lookup->GetSeason());
+    m_episodeSpin->SetValue(lookup->GetEpisode());
+    if (!lookup->GetSubtitle().isEmpty())
+    {
+        m_descriptionEdit->SetText(lookup->GetSubtitle());
+    }
+    if (!lookup->GetDescription().isEmpty())
+    {
+        m_descriptionEdit->SetText(lookup->GetDescription());
+    }
+}
+
+void RecMetadataEdit::OnSearchListSelection(RefCountHandler<MetadataLookup> lookup)
+{
+    QueryComplete(lookup);
+}
+
+void RecMetadataEdit::customEvent(QEvent *levent)
+{
+    if (levent->type() == MetadataFactoryMultiResult::kEventType)
+    {
+        if (m_busyPopup)
+        {
+            m_busyPopup->Close();
+            m_busyPopup = NULL;
+        }
+
+        MetadataFactoryMultiResult *mfmr = dynamic_cast<MetadataFactoryMultiResult*>(levent);
+
+        if (!mfmr)
+            return;
+
+        MetadataLookupList list = mfmr->results;
+
+        MetadataResultsDialog *resultsdialog =
+            new MetadataResultsDialog(m_popupStack, list);
+
+        connect(resultsdialog, SIGNAL(haveResult(RefCountHandler<MetadataLookup>)),
+                SLOT(OnSearchListSelection(RefCountHandler<MetadataLookup>)),
+                Qt::QueuedConnection);
+
+        if (resultsdialog->Create())
+            m_popupStack->AddScreen(resultsdialog);
+    }
+    else if (levent->type() == MetadataFactorySingleResult::kEventType)
+    {
+        if (m_busyPopup)
+        {
+            m_busyPopup->Close();
+            m_busyPopup = NULL;
+        }
+
+        MetadataFactorySingleResult *mfsr = dynamic_cast<MetadataFactorySingleResult*>(levent);
+
+        if (!mfsr && !mfsr->result)
+            return;
+
+        QueryComplete(mfsr->result);
+    }
+    else if (levent->type() == MetadataFactoryNoResult::kEventType)
+    {
+        if (m_busyPopup)
+        {
+            m_busyPopup->Close();
+            m_busyPopup = NULL;
+        }
+
+        MetadataFactoryNoResult *mfnr = dynamic_cast<MetadataFactoryNoResult*>(levent);
+
+        if (!mfnr)
+            return;
+
+        QString title = tr("No match found for this recording. You can "
+                           "try entering a TVDB/TMDB number, season, and "
+                           "episode manually.");
+
+        MythConfirmationDialog *okPopup =
+            new MythConfirmationDialog(m_popupStack, title, false);
+
+        if (okPopup->Create())
+            m_popupStack->AddScreen(okPopup);
+    }
+}
+
 //////////////////////////////////////////
 
 HelpPopup::HelpPopup(MythScreenStack *lparent)
diff --git a/mythtv/programs/mythfrontend/playbackbox.h b/mythtv/programs/mythfrontend/playbackbox.h
index 16a06b7..836c433 100644
--- a/mythtv/programs/mythfrontend/playbackbox.h
+++ b/mythtv/programs/mythfrontend/playbackbox.h
@@ -22,6 +22,7 @@ using namespace std;
 #include "tv_play.h"
 
 #include "mythscreentype.h"
+#include "metadatafactory.h"
 
 // mythfrontend
 #include "schedulecommon.h"
@@ -44,6 +45,7 @@ class MythUITextEdit;
 class MythUIButton;
 class MythDialogBox;
 class MythMenu;
+class MythUIBusyDialog;
 
 typedef QMap<QString,ProgramList>       ProgramMap;
 typedef QMap<QString,QString>           Str2StrMap;
@@ -530,16 +532,25 @@ class RecMetadataEdit : public MythScreenType
 
   protected slots:
     void SaveChanges(void);
+    void PerformQuery(void);
+    void OnSearchListSelection(RefCountHandler<MetadataLookup> lookup);
 
   private:
+    void customEvent(QEvent *event);
+    void QueryComplete(MetadataLookup *lookup);
+
     MythUITextEdit     *m_titleEdit;
     MythUITextEdit     *m_subtitleEdit;
     MythUITextEdit     *m_descriptionEdit;
     MythUITextEdit     *m_inetrefEdit;
     MythUISpinBox      *m_seasonSpin;
     MythUISpinBox      *m_episodeSpin;
+    MythUIBusyDialog   *m_busyPopup;
+    MythUIButton       *m_queryButton;
 
-    ProgramInfo *m_progInfo;
+    ProgramInfo        *m_progInfo;
+    MythScreenStack    *m_popupStack;
+    MetadataFactory    *m_metadataFactory;
 };
 
 class HelpPopup : public MythScreenType
diff --git a/mythtv/programs/mythfrontend/scheduleeditor.cpp b/mythtv/programs/mythfrontend/scheduleeditor.cpp
index b89b711..bc70f7e 100644
--- a/mythtv/programs/mythfrontend/scheduleeditor.cpp
+++ b/mythtv/programs/mythfrontend/scheduleeditor.cpp
@@ -1421,30 +1421,12 @@ void MetadataOptions::CreateBusyDialog(QString title)
 
 void MetadataOptions::PerformQuery()
 {
-    MetadataLookup *lookup = new MetadataLookup();
-
     CreateBusyDialog(tr("Trying to manually find this "
                         "recording online..."));
 
-    lookup->SetStep(kLookupSearch);
-    lookup->SetType(kMetadataRecording);
-    if ((m_recInfo && m_recInfo->GetCategoryType() == ProgramInfo::kCategoryMovie) ||
-        (m_seasonSpin->GetIntValue() == 0 &&
-         m_episodeSpin->GetIntValue() == 0))
-         lookup->SetSubtype(kProbableMovie);
-    else
-        lookup->SetSubtype(kProbableTelevision);
-    lookup->SetAllowGeneric(true);
-    lookup->SetAutomatic(false);
-    lookup->SetHandleImages(false);
-    lookup->SetHost(gCoreContext->GetMasterHostName());
-    lookup->SetTitle(m_recordingRule->m_title);
-    lookup->SetSubtitle(m_recordingRule->m_subtitle);
-    lookup->SetInetref(m_inetrefEdit->GetText());
-    lookup->SetCollectionref(m_inetrefEdit->GetText());
-    lookup->SetSeason(m_seasonSpin->GetIntValue());
-    lookup->SetEpisode(m_episodeSpin->GetIntValue());
+    MetadataLookup *lookup = CreateLookup(kMetadataRecording);
 
+    lookup->SetAutomatic(false);
     m_metadataFactory->Lookup(lookup);
 }
 
@@ -1614,28 +1596,33 @@ bool MetadataOptions::CanSetArtwork()
     return true;
 }
 
-void MetadataOptions::FindNetArt(VideoArtworkType type)
+MetadataLookup *MetadataOptions::CreateLookup(MetadataType mtype)
 {
-    if (!CanSetArtwork())
-        return;
-
     MetadataLookup *lookup = new MetadataLookup();
-
-    QString msg = tr("Searching for available artwork...");
-    CreateBusyDialog(msg);
-
     lookup->SetStep(kLookupSearch);
-    lookup->SetType(kMetadataVideo);
-    lookup->SetAutomatic(true);
-    lookup->SetHandleImages(false);
-    if ((m_recInfo && m_recInfo->GetCategoryType() == ProgramInfo::kCategoryMovie) ||
-        (m_seasonSpin->GetIntValue() == 0 &&
-         m_episodeSpin->GetIntValue() == 0))
-         lookup->SetSubtype(kProbableMovie);
+    lookup->SetType(mtype);
+    LookupType type = GuessLookupType(m_inetrefEdit->GetText());
+
+    if (type == kUnknownVideo)
+    {
+        if ((m_recInfo && m_recInfo->GetCategoryType() == ProgramInfo::kCategoryMovie) ||
+            (m_seasonSpin->GetIntValue() == 0 &&
+             m_episodeSpin->GetIntValue() == 0))
+        {
+            lookup->SetSubtype(kProbableMovie);
+        }
+        else
+        {
+            lookup->SetSubtype(kProbableTelevision);
+        }
+    }
     else
-        lookup->SetSubtype(kProbableTelevision);
+    {
+        // we could determine the type from the inetref
+        lookup->SetSubtype(type);
+    }
     lookup->SetAllowGeneric(true);
-    lookup->SetData(qVariantFromValue<VideoArtworkType>(type));
+    lookup->SetHandleImages(false);
     lookup->SetHost(gCoreContext->GetMasterHostName());
     lookup->SetTitle(m_recordingRule->m_title);
     lookup->SetSubtitle(m_recordingRule->m_subtitle);
@@ -1644,6 +1631,21 @@ void MetadataOptions::FindNetArt(VideoArtworkType type)
     lookup->SetSeason(m_seasonSpin->GetIntValue());
     lookup->SetEpisode(m_episodeSpin->GetIntValue());
 
+    return lookup;
+}
+
+void MetadataOptions::FindNetArt(VideoArtworkType type)
+{
+    if (!CanSetArtwork())
+        return;
+
+    QString msg = tr("Searching for available artwork...");
+    CreateBusyDialog(msg);
+
+    MetadataLookup *lookup = CreateLookup(kMetadataVideo);
+
+    lookup->SetAutomatic(true);
+    lookup->SetData(qVariantFromValue<VideoArtworkType>(type));
     m_imageLookup->addLookup(lookup);
 }
 
diff --git a/mythtv/programs/mythfrontend/scheduleeditor.h b/mythtv/programs/mythfrontend/scheduleeditor.h
index cae67b5..dbb1ae5 100644
--- a/mythtv/programs/mythfrontend/scheduleeditor.h
+++ b/mythtv/programs/mythfrontend/scheduleeditor.h
@@ -383,6 +383,7 @@ class MetadataOptions : public SchedEditChild
     QStringList GetSupportedImageExtensionFilter();
 
     void HandleDownloadedImages(MetadataLookup *lookup);
+    MetadataLookup *CreateLookup(MetadataType mtype);
 
     bool CanSetArtwork(void);
 
diff --git a/mythtv/programs/mythmetadatalookup/lookup.cpp b/mythtv/programs/mythmetadatalookup/lookup.cpp
index 1925c7d..cd18d02 100644
--- a/mythtv/programs/mythmetadatalookup/lookup.cpp
+++ b/mythtv/programs/mythmetadatalookup/lookup.cpp
@@ -50,9 +50,10 @@ void LookerUpper::HandleSingleRecording(const uint chanid,
     }
 
     m_updaterules = updaterules;
+    m_updateartwork = true;
 
     m_busyRecList.append(pginfo);
-    m_metadataFactory->Lookup(pginfo, true, false, false);
+    m_metadataFactory->Lookup(pginfo, true, m_updateartwork, false);
 }
 
 void LookerUpper::HandleAllRecordings(bool updaterules)
@@ -252,7 +253,7 @@ void LookerUpper::customEvent(QEvent *levent)
                     pginfo->GetSeriesID() == (list[p])->GetTMSref())
                 {
                     MetadataLookup *lookup = list[p];
-                    if (!lookup->GetSubtype() == kProbableGenericTelevision)
+                    if (lookup->GetSubtype() != kProbableGenericTelevision)
                         pginfo->SaveSeasonEpisode(lookup->GetSeason(), lookup->GetEpisode());
                     pginfo->SaveInetRef(lookup->GetInetref());
                     m_busyRecList.removeAll(pginfo);
@@ -281,7 +282,7 @@ void LookerUpper::customEvent(QEvent *levent)
             {
                 MetadataLookup *lookup = list[yearindex];
                 ProgramInfo *pginfo = qVariantValue<ProgramInfo *>(lookup->GetData());
-                if (!lookup->GetSubtype() == kProbableGenericTelevision)
+                if (lookup->GetSubtype() != kProbableGenericTelevision)
                     pginfo->SaveSeasonEpisode(lookup->GetSeason(), lookup->GetEpisode());
                 pginfo->SaveInetRef(lookup->GetInetref());
                 m_busyRecList.removeAll(pginfo);
@@ -338,7 +339,7 @@ void LookerUpper::customEvent(QEvent *levent)
         LOG(VB_GENERAL, LOG_DEBUG,
             QString("        User Rating: %1").arg(lookup->GetUserRating()));
 
-        if (!lookup->GetSubtype() == kProbableGenericTelevision)
+        if (lookup->GetSubtype() != kProbableGenericTelevision)
             pginfo->SaveSeasonEpisode(lookup->GetSeason(), lookup->GetEpisode());
         pginfo->SaveInetRef(lookup->GetInetref());
 
@@ -364,7 +365,8 @@ void LookerUpper::customEvent(QEvent *levent)
         if (m_updateartwork)
         {
             ArtworkMap map = lookup->GetDownloads();
-            SetArtwork(lookup->GetInetref(), lookup->GetSeason(),
+            SetArtwork(lookup->GetInetref(),
+                       lookup->GetIsCollection() ? 0 : lookup->GetSeason(),
                        gCoreContext->GetMasterHostName(), map);
         }
 
diff --git a/mythtv/programs/mythmetadatalookup/main.cpp b/mythtv/programs/mythmetadatalookup/main.cpp
index 0878925..1da7dfa 100644
--- a/mythtv/programs/mythmetadatalookup/main.cpp
+++ b/mythtv/programs/mythmetadatalookup/main.cpp
@@ -8,6 +8,9 @@ using namespace std;
 // Qt headers
 #include <QCoreApplication>
 #include <QEventLoop>
+#ifdef Q_OS_MAC
+#include <QProcessEnvironment>
+#endif
 
 // libmyth headers
 #include "exitcodes.h"
@@ -78,6 +81,15 @@ int main(int argc, char *argv[])
     QCoreApplication a(argc, argv);
     QCoreApplication::setApplicationName(MYTH_APPNAME_MYTHMETADATALOOKUP);
 
+#ifdef Q_OS_MAC
+    QString path = QCoreApplication::applicationDirPath();
+    setenv("PYTHONPATH",
+           QString("%1/../Resources/lib/python2.6/site-packages:%2")
+           .arg(path)
+           .arg(QProcessEnvironment::systemEnvironment().value("PYTHONPATH"))
+           .toUtf8().constData(), 1);
+#endif
+
     int retval;
     if ((retval = cmdline.ConfigureLogging()) != GENERIC_EXIT_OK)
         return retval;
diff --git a/mythtv/programs/mythtranscode/mpeg2fix.cpp b/mythtv/programs/mythtranscode/mpeg2fix.cpp
index 8ba085c..c7214d3 100644
--- a/mythtv/programs/mythtranscode/mpeg2fix.cpp
+++ b/mythtv/programs/mythtranscode/mpeg2fix.cpp
@@ -576,18 +576,21 @@ void MPEG2fixup::InitReplex()
     int mp2_count = 0, ac3_count = 0;
     for (FrameMap::Iterator it = aFrame.begin(); it != aFrame.end(); it++)
     {
-        int i = aud_map[it.key()];
+        int index = it.key();
+        if (index > inputFC->nb_streams)
+            continue;   // will never happen in practice
+        int i = aud_map[index];
         AVDictionaryEntry *metatag =
-            av_dict_get(inputFC->streams[it.key()]->metadata,
+            av_dict_get(inputFC->streams[index]->metadata,
                         "language", NULL, 0);
         char *lang = metatag ? metatag->value : (char *)"";
         ring_init(&rx.extrbuf[i], memsize / 5);
         ring_init(&rx.index_extrbuf[i], INDEX_BUF);
         rx.extframe[i].set = 1;
-        rx.extframe[i].bit_rate = getCodecContext(it.key())->bit_rate;
+        rx.extframe[i].bit_rate = getCodecContext(index)->bit_rate;
         rx.extframe[i].framesize = (*it)->first()->pkt.size;
         strncpy(rx.extframe[i].language, lang, 4);
-        switch(GetStreamType(it.key()))
+        switch(GetStreamType(index))
         {
             case AV_CODEC_ID_MP2:
             case AV_CODEC_ID_MP3:
@@ -803,10 +806,12 @@ bool MPEG2fixup::InitAV(QString inputfile, const char *type, int64_t offset)
                 break;
 
             case AVMEDIA_TYPE_AUDIO:
-                if (!allaudio && inputFC->streams[i]->codec->channels == 0)
+                if (!allaudio && ext_count > 0 &&
+                    inputFC->streams[i]->codec->channels < 2 &&
+                    inputFC->streams[i]->codec->sample_rate < 100000)
                 {
                     LOG(VB_GENERAL, LOG_ERR,
-                        QString("Skipping invalid audio stream: %1").arg(i));
+                        QString("Skipping audio stream: %1").arg(i));
                     break;
                 }
                 if (inputFC->streams[i]->codec->codec_id == AV_CODEC_ID_AC3 ||
@@ -1376,6 +1381,7 @@ int MPEG2fixup::GetFrame(AVPacket *pkt)
                 {
                     LOG(VB_GENERAL, LOG_DEBUG,
                         QString("Invalid stream ID %1, ignoring").arg(pkt->stream_index));
+                    framePool.enqueue(tmpFrame);
                 }
                 av_free_packet(pkt);
                 return 0;
@@ -2398,6 +2404,11 @@ int MPEG2fixup::Start()
 
             while (af->count())
             {
+                if (!CC || !CPC)
+                {
+                    framePool.enqueue(af->takeFirst());
+                    continue;
+                }
                 // What to do if the CC is corrupt?
                 // Just wait and hope it repairs itself
                 if (CC->sample_rate == 0 || !CPC || CPC->duration == 0)
diff --git a/mythtv/programs/mythtranscode/mpeg2fix.h b/mythtv/programs/mythtranscode/mpeg2fix.h
index 58fe5ca..d430ad4 100644
--- a/mythtv/programs/mythtranscode/mpeg2fix.h
+++ b/mythtv/programs/mythtranscode/mpeg2fix.h
@@ -219,10 +219,14 @@ class MPEG2fixup
     }
     AVCodecContext *getCodecContext(int id)
     {
+        if (id >= inputFC->nb_streams)
+            return NULL;
         return inputFC->streams[id]->codec;
     }
     AVCodecParserContext *getCodecParserContext(int id)
     {
+        if (id >= inputFC->nb_streams)
+            return NULL;
         return inputFC->streams[id]->parser;
     }
 
diff --git a/mythtv/programs/mythtranscode/videodecodebuffer.cpp b/mythtv/programs/mythtranscode/videodecodebuffer.cpp
index 73d23e0..b6bbdf9 100644
--- a/mythtv/programs/mythtranscode/videodecodebuffer.cpp
+++ b/mythtv/programs/mythtranscode/videodecodebuffer.cpp
@@ -1,11 +1,14 @@
 #include "videodecodebuffer.h"
 
+#include "mythplayer.h"
+#include "videooutbase.h"
+
 VideoDecodeBuffer::VideoDecodeBuffer(MythPlayer *player, VideoOutput *videoout,
                                      bool cutlist, int size)
   : m_player(player),         m_videoOutput(videoout),
-    m_honorCutlist(cutlist),
-    m_eof(false),             m_maxFrames(size),
-    m_runThread(true),        m_isRunning(false)
+    m_honorCutlist(cutlist),  m_maxFrames(size),
+    m_runThread(true),        m_isRunning(false),
+    m_eof(false)
 {
 
 }
@@ -35,8 +38,12 @@ void VideoDecodeBuffer::run()
     m_isRunning = true;
     while (m_runThread)
     {
+        QMutexLocker locker(&m_queueLock);
+
         if (m_frameList.size() < m_maxFrames && !m_eof)
         {
+            locker.unlock();
+
             DecodedFrameInfo tfInfo;
             tfInfo.frame = NULL;
             tfInfo.didFF = 0;
@@ -47,21 +54,22 @@ void VideoDecodeBuffer::run()
             {
                 tfInfo.frame = m_videoOutput->GetLastDecodedFrame();
 
-                QMutexLocker locker(&m_queueLock);
+                locker.relock();
                 m_frameList.append(tfInfo);
             }
-            else
+            else if (m_player->GetEof() != kEofStateNone)
             {
+                locker.relock();
                 m_eof = true;
             }
+            else
+                continue;
 
             m_frameWaitCond.wakeAll();
         }
         else
         {
-            m_frameWaitLock.lock();
-            m_frameWaitCond.wait(&m_frameWaitLock);
-            m_frameWaitLock.unlock();
+            m_frameWaitCond.wait(locker.mutex());
         }
     }
     m_isRunning = false;
@@ -69,27 +77,21 @@ void VideoDecodeBuffer::run()
 
 VideoFrame *VideoDecodeBuffer::GetFrame(int &didFF, bool &isKey)
 {
-    m_queueLock.lock();
+    QMutexLocker locker(&m_queueLock);
 
     if (m_frameList.isEmpty())
     {
-        m_queueLock.unlock();
-
         if (m_eof)
             return NULL;
 
-        m_frameWaitLock.lock();
-        m_frameWaitCond.wait(&m_frameWaitLock);
-        m_frameWaitLock.unlock();
+        m_frameWaitCond.wait(locker.mutex());
 
         if (m_frameList.isEmpty())
             return NULL;
-
-        m_queueLock.lock();
     }
 
     DecodedFrameInfo tfInfo = m_frameList.takeFirst();
-    m_queueLock.unlock();
+    locker.unlock();
     m_frameWaitCond.wakeAll();
 
     didFF = tfInfo.didFF;
diff --git a/mythtv/programs/mythtranscode/videodecodebuffer.h b/mythtv/programs/mythtranscode/videodecodebuffer.h
index 50c33d0..b4e241a 100644
--- a/mythtv/programs/mythtranscode/videodecodebuffer.h
+++ b/mythtv/programs/mythtranscode/videodecodebuffer.h
@@ -6,18 +6,20 @@
 #include <QMutex>
 #include <QRunnable>
 
-#include "mythplayer.h"
 #include "videooutbase.h"
 
+class MythPlayer;
+class VideoOutput;
+
 class VideoDecodeBuffer : public QRunnable
 {
   public:
     VideoDecodeBuffer(MythPlayer *player, VideoOutput *videoout,
         bool cutlist, int size = 5);
-    ~VideoDecodeBuffer();
+    virtual ~VideoDecodeBuffer();
 
-    void        stop(void);
-    void        run();
+    void          stop(void);
+    virtual void run();
     VideoFrame *GetFrame(int &didFF, bool &isKey);
 
   private:
@@ -28,17 +30,16 @@ class VideoDecodeBuffer : public QRunnable
         bool        isKey;
     } DecodedFrameInfo;
 
-    MythPlayer             *m_player;
-    VideoOutput            *m_videoOutput;
-    bool                    m_honorCutlist;
+    MythPlayer * const      m_player;
+    VideoOutput * const     m_videoOutput;
+    bool const              m_honorCutlist;
+    int const               m_maxFrames;
+    bool volatile           m_runThread;
+    bool volatile           m_isRunning;
+    QMutex mutable          m_queueLock; // Guards the following...
     bool                    m_eof;
-    int                     m_maxFrames;
-    bool                    m_runThread;
-    bool                    m_isRunning;
-    QMutex                  m_queueLock;
     QList<DecodedFrameInfo> m_frameList;
     QWaitCondition          m_frameWaitCond;
-    QMutex                  m_frameWaitLock;
 };
 
 #endif
diff --git a/mythtv/themes/classic/tv_schedule.xml b/mythtv/themes/classic/tv_schedule.xml
index c517e3a..6559d45 100644
--- a/mythtv/themes/classic/tv_schedule.xml
+++ b/mythtv/themes/classic/tv_schedule.xml
@@ -46,7 +46,7 @@
     <button>
         <type>TV_CONFLICTS</type>
         <text>Upcoming Recordings</text>
-        <description>VCR-like recording scheduler</description>
+        <description>See what will be recorded next</description>
         <action>TV_FIX_CONFLICTS</action>
     </button>
 
