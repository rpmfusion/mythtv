From 5a39bb25bfec2c0131fab04023c99ab89397c44b Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 14:23:43 +0200
Subject: [PATCH 01/28] MythTV python: Class System.system: correct typo.

When calling System.system, the following traceback bails:

Traceback
  File "MythTV/system.py", line 56, in system
    command = command.lsplit(' ',1)
AttributeError: 'str' object has no attribute 'lsplit'

Note the typo: 'lsplit' --> 'split'.
Python has [lr]strip methods, but provides only 'split()' and 'rsplit()'.
---
 mythtv/bindings/python/MythTV/system.py | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/system.py b/mythtv/bindings/python/MythTV/system.py
index 44803bd02b4..62f1e72c0f4 100644
--- a/mythtv/bindings/python/MythTV/system.py
+++ b/mythtv/bindings/python/MythTV/system.py
@@ -53,7 +53,7 @@ def wait(self):
 
     @classmethod
     def system(cls, command, db=None):
-        command = command.lsplit(' ',1)
+        command = command.split(' ',1)
         path = command[0]
         args = ''
         if len(command) > 1:
@@ -114,7 +114,7 @@ def __init__(self, path=None, setting=None, db=None, useshell=True, prefix=''):
                     break
             else:
                 raise MythFileError('Defined executable path does not exist.')
-                
+
         self.returncode = 0
         self.stderr = ''
         self.useshell = useshell
@@ -349,13 +349,13 @@ def _processMetadata(self, xml):
 
     def command(self, *args):
         return self._processMetadata(super(Grabber, self).command(*args))
- 
+
     def search(self, phrase, subtitle=None, tolerance=None, func=None):
         """
         obj.search(phrase, subtitle=None, tolerance=None) -> result generator
 
             Returns a generator of results matching the given search
-                phrase.  A secondary phrase can be given through the 
+                phrase.  A secondary phrase can be given through the
                 'subtitle' parameter, and an optional levenshtein
                 tolerance value can be given for filtering results.
         """
@@ -384,7 +384,7 @@ def search(self, phrase, subtitle=None, tolerance=None, func=None):
 
     def sortedSearch(self, phrase, subtitle=None, tolerance=None):
         """
-        Behaves like obj.search(), but sorts results based off 
+        Behaves like obj.search(), but sorts results based off
             levenshtein distance.
         """
         return sorted(self.search(phrase, subtitle, tolerance), \

From ba782e53e501e75d5760c86da53f65e61170511a Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 14:28:46 +0200
Subject: [PATCH 02/28] Update MythTV's python binding 'utility/dt.py'
 according  patch  from Ticket #13299: 
 Handle-timezone-files-with-no-modern-transitions-as-well_fixes_30_master.patch

Note: This handle the corner cases where the zone-info files have no
      'modern transitions' or no transitions at all.
---
 mythtv/bindings/python/MythTV/utility/dt.py | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/mythtv/bindings/python/MythTV/utility/dt.py b/mythtv/bindings/python/MythTV/utility/dt.py
index c4c128b1cb8..3f411406d73 100644
--- a/mythtv/bindings/python/MythTV/utility/dt.py
+++ b/mythtv/bindings/python/MythTV/utility/dt.py
@@ -163,6 +163,7 @@ def _process(self, fd, version=1, skip=False):
         # files have massively negative leading entries for e.g. the
         # big bang which gmtime() cannot cope with.
         first_modern_transition = None
+        i = 0   # assign i, in case the for-loop is not executed:
         for i in range(counts.transitions):  # read in epoch time data
             t = unpack(ttmfmt, fd.read(calcsize(ttmfmt)))[0]
 
@@ -177,6 +178,10 @@ def _process(self, fd, version=1, skip=False):
                 if first_modern_transition is not None:
                     raise e
 
+        # Special case if there are no modern transitions, like e.g. UTC timezone:
+        if ( (i == 0) and first_modern_transition is None ):
+            first_modern_transition = counts.transitions
+
         # read in transition type indexes
         types = [None]*counts.transitions
         for i in range(counts.transitions):

From 7985289ca168875b12ce7975fa6063807defa1e5 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 14:32:15 +0200
Subject: [PATCH 03/28] Correct typo in MythTV's python binding
 datetime.fromRfc().

When calling the method utility.datetime.fromRfc(), the following trace back occurs:
Traceback (most recent call last):
  File "test/test_datetime_001.py", line 232, in test_datetime_001_12
    t_fromrfc = datetime.fromRfc(t)
  File "MythTV/utility/dt.py", line 433, in fromRfc
    return cls(*tz)
TypeError: type object argument after * must be an iterable, not posixtzinfo

Solution: Return the correct datetime object.
---
 mythtv/bindings/python/MythTV/utility/dt.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/mythtv/bindings/python/MythTV/utility/dt.py b/mythtv/bindings/python/MythTV/utility/dt.py
index 3f411406d73..9efa4e1e17a 100644
--- a/mythtv/bindings/python/MythTV/utility/dt.py
+++ b/mythtv/bindings/python/MythTV/utility/dt.py
@@ -430,7 +430,7 @@ def fromRfc(cls, rfctime, tz=None):
             tz = cls.localTZ()
         dt.append(tz)
 
-        return cls(*tz)
+        return cls(*dt)
 
     @classmethod
     def duck(cls, t):

From ca9752841d990027df1502ee5d629db47aa29384 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 14:38:59 +0200
Subject: [PATCH 04/28] The conversion to/from bool in DictData from altdict.py
 does not work

as originally assumed: The string '0' or '1' should be converted to
 'True' or 'False', but python interprets 'bool('x')' as follows:

$ python
>>> bool('0')
True
>>> bool('1')
True

We need to convert the string to integer before castin to 'bool':

$ python
>>> bool(int('0'))
False
>>> bool(int('1'))
True
>>>
---
 mythtv/bindings/python/MythTV/altdict.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/mythtv/bindings/python/MythTV/altdict.py b/mythtv/bindings/python/MythTV/altdict.py
index 2c9a5e81c1f..ed41c2c0f4f 100644
--- a/mythtv/bindings/python/MythTV/altdict.py
+++ b/mythtv/bindings/python/MythTV/altdict.py
@@ -99,7 +99,7 @@ class DictData( OrdDict ):
     _field_type = None
     _trans = [  int,
                 locale.atof,
-                bool,
+                lambda x: bool(int(x)),
                 lambda x: x,
                 lambda x: datetime.fromtimestamp(x if x != '4294967295' else '0', datetime.UTCTZ())\
                                   .astimezone(datetime.localTZ()),

From 6355f51ef38cd24e7f53261f22eee21799f34979 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 14:42:08 +0200
Subject: [PATCH 05/28] Fix logging in Mythtv's python bindings msearch.py:

Logging is defined with those parameters:
MythLog.log(self, mask, level, message, detail=None)
---
 mythtv/bindings/python/MythTV/msearch.py | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/msearch.py b/mythtv/bindings/python/MythTV/msearch.py
index a5d1f3d1236..ca89a0928d4 100644
--- a/mythtv/bindings/python/MythTV/msearch.py
+++ b/mythtv/bindings/python/MythTV/msearch.py
@@ -30,7 +30,7 @@ def __init__(self):
                     port += 1
                 else:
                     raise MythError(MythError.SOCKET, e)
-        self.log(MythLog.DEBUG, MythLog.UPNP|MythLog.SOCKET,
+        self.log(MythLog.UPNP|MythLog.SOCKET, MythLog.DEBUG,
                     'Port %d opened for UPnP search.' % port)
         self.sock.setblocking(0.1)
 
@@ -49,7 +49,8 @@ def search(self, timeout=5.0, filter=None):
                 content-length,   request,   date,   usn,    location,
                 cache-control,    server,    ext,    st
         """
-        self.log(MythLog.DEBUG, MythLog.UPNP, 'running UPnP search')
+        self.log(MythLog.UPNP, MythLog.DEBUG, 'running UPnP search')
+
         sock = self.sock
         sreq = '\r\n'.join(['M-SEARCH * HTTP/1.1',
                             'HOST: %s:%s' % self.addr,
@@ -81,7 +82,7 @@ def search(self, timeout=5.0, filter=None):
                 if sdict['st'] not in filter:
                     continue
 
-            self.log(MythLog.UPNP, sdict['st'], sdict['location'])
+            self.log(MythLog.UPNP, MythLog.DEBUG, sdict['st'], sdict['location'])
             yield sdict
 
     def searchMythBE(self, timeout=5.0):

From 784b9626978128df523b5ecd59d7df9b298289b6 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 14:45:12 +0200
Subject: [PATCH 06/28] Adapt mythpython's MythXML class to new Services/API.

Note: Integers and Bollean values need to be converted to strings.
---
 mythtv/bindings/python/MythTV/methodheap.py | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/methodheap.py b/mythtv/bindings/python/MythTV/methodheap.py
index cbbc8615096..21f49165b21 100644
--- a/mythtv/bindings/python/MythTV/methodheap.py
+++ b/mythtv/bindings/python/MythTV/methodheap.py
@@ -44,7 +44,7 @@ class MythBE( FileOps ):
         getLoad()                 - returns a tuple of load averages
         getRecordings()           - returns a list of all recordings
         getSGFile()               - returns information on a single file
-        getSGList()               - returns lists of directories, 
+        getSGList()               - returns lists of directories,
                                     files, and sizes
         getUptime()               - returns system uptime in seconds
         isActiveBackend()         - determines whether backend is
@@ -1136,7 +1136,7 @@ def getSetting(self, key, hostname=None, default=None):
         if default:
             args['Default'] = default
         return self._request('Myth/GetSetting', **args)\
-                         .readJSON()['SettingList']['Settings'][0]['Value']
+                                        .readJSON()['String']
 
     def getProgramGuide(self, starttime, endtime, startchan, numchan=None):
         """
@@ -1146,11 +1146,11 @@ def getProgramGuide(self, starttime, endtime, startchan, numchan=None):
         endtime = datetime.duck(endtime)
         args = {'StartTime':starttime.utcisoformat().rsplit('.',1)[0],
                 'EndTime':endtime.utcisoformat().rsplit('.',1)[0],
-                'StartChanId':startchan, 'Details':1}
+                'StartChanId':startchan, 'Details':'1'}
         if numchan:
             args['NumOfChannels'] = numchan
         else:
-            args['NumOfChannels'] = 1
+            args['NumOfChannels'] = '1'
 
         dat = self._request('Guide/GetProgramGuide', **args).readJSON()
         for chan in dat['ProgramGuide']['Channels']:
@@ -1177,7 +1177,8 @@ def getRecorded(self, descending=True):
         """
         Returns a list of Program objects for recorded shows on the backend.
         """
-        for prog in self._request('Dvr/GetRecorded', Descending=descending)\
+        descendingstr = 'true' if descending else 'false'
+        for prog in self._request('Dvr/GetRecordedList', Descending=descendingstr)\
                     .readJSON()['ProgramList']['Programs']:
             yield Program.fromJSON(prog, self.db)
 

From b50f0cc6cd5f74280174817f16838994de007b15 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 14:47:30 +0200
Subject: [PATCH 07/28] The conversion to timestamps from MythTV's datetime
 object  and vice versa does not work if current time is in daylight saving
 zone  (dst).

Because of this bug, the methods 'fromEtree' and 'fromJSON' of the class 'Program' of the Python bindings
cannot convert fetched time values of format '2016-03-14T01:59:21Z' to correct timestamps.

For additional info, see
https://stackoverflow.com/questions/8777753/converting-datetime-date-to-utc-timestamp-in-python

I added a revised 'timestamp' method to MythTV's python binding 'datetime' and compared the output:

    def revised_timestamp(self):
         # utc time = local time - utc offset
         utc_naive = self.replace(tzinfo=None) - self.utcoffset()
         utc_epoch = self.utcfromtimestamp(0).replace(tzinfo=None)
         return ((utc_naive - utc_epoch).total_seconds())

    def timestamp(self):
        return time.mktime(self.timetuple()) + self.microsecond/1000000.

In the follwing example, times are taken at
Saturday, June 1, 2019 2:03:48.066 PM GMT+02:00 DST (for variable 'now') and
Saturday, June 1, 2019 2:04:07.954 PM GMT+02:00 DST (for variable('now_utc')

$ python2
>>> from MythTV import datetime
>>> now = datetime.now()
>>> now
datetime(2019, 6, 1, 14, 3, 48, 66210, tzinfo=<MythTV.utility.dt.posixtzinfo object at 0x7ff760301910>)
>>> now.utcoffset()
datetime.timedelta(0, 7200)
>>> now.timestamp()
1559390628.06621

Check https://www.epochconverter.com/ :
Convert epoch to human readable date and vice versa
1559390628.06621
GMT: Saturday, June 1, 2019 12:03:48.066 PM
Your time zone: Saturday, June 1, 2019 2:03:48.066 PM GMT+02:00 DST
Relative: 4 minutes ago

---> That's correct.

>>> now_utc = datetime.utcnow()
>>> now_utc
datetime(2019, 6, 1, 12, 4, 7, 954273, tzinfo=<MythTV.utility.dt.posixtzinfo object at 0x7ff7602f22d0>)
>>> now_utc.utcoffset()
datetime.timedelta(0)
>>> now_utc.timestamp()
1559387047.954273

Check https://www.epochconverter.com/ :
Convert epoch to human readable date and vice versa
1559387047.954273
GMT: Saturday, June 1, 2019 11:04:07.954 AM
Your time zone: Saturday, June 1, 2019 1:04:07.954 PM GMT+02:00 DST

---> That's wrong !

Now let's do the same with the 'revised' method of datetime:
>>> now.revised_timestamp()
1559390628.06621
https://www.epochconverter.com/
Convert epoch to human readable date and vice versa
1559390628.06621
GMT: Saturday, June 1, 2019 12:03:48.066 PM
Your time zone: Saturday, June 1, 2019 2:03:48.066 PM GMT+02:00 DST

---> That's correct.

>>> now_utc.revised_timestamp()
1559390647.954273

https://www.epochconverter.com/
1559390647.954273
GMT: Saturday, June 1, 2019 12:04:07.954 PM
Your time zone: Saturday, June 1, 2019 2:04:07.954 PM GMT+02:00 DST

---> That's correct as well!
---
 mythtv/bindings/python/MythTV/utility/dt.py | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/mythtv/bindings/python/MythTV/utility/dt.py b/mythtv/bindings/python/MythTV/utility/dt.py
index 9efa4e1e17a..a651aed2e2f 100644
--- a/mythtv/bindings/python/MythTV/utility/dt.py
+++ b/mythtv/bindings/python/MythTV/utility/dt.py
@@ -474,7 +474,10 @@ def mythformat(self):
         return self.astimezone(self.UTCTZ()).strftime('%Y%m%d%H%M%S')
 
     def timestamp(self):
-        return time.mktime(self.timetuple()) + self.microsecond/1000000.
+         # utc time = local time - utc offset
+         utc_naive = self.replace(tzinfo=None) - self.utcoffset()
+         utc_epoch = self.utcfromtimestamp(0).replace(tzinfo=None)
+         return ((utc_naive - utc_epoch).total_seconds())
 
     def rfcformat(self):
         return self.strftime('%a, %d %b %Y %H:%M:%S %z')

From ca80770a86c8e1b40ac58f71919ae1158cd14e44 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 14:52:31 +0200
Subject: [PATCH 08/28] Update 'MythBE.getFreeRecorderList' to Myth Protocol
 91.

Myth Protocol 87 added GET_FREE_INPUT_INFO, and removed GET_FREE_RECORDER_LIST.
Myth Protocols 89,90,91 changed return values of command GET_FREE_INPUT_INFO.
See definition InputInfo in inputinfo.h.
The Backend Command 'GET_FREE_INPUT_INFO' (Myth Protocol) returns:
A variable length list of InputInfo entries in preferred live TV order.
Returns an empty list if no recorders are available.

This commit changes the method 'getFreeRecorderList' of the class 'MythBE'
to use GET_FREE_INPUT_INFO.
The return type (list of integers) keeps unchanged.

Additionally, it introduces a a method 'getFreeInputInfo' to return
a list of 'InputInfo' tuples of free recorders in preferred live TV order.
The backend command 'GET_FREE_INPUT_INFO 0' returns a list of variable length
containing one or more 'InputInfo' objects.

See definition of InputInfo in inputinfo.h.

InputInfo is a named tuple containing:
('InputInfo', ('name', 'sourceid', 'inputid', 'mplexid', 'chanid', 'displayName',
'recPriority', 'scheduleOrder', 'livetvorder', 'quickTune')).

Usage examples:

MythBE.getFreeInputInfo()[3].displayName   ---> 'Eingang 13:MPEG2TS'

[x.inputid for x in getFreeInputInfo()]   --->  list of free recorders
---
 mythtv/bindings/python/MythTV/methodheap.py | 43 +++++++++++++++++++--
 1 file changed, 40 insertions(+), 3 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/methodheap.py b/mythtv/bindings/python/MythTV/methodheap.py
index 21f49165b21..43a3e74d768 100644
--- a/mythtv/bindings/python/MythTV/methodheap.py
+++ b/mythtv/bindings/python/MythTV/methodheap.py
@@ -16,6 +16,8 @@
 
 from datetime import timedelta
 from weakref import proxy
+from collections import namedtuple
+
 try:
     from urllib import urlopen
 except ImportError:
@@ -58,6 +60,11 @@ class MythBE( FileOps ):
 
     locked_tuners = {}
 
+    # Prepare tuple for backend command 'GET_FREE_INPUT_INFO'
+    _i_info = ('name', 'sourceid', 'inputid', 'mplexid', 'chanid', 'displayName',
+               'recPriority', 'scheduleOrder', 'livetvorder', 'quickTune')
+    _InputInfo = namedtuple('InputInfo', _i_info)
+
     def __del__(self):
         self.freeTuner()
 
@@ -107,12 +114,42 @@ def getRecorderList(self):
 
     def getFreeRecorderList(self):
         """
-        Returns a list of free recorders, or an empty list if none.
+        Returns a list of free recorders in preferred live TV order,
+        or an empty list if none.
         """
-        res = self.backendCommand('GET_FREE_RECORDER_LIST').split(BACKEND_SEP)
-        recorders = [int(d) for d in res]
+        res = self.backendCommand('GET_FREE_INPUT_INFO 0').split(BACKEND_SEP)
+        # this maps the list of variable length ('res') to InputInfo tuples:
+        res_inputinfo = \
+            [self._InputInfo(*el) for el in zip(*[iter(res)]*len(self._i_info))]
+        recorders = [x.inputid for x in res_inputinfo]
         return recorders
 
+    def getFreeInputInfo(self):
+        """
+        Return a list of 'InputInfo' tuples of free recorders in preferred
+        live TV order.
+        Returns an empty list if no recorders are available.
+        Introduced in protocol 87, changed in protocols 89, 90, 91.
+
+        InputInfo is a named tuple containing:
+        ('InputInfo', ('name', 'sourceid', 'inputid', 'mplexid', 'chanid',
+                       'displayName', 'recPriority', 'scheduleOrder',
+                       'livetvorder', 'quickTune')).
+
+        See definition of InputInfo in inputinfo.h.
+
+        Usage examples:
+
+        MythBE.getFreeInputInfo()[3].displayName   ---> 'Eingang 13:MPEG2TS'
+
+        [x.inputid for x in getFreeInputInfo()]   --->  list of free recorders
+        """
+        res = self.backendCommand('GET_FREE_INPUT_INFO 0').split(BACKEND_SEP)
+        # this maps the list of variable length ('res') to InputInfo tuples:
+        res_inputinfo = \
+            [self._InputInfo(*el) for el in zip(*[iter(res)]*len(self._i_info))]
+        return res_inputinfo
+
     def lockTuner(self,id=None):
         """
         Request a tuner be locked from use, optionally specifying which tuner

From 0994cc622ae6a21c6d6be5efc4a75bcf41571c23 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 15:05:34 +0200
Subject: [PATCH 09/28] Fix MythSytemEvent class of MythTV's python bindings

MythSytemEvent:

An event is identified by the regex [A-Z0-9_]* .
This includes the system event `KEY_01`.

BEEventConnection:

The class `BEEventConnection` has optional arguements like
`timeout` an `level`. Name then if the arguement order is not followed strictly.

Typo in the call of
"SystemEvent(event['event'], inst.db).command(event)"

Note:
'inst.db' is not a valid class at this level

Uppercase of system event scripts:

According wiki, the default substitution of parameters is given by uppercase,
like '%STARTTIMEUTC%' or %SENDER%'. Stick to that convention.
---
 mythtv/bindings/python/MythTV/methodheap.py | 6 +++---
 mythtv/bindings/python/MythTV/system.py     | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/methodheap.py b/mythtv/bindings/python/MythTV/methodheap.py
index 43a3e74d768..737fecd4d00 100644
--- a/mythtv/bindings/python/MythTV/methodheap.py
+++ b/mythtv/bindings/python/MythTV/methodheap.py
@@ -448,7 +448,7 @@ class systemeventhandler( object ):
         bs = BACKEND_SEP.replace('[','\[').replace(']','\]')
         re_process = re.compile(bs.join([
                 'BACKEND_MESSAGE',
-                'SYSTEM_EVENT (?P<event>[A-Z_]*)'
+                'SYSTEM_EVENT (?P<event>[A-Z0-9_]*)'
                     '( HOSTNAME (?P<hostname>[a-zA-Z0-9_\.]*))?'
                     '( SENDER (?P<sender>[a-zA-Z0-9_\.]*))?'
                     '( CARDID (?P<cardid>[0-9]*))?'
@@ -516,11 +516,11 @@ def __init__(self, backend=None, blockshutdown=False, db=None,
             self.registerevent(self._generic_handler)
 
     def _neweventconn(self):
-        return BEEventConnection(self.host, self.port, self.db.gethostname(), 3)
+        return BEEventConnection(self.host, self.port, self.db.gethostname(), level=3)
 
     @systemeventhandler
     def _generic_handler(self, event):
-        SystemEvent(event['event'], inst.db).command(event)
+        SystemEvent(event['event'], self.db).command(event)
 
 class Frontend( FEConnection ):
     _db = None
diff --git a/mythtv/bindings/python/MythTV/system.py b/mythtv/bindings/python/MythTV/system.py
index 62f1e72c0f4..aeeda8e401a 100644
--- a/mythtv/bindings/python/MythTV/system.py
+++ b/mythtv/bindings/python/MythTV/system.py
@@ -445,5 +445,5 @@ def command(self, eventdata):
             cmd = eventdata['program'].formatJob(cmd)
         for a in ('sender','cardid','secs'):
             if a in eventdata:
-                cmd = cmd.replace('%%%s%%' % a, eventdata[a])
+                cmd = cmd.replace('%%%s%%' % a.upper(), eventdata[a])
         return self._runcmd(cmd)

From fe1d1acba3a30d60431ff934212daf773ae19395 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 15:08:33 +0200
Subject: [PATCH 10/28] Allow storage group paths without trailing slashes in
 Python  Binding findfile method.

Use 'os.path.join instead of simply adding strings (path, filename).
This covers both options, paths with or without trailing slashes.
---
 mythtv/bindings/python/MythTV/mythproto.py | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/mythproto.py b/mythtv/bindings/python/MythTV/mythproto.py
index aa45d326b75..949efc1b22f 100644
--- a/mythtv/bindings/python/MythTV/mythproto.py
+++ b/mythtv/bindings/python/MythTV/mythproto.py
@@ -185,12 +185,12 @@ def findfile(filename, sgroup, db=None):
     for sg in db.getStorageGroup(groupname=sgroup):
         # search given group
         if sg.local:
-            if os.access(sg.dirname+filename, os.F_OK):
+            if os.access(os.path.join(sg.dirname, filename), os.F_OK):
                 return sg
     for sg in db.getStorageGroup():
         # not found, search all other groups
         if sg.local:
-            if os.access(sg.dirname+filename, os.F_OK):
+            if os.access(os.path.join(sg.dirname, filename), os.F_OK):
                 return sg
     return None
 
@@ -627,7 +627,7 @@ class FileOps( BECache ):
         reschedule()        - trigger a run of the scheduler
         fileExists()        - check whether a file can be found on a backend
         download()          - issue a download by the backend
-        downloadTo()        - issue a download by the backend to a defined 
+        downloadTo()        - issue a download by the backend to a defined
                               location
         allocateEventLock() - create an EventLock object that will be locked
                               until a requested regular expression is

From 3ea7bd014307a03cd65265191edf85ff2520db0a Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 15:10:55 +0200
Subject: [PATCH 11/28] Various fixes of MythTV Python Bindings in
 mythproto.py.

Commit eebe25c introduced the new setting 'BackendServerAddr' instead
of 'BackendServerIP[6]'. See ticket #13082.
Fix another occurence of  'BackendServerIP[6]' in class BECache.

In mythtv's protocol #84 the event 'UPDATE_FILE_SIZE' changed to use
'recordedid' instead of tuple ('chanid', 'starttime').
This commit adds an optional parameter 'recordedid' to ftopen(),
but still allows the optional ('chanid', 'starttime') tuple, and
fixes the handling of this event.
See ticket #12365, comment:5.

Fix the optional arguements when openening the control socket in the
class 'FileTransfer'. We need to enable receive events, if we want
listen to them. Long time ago, the commit cd23715 changed this
behaviour of the BEEvent class.

The method 'FileOps.downloadTo()' listen only for events
'DOWNLOAD_FILE UPDATE'. In short file transfers, the event
'DOWNLOAD_FILE FINISHED' is sent without an update event.
Listen for both events when allocating an eventlock.
---
 mythtv/bindings/python/MythTV/mythproto.py | 53 ++++++++++++----------
 1 file changed, 28 insertions(+), 25 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/mythproto.py b/mythtv/bindings/python/MythTV/mythproto.py
index 949efc1b22f..9aa8d725a75 100644
--- a/mythtv/bindings/python/MythTV/mythproto.py
+++ b/mythtv/bindings/python/MythTV/mythproto.py
@@ -81,12 +81,12 @@ def __init__(self, backend=None, blockshutdown=False, events=False, db=None):
                 # given backend is IP address
                 self.host = backend
                 self.hostname = self.db._gethostfromaddr(
-                                            backend, 'BackendServerIP')
+                                            backend, 'BackendServerAddr')
             elif check_ipv6(backend):
                 # given backend is IPv6 address
                 self.host = backend
                 self.hostname = self.db._gethostfromaddr(
-                                            backend, 'BackendServerIP6')
+                                            backend, 'BackendServerAddr')
             else:
                 # given backend is hostname, pull address from database
                 self.hostname = backend
@@ -195,7 +195,7 @@ def findfile(filename, sgroup, db=None):
     return None
 
 def ftopen(file, mode, forceremote=False, nooverwrite=False, db=None, \
-                       chanid=None, starttime=None, download=False):
+                chanid=None, starttime=None, recordedid=None, download=False):
     """
     ftopen(file, mode, forceremote=False, nooverwrite=False, db=None)
                                         -> FileTransfer object
@@ -218,17 +218,6 @@ def ftopen(file, mode, forceremote=False, nooverwrite=False, db=None, \
     if mode not in ('r','w'):
         raise TypeError("File I/O must be of type 'r' or 'w'")
 
-    if chanid and starttime:
-        protoopen = lambda host, file, storagegroup: \
-                      RecordFileTransfer(host, file, storagegroup,\
-                                         mode, chanid, starttime, db)
-    elif download:
-        protoopen = lambda host, lfile, storagegroup: \
-                      DownloadFileTransfer(host, lfile, storagegroup, \
-                                           mode, file, db)
-    else:
-        protoopen = lambda host, file, storagegroup: \
-                      FileTransfer(host, file, storagegroup, mode, db)
 
     # process URI (myth://<group>@<host>[:<port>]/<path/to/file>)
     match = None
@@ -253,6 +242,24 @@ def ftopen(file, mode, forceremote=False, nooverwrite=False, db=None, \
     if reip.match(host) or check_ipv6(host):
         host = db._gethostfromaddr(host)
 
+    # select the correct transfer function:
+    if chanid and starttime and not recordedid:
+        #  get recordedid from FileOps class
+        recordedid = \
+            FileOps(host, db=db).getRecording(chanid, starttime).recordedid
+    if recordedid:
+        protoopen = lambda host, file, storagegroup: \
+                      RecordFileTransfer(host, file, storagegroup,\
+                                         mode, recordedid, db)
+    elif download:
+        protoopen = lambda host, lfile, storagegroup: \
+                      DownloadFileTransfer(host, lfile, storagegroup, \
+                                           mode, file, db)
+    else:
+        protoopen = lambda host, file, storagegroup: \
+                      FileTransfer(host, file, storagegroup, mode, db)
+
+
     # user forced to remote access
     if forceremote:
         if (mode == 'w') and (filename.find('/') != -1):
@@ -370,7 +377,7 @@ def __init__(self, host, filename, sgroup, mode, db=None):
         self.mode = mode
 
         # open control socket
-        BEEvent.__init__(self, host, True, db=db)
+        BEEvent.__init__(self, host, blockshutdown=True, events=True, db=db)
         # open transfer socket
         self.ftsock = self.BETransConn(self.host, self.port,
                     self._conn.command.localname, self.filename,
@@ -549,18 +556,16 @@ def updatesize(self, event=None):
             self.re_update = re.compile(\
               re.escape(BACKEND_SEP).\
                 join(['BACKEND_MESSAGE',
-                      'UPDATE_FILE_SIZE %s %s (?P<size>[0-9]*)' %\
-                         (self.chanid, \
-                          self.starttime.isoformat()),
+                      'UPDATE_FILE_SIZE %s (?P<size>[0-9]*)' %\
+                         (self.recordedid),
                       'empty']))
             return self.re_update
         match = self.re_update.match(event)
         self._size = int(match.group('size'))
 
     def __init__(self, host, filename, sgroup, mode,
-                       chanid, starttime, db=None):
-        self.chanid = chanid
-        self.starttime = starttime
+                       recordedid, db=None):
+        self.recordedid = recordedid
         FileTransfer.__init__(self, host, filename, sgroup, mode, db)
 
 class DownloadFileTransfer( FileTransfer ):
@@ -721,7 +726,7 @@ def downloadTo(self, url, storagegroup, filename, \
             eventlock = self.allocateEventLock(\
                     re.escape(BACKEND_SEP).\
                             join(['BACKEND_MESSAGE',
-                                  'DOWNLOAD_FILE UPDATE',
+                                  'DOWNLOAD_FILE (FINISHED|UPDATE)',
                                   re.escape(url)]))
         if filename[0] != '/':
             filename = '/'+filename
@@ -970,9 +975,7 @@ def delete(self, force=False, rerecord=False):
     def _openProto(self):
         filename = self.filename if self.filename.startswith('myth://') else \
                     (self.hostname, self.storagegroup, self.filename)
-        return ftopen(filename, 'r', db=self._db, chanid=self.chanid, \
-                      starttime=self.recstartts)
-
+        return ftopen(filename, 'r', db=self._db, recordedid = self.recordedid)
     def _openXML(self):
         xml = XMLConnection(self.hostname, 6544)
         return xml._request('Content/GetRecording', ChanId=self.chanid, \

From 7ac4e9e21f830d9ad0bfeabcb5fc3287267dda84 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 15:13:20 +0200
Subject: [PATCH 12/28] Python Bindings Recorded.formatPath() bails if airdate
 is not  set.

Calling 'Recorded.formatPath("%U/%T/%pY-%pm-%pd %pH.%pi %T")' on a valid
Recorded instance, gives a traceback.

Recorded.formatPath  without valid airdate:

Traceback (most recent call last):
  File "test/test_Dataheap_Recorded_001.py", line 116, in test_Dataheap_Recorded_001_04
    print(rec.formatPath("%U/%T/%pY-%pm-%pd %pH.%pi %T"))
  File "MythTV/dataheap.py", line 440, in formatPath
    path = path.replace('%o'+tag, airdate.strftime(format))
ValueError: year=1 is before 1900; the datetime strftime() methods require year >= 1900

Setting 'airdate' to
_default_datetime = datetime(1900,1,1, tzinfo=datetime.UTCTZ())
cures it.
---
 mythtv/bindings/python/MythTV/dataheap.py | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/mythtv/bindings/python/MythTV/dataheap.py b/mythtv/bindings/python/MythTV/dataheap.py
index 946015c4129..f4f182276c1 100644
--- a/mythtv/bindings/python/MythTV/dataheap.py
+++ b/mythtv/bindings/python/MythTV/dataheap.py
@@ -428,7 +428,8 @@ def formatPath(self, path, replace=None):
                                   ('a','%p'),('A','%p') ):
                 path = path.replace(pre+tag, self[data].strftime(format))
         if self.originalairdate is None:
-            airdate = date(1,1,1)
+            airdate = _default_datetime
+
         else:
             airdate = self.originalairdate
         for (tag, format) in (('y','%y'),('Y','%Y'),('n','%m'),('m','%m'),

From 7e02d1e815131a5f0bc028b876c8e8cb1f6be95c Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 15:14:43 +0200
Subject: [PATCH 13/28] The class methods Job.from[Recorded,Program] should
 return the created class.

Python Bindings: When creating a Job instance with 'Job.fromRecorded' or
Job.fromProgram, the new created instances are not returned, like in the other
'Class.fromSomething' methods of the bindings.
---
 mythtv/bindings/python/MythTV/dataheap.py | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/dataheap.py b/mythtv/bindings/python/MythTV/dataheap.py
index f4f182276c1..653c779e4a2 100644
--- a/mythtv/bindings/python/MythTV/dataheap.py
+++ b/mythtv/bindings/python/MythTV/dataheap.py
@@ -708,7 +708,7 @@ def fromRecorded(cls, rec, type, status=None, schedruntime=None,
             job.args = args
         if flags:
             job.flags = flags
-        job.create()
+        return job.create()
 
     @classmethod
     def fromProgram(cls, prog, type, status=None, schedruntime=None,
@@ -729,7 +729,7 @@ def fromProgram(cls, prog, type, status=None, schedruntime=None,
             job.args = args
         if flags:
             job.flags = flags
-        job.create()
+        return job.create()
 
 class Channel( DBDataWrite ):
     """Channel(chanid=None, db=None) -> Channel object"""

From 6d32cd38a795f85383b7146edcc3d4f1462c5a32 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 15:16:47 +0200
Subject: [PATCH 14/28] Fix check in Python's Job.fromProgram classmethod.

We want to check the status of a recorded programg, and not the type.
In file static.py, the 'rsRecorded' is a member of RECSTATUS,
therefore check for 'recstatus' instead of 'rectype'.
---
 mythtv/bindings/python/MythTV/dataheap.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/mythtv/bindings/python/MythTV/dataheap.py b/mythtv/bindings/python/MythTV/dataheap.py
index 653c779e4a2..8ff7e843f92 100644
--- a/mythtv/bindings/python/MythTV/dataheap.py
+++ b/mythtv/bindings/python/MythTV/dataheap.py
@@ -713,7 +713,7 @@ def fromRecorded(cls, rec, type, status=None, schedruntime=None,
     @classmethod
     def fromProgram(cls, prog, type, status=None, schedruntime=None,
                                 hostname=None, args=None, flags=None):
-        if prog.rectype != prog.rsRecorded:
+        if prog.recstatus != prog.rsRecorded:
             raise MythError('Invalid recording type for Job.')
         job = cls(db=prog._db)
         job.type = type

From 1262662004100182e1476b8b56e5810ed5a23d49 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 15:19:42 +0200
Subject: [PATCH 15/28] Logging in the 'deadlinesocket' fails if dealing with
 utf-8 encoded strings.

The logging of the 'sendheader' and 'recvheader' methods needs unicode,
but the methods itself need to be fed with 'utf-8' encoded data.

See commit e20bd8b for further details.

Since thees methods itself deal with 'utf-8' encoded data, we need to
decode these data to unicode before we send them to the logging instance.

This commit provides and uses a generic function to decode strings to unicode for
python2 and python3, as well.

How to reproduce:

Start python from a PC that has mythtv frontend installed, but it is not currently
running:

When running the MythTV's python binding `BEEventMonitor`
and log events to a file, a traceback occurs:

$ python2 - --nodblog --loglevel debug --verbose all --logfile /tmp/my_logfile
>>> from MythTV import BEEventMonitor
>>> bemon = BEEventMonitor(systemevents=True)
>>> while (True):
....    continue

From another frontend, start playback of a recording that has a description
with German umlauts or French accents:

Enjoy the traceback:

Unhandled exception in thread started by
     <bound method BEEventConnection.eventloop
         of <MythTV.connections.BEEventConnection object at 0x7f6f922c1ad0>>
Traceback (most recent call last):
  File "MythTV/connections.py", line 427, in eventloop
    self.queueEvents()
  File "MythTV/connections.py", line 396, in queueEvents
    event = self.socket.recvheader(deadline=0.0)
  File "MythTV/utility/other.py", line 387, in recvheader
    'read <-- %d' % size, data)
  File "MythTV/logging.py", line 431, in __call__
    self.log(mask, level, message, detail)
  File "MythTV/logging.py", line 376, in log
    self._logwrite(mask, level, message, detail)
  File "MythTV/logging.py", line 408, in _logfile
    self._LOGFILE.write(buff.getvalue())
  File "/usr/lib/python2.7/codecs.py", line 708, in write
    return self.writer.write(data)
  File "/usr/lib/python2.7/codecs.py", line 369, in write
    data, consumed = self.encode(object, self.errors)
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 260:
    ordinal not in range(128)
---
 mythtv/bindings/python/MythTV/utility/other.py | 18 +++++++++++++++---
 1 file changed, 15 insertions(+), 3 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/utility/other.py b/mythtv/bindings/python/MythTV/utility/other.py
index 543bef38a00..740e81b107b 100644
--- a/mythtv/bindings/python/MythTV/utility/other.py
+++ b/mythtv/bindings/python/MythTV/utility/other.py
@@ -55,7 +55,7 @@ def run(self):
         except AttributeError as e:
             self.log(MythLog.GENERAL, MythLog.CRIT,
                      'failed at %d' % schema, 'no handler method')
-            raise MythDBError('Schema update failed, ' 
+            raise MythDBError('Schema update failed, '
                     "SchemaUpdate has no function 'up%s'" % schema)
 
         except StopIteration:
@@ -383,15 +383,16 @@ def recvheader(self, flags=0, deadline=None):
         """
         size = int(self.dlrecv(8, flags, deadline))
         data = self.dlrecv(size, flags, deadline)
+        # data is utf-8 encoded, convert to unicode for logging and ignore errors
         self.log(MythLog.SOCKET|MythLog.NETWORK, MythLog.DEBUG, \
-                            'read <-- %d' % size, data)
+                            'read <-- %d' % size, py23_str(data, True))
         return data
 
     def sendheader(self, data, flags=0):
         """Send data, prepending the length in the first 8 bytes."""
         try:
             self.log(MythLog.SOCKET|MythLog.NETWORK, MythLog.DEBUG, \
-                                'write --> %d' % len(data), data)
+                            'write --> %d' % len(data), py23_str(data, True))
             data = '%-8d%s' % (len(data), data)
             self.send(data, flags)
         except socket.error as e:
@@ -572,6 +573,17 @@ def check_ipv6(n):
     except socket.error:
         return False
 
+def py23_str(value, ignore_errors=False):
+    error_methods = ('strict', 'ignore')
+    error_method  = error_methods[ignore_errors]
+    try:  # Python 2
+        return unicode(value, errors=error_method, encoding='utf-8')
+    except NameError:  # Python 3
+        try:
+            return str(value,errors=error_method, encoding='utf-8')
+        except TypeError:  # Wasn't a bytes object, no need to decode
+            return str(value)
+
 class QuickProperty( object ):
     def __init__(self, maskedvar, default=None, handler=None):
         self.varname = maskedvar

From 89a1567ebc0982551c5d4efb80c0c28c2cc1e062 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 15:23:34 +0200
Subject: [PATCH 16/28] Fix mysql connection of the Python Bindings for
 python3.

The ticket #11938 shows a bug when connectiong to mysql using the python bindings.

This initial commit shows the initial intention of the author:

[Commit]4b3f512b[/Commit]
or
https://github.com/MythTV/mythtv/commit/980ae04

Let's stick to it.

Note: This will close #11938.
---
 mythtv/bindings/python/MythTV/_conn_mysqldb.py | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/_conn_mysqldb.py b/mythtv/bindings/python/MythTV/_conn_mysqldb.py
index 676d147a62a..177a880a121 100644
--- a/mythtv/bindings/python/MythTV/_conn_mysqldb.py
+++ b/mythtv/bindings/python/MythTV/_conn_mysqldb.py
@@ -34,12 +34,12 @@ def __init__(self, connection):
         super(LoggedCursor, self).__init__(connection)
         self.log = None
         self.ping = ref(self._ping121)
-        if MySQLdb.version_info >= ('1','2','2'):
+        if MySQLdb.version_info >= (1, 2, 2):
             self.ping = ref(self._ping122)
         self.ping()
 
-    def _ping121(self): self._get_db().ping(True)
-    def _ping122(self): self._get_db().ping()
+    def _ping121(self): self._get_db().ping()
+    def _ping122(self): self._get_db().ping(True)
 
     def _sanitize(self, query): return query.replace('?', '%s')
 

From 27dd6ad92b063bc1ca893fb10a4682dd13742c25 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 15:40:22 +0200
Subject: [PATCH 17/28] Fix Python Bindings to be compatible to python3 as
 well.

 - Make deadlinesocket of python bindings compatible to python3, too.

   MythTV's python bindings based on `deadlinesocket` need a
   byte like object in python3.
   Convert everything to/from utf-8 when sending/receiving data from
   the socket.

 - Update iterators and dictionaries of Python Bindings to be compatible
   to python3 as well.

   According porting guides to python3 [1], the methods
   `dict.keys()`, `dict.items()` and `dict.values()` now return
   views instead of lists.
   Unlike lists, a view does not hold copy the data.
   Updates to the underlying dict are reflected in the view.
   Use `list(dict.keys(), dict.items() and dict.values()` as appropriate.

 - Additionally, python2's `next()` method changed to python3 built-in
   function `next()`.

 - Convert `xrange` (python2) to `range` (python3).

 - Fix logging, convert to 'utf-8'.

 - Add a generic function `py23_str` to convert data to unicode/str.

 - Fix python3 handling of time-zone files after applying
   Handle-timezone-files-with-no-modern-transitions-as-well[29/master].patch
   from ticket #13299
---
 mythtv/bindings/python/MythTV/connections.py  | 14 ++++-----
 mythtv/bindings/python/MythTV/database.py     |  6 ++--
 mythtv/bindings/python/MythTV/dataheap.py     |  7 +++--
 mythtv/bindings/python/MythTV/logging.py      | 14 ++++-----
 mythtv/bindings/python/MythTV/methodheap.py   | 30 +++++++++++--------
 mythtv/bindings/python/MythTV/msearch.py      |  3 +-
 mythtv/bindings/python/MythTV/mythproto.py    |  7 ++++-
 mythtv/bindings/python/MythTV/system.py       |  4 +--
 .../python/MythTV/utility/__init__.py         |  2 +-
 mythtv/bindings/python/MythTV/utility/dt.py   | 13 ++++----
 .../bindings/python/MythTV/utility/other.py   | 10 ++++---
 11 files changed, 63 insertions(+), 47 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/connections.py b/mythtv/bindings/python/MythTV/connections.py
index e541d2cca1e..b83a445ea1c 100644
--- a/mythtv/bindings/python/MythTV/connections.py
+++ b/mythtv/bindings/python/MythTV/connections.py
@@ -313,7 +313,7 @@ def backendCommand(self, data, deadline=None):
 
                 # convert to unicode
                 try:
-                    res = str(''.join([res]), 'utf8')
+                    res = str(b''.join([res]), 'utf-8')
                 except:
                     res = u''.join([res])
 
@@ -396,7 +396,7 @@ def queueEvents(self):
                     event = self.socket.recvheader(deadline=0.0)
 
                     try:
-                        event = str(''.join([event]), 'utf8')
+                        event = str(b''.join([event]), 'utf-8')
                     except:
                         event = u''.join([event])
 
@@ -526,7 +526,7 @@ def connect(self, test=True):
     def disconnect(self):
         if not self.isConnected:
             return
-        self.socket.send("exit")
+        self.socket.send(b"exit")
         self.socket.close()
         self.socket = None
         self.isConnected = False
@@ -542,25 +542,25 @@ def send(self, mode, command=None):
         if not self.isConnected:
             self.connect()
         if command is None:
-            self.socket.send("help %s\n" % mode)
+            self.socket.send(("help %s\n" % mode).encode('utf-8'))
             res = self.recv()
             try:
                 return self._res_help[mode].findall(res)
             except:
                 return self._res_help[mode](res)
         else:
-            self.socket.send("%s %s\n" % (mode, command))
+            self.socket.send((u"%s %s\n" % (mode, command)).encode('utf-8'))
             return self._res_handler[mode](self.recv())
 
     def recv(self, deadline=None):
-        prompt = re.compile('([\r\n.]*)\r\n# ')
+        prompt = re.compile(b'([\r\n.]*)\r\n# ')
         try:
             res = self.socket.dlexpect(prompt, deadline=deadline)
         except socket.error:
             raise MythFEError(MythError.FE_CONNECTION, self.host, self.port)
         except KeyboardInterrupt:
             raise
-        return prompt.split(res)[0]
+        return prompt.split(res)[0].decode('utf-8')
 
 class XMLConnection( object ):
     """
diff --git a/mythtv/bindings/python/MythTV/database.py b/mythtv/bindings/python/MythTV/database.py
index f7f23b9a806..885cd4d310e 100644
--- a/mythtv/bindings/python/MythTV/database.py
+++ b/mythtv/bindings/python/MythTV/database.py
@@ -346,7 +346,7 @@ def _create(self, data=None, cursor=None):
 
         self._import(data)
         data = self._sanitize(dict(self))
-        for key,val in data.items():
+        for key,val in list(data.items()):
             if val is None:
                 del data[key]
             elif isinstance(val, datetime):
@@ -392,7 +392,7 @@ def _push(self):
         if (self._where is None) or (self._wheredat is None):
             return
         data = self._sanitize(dict(self))
-        for key, value in data.items():
+        for key, value in list(data.items()):
             if value == self._origdata[key]:
             # filter unchanged data
                 del data[key]
@@ -402,7 +402,7 @@ def _push(self):
             # no updates
             return
         format_string = ', '.join(['%s = ?' % d for d in data])
-        sql_values = data.values()
+        sql_values = list(data.values())
         sql_values.extend(self._getwheredat())
         with self._db.cursor(self._log) as cursor:
             cursor.execute("""UPDATE %s SET %s WHERE %s""" \
diff --git a/mythtv/bindings/python/MythTV/dataheap.py b/mythtv/bindings/python/MythTV/dataheap.py
index 8ff7e843f92..e3338fbb9de 100644
--- a/mythtv/bindings/python/MythTV/dataheap.py
+++ b/mythtv/bindings/python/MythTV/dataheap.py
@@ -126,17 +126,18 @@ def _setClassDefs(cls, db=None):
         db = DBCache(db)
         super(Record, cls)._setClassDefs(db)
         defaults = cls._template('Default', db=db)
-        for k,v in defaults.iteritems():
+        for k,v in list(defaults.items()):
             cls._defaults[k] = v
 
+
     _stored_templates = {}
     @classmethod
     def _template(cls, name, db=None):
         if name not in cls._stored_templates:
             db = DBCache(db)
             cls._setClassDefs(db)
-            tmp = cls._fromQuery("WHERE title=?", (name + " (Template)",))\
-                                    .next().iteritems()
+            tmp = next(cls._fromQuery("WHERE title=?", (name + " (Template)",)))\
+                                    .iteritems()
             data = {}
             for k,v in tmp:
                 if k in ['type', 'category', 'profile', 'recpriority',
diff --git a/mythtv/bindings/python/MythTV/logging.py b/mythtv/bindings/python/MythTV/logging.py
index 7304be4d717..63cac19affa 100644
--- a/mythtv/bindings/python/MythTV/logging.py
+++ b/mythtv/bindings/python/MythTV/logging.py
@@ -110,24 +110,24 @@ def _initlogger(cls):
     @classmethod
     def _parseinput(cls):
         args = iter(argv)
-        args.next()
+        next(args)
         try:
             while True:
-                arg = args.next()
+                arg = next(args)
                 if arg == '--quiet':
                     cls._QUIET += 1
                 elif arg == '--nodblog':
                     cls._DBLOG = False
                 elif arg == '--loglevel':
-                    cls._setlevel(args.next())
+                    cls._setlevel(next(args))
                 elif arg == '--verbose':
-                    cls._setmask(args.next())
+                    cls._setmask(next(args))
                 elif arg == '--logfile':
-                    cls._setfile(args.next())
+                    cls._setfile(next(args))
                 elif arg == '--logpath':
-                    cls._setpath(args.next())
+                    cls._setpath(next(args))
                 elif arg == '--syslog':
-                    cls._setsyslog(args.next())
+                    cls._setsyslog(next(args))
                 elif arg == '--':
                     break
 
diff --git a/mythtv/bindings/python/MythTV/methodheap.py b/mythtv/bindings/python/MythTV/methodheap.py
index 737fecd4d00..aa581d7cf09 100644
--- a/mythtv/bindings/python/MythTV/methodheap.py
+++ b/mythtv/bindings/python/MythTV/methodheap.py
@@ -25,6 +25,11 @@
 
 import re
 
+try:
+    xrange
+except NameError:
+    xrange = range
+
 class CaptureCard( DBData ):
     pass
 
@@ -294,7 +299,7 @@ def getFreeSpace(self,all=False):
             command = 'QUERY_FREE_SPACE_LIST'
         res = self.backendCommand(command).split(BACKEND_SEP)
         l = len(FreeSpace._field_order)
-        for i in xrange(len(res)/l):
+        for i in xrange(len(res)//l):
             yield FreeSpace(res[i*l:i*l+l])
 
     def getFreeSpaceSummary(self):
@@ -327,17 +332,18 @@ def walkSG(self, host, sg, top=None):
         """
         def walk(self, host, sg, root, path):
             res = self.getSGList(host, sg, root+path+'/')
-            if res < 0:
-                return {}
-            dlist = list(res[0])
-            res = [dlist, dict(zip(res[1], res[2]))]
-            if path == '':
-                res = {'/':res}
+            if isinstance(res, tuple):
+                dlist = list(res[0])
+                res = [dlist, dict(zip(res[1], res[2]))]
+                if path == '':
+                    res = {'/':res}
+                else:
+                    res = {path:res}
+                for d in dlist:
+                    res.update(walk(self, host, sg, root, path+'/'+d))
+                return res
             else:
-                res = {path:res}
-            for d in dlist:
-                res.update(walk(self, host, sg, root, path+'/'+d))
-            return res
+                return {}
 
         bases = self.getSGList(host, sg, '')
         if (top == '/') or (top is None): top = ''
@@ -352,7 +358,7 @@ def walk(self, host, sg, root, path):
                     walked[d] = res[d]
 
         res = []
-        for key, val in walked.iteritems():
+        for key, val in list(walked.items()):
             res.append((key, tuple(val[0]), val[1]))
         res.sort()
         return res
diff --git a/mythtv/bindings/python/MythTV/msearch.py b/mythtv/bindings/python/MythTV/msearch.py
index ca89a0928d4..b884679ce21 100644
--- a/mythtv/bindings/python/MythTV/msearch.py
+++ b/mythtv/bindings/python/MythTV/msearch.py
@@ -59,7 +59,7 @@ def search(self, timeout=5.0, filter=None):
                             'ST: ssdp:all',''])
         self._runsearch = True
         # spam the request a couple times
-        [sock.sendto(sreq, self.dest) for i in range(3)]
+        [sock.sendto(sreq.encode('utf-8'), self.dest) for i in range(3)]
 
         atime = time()+timeout
         while (time()<atime) and self._runsearch:
@@ -67,6 +67,7 @@ def search(self, timeout=5.0, filter=None):
                 sdata, saddr = sock.recvfrom(2048)
             except socket.error:
                 continue #no data, continue
+            sdata = sdata.decode('utf-8')
 
             lines = sdata.split('\n')
             sdict = {'request':lines[0].strip()}
diff --git a/mythtv/bindings/python/MythTV/mythproto.py b/mythtv/bindings/python/MythTV/mythproto.py
index 9aa8d725a75..08a62546647 100644
--- a/mythtv/bindings/python/MythTV/mythproto.py
+++ b/mythtv/bindings/python/MythTV/mythproto.py
@@ -26,6 +26,11 @@
 import re
 import os
 
+try:
+    xrange
+except NameError:
+    xrange = range
+
 class BECache( object ):
     """
     BECache(backend=None, noshutdown=False, db=None)
@@ -424,7 +429,7 @@ def read(self, size):
         if self._pos + size > self._size:
             size = self._size - self._pos
 
-        buff = ''
+        buff = b''
         while len(buff) < size:
             ct = size - len(buff)
             if ct > self._tsize:
diff --git a/mythtv/bindings/python/MythTV/system.py b/mythtv/bindings/python/MythTV/system.py
index aeeda8e401a..821faf5f128 100644
--- a/mythtv/bindings/python/MythTV/system.py
+++ b/mythtv/bindings/python/MythTV/system.py
@@ -63,10 +63,10 @@ def system(cls, command, db=None):
             s = cls(path, db=db)
             res = s(args)
             if len(res):
-                s.log(MythLog.SYSTEM, MythLog.DEBUG, '---- Output ----', res)
+                s.log(MythLog.SYSTEM, MythLog.DEBUG, '---- Output ----', res.decode('utf-8'))
             if len(s.stderr):
                 s.log(MythLog.SYSTEM, MythLog.DEBUG,
-                                               '---- Error  ----', s.stderr)
+                                               '---- Error  ----', s.stderr.decode('utf-8'))
             return 0
         except (MythDBError,MythFileError):
             return -1
diff --git a/mythtv/bindings/python/MythTV/utility/__init__.py b/mythtv/bindings/python/MythTV/utility/__init__.py
index 31d2afae28b..9e8913adc51 100644
--- a/mythtv/bindings/python/MythTV/utility/__init__.py
+++ b/mythtv/bindings/python/MythTV/utility/__init__.py
@@ -7,4 +7,4 @@
 
 from .other import _donothing, SchemaUpdate, databaseSearch, deadlinesocket, \
                    MARKUPLIST, levenshtein, ParseEnum, ParseSet, CopyData, \
-                   CopyData2, check_ipv6, QuickProperty
+                   CopyData2, check_ipv6, QuickProperty, py23_str
diff --git a/mythtv/bindings/python/MythTV/utility/dt.py b/mythtv/bindings/python/MythTV/utility/dt.py
index a651aed2e2f..c669e3d767a 100644
--- a/mythtv/bindings/python/MythTV/utility/dt.py
+++ b/mythtv/bindings/python/MythTV/utility/dt.py
@@ -129,7 +129,7 @@ class posixtzinfo( basetzinfo ):
     @staticmethod
     def _get_version(fd):
         """Confirm zoneinfo file magic string, and return version number."""
-        if fd.read(4) != 'TZif':
+        if fd.read(4) != b'TZif':
             raise MythTZError(MythTZError.TZ_INVALID_FILE)
         version = fd.read(1) # read version number
         fd.seek(15, 1) # skip reserved bytes
@@ -172,7 +172,7 @@ def _process(self, fd, version=1, skip=False):
                 transitions[i] = ([t, tt, None, None, None, None])
                 if first_modern_transition is None:
                     first_modern_transition = i
-            except ValueError as e:
+            except (ValueError, OSError) as e:
                 # ValueError is only accepted until we have seen a modern
                 # transition.
                 if first_modern_transition is not None:
@@ -202,7 +202,7 @@ def _process(self, fd, version=1, skip=False):
             transitions[i][5] = isdst
 
         # read in type names
-        for i, name in enumerate(fd.read(counts.abbrevs)[:-1].split('\0')):
+        for i, name in enumerate(fd.read(counts.abbrevs)[:-1].split(b'\0')):
             for j in range(first_modern_transition, counts.transitions):
                 if types[j] == i:
                     transitions[j][4] = name
@@ -222,17 +222,18 @@ def _process(self, fd, version=1, skip=False):
 
     def __init__(self, name=None):
         if name:
-            fd = open('/usr/share/zoneinfo/' + name)
+            fd = open('/usr/share/zoneinfo/' + name, 'rb')
         elif os.getenv('TZ'):
-            fd = open('/usr/share/zoneinfo/' + os.getenv('TZ'))
+            fd = open('/usr/share/zoneinfo/' + os.getenv('TZ'), 'rb')
         else:
-            fd = open('/etc/localtime')
+            fd = open('/etc/localtime', 'rb')
 
         version = self._get_version(fd)
         if version == 2:
             self._process(fd, skip=True)
             self._get_version(fd)
         self._process(fd, version)
+        fd.close()
 
 class offsettzinfo( _pytzinfo ):
     """Customized timezone class that provides a simple static offset."""
diff --git a/mythtv/bindings/python/MythTV/utility/other.py b/mythtv/bindings/python/MythTV/utility/other.py
index 740e81b107b..d96cccf53f0 100644
--- a/mythtv/bindings/python/MythTV/utility/other.py
+++ b/mythtv/bindings/python/MythTV/utility/other.py
@@ -328,7 +328,7 @@ def dlrecv(self, bufsize, flags=0, deadline=None):
             timeout = (deadline-t) if (deadline-t>0) else 0.0
             if len(select([self],[],[], timeout)[0]) == 0:
                 # deadline reached, terminate
-                return u''
+                return b''
 
             # append response to buffer
             p = buff.tell()
@@ -360,7 +360,7 @@ def dlexpect(self, pattern, flags=0, deadline=None):
             timeout = (deadline-t) if (deadline-t>0) else 0.0
             if len(select([self],[],[], timeout)[0]) == 0:
                 # deadline reached, terminate
-                return ''
+                return b''
 
             # append response to buffer
             p = buff.tell()
@@ -393,7 +393,9 @@ def sendheader(self, data, flags=0):
         try:
             self.log(MythLog.SOCKET|MythLog.NETWORK, MythLog.DEBUG, \
                             'write --> %d' % len(data), py23_str(data, True))
-            data = '%-8d%s' % (len(data), data)
+            # build the byte array:
+            length = b'%-8d' % len(data)
+            data = b"".join([length, data])
             self.send(data, flags)
         except socket.error as e:
             raise MythError(MythError.SOCKET, e.args)
@@ -580,7 +582,7 @@ def py23_str(value, ignore_errors=False):
         return unicode(value, errors=error_method, encoding='utf-8')
     except NameError:  # Python 3
         try:
-            return str(value,errors=error_method, encoding='utf-8')
+            return str(value, errors=error_method, encoding='utf-8')
         except TypeError:  # Wasn't a bytes object, no need to decode
             return str(value)
 

From cfd78f3d2aa85d1e34bc7a9d0ac8d68d884b97cb Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 16:11:45 +0200
Subject: [PATCH 18/28] Make mythwikiscripts compatible to python3.

Caching files is now different to python2:
Remove /tmp/mythwikiscripts.pickle* prior to testing mythwikiscripts.
---
 .../python/MythTV/wikiscripts/__init__.py     |  2 +-
 .../python/MythTV/wikiscripts/wikiscripts.py  | 64 +++++++++++++------
 .../bindings/python/scripts/mythwikiscripts   | 26 ++++----
 3 files changed, 59 insertions(+), 33 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/wikiscripts/__init__.py b/mythtv/bindings/python/MythTV/wikiscripts/__init__.py
index 212a8bf54ad..94718a5409c 100644
--- a/mythtv/bindings/python/MythTV/wikiscripts/__init__.py
+++ b/mythtv/bindings/python/MythTV/wikiscripts/__init__.py
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 
-from wikiscripts import *
+from .wikiscripts import *
 
 
 if __name__ == '__main__':
diff --git a/mythtv/bindings/python/MythTV/wikiscripts/wikiscripts.py b/mythtv/bindings/python/MythTV/wikiscripts/wikiscripts.py
index 2bc70177c8a..2f02d1923e6 100644
--- a/mythtv/bindings/python/MythTV/wikiscripts/wikiscripts.py
+++ b/mythtv/bindings/python/MythTV/wikiscripts/wikiscripts.py
@@ -2,19 +2,34 @@
 # -*- coding: UTF-8 -*-
 #----------------------
 
-from urllib import urlopen
+try:
+    from urllib import urlopen
+except ImportError:
+    from urllib.request import urlopen
 from time import time
-from thread import start_new_thread, allocate_lock
+try:
+    from thread import start_new_thread, allocate_lock
+except ImportError:
+    from _thread import start_new_thread, allocate_lock
 from time import sleep, time
-from MythTV import OrdDict
 import threading
-import cPickle
-import Queue
+try:
+    import cPickle as pickle
+except:
+    import pickle
+from MythTV import OrdDict
+try:
+    import Queue
+except ImportError:
+    import queue as Queue
 import lxml
 import lxml.html
 import os
+import sys
 import stat
 
+from builtins import input
+
 BASEURL = 'https://www.mythtv.org/wiki'
 
 def getScripts():
@@ -22,7 +37,7 @@ def getScripts():
 
 def getPage(**kwargs):
     url = "{0}?{1}".format(BASEURL,
-            '&'.join(['{0}={1}'.format(k,v) for k,v in kwargs.items()]))
+            '&'.join(['{0}={1}'.format(k,v) for k,v in list(kwargs.items())]))
     return lxml.html.parse(urlopen(url)).getroot()
 
 def getWhatLinksHere(page):
@@ -38,7 +53,7 @@ class Script( object ):
     _queue   = Queue.Queue()
     _pool    = []
     _running = True
-    
+
 
     _valid = False
     _xp_info = lxml.etree.XPath("//span[@id='script-info']/text()")
@@ -59,7 +74,8 @@ def getAll(cls, refresh=False):
             return []
         cls._dumpCache()
         scripts = [s for s in scripts if s.isValid()]
-        scripts.sort()
+        #scripts.sort()   ### does not work in python3
+        scripts.sort(key=lambda s: s.url)
         return scripts
 
     @classmethod
@@ -107,7 +123,7 @@ def __init__(self, url, refresh=False, pool=4):
                 t = threading.Thread(target=self.processQueue)
                 t.start()
                 self._pool.append(t)
-        
+
     def isValid(self): return self._valid
 
     def processPage(self):
@@ -123,7 +139,7 @@ def processPage(self):
 
     def getInfo(self, etree):
         text = self._xp_info(etree)[0].strip().split('\n')
-        for i in reversed(range(len(text))):
+        for i in reversed(list(range(len(text)))):
             if '=' not in text[i]:
                 text[i-1] += text.pop(i)
         self.info = OrdDict([a.split('=') for a in text])
@@ -144,14 +160,14 @@ def getScript(self, etree):
             code = self._xp_code(etree)
             name = ''
             size = 0
-            for i in range(len(code)):
+            for i in list(range(len(code))):
                 names[i] = str(names[i])
                 if size < len(code[i]):
                     size = len(code[i])
                     name = names[i]
                 code[i] = code[i].lstrip()
                 code[i] = code[i].replace(u'\xa0',' ')
-            self.code = dict(zip(names,code))
+            self.code = dict(list(zip(names,code)))
             if self.info.name == 'unnamed':
                 self.info.name = name
 
@@ -187,12 +203,16 @@ def _loadCache(cls, refresh):
         if refresh:
             cls._cache = {}
             return
-
-        path = '/tmp/mythwikiscripts.pickle'
+        if (sys.version_info[0] == 2):
+            path = '/tmp/mythwikiscripts.pickle'
+            fmode = 'r'
+        else:
+            path = '/tmp/mythwikiscripts.pickle3'
+            fmode = 'rb'
         if os.access(path, os.F_OK):
             try:
-                fd = open(path,'r')
-                cls._cache = cPickle.load(fd)
+                fd = open(path, fmode)
+                cls._cache = pickle.load(fd)
                 fd.close()
             except:
                 os.remove(path)
@@ -202,10 +222,16 @@ def _loadCache(cls, refresh):
 
     @classmethod
     def _dumpCache(cls):
-        path = '/tmp/mythwikiscripts.pickle'
+        ### XXX ToDo allign pickle protocol versions
         try:
-            fd = open(path,'w')
-            cls._cache = cPickle.dump(cls._cache,fd)
+            if (sys.version_info[0] == 2):
+                path = '/tmp/mythwikiscripts.pickle'
+                fd = open(path,'w')
+                cls._cache = pickle.dump(cls._cache,fd)
+            else:
+                path = '/tmp/mythwikiscripts.pickle3'
+                fd = open(path,'wb')
+                cls._cache = pickle.dump(cls._cache,fd,  protocol=1)
             fd.close()
         except:
             os.remove(path)
diff --git a/mythtv/bindings/python/scripts/mythwikiscripts b/mythtv/bindings/python/scripts/mythwikiscripts
index 673ebf2a708..8de0fff120c 100755
--- a/mythtv/bindings/python/scripts/mythwikiscripts
+++ b/mythtv/bindings/python/scripts/mythwikiscripts
@@ -7,14 +7,14 @@ import sys
 
 def get_input(comment, items):
     while True:
-        print '  0: Exit'
+        print('  0: Exit')
         for i,item in enumerate(items):
-            print '  {0}: {1}'.format(i+1, item)
-        print comment
+            print('  {0}: {1}'.format(i+1, item))
+        print(comment)
 
         while True:
             try:
-                i = raw_input('> ')
+                i = input('> ')
                 if i == 'list':
                     break
                 elif i in ('exit','0'):
@@ -23,17 +23,17 @@ def get_input(comment, items):
                 i = int(i)-1
                 if i in range(len(items)):
                     return i
-                print "Selection is outside range. Use 'list' to list options."
+                print("Selection is outside range. Use 'list' to list options.")
 
             except KeyboardInterrupt:
                 sys.exit()
             except EOFError:
                 sys.exit()
             except:
-                print 'This input only accepts integers.  Use Ctrl-C to exit'
+                print('This input only accepts integers.  Use Ctrl-C to exit')
 
 def selectCat(catlist):
-    keys = catlist.keys()
+    keys = list(catlist.keys())
     while True:
         inp = get_input('Please choose a category.', keys)
         if inp == -1:
@@ -49,18 +49,18 @@ def selectScript(scriptlist):
         saveScript(scriptlist[inp])
 
 def saveScript(script):
-    print 'Author:      '+script.info.author
-    print 'Description: '+script.info.long
-    print 'Webpage:     '+script.info.webpage
+    print('Author:      '+script.info.author)
+    print('Description: '+script.info.long)
+    print('Webpage:     '+script.info.webpage)
 
-    for name in script.code.keys():
+    for name in list(script.code.keys()):
         if name[0] in ('/', '~'):
             path = name
         else:
             path = '~/bin/'+name
 
         try:
-            inp = raw_input('Save to [{0}]:'.format(path))
+            inp = input('Save to [{0}]:'.format(path))
         except EOFError:
             sys.exit()
         except KeyboardInterrupt:
@@ -81,7 +81,7 @@ if __name__ == '__main__':
     print "This script parses the wiki, and may take several minutes."
     tic = time()
     tmp = Script.getAll()
-    print 'Loading took %0.2f seconds' % (time()-tic)
+    print('Loading took %0.2f seconds' % (time()-tic))
 
     scripts = {}
     for script in tmp:

From a90e2db32896ba1ca0851144006ba01a3fd6ae56 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 16:47:37 +0200
Subject: [PATCH 19/28] Add compatibility to python3 to tmdb3 module.

How to check and reproduce:

Check out mythtv from git.

Set the pythonpath to the folder holding the bindings "MythTV":
Example:
export PYTHONPATH=$HOME/dnalor_mythtv/mythtv/mythtv/bindings/python

Create a symlink for tmdb3
$ cd MythTV
$ ln -s ../tmdb3/tmdb3 tmdb3

Copy the folder
mythtv/mythtv/programs/scripts/metadata/Movie
to
$PYTHONPATH/share/mythtv/metadata/Movie

Note: This is noa absolutely necessary, but it is needed for testing
the 'tmdb3' api together with the 'MythTV' bindings.

Clear the tmdb3 cache:
Create a script:
CF=$HOME/.mythtv/cache/pytmdb3.cache
rm $CF
touch $CF

Delete all '*.pyc' files:
find . -name "*.pyc" -type f -delete

Switch to python3:

Make python3 the default when called via `python` or `#!/usr/bin/env python`:
Put a symlink from python3 to python on top of the `PATH` environment:
As root, type
 mkdir -p /opt/python3
 ln -s `which python3` /opt/python3/python

Then in the terminal add the path as first entry:
$ export PATH=/opt/python3/:$PATH

test with
$ env python --version

Run the following tests from the path $PYTHONPATH :

$ python ./share/mythtv/metadata/Movie/tmdb3.py --version
$ python ./share/mythtv/metadata/Movie/tmdb3.py --test
$ python ./share/mythtv/metadata/Movie/tmdb3.py -M -l en 'Indiana Jones'
$ python ./share/mythtv/metadata/Movie/tmdb3.py -M -l de 'Indiana Jones'
$ python ./share/mythtv/metadata/Movie/tmdb3.py -D -l de 217
$ python ./share/mythtv/metadata/Movie/tmdb3.py -l en -C 10
$ python ./share/mythtv/metadata/Movie/tmdb3.py -l en -a US -C 10
$ python ./share/mythtv/metadata/Movie/tmdb3.py -l en -a de -C 10
$ python ./share/mythtv/metadata/Movie/tmdb3.py -l en -a de -C 10 --debug
---
 .../python/tmdb3/scripts/populate_locale.py   |  4 +-
 .../bindings/python/tmdb3/scripts/pytmdb3.py  |  8 +--
 .../bindings/python/tmdb3/tmdb3/__init__.py   | 12 ++---
 mythtv/bindings/python/tmdb3/tmdb3/cache.py   | 10 ++--
 .../python/tmdb3/tmdb3/cache_engine.py        |  6 ++-
 .../bindings/python/tmdb3/tmdb3/cache_file.py | 20 ++++---
 .../bindings/python/tmdb3/tmdb3/cache_null.py |  2 +-
 mythtv/bindings/python/tmdb3/tmdb3/locales.py |  2 +-
 mythtv/bindings/python/tmdb3/tmdb3/pager.py   |  9 +++-
 mythtv/bindings/python/tmdb3/tmdb3/request.py | 53 ++++++++++++-------
 .../bindings/python/tmdb3/tmdb3/tmdb_api.py   | 31 ++++++-----
 .../bindings/python/tmdb3/tmdb3/tmdb_auth.py  |  6 +--
 mythtv/bindings/python/tmdb3/tmdb3/util.py    | 24 ++++-----
 .../programs/scripts/metadata/Movie/tmdb3.py  | 43 +++++++++------
 14 files changed, 135 insertions(+), 95 deletions(-)

diff --git a/mythtv/bindings/python/tmdb3/scripts/populate_locale.py b/mythtv/bindings/python/tmdb3/scripts/populate_locale.py
index d1aee4dd1b6..2f6ec6e5533 100755
--- a/mythtv/bindings/python/tmdb3/scripts/populate_locale.py
+++ b/mythtv/bindings/python/tmdb3/scripts/populate_locale.py
@@ -23,7 +23,7 @@ def sanitize(name):
 while True:
     line = fd.readline()
     if len(line) == 0:
-        print "code endpoint not found, aborting!"
+        print ("code endpoint not found, aborting!")
         sys.exit(1)
     if line.startswith('########'):
         endpt = fd.tell()
@@ -44,7 +44,7 @@ def sanitize(name):
         # skip empty 639-1 code
         continue
     name, _, _, iso639_2, iso639_1 = [t.text for t in row]
-    
+
     fd.write('Language("{0}", "{1}", u"{2}")\n'.format(iso639_1, iso639_2, sanitize(name).encode('utf8')))
 
 root = lxml.html.parse('http://www.iso.org/iso/country_codes/iso_3166_code_lists/country_names_and_code_elements.htm').getroot()
diff --git a/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py b/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py
index afce681e2cb..0bc68d1a025 100755
--- a/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py
+++ b/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py
@@ -23,10 +23,10 @@
 
     if opts.version:
         from tmdb3.tmdb_api import __title__, __purpose__, __version__, __author__
-        print __title__
-        print ""
-        print __purpose__
-        print "Version: "+__version__
+        print (__title__)
+        print ("")
+        print (__purpose)__
+        print ("Version: "+__version__)
         sys.exit(0)
 
     if opts.nocache:
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/__init__.py b/mythtv/bindings/python/tmdb3/tmdb3/__init__.py
index d5e35b30e5a..d84e15ffeed 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/__init__.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/__init__.py
@@ -1,12 +1,12 @@
 #!/usr/bin/env python
 
-from tmdb_api import Configuration, searchMovie, searchMovieWithYear, \
+from .tmdb_api import Configuration, searchMovie, searchMovieWithYear, \
                      searchPerson, searchStudio, searchList, searchCollection, \
                      searchSeries, Person, Movie, Collection, Genre, List, \
                      Series, Studio, Network, Episode, Season, __version__
-from request import set_key, set_cache
-from locales import get_locale, set_locale
-from tmdb_auth import get_session, set_session
-from cache_engine import CacheEngine
-from tmdb_exceptions import *
+from .request import Request, set_key, set_cache
+from .locales import get_locale, set_locale
+from .tmdb_auth import get_session, set_session
+from .cache_engine import CacheEngine
+from .tmdb_exceptions import *
 
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/cache.py b/mythtv/bindings/python/tmdb3/tmdb3/cache.py
index 463d7a2c424..9122ef21edc 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/cache.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/cache.py
@@ -10,11 +10,11 @@
 import time
 import os
 
-from tmdb_exceptions import *
-from cache_engine import Engines
+from .tmdb_exceptions import *
+from .cache_engine import Engines
 
-import cache_null
-import cache_file
+from . import cache_null
+from . import cache_file
 
 
 class Cache(object):
@@ -44,7 +44,7 @@ def _import(self, data=None):
                 self._age = max(self._age, obj.creation)
 
     def _expire(self):
-        for k, v in self._data.items():
+        for k, v in list(self._data.items()):
             if v.expired:
                 del self._data[k]
 
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/cache_engine.py b/mythtv/bindings/python/tmdb3/tmdb3/cache_engine.py
index 11019551cbf..150bb1eab12 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/cache_engine.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/cache_engine.py
@@ -9,7 +9,9 @@
 
 import time
 from weakref import ref
+import sys
 
+from future.utils import with_metaclass
 
 class Engines(object):
     """
@@ -43,8 +45,8 @@ def __init__(cls, name, bases, attrs):
             Engines.register(cls)
 
 
-class CacheEngine(object):
-    __metaclass__ = CacheEngineType
+class CacheEngine(with_metaclass(CacheEngineType, object)):
+
     name = 'unspecified'
 
     def __init__(self, parent):
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/cache_file.py b/mythtv/bindings/python/tmdb3/tmdb3/cache_file.py
index 4e965815c34..85455b7c554 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/cache_file.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/cache_file.py
@@ -16,10 +16,14 @@
 import os
 import io
 
-from cStringIO import StringIO
+try:
+    from cStringIO import StringIO
+except ImportError:
+    # from io import BytesIO as StringIO
+    from io import StringIO
 
-from tmdb_exceptions import *
-from cache_engine import CacheEngine, CacheObject
+from .tmdb_exceptions import *
+from .cache_engine import CacheEngine, CacheObject
 
 ####################
 # Cache File Format
@@ -123,7 +127,7 @@ def parse_filename(filename):
         if filename.startswith('~'):
             # check for home directory
             return os.path.expanduser(filename)
-        elif (ord(filename[0]) in (range(65, 91) + range(99, 123))) \
+        elif (ord(filename[0]) in (list(range(65, 91) + range(99, 123)))) \
                 and (filename[1:3] == ':\\'):
             # check for absolute drive path (e.g. C:\...)
             return filename
@@ -195,7 +199,7 @@ def data(self, value):
     def load(self, fd):
         fd.seek(self.position)
         self._buff.seek(0)
-        self._buff.write(fd.read(self.size))
+        self._buff.write(fd.read(self.size).decode('utf-8'))
 
     def dumpslot(self, fd):
         pos = fd.tell()
@@ -204,7 +208,7 @@ def dumpslot(self, fd):
     def dumpdata(self, fd):
         self.size
         fd.seek(self.position)
-        fd.write(self._buff.getvalue())
+        fd.write(self._buff.getvalue().encode('utf-8'))
 
 
 class FileEngine( CacheEngine ):
@@ -266,7 +270,7 @@ def _init_cache(self):
     def get(self, date):
         self._init_cache()
         self._open('r+b')
-        
+
         with Flock(self.cachefd, Flock.LOCK_SH):
             # return any new objects in the cache
             return self._read(date)
@@ -371,7 +375,7 @@ def _write(self, data):
         else:
             # rewrite cache file from scratch
             # pull data from parent cache
-            data.extend(self.parent()._data.values())
+            data.extend(list(self.parent()._data.values()))
             data.sort(key=lambda x: x.creation)
             # write header
             size = len(data) + self.preallocate
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/cache_null.py b/mythtv/bindings/python/tmdb3/tmdb3/cache_null.py
index 8c360da83a0..0a20ae0d18d 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/cache_null.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/cache_null.py
@@ -7,7 +7,7 @@
 # Purpose: Null caching engine for debugging purposes
 #-----------------------
 
-from cache_engine import CacheEngine
+from .cache_engine import CacheEngine
 
 
 class NullEngine(CacheEngine):
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/locales.py b/mythtv/bindings/python/tmdb3/tmdb3/locales.py
index 0ef0310bb1c..319f26251ac 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/locales.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/locales.py
@@ -6,7 +6,7 @@
 # Author: Raymond Wagner
 #-----------------------
 
-from tmdb_exceptions import *
+from .tmdb_exceptions import *
 import locale
 
 syslocale = None
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/pager.py b/mythtv/bindings/python/tmdb3/tmdb3/pager.py
index ebcb9d2fa0c..64c0a583f51 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/pager.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/pager.py
@@ -8,6 +8,11 @@
 
 from collections import Sequence, Iterator
 
+try:
+    xrange
+except NameError:
+    xrange = range
+
 
 class PagedIterator(Iterator):
     def __init__(self, parent):
@@ -18,12 +23,14 @@ def __init__(self, parent):
     def __iter__(self):
         return self
 
-    def next(self):
+    def __next__(self):
         self._index += 1
         if self._index == self._len:
             raise StopIteration
         return self._parent[self._index]
 
+    next = __next__  # for Python2
+
 
 class UnpagedData(object):
     def copy(self):
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/request.py b/mythtv/bindings/python/tmdb3/tmdb3/request.py
index 1b6663dcfd7..d87503e5a80 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/request.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/request.py
@@ -8,18 +8,31 @@
 #          TMDb v3 API
 #-----------------------
 
-from tmdb_exceptions import *
-from locales import get_locale
-from cache import Cache
+from .tmdb_exceptions import *
+from .locales import get_locale
+from .cache import Cache
+
+# supports python2 and python3
+try:
+    from urllib  import urlencode
+    from urllib2 import Request   as _py23Request
+    from urllib2 import urlopen   as _py23urlopen
+    from urllib2 import HTTPError as _py23HTTPError
+
+except (NameError, ImportError):
+    from urllib.parse   import urlencode
+    from urllib.request import Request   as _py23Request
+    from urllib.request import urlopen   as _py23urlopen
+    from urllib.error   import HTTPError as _py23HTTPError
+    import urllib.error
+    import urllib.parse
 
-from urllib import urlencode
-import urllib2
 import json
 import os
 import time
 
 DEBUG = False
-cache = Cache(filename='pytmdb3.cache')
+cache = Cache(filename='pytmdb3.cache')  # split cache file into py2 and py3 ?
 
 #DEBUG = True
 #cache = Cache(engine='null')
@@ -44,7 +57,7 @@ def set_cache(engine=None, *args, **kwargs):
     cache.configure(engine, *args, **kwargs)
 
 
-class Request(urllib2.Request):
+class Request(_py23Request):
     _api_key = None
     _base_url = "http://api.themoviedb.org/3/"
 
@@ -62,17 +75,17 @@ def __init__(self, url, **kwargs):
         """
         kwargs['api_key'] = self.api_key
         self._url = url.lstrip('/')
-        self._kwargs = dict([(kwa, kwv) for kwa, kwv in kwargs.items()
+        self._kwargs = dict([(kwa, kwv) for kwa, kwv in list(kwargs.items())
                                         if kwv is not None])
 
         locale = get_locale()
         kwargs = {}
-        for k, v in self._kwargs.items():
+        for k, v in list(self._kwargs.items()):
             kwargs[k] = locale.encode(v)
         url = '{0}{1}?{2}'\
                 .format(self._base_url, self._url, urlencode(kwargs))
 
-        urllib2.Request.__init__(self, url)
+        _py23Request.__init__(self, url)
         self.add_header('Accept', 'application/json')
         self.lifetime = 3600  # 1hr
 
@@ -81,7 +94,7 @@ def new(self, **kwargs):
         Create a new instance of the request, with tweaked arguments.
         """
         args = dict(self._kwargs)
-        for k, v in kwargs.items():
+        for k, v in list(kwargs.items()):
             if v is None:
                 if k in args:
                     del args[k]
@@ -93,24 +106,24 @@ def new(self, **kwargs):
 
     def add_data(self, data):
         """Provide data to be sent with POST."""
-        urllib2.Request.add_data(self, urlencode(data))
+        _py23Request.data = (self, urllib.parse.urlencode(data))
 
     def open(self):
         """Open a file object to the specified URL."""
         try:
             if DEBUG:
-                print 'loading '+self.get_full_url()
-                if self.has_data():
-                    print '  '+self.get_data()
-            return urllib2.urlopen(self)
-        except urllib2.HTTPError, e:
+                print('loading '+self.get_full_url())
+                if self.data:
+                    print('  '+self.data)
+            return _py23urlopen(self)
+        except _py23HTTPError as e:
             raise TMDBHTTPError(e)
 
     def read(self):
         """Return result from specified URL as a string."""
         return self.open().read()
 
-    @cache.cached(urllib2.Request.get_full_url)
+    @cache.cached(_py23Request.get_full_url)
     def readJSON(self):
         """Parse result from specified URL as JSON data."""
         url = self.get_full_url()
@@ -120,7 +133,7 @@ def readJSON(self):
                 # catch HTTP error from open()
                 data = json.load(self.open())
                 break
-            except TMDBHTTPError, e:
+            except TMDBHTTPError as e:
                 try:
                     # try to load whatever was returned
                     data = json.loads(e.response)
@@ -132,7 +145,7 @@ def readJSON(self):
                     if data.get('status_code', 1) ==25:
                         # Sleep and retry query.
                         if DEBUG:
-                            print 'Retry after {0} seconds'.format(max(float(e.headers['retry-after']),10))
+                            print('Retry after {0} seconds'.format(max(float(e.headers['retry-after']),10)))
                         time.sleep(max(float(e.headers['retry-after']),10))
                         continue
                     else:
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py b/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py
index a28fda8e2d8..b8c44f6f702 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py
@@ -59,21 +59,23 @@
 # 0.6.14 Add support for Lists
 # 0.6.15 Add ability to search Collections
 # 0.6.16 Make absent primary images return None (previously u'')
-# 0.6.17 Add userrating/votes to Image, add overview to Collection, remove 
+# 0.6.17 Add userrating/votes to Image, add overview to Collection, remove
 #           releasedate sorting from Collection Movies
 # 0.7.0  Add support for television series data
+# 0.7.0.a  Added compatibility to python3, tested with python 3.6 and 2.7
 
-from request import set_key, Request
-from util import Datapoint, Datalist, Datadict, Element, NameRepr, SearchRepr
-from pager import PagedRequest
-from locales import get_locale, set_locale
-from tmdb_auth import get_session, set_session
-from tmdb_exceptions import *
+from .request import set_key, Request
+from .util import Datapoint, Datalist, Datadict, Element, NameRepr, SearchRepr
+from .pager import PagedRequest
+from .locales import get_locale, set_locale
+from .tmdb_auth import get_session, set_session
+from .tmdb_exceptions import *
 
 import json
-import urllib
-import urllib2
 import datetime
+import sys
+
+IS_PY3 = sys.version_info[0] == 3
 
 DEBUG = False
 
@@ -234,7 +236,7 @@ class Image(Element):
     width = Datapoint('width')
     language = Datapoint('iso_639_1')
     userrating = Datapoint('vote_average')
-    votes = Datapoint('vote_count') 
+    votes = Datapoint('vote_count')
 
     def sizes(self):
         return ['original']
@@ -265,11 +267,14 @@ def __eq__(self, other):
         return self.filename == other.filename
 
     # special handling for boolean to see if exists
-    def __nonzero__(self):
+    def __bool__(self):
         if len(self.filename) == 0:
             return False
         return True
 
+    __nonzero__  = __bool__    # for  python2
+
+
     def __repr__(self):
         # BASE62 encoded filename, no need to worry about unicode
         return u"<{0.__class__.__name__} '{0.filename}'>".format(self)
@@ -405,7 +410,7 @@ class AppleTrailer(Element):
     sources = Datadict('sources', handler=Trailer, attr='size')
 
     def sizes(self):
-        return self.sources.keys()
+        return list(self.sources.keys())
 
     def geturl(self, size=None):
         if size is None:
@@ -454,7 +459,7 @@ class GenreList(Element):
             def _populate(self):
                 return Request('genre/list', language=self._locale.language)
         return GenreList(locale=locale).genres
-        
+
 
 class Studio(NameRepr, Element):
     id = Datapoint('id', initarg=1)
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/tmdb_auth.py b/mythtv/bindings/python/tmdb3/tmdb3/tmdb_auth.py
index b447b5ab8da..030838c7f5a 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/tmdb_auth.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/tmdb_auth.py
@@ -4,7 +4,7 @@
 # Name: tmdb_auth.py
 # Python Library
 # Author: Raymond Wagner
-# Purpose: Provide authentication and session services for 
+# Purpose: Provide authentication and session services for
 #          calls against the TMDB v3 API
 #-----------------------
 
@@ -65,8 +65,8 @@ def fromIso(cls, isotime, sep='T'):
             dt.append(tz)
         return cls(*dt)
 
-from request import Request
-from tmdb_exceptions import *
+from .request import Request
+from .tmdb_exceptions import *
 
 syssession = None
 
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/util.py b/mythtv/bindings/python/tmdb3/tmdb3/util.py
index a0d2e28a333..ee3cb4558a2 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/util.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/util.py
@@ -7,9 +7,10 @@
 #-----------------------
 
 from copy import copy
-from locales import get_locale
-from tmdb_auth import get_session
+from .locales import get_locale
+from .tmdb_auth import get_session
 
+from future.utils import with_metaclass
 
 class NameRepr(object):
     """Mixin for __repr__ methods using 'name' attribute."""
@@ -74,7 +75,7 @@ def __call__(self):
             self.apply(req.new(language=None, country=None).readJSON())
             # re-apply the filtered first pass data over top the second
             # unfiltered set. this is to work around the issue that the
-            # properties have no way of knowing when they should or 
+            # properties have no way of knowing when they should or
             # should not overwrite existing data. the cache engine will
             # take care of the duplicate query
         self.apply(req.readJSON())
@@ -82,7 +83,7 @@ def __call__(self):
     def apply(self, data, set_nones=True):
         # apply data directly, bypassing callable function
         unfilled = False
-        for k, v in self.lookup.items():
+        for k, v in list(self.lookup.items()):
             if (k in data) and \
                     ((data[k] is not None) if callable(self.func) else True):
                 # argument received data, populate it
@@ -222,7 +223,7 @@ def __set__(self, inst, value):
                     val._locale = inst._locale
                     val._session = inst._session
 
-                    for source, dest in self.passthrough.items():
+                    for source, dest in list(self.passthrough.items()):
                         setattr(val, dest, getattr(inst, source))
 
                 data.append(val)
@@ -288,7 +289,7 @@ def __set__(self, inst, value):
                     val._locale = inst._locale
                     val._session = inst._session
 
-                    for source, dest in self.passthrough.items():
+                    for source, dest in list(self.passthrough.items()):
                         setattr(val, dest, getattr(inst, source))
 
                 data[self.getkey(val)] = val
@@ -310,7 +311,7 @@ def __new__(mcs, name, bases, attrs):
 
         for base in reversed(bases):
             if isinstance(base, mcs):
-                for k, attr in base.__dict__.items():
+                for k, attr in list(base.__dict__.items()):
                     if isinstance(attr, Data):
                         # extract copies of each defined Data element from
                         # parent classes
@@ -321,7 +322,7 @@ def __new__(mcs, name, bases, attrs):
                         # extract copies of each defined Poller function
                         # from parent classes
                         pollers[k] = attr.func
-        for k, attr in attrs.items():
+        for k, attr in list(attrs.items()):
             if isinstance(attr, Data):
                 data[k] = attr
         if '_populate' in attrs:
@@ -332,7 +333,7 @@ def __new__(mcs, name, bases, attrs):
         # which Data points
         pollermap = dict([(k, []) for k in pollers])
         initargs = []
-        for k, v in data.items():
+        for k, v in list(data.items()):
             v.name = k
             if v.initarg:
                 initargs.append(v)
@@ -348,7 +349,7 @@ def __new__(mcs, name, bases, attrs):
 
         # wrap each used poller function with a Poller class, and push into
         # the new class attributes
-        for k, v in pollermap.items():
+        for k, v in list(pollermap.items()):
             if len(v) == 0:
                 continue
             lookup = dict([(attr.field, attr.name) for attr in v])
@@ -398,6 +399,5 @@ def __call__(cls, *args, **kwargs):
         return obj
 
 
-class Element( object ):
-    __metaclass__ = ElementType
+class Element( with_metaclass( ElementType, object ) ):
     _lang = 'en'
diff --git a/mythtv/programs/scripts/metadata/Movie/tmdb3.py b/mythtv/programs/scripts/metadata/Movie/tmdb3.py
index 9739ecf320e..9bc812faa04 100755
--- a/mythtv/programs/scripts/metadata/Movie/tmdb3.py
+++ b/mythtv/programs/scripts/metadata/Movie/tmdb3.py
@@ -26,11 +26,20 @@
 #       resolved upstream.
 # 0.3.7 Add handling for TMDB site returning insufficient results from a
 #       query
+# 0.3.7.a : Added compatibiliy to python3, tested with python 3.6 and 2.7
 
 from optparse import OptionParser
 import sys
 import signal
 
+def print_etree(etostr):
+    """lxml.etree.tostring is a bytes object in python3, and a str in python2.
+    """
+    if sys.version_info[0] == 3:
+        sys.stdout.write(etostr.decode())
+    else:
+        sys.stdout.write(etostr)
+
 def timeouthandler(signal, frame):
     raise RuntimeError("Timed out")
 
@@ -58,14 +67,14 @@ def buildSingle(inetref, opts):
             if getattr(movie, j):
                 setattr(m, i, getattr(movie, j))
         except TMDBRequestInvalid:
-            sys.stdout.write(etree.tostring(tree, encoding='UTF-8', pretty_print=True,
+            print_etree(etree.tostring(tree, encoding='UTF-8', pretty_print=True,
                                             xml_declaration=True))
             sys.exit()
 
     if movie.title:
         m.title = movie.title
 
-    releases = movie.releases.items()
+    releases = list(movie.releases.items())
 
 # get the release date for the wanted country
 # TODO if that is not part of the reply use the primary release date (Primary=true)
@@ -73,14 +82,14 @@ def buildSingle(inetref, opts):
 # if there is not a single release date in the reply, then leave it empty
     if len(releases) > 0:
         if opts.country:
-            # resort releases with selected country at top to ensure it 
-            # is selected by the metadata libraries 
-            r = zip(*releases) 
-            if opts.country in r[0]: 
-                index = r[0].index(opts.country) 
-                releases.insert(0, releases.pop(index)) 
+            # resort releases with selected country at top to ensure it
+            # is selected by the metadata libraries
+            r = list(zip(*releases))
+            if opts.country in r[0]:
+                index = r[0].index(opts.country)
+                releases.insert(0, releases.pop(index))
 
-        m.releasedate = releases[0][1].releasedate 
+        m.releasedate = releases[0][1].releasedate
 
     m.inetref = str(movie.id)
     if movie.collection:
@@ -117,7 +126,7 @@ def buildSingle(inetref, opts):
                         'height':str(poster.height),
                         'width':str(poster.width)})
     tree.append(m.toXML())
-    sys.stdout.write(etree.tostring(tree, encoding='UTF-8', pretty_print=True,
+    print_etree(etree.tostring(tree, encoding='UTF-8', pretty_print=True,
                                     xml_declaration=True))
     sys.exit()
 
@@ -182,7 +191,7 @@ def buildList(query, opts):
             # page limiter, dont want to overload the server
             break
 
-    sys.stdout.write(etree.tostring(tree, encoding='UTF-8', pretty_print=True,
+    print_etree(etree.tostring(tree, encoding='UTF-8', pretty_print=True,
                                     xml_declaration=True))
     sys.exit(0)
 
@@ -198,7 +207,7 @@ def buildCollection(inetref, opts):
     try:
         m.title = collection.name
     except TMDBRequestInvalid:
-        sys.stdout.write(etree.tostring(tree, encoding='UTF-8', pretty_print=True,
+        print_etree(etree.tostring(tree, encoding='UTF-8', pretty_print=True,
                                         xml_declaration=True))
         sys.exit()
     if collection.backdrop:
@@ -210,7 +219,7 @@ def buildCollection(inetref, opts):
         m.images.append({'type':'coverart', 'url':p.geturl(),
                   'thumb':p.geturl(p.sizes()[0])})
     tree.append(m.toXML())
-    sys.stdout.write(etree.tostring(tree, encoding='UTF-8', pretty_print=True,
+    print_etree(etree.tostring(tree, encoding='UTF-8', pretty_print=True,
                                     xml_declaration=True))
     sys.exit()
 
@@ -227,7 +236,7 @@ def buildVersion():
     etree.SubElement(version, "version").text = __version__
     etree.SubElement(version, "accepts").text = 'tmdb.py'
     etree.SubElement(version, "accepts").text = 'tmdb.pl'
-    sys.stdout.write(etree.tostring(version, encoding='UTF-8', pretty_print=True,
+    print_etree(etree.tostring(version, encoding='UTF-8', pretty_print=True,
                                     xml_declaration=True))
     sys.exit(0)
 
@@ -250,10 +259,10 @@ def performSelfTest():
         import lxml
     except:
         err = 1
-        print "Failed to import python lxml library."
+        print ("Failed to import python lxml library.")
 
     if not err:
-        print "Everything appears in order."
+        print ("Everything appears in order.")
     sys.exit(err)
 
 def main():
@@ -301,7 +310,7 @@ def main():
         if (not confdir) or (confdir == '/'):
             confdir = os.environ.get('HOME', '')
             if (not confdir) or (confdir == '/'):
-                print "Unable to find MythTV directory for metadata cache."
+                print ("Unable to find MythTV directory for metadata cache.")
                 sys.exit(1)
             confdir = os.path.join(confdir, '.mythtv')
         cachedir = os.path.join(confdir, 'cache')

From 6c912c1f2f8d994e9fdf1ad96f11776a9b5f4d7d Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 17 Aug 2019 17:09:31 +0200
Subject: [PATCH 20/28] Make mythpython script compatible to python3.

---
 mythtv/bindings/python/scripts/mythpython | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/mythtv/bindings/python/scripts/mythpython b/mythtv/bindings/python/scripts/mythpython
index 8e52e996e02..e6176f313e9 100755
--- a/mythtv/bindings/python/scripts/mythpython
+++ b/mythtv/bindings/python/scripts/mythpython
@@ -9,20 +9,20 @@ if __name__ == '__main__':
             name = '    {0}:'.format(name)
             if s: ver = str(s)
             elif j: ver = '.'.join([str(i) for i in j])
-            print '{0:<30}{1}'.format(name, ver)
+            print('{0:<30}{1}'.format(name, ver))
 
         import MythTV.ttvdb.tvdb_api
         import MythTV.tmdb3
         import lxml.etree
-        print 'MythTV Python Bindings'
-        print '  local versions'
+        print('MythTV Python Bindings')
+        print( '  local versions')
         print_version('bindings version', j=static.OWN_VERSION)
         print_version('ttvdb version', MythTV.ttvdb.tvdb_api.__version__)
         print_version('tmdb version', MythTV.tmdb3.__version__)
-        print '  external versions'
+        print('  external versions')
         print_version('lxml version', lxml.etree.__version__)
         print_version('{0} version'.format(static.dbmodule[0]), j=static.dbmodule[1:])
-        print '  protocol versions'
+        print('  protocol versions')
         print_version('backend', static.PROTO_VERSION)
         print_version('schema', static.SCHEMA_VERSION)
         print_version('music schema', static.MUSICSCHEMA_VERSION)

From 4fddaee8bab691b535b55faa70b2edd8242aa753 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Thu, 22 Aug 2019 19:58:23 +0200
Subject: [PATCH 21/28] Fix missing conversion to python3 in mythwikiscripts.

---
 mythtv/bindings/python/scripts/mythwikiscripts | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/mythtv/bindings/python/scripts/mythwikiscripts b/mythtv/bindings/python/scripts/mythwikiscripts
index 8de0fff120c..2d614dd149d 100755
--- a/mythtv/bindings/python/scripts/mythwikiscripts
+++ b/mythtv/bindings/python/scripts/mythwikiscripts
@@ -77,8 +77,8 @@ def saveScript(script):
         script.saveScript(name, os.path.expanduser(path))
 
 if __name__ == '__main__':
-    print "MythTV Interactive Script Downloader."
-    print "This script parses the wiki, and may take several minutes."
+    print("MythTV Interactive Script Downloader.")
+    print("This script parses the wiki, and may take several minutes.")
     tic = time()
     tmp = Script.getAll()
     print('Loading took %0.2f seconds' % (time()-tic))

From a6462977030503afe0adfba7db00dd1247b5fc37 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Thu, 22 Aug 2019 20:05:38 +0200
Subject: [PATCH 22/28] Fix compatibility to python3 in
 'VideoGrabber.grabInetref'.

During testing of the use case shown in 'mythvidexport.py',
I found an additional incompatibility to python3.

This patch fixes #12243 as well, by providing the correct
'inetref' id to the grabber script.
---
 mythtv/bindings/python/MythTV/system.py | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/mythtv/bindings/python/MythTV/system.py b/mythtv/bindings/python/MythTV/system.py
index 821faf5f128..9b89c3ae066 100644
--- a/mythtv/bindings/python/MythTV/system.py
+++ b/mythtv/bindings/python/MythTV/system.py
@@ -408,7 +408,10 @@ def grabInetref(self, inetref, season=None, episode=None):
                 args = (inetref, season, episode)
             else:
                 args = (inetref,)
-        return self.command('-D', *args).next()
+        # inetref may expand to "my_grabber_script.xyz_1234" or "9876"
+        args = list(args)
+        args[0] = args[0].split("_")[-1]
+        return next(self.command('-D', *args))
 
 class SystemEvent( System ):
     """

From 8883b8204e797612f12a1e7f0f33599627acf234 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 24 Aug 2019 15:18:42 +0200
Subject: [PATCH 23/28] Fix a leftover in tmdb3 binding and a typo introduced
 in commit a90e2db

This fixes a typo introduced in one of the previous commits and
corrects python3 compatibiliy in the grabber script tmdb3.py.
---
 mythtv/bindings/python/tmdb3/scripts/pytmdb3.py | 2 +-
 mythtv/programs/scripts/metadata/Movie/tmdb3.py | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py b/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py
index 0bc68d1a025..00df92cd9ad 100755
--- a/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py
+++ b/mythtv/bindings/python/tmdb3/scripts/pytmdb3.py
@@ -25,7 +25,7 @@
         from tmdb3.tmdb_api import __title__, __purpose__, __version__, __author__
         print (__title__)
         print ("")
-        print (__purpose)__
+        print (__purpose__)
         print ("Version: "+__version__)
         sys.exit(0)
 
diff --git a/mythtv/programs/scripts/metadata/Movie/tmdb3.py b/mythtv/programs/scripts/metadata/Movie/tmdb3.py
index 9bc812faa04..52dd7f0352b 100755
--- a/mythtv/programs/scripts/metadata/Movie/tmdb3.py
+++ b/mythtv/programs/scripts/metadata/Movie/tmdb3.py
@@ -337,7 +337,7 @@ def main():
 
         if opts.collectiondata:
             buildCollection(args[0], opts)
-    except RuntimeError, exc:
+    except RuntimeError as exc:
         sys.stdout.write('ERROR: ' + str(exc) + ' exception')
         sys.exit(1)
 

From 5ab055e1a9da87dd0b5c2e78b832e399775256bf Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 24 Aug 2019 16:34:33 +0200
Subject: [PATCH 24/28] Python Bindings: Remove deprecation warnings (python3)

Python3 throws deprecation warnings about 'invalid escape sequences'
when runnig from console with the '-W' switch.

Note: Future python 3.x versions expose these warnings to the user and will
treat them as errors, later on.

This commit removes the deprecation warnings, beeing compatible
to python2 and python3

How to check: Run on the devel/python3 branch:

$ python3 -Wd -m compileall -f -q MythTV
    MythTV/connections.py:461: DeprecationWarning: invalid escape sequence \w
      _res_help = {'jump':  re.compile('(\w+)[ ]+- ([\w /,]+)'),
    MythTV/connections.py:463: DeprecationWarning: invalid escape sequence \w
      'query': re.compile('query ([\w ]*\w+)[ \r\n]+- ([\w /,]+)'),
    MythTV/connections.py:464: DeprecationWarning: invalid escape sequence \w
      'play':  re.compile('play ([\w -:]*\w+)[ \r\n]+- ([\w /:,\(\)]+)')}
    MythTV/connections.py:476: DeprecationWarning: invalid escape sequence \.
      reLOC = re.compile('http://(?P<ip>[0-9\.]+):(?P<port>[0-9]+)/.*')
    MythTV/connections.py:604: DeprecationWarning: invalid escape sequence \.
      reLOC = re.compile('http://(?P<ip>[0-9\.]+):(?P<port>[0-9]+)/.*')
    MythTV/dataheap.py:998: DeprecationWarning: invalid escape sequence \s
      sep = '(?:\s?(?:-|/)?\s?)?'
    MythTV/dataheap.py:1002: DeprecationWarning: invalid escape sequence \d
      '(\d{1,4})',
    MythTV/dataheap.py:1004: DeprecationWarning: invalid escape sequence \d
      '(\d{1,3})',
    MythTV/dataheap.py:1007: DeprecationWarning: invalid escape sequence \d
      regex2 = re.compile('(%s(?:Season%s\d*%s)*%s)$' \
    MythTV/methodheap.py:454: DeprecationWarning: invalid escape sequence \[
      bs = BACKEND_SEP.replace('[','\[').replace(']','\]')
    MythTV/methodheap.py:454: DeprecationWarning: invalid escape sequence \]
      bs = BACKEND_SEP.replace('[','\[').replace(']','\]')
    MythTV/methodheap.py:458: DeprecationWarning: invalid escape sequence \.
      '( HOSTNAME (?P<hostname>[a-zA-Z0-9_\.]*))?'
    MythTV/methodheap.py:459: DeprecationWarning: invalid escape sequence \.
      '( SENDER (?P<sender>[a-zA-Z0-9_\.]*))?'
    MythTV/methodheap.py:1146: DeprecationWarning: invalid escape sequence \d
      if re.match('(?:\d{1,3}\.){3}\d{1,3}',backend) or \
    MythTV/mythproto.py:61: DeprecationWarning: invalid escape sequence \d
      _reip = re.compile('(?:\d{1,3}\.){3}\d{1,3}')
    MythTV/mythproto.py:220: DeprecationWarning: invalid escape sequence \[
      'myth://((?P<group>.*)@)?(?P<host>[\[\]a-zA-Z0-9_\-\.]*)(:[0-9]*)?/(?P<file>.*)')
    MythTV/mythproto.py:221: DeprecationWarning: invalid escape sequence \d
      reip = re.compile('(?:\d{1,3}\.){3}\d{1,3}')
---
 mythtv/bindings/python/MythTV/connections.py | 10 ++++-----
 mythtv/bindings/python/MythTV/dataheap.py    | 20 +++++++++---------
 mythtv/bindings/python/MythTV/methodheap.py  | 22 ++++++++++----------
 mythtv/bindings/python/MythTV/mythproto.py   |  6 +++---
 4 files changed, 29 insertions(+), 29 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/connections.py b/mythtv/bindings/python/MythTV/connections.py
index b83a445ea1c..871b9604450 100644
--- a/mythtv/bindings/python/MythTV/connections.py
+++ b/mythtv/bindings/python/MythTV/connections.py
@@ -458,10 +458,10 @@ class FEConnection( object ):
                     'key':   lambda r: r=='OK',
                     'query': lambda r: r,
                     'play':  lambda r: r=='OK'}
-    _res_help = {'jump':  re.compile('(\w+)[ ]+- ([\w /,]+)'),
+    _res_help = {'jump':  re.compile(r'(\w+)[ ]+- ([\w /,]+)'),
                  'key':   lambda r: r.split('\r\n')[4].split(', '),
-                 'query': re.compile('query ([\w ]*\w+)[ \r\n]+- ([\w /,]+)'),
-                 'play':  re.compile('play ([\w -:]*\w+)[ \r\n]+- ([\w /:,\(\)]+)')}
+                 'query': re.compile(r'query ([\w ]*\w+)[ \r\n]+- ([\w /,]+)'),
+                 'play':  re.compile(r'play ([\w -:]*\w+)[ \r\n]+- ([\w /:,\(\)]+)')}
 
     def __init__(self, host, port, deadline=10.0, test=True):
         self.isConnected = False
@@ -473,7 +473,7 @@ def __init__(self, host, port, deadline=10.0, test=True):
 
     @classmethod
     def fromUPNP(cls, timeout=5):
-        reLOC = re.compile('http://(?P<ip>[0-9\.]+):(?P<port>[0-9]+)/.*')
+        reLOC = re.compile(r'http://(?P<ip>[0-9\.]+):(?P<port>[0-9]+)/.*')
         msearch = MSearch()
         for res in msearch.searchMythFE(timeout):
             ip, port = reLOC.match(res['location']).group(1,2)
@@ -601,7 +601,7 @@ def __init__(self, host, port):
 
     @classmethod
     def fromUPNP(cls, timeout=5.0):
-        reLOC = re.compile('http://(?P<ip>[0-9\.]+):(?P<port>[0-9]+)/.*')
+        reLOC = re.compile(r'http://(?P<ip>[0-9\.]+):(?P<port>[0-9]+)/.*')
         msearch = MSearch()
         for res in msearch.searchMythBE(timeout):
             ip, port = reLOC.match(res['location']).group(1,2)
diff --git a/mythtv/bindings/python/MythTV/dataheap.py b/mythtv/bindings/python/MythTV/dataheap.py
index e3338fbb9de..2e6c6c294ee 100644
--- a/mythtv/bindings/python/MythTV/dataheap.py
+++ b/mythtv/bindings/python/MythTV/dataheap.py
@@ -995,17 +995,17 @@ def parseFilename(self):
         for old in ('%20','_','.'):
             filename = filename.replace(old, ' ')
 
-        sep = '(?:\s?(?:-|/)?\s?)?'
+        sep = r'(?:\s?(?:-|/)?\s?)?'
         regex1 = re.compile(
-            sep.join(['^(.*[^s0-9])',
-                      '(?:s|(?:Season))?',
-                      '(\d{1,4})',
-                      '(?:[ex/]|Episode)',
-                      '(\d{1,3})',
-                      '(.*)$']), re.I)
-
-        regex2 = re.compile('(%s(?:Season%s\d*%s)*%s)$' \
-                            % (sep, sep, sep, sep), re.I)
+            sep.join([r'^(.*[^s0-9])',
+                      r'(?:s|(?:Season))?',
+                      r'(\d{1,4})',
+                      r'(?:[ex/]|Episode)',
+                      r'(\d{1,3})',
+                      r'(.*)$']), re.I)
+
+        title_pattern = r'(%s(?:Season%s\d*%s)*%s)$' % (sep, sep, sep, sep)
+        regex2 = re.compile(title_pattern, re.I)
 
         match1 = regex1.search(filename)
         if match1:
diff --git a/mythtv/bindings/python/MythTV/methodheap.py b/mythtv/bindings/python/MythTV/methodheap.py
index aa581d7cf09..6cfa252063a 100644
--- a/mythtv/bindings/python/MythTV/methodheap.py
+++ b/mythtv/bindings/python/MythTV/methodheap.py
@@ -451,17 +451,17 @@ def eventMonitor(self, event=None):
 class MythSystemEvent( BECache ):
     class systemeventhandler( object ):
         # decorator class for system events
-        bs = BACKEND_SEP.replace('[','\[').replace(']','\]')
+        bs = BACKEND_SEP.replace('[',r'\[').replace(']',r'\]')
         re_process = re.compile(bs.join([
-                'BACKEND_MESSAGE',
-                'SYSTEM_EVENT (?P<event>[A-Z0-9_]*)'
-                    '( HOSTNAME (?P<hostname>[a-zA-Z0-9_\.]*))?'
-                    '( SENDER (?P<sender>[a-zA-Z0-9_\.]*))?'
-                    '( CARDID (?P<cardid>[0-9]*))?'
-                    '( CHANID (?P<chanid>[0-9]*))?'
-                    '( STARTTIME (?P<starttime>[0-9-]*T[0-9-]))?'
-                    '( SECS (?P<secs>[0-9]*))?',
-                'empty']))
+                r'BACKEND_MESSAGE',
+                r'SYSTEM_EVENT (?P<event>[A-Z0-9_]*)'
+                    r'( HOSTNAME (?P<hostname>[a-zA-Z0-9_\.]*))?'
+                    r'( SENDER (?P<sender>[a-zA-Z0-9_\.]*))?'
+                    r'( CARDID (?P<cardid>[0-9]*))?'
+                    r'( CHANID (?P<chanid>[0-9]*))?'
+                    r'( STARTTIME (?P<starttime>[0-9-]*T[0-9-]))?'
+                    r'( SECS (?P<secs>[0-9]*))?',
+                r'empty']))
 
         def __init__(self, func):
             self.func = func
@@ -1143,7 +1143,7 @@ def __init__(self, backend=None, port=None, db=None):
         if backend is None:
             # use master backend
             backend = self.db.settings.NULL.MasterServerIP
-        if re.match('(?:\d{1,3}\.){3}\d{1,3}',backend) or \
+        if re.match(r'(?:\d{1,3}\.){3}\d{1,3}',backend) or \
                     check_ipv6(backend):
             # process ip address
             host = self.db._gethostfromaddr(backend)
diff --git a/mythtv/bindings/python/MythTV/mythproto.py b/mythtv/bindings/python/MythTV/mythproto.py
index 08a62546647..9fda5f10e8c 100644
--- a/mythtv/bindings/python/MythTV/mythproto.py
+++ b/mythtv/bindings/python/MythTV/mythproto.py
@@ -58,7 +58,7 @@ class _ConnHolder( object ):
 
     logmodule = 'Python Backend Connection'
     _shared = weakref.WeakValueDictionary()
-    _reip = re.compile('(?:\d{1,3}\.){3}\d{1,3}')
+    _reip = re.compile(r'(?:\d{1,3}\.){3}\d{1,3}')
 
     def __repr__(self):
         return "<%s 'myth://%s:%d/' at %s>" % \
@@ -217,8 +217,8 @@ def ftopen(file, mode, forceremote=False, nooverwrite=False, db=None, \
     db = DBCache(db)
     log = MythLog('Python File Transfer', db=db)
     reuri = re.compile(\
-        'myth://((?P<group>.*)@)?(?P<host>[\[\]a-zA-Z0-9_\-\.]*)(:[0-9]*)?/(?P<file>.*)')
-    reip = re.compile('(?:\d{1,3}\.){3}\d{1,3}')
+        r'myth://((?P<group>.*)@)?(?P<host>[\[\]a-zA-Z0-9_\-\.]*)(:[0-9]*)?/(?P<file>.*)')
+    reip = re.compile(r'(?:\d{1,3}\.){3}\d{1,3}')
 
     if mode not in ('r','w'):
         raise TypeError("File I/O must be of type 'r' or 'w'")

From 9dea0fa0cf0e8ac5f63abddb8055b034bfcc6ff3 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sat, 31 Aug 2019 15:40:33 +0200
Subject: [PATCH 25/28] Update Movie Grabber tmdb3.py to meet python3
 compatibility, again

- Fix another occurence of deprecated next() method

- Check against python2 instead of python3 to be future proof.

Tested with
$ env python3 --version
Python 3.6.8

$ python ....metadata/Movie/tmdb3.py --version
$ python ..../metadata/Movie/tmdb3.py --test
$ python ..../metadata/Movie/tmdb3.py -M -l en 'Indiana Jones'
$ python ..../metadata/Movie/tmdb3.py -M -l de 'Indiana Jones'
$ python ..../metadata/Movie/tmdb3.py -D -l de 217
$ python ..../metadata/Movie/tmdb3.py -l en -C 10
$ python ..../metadata/Movie/tmdb3.py -l en -a US -C 10
$ python ..../metadata/Movie/tmdb3.py -l en -a de -C 10
$ python ..../metadata/Movie/tmdb3.py -l en -a de -C 10 --debug

and python2 as well.
---
 mythtv/programs/scripts/metadata/Movie/tmdb3.py | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/mythtv/programs/scripts/metadata/Movie/tmdb3.py b/mythtv/programs/scripts/metadata/Movie/tmdb3.py
index 52dd7f0352b..2757e2fa7a4 100755
--- a/mythtv/programs/scripts/metadata/Movie/tmdb3.py
+++ b/mythtv/programs/scripts/metadata/Movie/tmdb3.py
@@ -35,10 +35,10 @@
 def print_etree(etostr):
     """lxml.etree.tostring is a bytes object in python3, and a str in python2.
     """
-    if sys.version_info[0] == 3:
-        sys.stdout.write(etostr.decode())
-    else:
+    if sys.version_info[0] == 2:
         sys.stdout.write(etostr)
+    else:
+        sys.stdout.write(etostr.decode())
 
 def timeouthandler(signal, frame):
     raise RuntimeError("Timed out")
@@ -149,7 +149,7 @@ def buildList(query, opts):
     count = 0
     while True:
         try:
-            res = results.next()
+            res = next(results)
         except StopIteration:
             # end of results
             break

From 7e95039d622b39bfb06f639ea9f107b9a5cf5ff0 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sun, 1 Sep 2019 10:05:35 +0200
Subject: [PATCH 26/28] TMDB3: Add compatibility to python3 for '__repr__'
 methods

This method is mostly used on terminal sessions like

  >>> from MythTV.tmdb3 import searchMovie
  >>> res = searchMovie('A New Hope')
  >>> res
  <Search Results: A New Hope>
  >>> len(res)
  5
  >>> res[0]
  <Movie 'Star Wars' (1977)>
  >>> res[1]
  <Movie 'New Hope' (2012)>

With python3, one will get an error response like
"TypeError: __repr__ returned non-string (type bytes)"
---
 .../bindings/python/tmdb3/tmdb3/__init__.py   |  3 ++
 .../bindings/python/tmdb3/tmdb3/tmdb_api.py   | 46 +++++++++----------
 mythtv/bindings/python/tmdb3/tmdb3/util.py    | 16 +++++--
 3 files changed, 38 insertions(+), 27 deletions(-)

diff --git a/mythtv/bindings/python/tmdb3/tmdb3/__init__.py b/mythtv/bindings/python/tmdb3/tmdb3/__init__.py
index d84e15ffeed..83c20cf3fe5 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/__init__.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/__init__.py
@@ -1,5 +1,8 @@
 #!/usr/bin/env python
 
+import sys
+IS_PY2 = sys.version_info[0] == 2
+
 from .tmdb_api import Configuration, searchMovie, searchMovieWithYear, \
                      searchPerson, searchStudio, searchList, searchCollection, \
                      searchSeries, Person, Movie, Collection, Genre, List, \
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py b/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py
index b8c44f6f702..89ceb84983a 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/tmdb_api.py
@@ -64,8 +64,10 @@
 # 0.7.0  Add support for television series data
 # 0.7.0.a  Added compatibility to python3, tested with python 3.6 and 2.7
 
+from . import IS_PY2
+
 from .request import set_key, Request
-from .util import Datapoint, Datalist, Datadict, Element, NameRepr, SearchRepr
+from .util import Datapoint, Datalist, Datadict, Element, NameRepr, SearchRepr, tmdb3_repr
 from .pager import PagedRequest
 from .locales import get_locale, set_locale
 from .tmdb_auth import get_session, set_session
@@ -73,9 +75,6 @@
 
 import json
 import datetime
-import sys
-
-IS_PY3 = sys.version_info[0] == 3
 
 DEBUG = False
 
@@ -317,8 +316,8 @@ def __eq__(self, other):
         return self.country == other.country
 
     def __repr__(self):
-        return u"<{0.__class__.__name__} '{0.title}' ({0.country})>"\
-               .format(self).encode('utf-8')
+        return tmdb3_repr(u"<{0.__class__.__name__} '{0.title}' ({0.country})>"\
+               .format(self))
 
 
 class Person(Element):
@@ -335,8 +334,8 @@ class Person(Element):
     aliases = Datalist('also_known_as')
 
     def __repr__(self):
-        return u"<{0.__class__.__name__} '{0.name}'>"\
-                            .format(self).encode('utf-8')
+        return tmdb3_repr(u"<{0.__class__.__name__} '{0.name}'>"\
+                            .format(self))
 
     def _populate(self):
         return Request('person/{0}'.format(self.id))
@@ -359,8 +358,8 @@ class Cast(Person):
     order = Datapoint('order')
 
     def __repr__(self):
-        return u"<{0.__class__.__name__} '{0.name}' as '{0.character}'>"\
-               .format(self).encode('utf-8')
+        return tmdb3_repr(u"<{0.__class__.__name__} '{0.name}' as '{0.character}'>"\
+               .format(self))
 
 
 class Crew(Person):
@@ -368,8 +367,8 @@ class Crew(Person):
     department = Datapoint('department')
 
     def __repr__(self):
-        return u"<{0.__class__.__name__} '{0.name}','{0.job}'>"\
-               .format(self).encode('utf-8')
+        return tmdb3_repr(u"<{0.__class__.__name__} '{0.name}','{0.job}'>"\
+               .format(self))
 
 
 class Keyword(Element):
@@ -377,8 +376,7 @@ class Keyword(Element):
     name = Datapoint('name')
 
     def __repr__(self):
-        return u"<{0.__class__.__name__} {0.name}>"\
-               .format(self).encode('utf-8')
+        return tmdb3_repr(u"<{0.__class__.__name__} {0.name}>".format(self))
 
 
 class Release(Element):
@@ -386,8 +384,8 @@ class Release(Element):
     country = Datapoint('iso_3166_1')
     releasedate = Datapoint('release_date', handler=process_date)
     def __repr__(self):
-        return u"<{0.__class__.__name__} {0.country}, {0.releasedate}>"\
-               .format(self).encode('utf-8')
+        return tmdb3_repr(u"<{0.__class__.__name__} {0.country}, {0.releasedate}>"\
+               .format(self))
 
 
 class Trailer(Element):
@@ -430,8 +428,8 @@ class Translation(Element):
     englishname = Datapoint('english_name')
 
     def __repr__(self):
-        return u"<{0.__class__.__name__} '{0.name}' ({0.language})>"\
-               .format(self).encode('utf-8')
+        return tmdb3_repr(u"<{0.__class__.__name__} '{0.name}' ({0.language})>"\
+               .format(self))
 
 
 class Genre(NameRepr, Element):
@@ -719,16 +717,16 @@ def _printable_name(self):
         return s
 
     def __repr__(self):
-        return u"<{0} {1}>".format(self.__class__.__name__,
-                                   self._printable_name()).encode('utf-8')
+        return tmdb3_repr(u"<{0} {1}>".format(self.__class__.__name__,
+                                   self._printable_name()))
 
 
 class ReverseCast( Movie ):
     character = Datapoint('character')
 
     def __repr__(self):
-        return (u"<{0.__class__.__name__} '{0.character}' on {1}>"
-                .format(self, self._printable_name()).encode('utf-8'))
+        return tmdb3_repr(u"<{0.__class__.__name__} '{0.character}' on {1}>"
+                .format(self, self._printable_name()))
 
 
 class ReverseCrew( Movie ):
@@ -736,8 +734,8 @@ class ReverseCrew( Movie ):
     job = Datapoint('job')
 
     def __repr__(self):
-        return (u"<{0.__class__.__name__} '{0.job}' for {1}>"
-                .format(self, self._printable_name()).encode('utf-8'))
+        return tmdb3_repr(u"<{0.__class__.__name__} '{0.job}' for {1}>"
+                .format(self, self._printable_name()))
 
 
 class Collection(NameRepr, Element):
diff --git a/mythtv/bindings/python/tmdb3/tmdb3/util.py b/mythtv/bindings/python/tmdb3/tmdb3/util.py
index ee3cb4558a2..18f88347fd5 100644
--- a/mythtv/bindings/python/tmdb3/tmdb3/util.py
+++ b/mythtv/bindings/python/tmdb3/tmdb3/util.py
@@ -6,17 +6,26 @@
 # Author: Raymond Wagner
 #-----------------------
 
+from . import IS_PY2
+
 from copy import copy
 from .locales import get_locale
 from .tmdb_auth import get_session
 
 from future.utils import with_metaclass
 
+
+def tmdb3_repr(x):
+    if IS_PY2:
+        return(x.encode('utf-8'))
+    else:
+        return(x)
+
+
 class NameRepr(object):
     """Mixin for __repr__ methods using 'name' attribute."""
     def __repr__(self):
-        return u"<{0.__class__.__name__} '{0.name}'>"\
-                    .format(self).encode('utf-8')
+        return tmdb3_repr(u"<{0.__class__.__name__} '{0.name}'>".format(self))
 
 
 class SearchRepr(object):
@@ -26,7 +35,7 @@ class SearchRepr(object):
     """
     def __repr__(self):
         name = self._name if self._name else self._request._kwargs['query']
-        return u"<Search Results: {0}>".format(name).encode('utf-8')
+        return tmdb3_repr(u"<Search Results: {0}>".format(name))
 
 
 class Poller(object):
@@ -366,6 +375,7 @@ def __new__(mcs, name, bases, attrs):
                 [a.name for a in sorted(initargs, key=lambda x: x.initarg)])
         return type.__new__(mcs, name, bases, attrs)
 
+
     def __call__(cls, *args, **kwargs):
         obj = cls.__new__(cls)
         if ('locale' in kwargs) and (kwargs['locale'] is not None):

From 1297759229ba345d26936a7e57cfb2cc3b7a9d1b Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Sun, 1 Sep 2019 20:46:27 +0200
Subject: [PATCH 27/28] MythTV: Add compatibility to python3 for '__repr__'
 methods

The 'repr()' method calls the '__repr__' method of an instanciated class in
python and is used mostly in the interactive python shell, like

$ python2
Python 2.7.15+ (default, Nov 27 2018, 23:36:35)

>>> from MythTV import MythDB, Recorded
>>> db = MythDB()
>>> rec = Recorded((3002, 20190622125000), db = db)
>>> rec     # -----> Note: this calls __repr__ under the hood.
b'<Recorded 'Reisezelt - Kurztrip','2019-06-47 12:50:00+02:00' at 0x7fcdb0faabe0>'
>>>

With Python3, this 'repr()' method returns a 'str' type (i.e. unicode),
in contrast to Python2, where this method may return a native 'str' type (ascii)
or an 'utf-8' encoded string.

Using this in a Python3 shell, leads to the following Type-Error:

  $ python3
  Python 3.6.8 (default, Jan 14 2019, 11:02:34)
  >>> from MythTV import MythDB, Recorded
  >>> db = MythDB()
  >>> rec = Recorded((3002, 20190622125000), db = db)
  >>> rec
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  TypeError: __repr__ returned non-string (type NoneType)
  >>>

This patch adds compatibility to Python3, it simply selects the current
python version when returning data from the '__repr__()' method.
---
 mythtv/bindings/python/MythTV/database.py     | 16 ++++++++--------
 mythtv/bindings/python/MythTV/dataheap.py     | 19 ++++++++++---------
 mythtv/bindings/python/MythTV/mythproto.py    |  8 ++++----
 mythtv/bindings/python/MythTV/system.py       |  4 ++--
 .../python/MythTV/utility/__init__.py         |  3 ++-
 .../bindings/python/MythTV/utility/other.py   |  7 +++++++
 6 files changed, 33 insertions(+), 24 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/database.py b/mythtv/bindings/python/MythTV/database.py
index 885cd4d310e..86294414320 100644
--- a/mythtv/bindings/python/MythTV/database.py
+++ b/mythtv/bindings/python/MythTV/database.py
@@ -8,7 +8,7 @@
 from MythTV.altdict import OrdDict, DictData
 from MythTV.logging import MythLog
 from MythTV.msearch import MSearch
-from MythTV.utility import datetime, dt, _donothing, QuickProperty
+from MythTV.utility import datetime, dt, _donothing, QuickProperty, py23_repr
 from MythTV.exceptions import MythError, MythDBError, MythTZError
 from MythTV.connections import DBConnection, LoggedCursor, XMLConnection
 
@@ -220,7 +220,7 @@ def __str__(self):
                  hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
     def __getstate__(self):
         data = {'data':DictData.__getstate__(self)}
@@ -463,7 +463,7 @@ def __init__(self, data):
             self._changed = True
             self.__hash__()
         def __str__(self): return str(self.items())
-        def __repr__(self): return str(self).encode('utf-8')
+        def __repr__(self): return py23_repr(str(self))
         def __hash__(self):
             if self._changed:
                 self._hash = hash(sum(map(hash,self.values())))
@@ -1116,7 +1116,7 @@ class _TableFields( OrdDict ):
         """Provides a dictionary-like list of table fieldnames"""
         class _FieldData( OrdDict ):
             def __str__(self): return str(list(self))
-            def __repr__(self): return str(self).encode('utf-8')
+            def __repr__(self): return py23_repr(str(self))
             def __iter__(self): return self.iterkeys()
             def __init__(self, result):
                 data = [(row[0],
@@ -1135,7 +1135,7 @@ def __getitem__(self,key):
                         raise KeyError(str(key))
         _localvars = ['_field_order','_db','_log']
         def __str__(self): return str(list(self))
-        def __repr__(self): return str(self).encode('utf-8')
+        def __repr__(self): return py23_repr(str(self))
         def __iter__(self): return self.iterkeys()
         def __init__(self, db, log):
             OrdDict.__init__(self)
@@ -1160,7 +1160,7 @@ class _Settings( OrdDict ):
         class _HostSettings( OrdDict ):
             _localvars = ['_field_order','_log','_db','_host','_insert','_where']
             def __str__(self): return str(list(self))
-            def __repr__(self): return str(self).encode('utf-8')
+            def __repr__(self): return py23_repr(str(self))
             def __iter__(self): return self.iterkeys()
             def __init__(self, db, log, host):
                 OrdDict.__init__(self)
@@ -1234,7 +1234,7 @@ def getall(self):
 
         _localvars = ['_field_order','_log','_db']
         def __str__(self): return str(list(self))
-        def __repr__(self): return str(self).encode('utf-8')
+        def __repr__(self): return py23_repr(str(self))
         def __iter__(self): return self.iterkeys()
         def __init__(self, db, log):
             OrdDict.__init__(self)
@@ -1440,7 +1440,7 @@ def __str__(self):
                     (self.groupname, self.hostname,
                         self.dirname, hex(id(self)))
 
-    def __repr__(self): return str(self).encode('utf-8')
+    def __repr__(self): return py23_repr(str(self))
 
     def _evalwheredat(self, wheredat=None):
         DBData._evalwheredat(self, wheredat)
diff --git a/mythtv/bindings/python/MythTV/dataheap.py b/mythtv/bindings/python/MythTV/dataheap.py
index 2e6c6c294ee..12c91ebaa48 100644
--- a/mythtv/bindings/python/MythTV/dataheap.py
+++ b/mythtv/bindings/python/MythTV/dataheap.py
@@ -10,7 +10,8 @@
 from MythTV.database import *
 from MythTV.system import Grabber, InternetMetadata, VideoMetadata
 from MythTV.mythproto import ftopen, FileOps, Program
-from MythTV.utility import CMPRecord, CMPVideo, MARKUPLIST, datetime, ParseSet
+from MythTV.utility import CMPRecord, CMPVideo, MARKUPLIST, datetime, ParseSet,\
+                           py23_repr
 
 import re
 import locale
@@ -166,7 +167,7 @@ def __str__(self):
                                     % (self.title, self.type, hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
     def __init__(self, data=None, db=None, template=None):
         DBDataWrite.__init__(self, data, db)
@@ -334,7 +335,7 @@ def __str__(self):
                 self.starttime.isoformat(' '), hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
     def __init__(self, data=None, db=None):
         if data is not None:
@@ -576,7 +577,7 @@ def __str__(self):
                 self.starttime.isoformat(' '), hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
     def __init__(self, data=None, db=None):
         if data is not None:
@@ -614,7 +615,7 @@ def __str__(self):
                 self.starttime.isoformat(' '), hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
     def __init__(self, data=None, db=None):
         if data is not None:
@@ -658,7 +659,7 @@ def __str__(self):
                         (self.inetref, self.season, hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
     coverart = Artwork('coverart')
     fanart   = Artwork('fanart')
@@ -680,7 +681,7 @@ def __str__(self):
         return u"<Job '%s' at %s>" % (self.id, hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
     def setComment(self,comment):
         """Job.setComment(comment) -> None, updates comment"""
@@ -750,7 +751,7 @@ def __str__(self):
                         (self.chanid, self.name, hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
 class Guide( CMPRecord, DBData ):
     """
@@ -767,7 +768,7 @@ def __str__(self):
                 self.starttime.isoformat(' '), hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
     def getRecStatus(self):
         be = FileOps(db=self._db)
diff --git a/mythtv/bindings/python/MythTV/mythproto.py b/mythtv/bindings/python/MythTV/mythproto.py
index 9fda5f10e8c..1672ba22bdf 100644
--- a/mythtv/bindings/python/MythTV/mythproto.py
+++ b/mythtv/bindings/python/MythTV/mythproto.py
@@ -11,8 +11,8 @@
 from MythTV.altdict import DictData
 from MythTV.connections import BEConnection, BEEventConnection
 from MythTV.database import DBCache
-from MythTV.utility import CMPRecord, datetime, \
-                           ParseEnum, CopyData, CopyData2, check_ipv6
+from MythTV.utility import CMPRecord, datetime, ParseEnum, \
+                           CopyData, CopyData2, check_ipv6, py23_repr
 
 from datetime import date
 from time import sleep
@@ -828,7 +828,7 @@ def __str__(self):
                     % (self.path, self.host, hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
     def __init__(self, raw):
         DictData.__init__(self, raw)
@@ -879,7 +879,7 @@ def __str__(self):
                  self.starttime.isoformat(' '), hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
     def __init__(self, raw, db=None):
         DictData.__init__(self, raw)
diff --git a/mythtv/bindings/python/MythTV/system.py b/mythtv/bindings/python/MythTV/system.py
index 9b89c3ae066..d1d7546c0eb 100644
--- a/mythtv/bindings/python/MythTV/system.py
+++ b/mythtv/bindings/python/MythTV/system.py
@@ -7,7 +7,7 @@
 from MythTV.exceptions import MythError, MythDBError, MythFileError
 from MythTV.logging import MythLog
 from MythTV.altdict import DictData, OrdDict
-from MythTV.utility import levenshtein, DequeBuffer
+from MythTV.utility import levenshtein, DequeBuffer, py23_repr
 from MythTV.database import DBCache
 
 from subprocess import Popen
@@ -153,7 +153,7 @@ def __str__(self):
                     self.path, hex(id(self)))
 
     def __repr__(self):
-        return str(self).encode('utf-8')
+        return py23_repr(str(self))
 
     def append(self, *args):
         """
diff --git a/mythtv/bindings/python/MythTV/utility/__init__.py b/mythtv/bindings/python/MythTV/utility/__init__.py
index 9e8913adc51..4f8d060a23f 100644
--- a/mythtv/bindings/python/MythTV/utility/__init__.py
+++ b/mythtv/bindings/python/MythTV/utility/__init__.py
@@ -7,4 +7,5 @@
 
 from .other import _donothing, SchemaUpdate, databaseSearch, deadlinesocket, \
                    MARKUPLIST, levenshtein, ParseEnum, ParseSet, CopyData, \
-                   CopyData2, check_ipv6, QuickProperty, py23_str
+                   CopyData2, check_ipv6, QuickProperty, py23_str, py23_repr
+
diff --git a/mythtv/bindings/python/MythTV/utility/other.py b/mythtv/bindings/python/MythTV/utility/other.py
index d96cccf53f0..c8995e2251f 100644
--- a/mythtv/bindings/python/MythTV/utility/other.py
+++ b/mythtv/bindings/python/MythTV/utility/other.py
@@ -15,6 +15,7 @@
 import weakref
 import socket
 import re
+import sys
 from builtins import range
 
 def _donothing(*args, **kwargs):
@@ -586,6 +587,12 @@ def py23_str(value, ignore_errors=False):
         except TypeError:  # Wasn't a bytes object, no need to decode
             return str(value)
 
+def py23_repr(x):
+    if sys.version_info[0] == 2:
+        return(x.encode('utf-8'))
+    else:
+        return(x)
+
 class QuickProperty( object ):
     def __init__(self, maskedvar, default=None, handler=None):
         self.varname = maskedvar

From 1466f61e5a515db6065cf97d3017d3d935284111 Mon Sep 17 00:00:00 2001
From: Roland Ernst <rcrernst@gmail.com>
Date: Mon, 2 Sep 2019 23:37:50 +0200
Subject: [PATCH 28/28] Add Compatibility to Python3 for metaclasses

Python3 changed the way how to use a metaclass:

See
https://python-future.org/compatible_idioms.html#metaclasses

On python2, one can test it on classes using the 'InputSingleton':

MythTV is using metaclasses for getting the time zone info
in utility/dt.py: The `class posixtzinfo` is designed as
`InputSingleton`, which means that every subsequent call
with the same parameter returns the same object.
With the patches applied from #13299, one gets on python2:

    $ python
    Python 2.7.15+ (default, Nov 27 2018, 23:36:35)
    >>> from MythTV.utility.dt import *
    >>> from MythTV.utility.singleton import InputSingleton

    >>> a = posixtzinfo()
    >>> b=  posixtzinfo('Etc/UTC')
    >>> c = posixtzinfo("America/Anchorage")

    >>> x = posixtzinfo()
    >>> y = posixtzinfo('Etc/UTC')
    >>> z = posixtzinfo("America/Anchorage")

    >>> c == z
    True
    >>> a == x
    True
    >>> b == y
    True

With python3, i get:

    >>> a == x
    False
    >>> b == y
    False
    >>> c == z
    False

which means, the 'InputSingleton' is not applied in the correct way.

Python3 simply ignores the '__metaclass__' property of Python2.

This patch adds the compatibility layer from python-future.

Additionally, this patch fixes an error

  'RuntimeError: dictionary changed size during iteration'

which is needed for python2 to python3 conversion and only occurs if
the '__metaclass__' is not applied correctly (on python3).
---
 mythtv/bindings/python/MythTV/utility/dt.py   | 6 +++---
 mythtv/bindings/python/MythTV/utility/enum.py | 6 +++---
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/mythtv/bindings/python/MythTV/utility/dt.py b/mythtv/bindings/python/MythTV/utility/dt.py
index c669e3d767a..ef61749a56f 100644
--- a/mythtv/bindings/python/MythTV/utility/dt.py
+++ b/mythtv/bindings/python/MythTV/utility/dt.py
@@ -11,10 +11,11 @@
                      tzinfo as _pytzinfo, \
                      timedelta
 from collections import namedtuple
+from future.utils import with_metaclass
 import os
 import re
 import time
-from . import singleton
+from .singleton import InputSingleton
 time.tzset()
 
 class basetzinfo( _pytzinfo ):
@@ -116,12 +117,11 @@ def tzname(self, dt=None):
 #    database.
 #    """
 
-class posixtzinfo( basetzinfo ):
+class posixtzinfo( with_metaclass(InputSingleton, basetzinfo) ):
     """
     Customized timezone class that can import timezone data from the local
     POSIX zoneinfo files.
     """
-    __metaclass__ = singleton.InputSingleton
     _Count = namedtuple('Count', \
                         'gmt_indicators std_indicators leap_seconds '+\
                         'transitions types abbrevs')
diff --git a/mythtv/bindings/python/MythTV/utility/enum.py b/mythtv/bindings/python/MythTV/utility/enum.py
index 3875054c7b1..a5dbec5abf1 100644
--- a/mythtv/bindings/python/MythTV/utility/enum.py
+++ b/mythtv/bindings/python/MythTV/utility/enum.py
@@ -7,6 +7,7 @@
 #------------------------------
 
 from builtins import int
+from future.utils import with_metaclass
 
 class EnumValue( object ):
     _next = 0
@@ -32,7 +33,7 @@ def _incr(cls, value):
 
 class EnumType( type ):
     def __new__(mcs, name, bases, attrs):
-        for k,v in attrs.items():
+        for k,v in list(attrs.items()):
             if isinstance(v, int):
                 EnumValue(k, v)
                 del attrs[k]
@@ -51,8 +52,7 @@ def __getattr__(cls, key):
             return cls(cls._values[key].value)
         raise AttributeError(key)
 
-class BaseEnum( object ):
-    __metaclass__ = EnumType
+class BaseEnum( with_metaclass( EnumType, object )):
 
     def __init__(self, mode):
         self.mode = mode
