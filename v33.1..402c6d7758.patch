From 3db72cc1d34609a1e07ec44b0d999c673501963c Mon Sep 17 00:00:00 2001
From: David Hampton <mythtv@love2code.net>
Date: Mon, 6 Feb 2023 22:53:49 -0500
Subject: [PATCH 01/15] Arch linux refuses to accept egrep. Switch to 'grep
 -E'.

(cherry picked from commit bbcc7db3fdcd338af1889c8226c933cc7172715d)
---
 mythtv/version.sh | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/mythtv/version.sh b/mythtv/version.sh
index 871d9748821..cbbd696721c 100755
--- a/mythtv/version.sh
+++ b/mythtv/version.sh
@@ -80,7 +80,7 @@ else
     esac
 fi
 
-if ! echo "${SOURCE_VERSION}" | egrep -i "v[0-9]+.*"   ; then
+if ! echo "${SOURCE_VERSION}" | grep -Ei "v[0-9]+.*"   ; then
     # Invalid version - use SRC_VERSION file
     echo "WARNING: Invalid source version ${SOURCE_VERSION}, must start with v and a number, will use SRC_VERSION file instead"
     . $GITTREEDIR/SRC_VERSION

From 0c373c3b98e2cf8426457ff75be2935ec6f53248 Mon Sep 17 00:00:00 2001
From: Mark Spieth <mspieth@digivation.com.au>
Date: Sat, 11 Feb 2023 13:48:57 +1100
Subject: [PATCH 02/15] Android: OpenSSL 1.1.1 load system CA certificates
 explicitly Issue: 125

* Move all android library dependencies to the packaging repo
---
 mythtv/programs/mythfrontend/mythfrontend.cpp |  6 +++
 mythtv/programs/mythfrontend/mythfrontend.pro | 53 +------------------
 2 files changed, 8 insertions(+), 51 deletions(-)

diff --git a/mythtv/programs/mythfrontend/mythfrontend.cpp b/mythtv/programs/mythfrontend/mythfrontend.cpp
index 8cc6448a365..221fe507236 100644
--- a/mythtv/programs/mythfrontend/mythfrontend.cpp
+++ b/mythtv/programs/mythfrontend/mythfrontend.cpp
@@ -1892,6 +1892,12 @@ Q_DECL_EXPORT int main(int argc, char **argv)
     SignalHandler::SetHandler(SIGUSR2, handleSIGUSR2);
 #endif
 
+#if defined(Q_OS_ANDROID)
+    auto config = QSslConfiguration::defaultConfiguration();
+    config.setCaCertificates(QSslConfiguration::systemCaCertificates());
+    QSslConfiguration::setDefaultConfiguration(config);
+#endif
+
     int retval = cmdline.ConfigureLogging();
     if (retval != GENERIC_EXIT_OK)
         return retval;
diff --git a/mythtv/programs/mythfrontend/mythfrontend.pro b/mythtv/programs/mythfrontend/mythfrontend.pro
index 0b17943c309..4b9913f9d93 100644
--- a/mythtv/programs/mythfrontend/mythfrontend.pro
+++ b/mythtv/programs/mythfrontend/mythfrontend.pro
@@ -132,55 +132,6 @@ using_libdns_sd {
 }
 
 android {
-
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libbluray.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libicudata70.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libexiv2.14.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libfreetype.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libharfbuzz.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libfribidi.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libiconv.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libass.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libtag.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libxml2.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libfontconfig.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)liblzo2.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libicuuc70.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libicui18n70.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)mariadb/libmariadb.so
-
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libexiv2.14.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)liblzo2.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libicudata65.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libicui18n65.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libicuuc65.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libbluray.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libxml2.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libfreetype.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)mariadb/libmariadb.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libfontconfig.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libtag.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libfribidi.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libass.so
-    #ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libiconv.so
-
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libmythavutil.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libmythpostproc.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libmythavfilter.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libmythswresample.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libmythswscale.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libmythavcodec.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIBCOMMON)libmythavformat.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIB)libmythbase-$${LIBVERSION}.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIB)libmythui-$${LIBVERSION}.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIB)libmythservicecontracts-$${LIBVERSION}.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIB)libmythupnp-$${LIBVERSION}.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIB)libmyth-$${LIBVERSION}.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIB)libmythtv-$${LIBVERSION}.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIB)libmythmetadata-$${LIBVERSION}.so
-    ANDROID_EXTRA_LIBS += $$(MYTHINSTALLLIB)libmythprotoserver-$${LIBVERSION}.so
-
-    ANDROID_PACKAGE_SOURCE_DIR += $$(MYTHPACKAGEBASE)/android-package-source
-
-    ANDROID_MIN_SDK_VERSION = $$(ANDROID_MIN_SDK_VERSION)
+    message( myth android lib include $$(ANDROID_QT_DEPENDENCY_INCLUDE) )
+    include ( $$(ANDROID_QT_DEPENDENCY_INCLUDE) )
 }

From a803b198a84e04aa9a83dee5047193e431e9b3ed Mon Sep 17 00:00:00 2001
From: Klaas de Waal <klaas@kldo.nl>
Date: Thu, 9 Feb 2023 21:44:34 +0100
Subject: [PATCH 03/15] Send REC_PENDING event before recording starts

Fix the logic that sends the REC_PENDING event.
- REC_PENDING event is sent always before the REC_STARTED.
- REC_PENDING event is sent at 120, 90, 60 and 30 seconds before the start of the recording.
- Start of the recording is the scheduled program start time plus the RecordPreRoll setting value.
- When a recording is scheduled to start recording immediately then there is
  one REC_PENDING event with 0 seconds immediately followed by the REC_STARTED event.
- The setting WakeUpThreshold specifies how early the slave backends are signaled to start
  before the recording is started. This setting is used as configured, but now with a minimum
  value of RecordPreRoll plus 120 seconds so that there is always time for the REC_PENDING events.

(cherry picked from commit 55a7d8293004b0cadb921a383b44a0fb9954a287)
---
 mythtv/programs/mythbackend/scheduler.cpp | 45 ++++++++++++++++-------
 1 file changed, 32 insertions(+), 13 deletions(-)

diff --git a/mythtv/programs/mythbackend/scheduler.cpp b/mythtv/programs/mythbackend/scheduler.cpp
index 2fc66467a10..aba76438cec 100644
--- a/mythtv/programs/mythbackend/scheduler.cpp
+++ b/mythtv/programs/mythbackend/scheduler.cpp
@@ -2118,6 +2118,10 @@ void Scheduler::run(void)
                 idleWaitForRecordingTime =
                     gCoreContext->GetDurSetting<std::chrono::minutes>("idleWaitForRecordingTime", 15min);
 
+                // Wakeup slaves at least 2 minutes before recording starts.
+                // This allows also REC_PENDING events.
+                wakeThreshold = std::max(wakeThreshold, prerollseconds + 120s);
+
                 QElapsedTimer t; t.start();
                 if (HandleReschedule())
                 {
@@ -2169,6 +2173,31 @@ void Scheduler::run(void)
             }
         }
 
+        // Wake any slave backends that need waking
+        curtime = MythDate::current();
+        for (auto it = startIter; it != m_recList.end(); ++it)
+        {
+            auto secsleft = std::chrono::seconds(curtime.secsTo((*it)->GetRecordingStartTime()));
+            auto timeBeforePreroll = secsleft - prerollseconds;
+            if (timeBeforePreroll <= wakeThreshold)
+            {
+                HandleWakeSlave(**it, prerollseconds);
+
+                // Adjust wait time until REC_PENDING event
+                if (timeBeforePreroll > 0s)
+                {
+                    std::chrono::seconds waitpending;
+                    if (timeBeforePreroll > 120s)
+                        waitpending = timeBeforePreroll -120s;
+                    else
+                        waitpending = std::min(timeBeforePreroll, 30s);
+                    nextWakeTime = MythDate::current().addSecs(waitpending.count());
+                }
+            }
+            else
+                break;
+        }
+
         // Start any recordings that are due to be started
         // & call RecordPending for recordings due to start in 30 seconds
         // & handle RecStatus::Tuning updates
@@ -2186,17 +2215,6 @@ void Scheduler::run(void)
         if (m_recListChanged)
             continue;
 
-        /// Wake any slave backends that need waking
-        curtime = MythDate::current();
-        for (auto it = startIter; it != m_recList.end(); ++it)
-        {
-            auto secsleft = std::chrono::seconds(curtime.secsTo((*it)->GetRecordingStartTime()));
-            if ((secsleft - prerollseconds) <= wakeThreshold)
-                HandleWakeSlave(**it, prerollseconds);
-            else
-                break;
-        }
-
         if (statuschanged)
         {
             MythEvent me("SCHEDULE_CHANGE");
@@ -2547,13 +2565,14 @@ void Scheduler::HandleWakeSlave(RecordingInfo &ri, std::chrono::seconds prerolls
     bool pendingEventSent = false;
     for (size_t i = 0; i < kSysEventSecs.size(); i++)
     {
-        if (((secsleft - prerollseconds) <= kSysEventSecs[i]) && (secsleft > 0s) &&
+        auto pending_secs = std::max((secsleft - prerollseconds), 0s);
+        if ((pending_secs <= kSysEventSecs[i]) &&
             (!m_sysEvents[i].contains(sysEventKey)))
         {
             if (!pendingEventSent)
             {
                 SendMythSystemRecEvent(
-                    QString("REC_PENDING SECS %1").arg((secsleft - prerollseconds).count()), &ri);
+                    QString("REC_PENDING SECS %1").arg(pending_secs.count()), &ri);
             }
 
             m_sysEvents[i].insert(sysEventKey);

From c273ed0f9a2491b7f6ec377be0a0a861f7788849 Mon Sep 17 00:00:00 2001
From: jhoyt4 <john.hoyt@gmail.com>
Date: Sat, 18 Feb 2023 09:42:47 -0500
Subject: [PATCH 04/15] OSX: Handle constants deprecated for 11.7

  - Fixes regression caused by deprecation of constants by Apple
    in 11.5.7.
  - Initial fix for macOS 12 introduced in commit 3787583

(cherry picked from commit df7903b418da240e0ed5ea9bcb981a921ff4e8de)
---
 mythtv/libs/libmyth/audio/audiooutputca.cpp   | 44 +++++++++----------
 .../libmythbase/platforms/mythpowerosx.cpp    |  8 ++--
 mythtv/libs/libmythui/devices/AppleRemote.cpp |  8 ++--
 .../libmythui/platforms/mythutilscocoa.mm     |  8 ++--
 4 files changed, 34 insertions(+), 34 deletions(-)

diff --git a/mythtv/libs/libmyth/audio/audiooutputca.cpp b/mythtv/libs/libmyth/audio/audiooutputca.cpp
index beef4941a62..a23c8bfcdf7 100644
--- a/mythtv/libs/libmyth/audio/audiooutputca.cpp
+++ b/mythtv/libs/libmyth/audio/audiooutputca.cpp
@@ -26,9 +26,9 @@
 #include "libmythbase/mythcorecontext.h"
 #include "audiooutputca.h"
 
-#if !defined(MAC_OS_VERSION_12_0)
-#define kAudioObjectPropertyElementMain kAudioObjectPropertyElementMaster
-#endif
+// kAudioObjectPropertyElementMaster was deprecated in OS_X 12
+// kAudioObjectPropertyElementMaster defaults to a main/master port value of 0
+static constexpr int8_t kMythAudioObjectPropertyElementMain { 0 };
 
 #define LOC QString("CoreAudio: ")
 
@@ -551,7 +551,7 @@ AudioDeviceID CoreAudioData::GetDeviceWithName(const QString &deviceName)
     {
 	kAudioHardwarePropertyDevices,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     OSStatus err = AudioObjectGetPropertyDataSize(kAudioObjectSystemObject, &pa,
@@ -605,7 +605,7 @@ AudioDeviceID CoreAudioData::GetDefaultOutputDevice()
     {
 	kAudioHardwarePropertyDefaultOutputDevice,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     // Find the ID of the default Device
@@ -633,7 +633,7 @@ int CoreAudioData::GetTotalOutputChannels()
     {
 	kAudioDevicePropertyStreamConfiguration,
 	kAudioDevicePropertyScopeOutput, // Scope needs to be set to output to find output streams
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     OSStatus err = AudioObjectGetPropertyDataSize(mDeviceID, &pa,
@@ -677,7 +677,7 @@ QString *CoreAudioData::GetName()
     {
 	kAudioObjectPropertyName,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     CFStringRef name;
@@ -705,7 +705,7 @@ bool CoreAudioData::GetAutoHogMode()
     {
 	kAudioHardwarePropertyHogModeIsAllowed,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     OSStatus err = AudioObjectGetPropertyData(kAudioObjectSystemObject, &pa, 0, nullptr, &size, &val);
@@ -725,7 +725,7 @@ void CoreAudioData::SetAutoHogMode(bool enable)
     {
 	kAudioHardwarePropertyHogModeIsAllowed,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     OSStatus err = AudioObjectSetPropertyData(kAudioObjectSystemObject, &pa, 0, nullptr,
@@ -745,7 +745,7 @@ pid_t CoreAudioData::GetHogStatus()
     {
 	kAudioDevicePropertyHogMode,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     OSStatus err = AudioObjectGetPropertyData(kAudioObjectSystemObject, &pa, 0, nullptr,
@@ -767,7 +767,7 @@ bool CoreAudioData::SetHogStatus(bool hog)
     {
 	kAudioDevicePropertyHogMode,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     // According to Jeff Moore (Core Audio, Apple), Setting kAudioDevicePropertyHogMode
@@ -831,7 +831,7 @@ bool CoreAudioData::SetMixingSupport(bool mix)
     {
 	kAudioDevicePropertySupportsMixing,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
     OSStatus err = AudioObjectSetPropertyData(mDeviceID, &pa, 0, nullptr,
 					      sizeof(mixEnable), &mixEnable);
@@ -857,7 +857,7 @@ bool CoreAudioData::GetMixingSupport()
     {
 	kAudioDevicePropertySupportsMixing,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
     OSStatus err = AudioObjectGetPropertyData(mDeviceID, &pa, 0, nullptr,
 					      &size, &val);
@@ -879,7 +879,7 @@ AudioStreamIDVec CoreAudioData::StreamsList(AudioDeviceID d)
     {
 	kAudioDevicePropertyStreams,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     err = AudioObjectGetPropertyDataSize(d, &pa,
@@ -925,7 +925,7 @@ AudioStreamRangedVec CoreAudioData::FormatsList(AudioStreamID s)
         // Bugfix: kAudioStreamPropertyPhysicalFormats, is meant to only give array of AudioStreamBasicDescription
         kAudioStreamPropertyAvailablePhysicalFormats, // gives array of AudioStreamRangedDescription
         kAudioObjectPropertyScopeGlobal,
-        kAudioObjectPropertyElementMain
+        kMythAudioObjectPropertyElementMain
     };
 
     // Retrieve all the stream formats supported by this output stream
@@ -987,7 +987,7 @@ RatesVec CoreAudioData::RatesList(AudioDeviceID d)
     {
 	kAudioDevicePropertyAvailableNominalSampleRates,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     // retrieve size of rate list
@@ -1119,7 +1119,7 @@ int CoreAudioData::OpenAnalog()
     {
 	kAudioHardwarePropertyDevices,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     Debug("OpenAnalog: Entering");
@@ -1511,7 +1511,7 @@ bool CoreAudioData::OpenSPDIF()
 	{
 	    kAudioStreamPropertyPhysicalFormat,
 	    kAudioObjectPropertyScopeGlobal,
-	    kAudioObjectPropertyElementMain
+	    kMythAudioObjectPropertyElementMain
 	};
 
         // Retrieve the original format of this stream first
@@ -1628,7 +1628,7 @@ int CoreAudioData::AudioStreamChangeFormat(AudioStreamID               s,
     {
 	kAudioStreamPropertyPhysicalFormat,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
     OSStatus err = AudioObjectSetPropertyData(s, &pa, 0, nullptr,
 					      sizeof(format), &format);
@@ -1682,7 +1682,7 @@ void CoreAudioData::ResetAudioDevices()
     {
 	kAudioHardwarePropertyDevices,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     OSStatus err = AudioObjectGetPropertyDataSize(kAudioObjectSystemObject, &pa,
@@ -1728,7 +1728,7 @@ void CoreAudioData::ResetStream(AudioStreamID s)
     {
 	kAudioStreamPropertyPhysicalFormat,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
 
@@ -1777,7 +1777,7 @@ QMap<QString, QString> *AudioOutputCA::GetDevices(const char */*type*/)
     {
 	kAudioHardwarePropertyDevices,
 	kAudioObjectPropertyScopeGlobal,
-	kAudioObjectPropertyElementMain
+	kMythAudioObjectPropertyElementMain
     };
 
     OSStatus err = AudioObjectGetPropertyDataSize(kAudioObjectSystemObject, &pa,
diff --git a/mythtv/libs/libmythbase/platforms/mythpowerosx.cpp b/mythtv/libs/libmythbase/platforms/mythpowerosx.cpp
index 60e4903be1e..bc743022016 100644
--- a/mythtv/libs/libmythbase/platforms/mythpowerosx.cpp
+++ b/mythtv/libs/libmythbase/platforms/mythpowerosx.cpp
@@ -8,9 +8,9 @@
 #include <IOKit/ps/IOPSKeys.h>
 #include <AvailabilityMacros.h>
 
-#if !defined(MAC_OS_VERSION_12_0)
-#define kIOMainPortDefault kIOMasterPortDefault
-#endif
+// kIOMainPortDefault was deprecated in OS_X 12
+// kIOMainPortDefault defaults to a main/master port value of 0
+static constexpr int8_t kMythIOMainPortDefault { 0 };
 
 #define LOC QString("PowerOSX: ")
 
@@ -65,7 +65,7 @@ void MythPowerOSX::Init(void)
 
     // Is there a battery?
     CFArrayRef batteryinfo = NULL;
-    if (IOPMCopyBatteryInfo(kIOMainPortDefault, &batteryinfo) == kIOReturnSuccess)
+    if (IOPMCopyBatteryInfo(kMythIOMainPortDefault, &batteryinfo) == kIOReturnSuccess)
     {
         CFRelease(batteryinfo);
 
diff --git a/mythtv/libs/libmythui/devices/AppleRemote.cpp b/mythtv/libs/libmythui/devices/AppleRemote.cpp
index 3749ba894c9..e79db57e270 100644
--- a/mythtv/libs/libmythui/devices/AppleRemote.cpp
+++ b/mythtv/libs/libmythui/devices/AppleRemote.cpp
@@ -23,9 +23,9 @@
 
 #include "libmythbase/mythlogging.h"
 
-#if !defined(MAC_OS_VERSION_12_0)
-#define kIOMainPortDefault kIOMasterPortDefault
-#endif
+// kIOMainPortDefault was deprecated in OS_X 12
+// kIOMainPortDefault defaults to a main/master port value of 0
+static constexpr int8_t kMythIOMainPortDefault { 0 };
 
 AppleRemote*    AppleRemote::_instance = nullptr;
 
@@ -193,7 +193,7 @@ static io_object_t _findAppleRemoteDevice(const char *devName)
     hidMatchDictionary = IOServiceMatching(devName);
 
     // check for matching devices
-    ioReturnValue = IOServiceGetMatchingServices(kIOMainPortDefault,
+    ioReturnValue = IOServiceGetMatchingServices(kMythIOMainPortDefault,
                                                  hidMatchDictionary,
                                                  &hidObjectIterator);
 
diff --git a/mythtv/libs/libmythui/platforms/mythutilscocoa.mm b/mythtv/libs/libmythui/platforms/mythutilscocoa.mm
index 98b054f9874..d6da5c653c0 100644
--- a/mythtv/libs/libmythui/platforms/mythutilscocoa.mm
+++ b/mythtv/libs/libmythui/platforms/mythutilscocoa.mm
@@ -6,9 +6,9 @@
 #import <IOKit/graphics/IOGraphicsLib.h>
 #include <AvailabilityMacros.h>
 
-#if !defined(MAC_OS_VERSION_12_0)
-#define kIOMainPortDefault kIOMasterPortDefault
-#endif
+// kIOMainPortDefault was deprecated in OS_X 12
+// kIOMainPortDefault defaults to a main/master port value of 0
+static constexpr int8_t kMythIOMainPortDefault { 0 };
 
 CGDirectDisplayID GetOSXCocoaDisplay(void* View)
 {
@@ -44,7 +44,7 @@ QByteArray GetOSXEDID(CGDirectDisplayID Display)
     CFMutableDictionaryRef matching = IOServiceMatching("IODisplayConnect");
 
     io_iterator_t iter;
-    if (IOServiceGetMatchingServices(kIOMainPortDefault, matching, &iter))
+    if (IOServiceGetMatchingServices(kMythIOMainPortDefault, matching, &iter))
       return result;
 
     io_service_t service = 0;

From 7f288be61b5fa653b5afd35b0ceea3b524ae8a1c Mon Sep 17 00:00:00 2001
From: Klaas de Waal <klaas@kldo.nl>
Date: Sun, 12 Mar 2023 20:54:07 +0100
Subject: [PATCH 05/15] mythtv-setup hanging at Video Sources

On Ubuntu 22.10 mythtv-setup hangs in Video Sources when creating a new Video source.
The problem has been traced to running tv_find_grabbers by MythSystemLegacy.
The fix consists of adding the kMSDontDisableDrawing flag to the invocation of MythSystemLegacy.
It is not clear why this problem only appears on Ubuntu 22.10 and not on other distro's.

Refs #690

(cherry picked from commit 337500ecae712b48a2956bae5d786d6e90e4c667)
---
 mythtv/libs/libmythtv/videosource.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/mythtv/libs/libmythtv/videosource.cpp b/mythtv/libs/libmythtv/videosource.cpp
index 6bb169409eb..1bb70946466 100644
--- a/mythtv/libs/libmythtv/videosource.cpp
+++ b/mythtv/libs/libmythtv/videosource.cpp
@@ -298,7 +298,7 @@ class XMLTVGrabber : public MythUIComboBoxSetting
             args += "baseline";
 
             MythSystemLegacy find_grabber_proc("tv_find_grabbers", args,
-                                                kMSStdOut | kMSRunShell);
+                                                kMSStdOut | kMSRunShell | kMSDontDisableDrawing);
             find_grabber_proc.Run(25s);
             LOG(VB_GENERAL, LOG_INFO,
                 loc + "Running 'tv_find_grabbers " + args.join(" ") + "'.");

From b391cfb6a7ac87d245f697edb77c0114d67de683 Mon Sep 17 00:00:00 2001
From: Klaas de Waal <klaas@kldo.nl>
Date: Fri, 17 Mar 2023 23:01:07 +0100
Subject: [PATCH 06/15] Conversion of negative time values to string

When converting a negative time value with format string "m:ss" there is
a minus sign before the minutes and also a minus sign before the seconds.
The implementation apparently only supports positive time interval values.
The implementation is now extended to support negative time interval values
by converting the absolute time value to string and then prepending a minus
sign when the time value is negative.
The implementation was introduced in commit 65b9c73adacabe38877c3e18af5d4a0545799c1
"Better fix for MythDate::formatTime to handle overflows.", committed on Mar 16, 2022.

Refs #733

(cherry picked from commit c166849536ca2785184b5b6a20aec6bfd3b7a099)
---
 mythtv/libs/libmythbase/mythdate.cpp | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/mythtv/libs/libmythbase/mythdate.cpp b/mythtv/libs/libmythbase/mythdate.cpp
index 8f3397241a6..21a307cb453 100644
--- a/mythtv/libs/libmythbase/mythdate.cpp
+++ b/mythtv/libs/libmythbase/mythdate.cpp
@@ -237,6 +237,9 @@ QString formatTime(std::chrono::milliseconds msecs, QString fmt)
     static const QRegularExpression sRe("s+");
     static const QRegularExpression zRe("z+");
 
+    bool negativeTime = msecs < 0ms;
+    msecs = std::chrono::milliseconds(std::abs(msecs.count()));
+
     QRegularExpressionMatch match = hRe.match(fmt);
     if (match.hasMatch())
     {
@@ -272,6 +275,10 @@ QString formatTime(std::chrono::milliseconds msecs, QString fmt)
         QString text = StringUtil::intToPaddedString(value, width);
         fmt.replace(match.capturedStart(), match.capturedLength(), text);
     }
+
+    if (negativeTime)
+        fmt.prepend("-");
+
     return fmt;
 }
 

From 142a8e070841c74d200e3444f6b815cde5452809 Mon Sep 17 00:00:00 2001
From: Klaas de Waal <klaas@kldo.nl>
Date: Sun, 26 Mar 2023 14:29:59 +0200
Subject: [PATCH 07/15] End-of-file in MythMusic

Detect end-of-file when reading music files and return the AVERROR_EOF status to FFmpeg.
In version 33 MythTV has upgraded to a version of FFmpeg that does require this.

Refs #686

(cherry picked from commit b9354c9f9e5672655a87078c15d6cda77702d89e)
---
 mythplugins/mythmusic/mythmusic/remoteavformatcontext.h | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/mythplugins/mythmusic/mythmusic/remoteavformatcontext.h b/mythplugins/mythmusic/mythmusic/remoteavformatcontext.h
index 92c9c6264cf..0a1b713ff09 100644
--- a/mythplugins/mythmusic/mythmusic/remoteavformatcontext.h
+++ b/mythplugins/mythmusic/mythmusic/remoteavformatcontext.h
@@ -136,7 +136,9 @@ class RemoteAVFormatContext
     static int ReadFunc(void *opaque, uint8_t *buf, int buf_size)
     {
         auto *rf = reinterpret_cast< RemoteFile* >(opaque);
-        return rf->Read(buf, buf_size);
+        int len = rf->Read(buf, buf_size);
+        int ret = ((len == 0) && (buf_size > 0)) ? AVERROR_EOF : len;
+        return ret;
     }
 
     static int WriteFunc(void */*opaque*/, uint8_t */*buf*/, int/*buf_size*/)

From f2a964ed814a08d8a3016e5b0b1f0979e4586360 Mon Sep 17 00:00:00 2001
From: Jan Hambrecht <jaham@gmx.net>
Date: Sat, 18 Mar 2023 23:16:08 +0100
Subject: [PATCH 08/15] Fix detection of optical drives

Checking for mount points is not reliable to determine if a block device
is an optical drive. This commit uses the 'MediaCompatibility' property
of the 'org.freedesktop.UDisks2.Drive' DBUS interface to check if the
drive supports optical media.
Also changes the function name in the log messages to match the function
they are called from.

(cherry picked from commit 998669de6114706d0459214ecc030aed7489afab)
---
 mythtv/libs/libmyth/mediamonitor-unix.cpp | 21 ++++++++++++---------
 1 file changed, 12 insertions(+), 9 deletions(-)

diff --git a/mythtv/libs/libmyth/mediamonitor-unix.cpp b/mythtv/libs/libmyth/mediamonitor-unix.cpp
index c9536f5584a..1a752c4aeb9 100644
--- a/mythtv/libs/libmyth/mediamonitor-unix.cpp
+++ b/mythtv/libs/libmyth/mediamonitor-unix.cpp
@@ -179,7 +179,8 @@ static QVariant DriveProperty(const QDBusObjectPath& o, const std::string& kszPr
     {
         v = iface.property(kszProperty.c_str());
         LOG(VB_MEDIA, LOG_DEBUG, LOC +
-            "Udisks2:Drive:" + kszProperty.c_str() + " : " + v.toString() );
+            "Udisks2:Drive:" + kszProperty.c_str() + " : " + 
+            (v.canConvert<QStringList>() ? v.toStringList().join(", ") : v.toString()) );
     }
     return v;
 }
@@ -193,18 +194,18 @@ static bool DetectDevice(const QDBusObjectPath& entry, MythUdisksDevice& device,
 #if 0
     QString devraw = block.property("Device").toString();
     LOG(VB_MEDIA, LOG_DEBUG, LOC +
-        "CheckMountable: Raw Device found: " + devraw);
+        "DetectDevice: Raw Device found: " + devraw);
 #endif
     if (!block.property("HintSystem").toBool() &&
         !block.property("HintIgnore").toBool())
     {
         dev = block.property("Device").toString();
         LOG(VB_MEDIA, LOG_DEBUG, LOC +
-            "CheckMountable: Device found: " + dev);
+            "DetectDevice: Device found: " + dev);
 
         bool readonly = block.property("ReadOnly").toBool();
         LOG(VB_MEDIA, LOG_DEBUG, LOC +
-            QString("CheckMountable: Device:ReadOnly '%1'").arg(readonly));
+            QString("DetectDevice: Device:ReadOnly '%1'").arg(readonly));
 
         // ignore floppies, too slow
         if (dev.startsWith("/dev/fd"))
@@ -219,7 +220,7 @@ static bool DetectDevice(const QDBusObjectPath& entry, MythUdisksDevice& device,
         bool isfsmountable = (properties.lastError().type() == QDBusError::NoError);
 
         LOG(VB_MEDIA, LOG_DEBUG, LOC +
-            QString("     CheckMountable:Entry:isfsmountable : %1").arg(isfsmountable));
+            QString("     DetectDevice:Entry:isfsmountable : %1").arg(isfsmountable));
 
         // Get properties of the corresponding drive
         // Note: the properties 'Optical' and 'OpticalBlank' needs a medium inserted
@@ -229,17 +230,19 @@ static bool DetectDevice(const QDBusObjectPath& entry, MythUdisksDevice& device,
             desc += " ";
         desc += DriveProperty(drivePath, "Model").toString();
         LOG(VB_MEDIA, LOG_DEBUG, LOC +
-            QString("CheckMountable: Found drive '%1'").arg(desc));
+            QString("DetectDevice: Found drive '%1'").arg(desc));
+        const auto media = DriveProperty(drivePath, "MediaCompatibility").toStringList();
+        const bool isOptical = !media.filter("optical", Qt::CaseInsensitive).isEmpty();
 #if 0
-        LOG(VB_MEDIA, LOG_DEBUG, LOC + QString("CheckMountable:Drive:Optical : %1")
+        LOG(VB_MEDIA, LOG_DEBUG, LOC + QString("DetectDevice:Drive:Optical : %1")
                 .arg(DriveProperty(drivePath, "Optical").toString()));
-        LOG(VB_MEDIA, LOG_DEBUG, LOC + QString("CheckMountable:Drive:OpticalBlank : %1")
+        LOG(VB_MEDIA, LOG_DEBUG, LOC + QString("DetectDevice:Drive:OpticalBlank : %1")
                 .arg(DriveProperty(drivePath, "OpticalBlank").toString()));
 #endif
 
         if (DriveProperty(drivePath, "Removable").toBool())
         {
-            if (readonly && !isfsmountable)
+            if (readonly && isOptical)
             {
                 device = UDisks2DVD;
                 return true;

From 44b1ac1d59aff9b9e4340e9a693a0e7a2b3e0799 Mon Sep 17 00:00:00 2001
From: Jan Hambrecht <jaham@gmx.net>
Date: Sun, 19 Mar 2023 16:20:43 +0100
Subject: [PATCH 09/15] Remove checking 'ReadOnly' drive property

When checking if a drive is an optical drive, rely only on the
'MediaCompatibility' property and not the 'ReadOnly' property
of the 'org.freedesktop.UDisks2.Drive' interface.

(cherry picked from commit 9957ffab6c452c373bc60a1b9b9c3a3212d4f8f0)
---
 mythtv/libs/libmyth/mediamonitor-unix.cpp | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/mythtv/libs/libmyth/mediamonitor-unix.cpp b/mythtv/libs/libmyth/mediamonitor-unix.cpp
index 1a752c4aeb9..85ef34218d4 100644
--- a/mythtv/libs/libmyth/mediamonitor-unix.cpp
+++ b/mythtv/libs/libmyth/mediamonitor-unix.cpp
@@ -203,10 +203,6 @@ static bool DetectDevice(const QDBusObjectPath& entry, MythUdisksDevice& device,
         LOG(VB_MEDIA, LOG_DEBUG, LOC +
             "DetectDevice: Device found: " + dev);
 
-        bool readonly = block.property("ReadOnly").toBool();
-        LOG(VB_MEDIA, LOG_DEBUG, LOC +
-            QString("DetectDevice: Device:ReadOnly '%1'").arg(readonly));
-
         // ignore floppies, too slow
         if (dev.startsWith("/dev/fd"))
             return false;
@@ -242,7 +238,7 @@ static bool DetectDevice(const QDBusObjectPath& entry, MythUdisksDevice& device,
 
         if (DriveProperty(drivePath, "Removable").toBool())
         {
-            if (readonly && isOptical)
+            if (isOptical)
             {
                 device = UDisks2DVD;
                 return true;

From 0682d4d42dd50ad8592c522fe39fc8a81a11ee59 Mon Sep 17 00:00:00 2001
From: Jan Hambrecht <jaham@gmx.net>
Date: Sun, 19 Mar 2023 16:26:15 +0100
Subject: [PATCH 10/15] Cleanup function 'DetectDevice'

Remove dead code which is not going to be used anymore

(cherry picked from commit 80b4911f15324440fbd04c3580922463f87a2ae1)
---
 mythtv/libs/libmyth/mediamonitor-unix.cpp | 12 +-----------
 1 file changed, 1 insertion(+), 11 deletions(-)

diff --git a/mythtv/libs/libmyth/mediamonitor-unix.cpp b/mythtv/libs/libmyth/mediamonitor-unix.cpp
index 85ef34218d4..36aa9f4c906 100644
--- a/mythtv/libs/libmyth/mediamonitor-unix.cpp
+++ b/mythtv/libs/libmyth/mediamonitor-unix.cpp
@@ -191,11 +191,7 @@ static bool DetectDevice(const QDBusObjectPath& entry, MythUdisksDevice& device,
 {
     QDBusInterface block(UDISKS2_SVC, entry.path(), UDISKS2_SVC_BLOCK,
                          QDBusConnection::systemBus() );
-#if 0
-    QString devraw = block.property("Device").toString();
-    LOG(VB_MEDIA, LOG_DEBUG, LOC +
-        "DetectDevice: Raw Device found: " + devraw);
-#endif
+
     if (!block.property("HintSystem").toBool() &&
         !block.property("HintIgnore").toBool())
     {
@@ -229,12 +225,6 @@ static bool DetectDevice(const QDBusObjectPath& entry, MythUdisksDevice& device,
             QString("DetectDevice: Found drive '%1'").arg(desc));
         const auto media = DriveProperty(drivePath, "MediaCompatibility").toStringList();
         const bool isOptical = !media.filter("optical", Qt::CaseInsensitive).isEmpty();
-#if 0
-        LOG(VB_MEDIA, LOG_DEBUG, LOC + QString("DetectDevice:Drive:Optical : %1")
-                .arg(DriveProperty(drivePath, "Optical").toString()));
-        LOG(VB_MEDIA, LOG_DEBUG, LOC + QString("DetectDevice:Drive:OpticalBlank : %1")
-                .arg(DriveProperty(drivePath, "OpticalBlank").toString()));
-#endif
 
         if (DriveProperty(drivePath, "Removable").toBool())
         {

From 51cb10a67855bae82a97ca1995956622b0902021 Mon Sep 17 00:00:00 2001
From: Bill Meek <bmeek@mythtv.org>
Date: Mon, 10 Apr 2023 10:45:38 -0500
Subject: [PATCH 11/15] ApplyRecordRecGroupChange: replace chanid/starttime
 with recordedid

Solves issue here: https://forum.mythtv.org/viewtopic.php?p=25852#p25852
---
 mythtv/libs/libmythtv/recordinginfo.cpp | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/mythtv/libs/libmythtv/recordinginfo.cpp b/mythtv/libs/libmythtv/recordinginfo.cpp
index c5126376f47..a16c7f2c6bd 100644
--- a/mythtv/libs/libmythtv/recordinginfo.cpp
+++ b/mythtv/libs/libmythtv/recordinginfo.cpp
@@ -685,12 +685,10 @@ void RecordingInfo::ApplyRecordRecGroupChange(const QString &newrecgroup)
     query.prepare("UPDATE recorded"
                   " SET recgroup = :RECGROUP, "
                   "     recgroupid = :RECGROUPID "
-                  " WHERE chanid = :CHANID"
-                  " AND starttime = :START ;");
+                  " WHERE recordedid = :RECORDEDID");
     query.bindValue(":RECGROUP", null_to_empty(newrecgroup));
     query.bindValue(":RECGROUPID", newrecgroupid);
-    query.bindValue(":START", m_recStartTs);
-    query.bindValue(":CHANID", m_chanId);
+    query.bindValue(":RECORDEDID", m_recordedId);
 
     if (!query.exec())
         MythDB::DBError("RecGroup update", query);

From c4b7e4c43321154bf5eaa67af02b7ba7ea6bffb8 Mon Sep 17 00:00:00 2001
From: Bill Meek <bmeek@mythtv.org>
Date: Sun, 16 Apr 2023 23:59:37 -0500
Subject: [PATCH 12/15] mythdbcon: force QMetaType::QDateTime values to use
 MythDate::kDatabase

This cares for a recent ibqt5sql5-mysql update in at least one
distribution where it isn't removing timezone information from
a query causing it to fail.

Log example without patch:
MSqlQuery::exec(DBManager16) UPDATE recorded SET recgroup = 'Deleted', recgroupid = 3 WHERE chanid = '10901' AND starttime = '2023-04-08T05:00:00.000Z' ; <<<< Took 0ms

Log example with patch:
MSqlQuery::exec(DBManager1) UPDATE recorded SET recgroup = 'Deleted', recgroupid = 3 WHERE chanid = '10901' AND starttime = '2023-04-07 05:30:00' ; <<<< Took 0ms

Results seen by users on the Forum and mailing list.

Credits to Mark, Roland and Klaas.

See: https://forum.mythtv.org/viewtopic.php?p=25833#p25833

The Debian solution is due 4/31/2023.

(cherry picked from commit d889da2b0ebdbbfaa59051ae30a6b5b9a5930cdb)
---
 mythtv/libs/libmythbase/mythdbcon.cpp | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/mythtv/libs/libmythbase/mythdbcon.cpp b/mythtv/libs/libmythbase/mythdbcon.cpp
index 1ec6e1ca7da..b1e251fd809 100644
--- a/mythtv/libs/libmythbase/mythdbcon.cpp
+++ b/mythtv/libs/libmythbase/mythdbcon.cpp
@@ -882,6 +882,15 @@ bool MSqlQuery::testDBConnection()
 
 void MSqlQuery::bindValue(const QString &placeholder, const QVariant &val)
 {
+#if QT_VERSION < QT_VERSION_CHECK(6,0,0)
+    if (static_cast<QMetaType::Type>(val.type()) == QMetaType::QDateTime)
+    {
+        QSqlQuery::bindValue(placeholder,
+                             MythDate::toString(val.toDateTime(), MythDate::kDatabase),
+                             QSql::In);
+        return;
+    }
+#endif
     QSqlQuery::bindValue(placeholder, val, QSql::In);
 }
 
@@ -897,6 +906,15 @@ void MSqlQuery::bindValueNoNull(const QString &placeholder, const QVariant &val)
         QSqlQuery::bindValue(placeholder, QString(""), QSql::In);
         return;
     }
+#if QT_VERSION < QT_VERSION_CHECK(6,0,0)
+    if (type == QMetaType::QDateTime)
+    {
+        QSqlQuery::bindValue(placeholder,
+                             MythDate::toString(val.toDateTime(), MythDate::kDatabase),
+                             QSql::In);
+        return;
+    }
+#endif
     QSqlQuery::bindValue(placeholder, val, QSql::In);
 }
 

From 83e1df82c2094586a585b8d5cde9de14e9be0735 Mon Sep 17 00:00:00 2001
From: Klaas de Waal <klaas@kldo.nl>
Date: Thu, 18 May 2023 21:00:28 +0200
Subject: [PATCH 13/15] Fix mythbackend segfault after failed Live TV

A failing Live TV can cause a segfault of mythbackend
due to a delete of an already deleted object.
This is not immediately obvious due to pointer
aliasing but valgrind figures it out anyway.

(cherry picked from commit 68b368673704f35072dbc3fb44e0c8444d737963)
Signed-off-by: Klaas de Waal <klaas@kldo.nl>
---
 mythtv/libs/libmythtv/tv_rec.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/mythtv/libs/libmythtv/tv_rec.cpp b/mythtv/libs/libmythtv/tv_rec.cpp
index 7d16a16ddb1..d4a106c6b9e 100644
--- a/mythtv/libs/libmythtv/tv_rec.cpp
+++ b/mythtv/libs/libmythtv/tv_rec.cpp
@@ -4218,6 +4218,8 @@ void TVRec::TuningNewRecorder(MPEGStreamData *streamData)
             gCoreContext->dispatch(me);
         }
         TeardownRecorder(kFlagKillRec);
+        if (m_tvChain)
+            rec = nullptr;
         goto err_ret;
     }
 

From beaf2bacbe63da92da49e37807efa1738e1fa5c1 Mon Sep 17 00:00:00 2001
From: MmAaXx500 <viktor.balogh45@gmail.com>
Date: Thu, 6 Jul 2023 17:58:46 +0200
Subject: [PATCH 14/15] Fix heap-use-after-free in TVRec with Live TV

When playing Live TV continuously on the same channel, there is
a moment when according to the guide one program ends and the next
program begins. At this moment the Live TV recording is stopped and
a new recording is started. There is small time period in between
in which there is no valid program info and an update of the program
info from another thread in that period results then in access
of already deleted program info instance.
Fixed by using the m_stateChangeLock to lock the complete sequence.

Refs #768
Refs #769

Signed-off-by: Klaas de Waal <klaas@kldo.nl>
---
 mythtv/libs/libmythtv/tv_rec.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/mythtv/libs/libmythtv/tv_rec.cpp b/mythtv/libs/libmythtv/tv_rec.cpp
index d4a106c6b9e..2b1708176d4 100644
--- a/mythtv/libs/libmythtv/tv_rec.cpp
+++ b/mythtv/libs/libmythtv/tv_rec.cpp
@@ -3339,6 +3339,8 @@ void TVRec::RingBufferChanged(MythMediaBuffer *Buffer, RecordingInfo *pginfo, Re
 {
     LOG(VB_GENERAL, LOG_INFO, LOC + "RingBufferChanged()");
 
+    QMutexLocker lock(&m_stateChangeLock);
+
     if (pginfo)
     {
         if (m_curRecording)

From 402c6d7758d02733e0b4c76a80df862c977e3307 Mon Sep 17 00:00:00 2001
From: David Hampton <mythtv@love2code.net>
Date: Fri, 21 Jul 2023 00:59:43 -0400
Subject: [PATCH 15/15] Work around Linux kernel header 6.5 using C++ reserved
 keyword.

Starting with kernel 6.5.0, a rewrite of the linux/ioprio.h header
file uses the C++ reserved keyword "class" as a variable name.
Fortunately we can redefine the string "class" for the duration of the
inclusion without any ill effects.

Fixes #778.

(cherry picked from commit 7d6c7d605f87b697c7488d1eb4a3246b83e31f01)
---
 mythtv/libs/libmythbase/mythmiscutil.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/mythtv/libs/libmythbase/mythmiscutil.cpp b/mythtv/libs/libmythbase/mythmiscutil.cpp
index 1fc0e93b0b5..6f4241268f7 100644
--- a/mythtv/libs/libmythbase/mythmiscutil.cpp
+++ b/mythtv/libs/libmythbase/mythmiscutil.cpp
@@ -703,7 +703,12 @@ void myth_yield(void)
 #include <sys/ptrace.h>
 #include <sys/syscall.h>
 #if __has_include(<linux/ioprio.h>)
+// Starting with kernel 6.5.0, the following include uses the C++
+// reserved keyword "class" as a variable name. Fortunately we can
+// redefine it without any ill effects.
+#define class class2
 #include <linux/ioprio.h>
+#undef class
 #else
 static constexpr int8_t IOPRIO_BITS        { 16 };
 static constexpr int8_t IOPRIO_CLASS_SHIFT { 13 };
